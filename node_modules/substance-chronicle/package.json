{
  "name": "substance-chronicle",
  "description": "A Javascript versioning library inspired by Git.",
  "url": "http://github.com/substance/chronicle/",
  "keywords": [
    "substance",
    "versioning"
  ],
  "author": {
    "name": "Oliver Buchtala"
  },
  "contributors": [
    {
      "name": "Michael Aufreiter"
    }
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/substance/chronicle.git"
  },
  "dependencies": {
    "underscore": "1.5.x",
    "substance-util": "0.3.0-1",
    "substance-operator": "0.3.0-1"
  },
  "devDependencies": {
    "mocha": "1.12.x",
    "substance-test": "0.3.0-1"
  },
  "scripts": {
    "test": "mocha -R spec tests/run.js"
  },
  "version": "0.3.0-1",
  "engines": {
    "node": ">=0.8.x",
    "npm": ">=1.1.x"
  },
  "readme": "Chronicle [![Build Status](https://travis-ci.org/substance/chronicle.png)](https://travis-ci.org/substance/chronicle)\n=========\n\nA git inspired versioning API based on Operational Transformations (OT).\nThe actual content to be versioned or a persistence mechanism is not addressed in this module.\nInstead one would have to create an adapter which is implementing an OT interface.\n\n> Current state:\n>\n> Chronicle is working, but should be considered experimental, though. There are\n> some examples in our [test suite](https://github.com/substance/tests/tree/master/tests/chronicle).\n>\n> We are refactoring our [`data.js`](https://github.com/michael/data) library\n> to use operational transformations.\n> This way we achieve to provide a means to add versioning to anything that can\n> be modelled with `data.js`\n\nTheory\n--------\n\n### Operational Transformation\n\nWith Operational Transformations changes to a document are done via so called operations.\nOperations are invertible and can be concatenated constituting a graph of document versions\nthat can be created by applying operations.\n\n![Operations](http://github.com/substance/chronicle/blob/gh-pages/images/graph.jpg?raw=true)\n\nOT has its application in real-time collaborative editing, i.e., two or more users edit a\ndocument simultanously, e.g., as it is possible with Google Docs.\nThe OT theory defines a special transformation describes how a temporary divergence can\nbe resolved when two user change the document\nat the same time, to ensure that the users continue to see and work on exactly the\nsame document content.\n\n![Transformation](http://github.com/substance/chronicle/blob/gh-pages/images/trafo.jpg?raw=true)\n\n    transform(a, b) = (a', b')\n\nThe transformation creates two (new) changes `a'` and `b'` which can be applied\nto the original versions to achieve a common state.\n\n### Version Control\n\nThe underlying model in GIT is very similar in the regard that there is a graph of\nchanges, so called commits.\nIn contrast to the previous approach, the system identifies states by commits\nand not by document versions. This is indeed important as there should\nbe a common sense between the user about the history of changes.\nThus, applying transformed changes as above do not lead to a common state:\n\n![Commits](http://github.com/substance/chronicle/blob/gh-pages/images/commits.jpg?raw=true)\n\nDifferent paths of changes are called branches.\nTo be ables to have a common base to work on, one would need to bring branches\ntogether again, what is called a *merge*.\nOne of the users would decide to merge and record his decision as an extra change.\nIn very many cases the changes of different users do not interfer, i.e., they are not\nconflicting. Then, a merge typically can be applied automatically.\n\n![Merge](http://github.com/substance/chronicle/blob/gh-pages/images/merge.jpg?raw=true)\n\nConflicting changes are not addressed by the OT. E.g., if two users add the same text\nat the same time it will be there twice.\n\nA different important aspect in VCS is to have control about what changes exactly are merged\ninto the common repository. In the OT usecase all users have the same role and permissions.\nContrarily, in VCS typically there are gate-keepers who ensure quality of commits, etc.\n\n\n### Operational Tranform based Version-Control\n\nA great part for implementing a VCS is already given by the OT framework.\nHowever, there are minor conceptual differences which need a bit of an algorithmic foundation.\n\nWe introduce two basic operations that can be derived from the OT framework\nand form the basic toolset for the algorithms used for Versioning.\n\n- Principal Rebase: this is a straight-forward extension of the transform operator\n  which can be applied to on graphs.\n\n- Elimination: this allows to eliminate the effect of a change by rebasing a graph on\n  the parent of the change to be eliminated.\n\nAdditionally, we will have to add conflict detection.\n\n#### Principal Rebase\n\nRebasing is an operation which transplants a change (or sub-graph) to a new target parent.\nWe call a principal rebase, those where the two involved changes are siblings.\n\nConsider the following situation:\n\n![Merge](http://github.com/substance/chronicle/blob/gh-pages/images/rebase-1.jpg?raw=true)\n\nRebasing the change `b` onto change `a` would give a sequence of (new) changes `b'`, and `c'`.\n\n![Merge](http://github.com/substance/chronicle/blob/gh-pages/images/rebase-2.jpg?raw=true)\n\nLet us first consider only this special kind of rebase-scenarios, where the\ntwo changes `a` and `b` are siblings.\n\nThe case with only two changes involved is directly covered by the `transform` operation.\n\n    transform(a,b) = (a', b')\n\n![Merge](http://github.com/substance/chronicle/blob/gh-pages/images/rebase-3.jpg?raw=true)\n\nThis can be extended iteratively to the case with children changes.\n\n    transform(a', c) = (a'', c')\n\n![Merge](http://github.com/substance/chronicle/blob/gh-pages/images/rebase-4.jpg?raw=true)\n\n\n#### Elimination\n\nNow let us consider a more general case, e.g., in the above example we would want to\nrebase change `c` onto `a`.\nTo reduce this problem to the previous case, we need to eliminate change `b`.\nAs all changes are invertible we can introduce an inversion of `b`.\nThen we can apply the following transformation to achieve the desired change `c'`.\n\n    transform(inv(b), c) = (inv(b)' , c')\n\n![Merge](http://github.com/substance/chronicle/blob/gh-pages/images/reduction-1.jpg?raw=true)\n\n![Merge](http://github.com/substance/chronicle/blob/gh-pages/images/reduction-2.jpg?raw=true)\n\nAs before, to propagate this reduction through a sub-graph we would apply\nthe transformation to all children recursively.\n\n#### Conflict detection\n\nIn contrast to online collaborative editing, for a VCS it is necessary to detect conflicting\nchanges. Such conflicts would not be merged silently, but the user would decide what to do.\nConflicts are domain specific, i.e., the operations need to detect such cases.\nIn *Chronicle* we decided not to add a statical detection mechanism but instead\nintroduce an option `check` in the OT `transform` method. If the option is enabled,\n`transform` is expected to throw a dedicated error, `errors.MergeConflict`,\nwhich contains the two operations causing a conflict.\n\n#### Merge\n\nThe most complex operation in *Chronicle* is merging. All merging strategies are mapped\nto the case of a manually defined sequence of changes.\n\nGiven two branches `a = (a_1, ..., a_k)` and `b = (b_1, ..., b_r)`, a merge `m` defines\na sequence of changes of `a` and `b`.\nLet `m_a` and `m_b` be the intersection of `m` with `a` and `b`, respectively.\n\n> Note: at the moment, it is not possible to reorder changes, i.e., the changes in `m_a`\n  must have the same order as in `a`, and the same with `m_b` and `b`.\n\nA merge can thus be achieved by the following steps:\n\n1. Reduce `a` to `m_a`: [eliminate](http://github.com/substance/chronicle#elimination)\n   all changes in `a` that are not in `m_a`.\n   This has to be done in reverse order, i.e., from right to left, as not to violate\n   dependencies of changes.\n   In other words, it is always better to revert changes from right to left (newer to older).\n\n   > Note: the elimination will create temporary branches. The original changes stay untouched.\n   >\n   > TODO: add an illustration\n\n2. Reduce `b` to `m_b`: same procedure as with `a`.\n\n3. Merge `m_a` and `m_b`: this is done by iteratively apply a\n   [Principal Rebase](http://github.com/substance/chronicle#principal-rebase).\n\n#### Rebase\n\nA rebase can be derived from the merge implementation.\n\nConsider this situation:\n\n> TODO: add illustration showing two branches a and b having a common root r\n\nRebasing `b_r` onto `a_k` is done by:\n\n1. [Eliminating](http://github.com/substance/chronicle#elimination)\n   `b_{r-1}, ..., b_1` which results in b_r'\n\n   > TODO: add illustration showing a transformed b_r' as sibling of a_1 and b_1\n\n2. Iteratively rebase b_r' onto `a_1` to `a_k`\n\n> TODO: add illustration showing a transformed b_r as sibling of a_1\n\nThis of course would fail, if `b_r` was depending on any of the eliminated changes.\n\n> Note: not yet implemented.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/substance/chronicle/issues"
  },
  "homepage": "https://github.com/substance/chronicle",
  "_id": "substance-chronicle@0.3.0-1",
  "_from": "substance-chronicle@"
}

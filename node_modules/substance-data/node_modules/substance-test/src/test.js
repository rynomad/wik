"use strict";

var _    = require('underscore');
var util   = require('substance-util');

// Expands the actions into a unified format.
// --------
//
// For convenienve, tests maybe be declared in a simpler format.

var compileActions = function(uncompiledTest) {

  // console.log("expand actions...");
  var actions = [];
  var action = null;

  function action_template() {
    return {
      'label': "unknown",
      'func': null
    };
  }

  function complete_action() {
    actions.push(action);
    action = action_template();
  }

  action = action_template();

  _.each(uncompiledTest.actions, function(elem) {
    var objType = Object.prototype.toString.call(elem);
    // actions can be declared in a declarative way in as a sequence of
    // functions (=actions) separated by strings which are used
    // as labels or to specify the platform
    if(objType === '[object String]') {
      action.label = elem;
    }
    // alternatively, only the action body can be given
    else if (objType === '[object Function]') {
      action.func = elem;
      complete_action();
    }
    // and also a direct version as object
    else {
      if (elem.func) action.func = elem.func;
      if (elem.label) action.label = elem.label;
      complete_action();
    }
  });

  return actions;
};

var pathToId = function(path) {
  var id = path.join("_");
  id = id.replace(/[:@/()]/g, "").replace(/\s/g, "_");
  return id;
};

var Test = function() {
  this.actions = compileActions(this);
};

Test.registerTest = function(path, test) {
  test.path = path;
  test.id = pathToId(path);
  // the last entry of the path is taken as name
  test.name = _.last(path);

  // register the test globally
  Test.tests[test.id] = test;
};

Test.Prototype = function() {

  _.extend(this, util.Events);

  this.run = function(cb) {
    var self = this;

    var report = [];

    function setup(cb) {

      try {
        console.log("## Setup");
        // synchronous
        if (self.setup.length === 0) {
          self.setup();
          cb(null);
        }
        // asynchronous
        else {
          self.setup(cb);
        }
      } catch(err) {
        console.log("Caught error during setup:", err);
        util.printStackTrace(err, 1);
        cb(err);
      }
    }

    function runActions(cb) {
      var options = {
        items: self.actions,
        stopOnError: false,
        iterator: function(action, cb) {
          var reportItem = {
            label: action.label,
            sourcecode: action.func.toString(),
            duration: 0
          };
          try {
            console.log("## Action:", action.label);

            // synchronous actions
            if (action.func.length === 0) {
              var start = Date.now();
              action.func.call(self);
              reportItem.duration = Date.now() - start;
              self.trigger('action:success', null, action);
              report.push(reportItem);
              cb(null);
            }
            // asynchronous actions
            else {
              var start = Date.now();
              action.func.call(self, function(err, data) {
                reportItem.duration = Date.now() - start;
                if (err) {
                  console.error(err.toString());
                  util.printStackTrace(err);
                  self.trigger('action:error', err, action);
                  reportItem.error = err;
                } else {
                  self.trigger('action:success', null, action);
                }
                report.push(reportItem);

                if (self.delay) {
                  _.delay(cb, self.delay, err, data);
                } else {
                  cb(err, data);
                }

              });
            }
          } catch(err) {
            console.error(err.name+":", err.message);
            util.printStackTrace(err);
            self.trigger('action:error', err, action);
            reportItem.error = err;
            report.push(reportItem);
            cb(err);
          }
        }
      };

      util.async.each(options, cb);
    }

    function finish(cb) {
      console.log("# Finished Test: ", self.name);
      cb(null);
    }

    console.log("# Test:", self.path.join("/"),"/", self.name);
    var options = {
      functions: [setup, runActions, finish],
      finally: function(err) {
        self.tearDown();
        cb(err, report);
      }
    };
    if (cb === undefined) {
      cb = function(err) {
        if (err) console.log(err, report);
      };
    }
    util.async.sequential(options, cb);
  };

  // a stub setup function called before running test action
  this.setup = function() {};

  this.tearDown = function() {};

};

Test.prototype = new Test.Prototype();

// Global Test Registry
// --------
//

Test.tests = Test.tests || {};


module.exports = Test;

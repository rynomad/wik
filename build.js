(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var wik = {}




wik.create  = require('./lib/wikConstructor.js')
wik.factory = require('./lib/factory.js')
wik.threadSpinner = require('./lib/threadSpinner.js')
wik.resolveWik = require('./lib/wikResolver.js')
wik.resolveThread = require('./lib/threadResolver.js')
wik.diff = require('diff')
wik.deepDiff = require('deep-diff')
wik.nfd = require('NFD-js')
wik.operator = require('substance-operator')
module.exports = wik

},{"./lib/factory.js":2,"./lib/threadResolver.js":5,"./lib/threadSpinner.js":6,"./lib/wikConstructor.js":7,"./lib/wikResolver.js":8,"NFD-js":10,"deep-diff":129,"diff":130,"substance-operator":132}],2:[function(require,module,exports){
//Entry point for creating new threads and calling various plugins

var factory = {}
  , operator = require('substance-operator')
  , uuidGen = require('node-uuid')
  , storage = require('./storage.js')
  , steward = require('./steward.js')

factory.add = function(callback) {
  console.log('addFactory')
  var wik = this
    , parentUri = wik.uri
    , addFactory = operator.ObjectOperation.Update(["story"], operator.ArrayOperation.Insert(wik.story.length, "FACTORY"))
    , scrubUri = operator.ObjectOperation.Update(["uri"], operator.TextOperation.Delete(112, wik.uri.substr(112)))
    , stampUri = operator.ObjectOperation.Update(["uri"], operator.TextOperation.Insert(112, Date.now().toString()))
    , compoundPatch = operator.ObjectOperation.Compound([addFactory, scrubUri, stampUri])

  console.log("patches generated")
  compoundPatch.apply(wik)

  var jsonPatch = compoundPatch.toJSON()
  jsonPatch.uri = wik.uri
  jsonPatch.parentUri = parentUri
  storage.storePatch(jsonPatch)

  return compoundPatch

}

factory.createThread = function(wik, pos, targetType) {

  var uuid = uuidGen.v4()
    , timestamp = Date.now().toString()
    , parentUri = wik.uri
    , threadUri = "/wiki/" + targetType + "/" + uuid + "/" + steward.hashName + "/" + timestamp
    , scrubFactory = operator.ObjectOperation.Update(["story"], operator.ArrayOperation.Delete(pos, "FACTORY"))
    , addItem = operator.ObjectOperation.Update(["story"], operator.ArrayOperation.Insert(pos, threadUri))
    , scrubUri = operator.ObjectOperation.Update(["uri"], operator.TextOperation.Delete(112, wik.uri.substr(112)))
    , stampUri = operator.ObjectOperation.Update(["uri"], operator.TextOperation.Insert(112, timestamp))
    , wikCompound = operator.ObjectOperation.Compound([scrubFactory, addItem, scrubUri, stampUri])
    , wikPatchJSON = wikCompound.toJSON()
    , thread = {}
    , addtype = operator.ObjectOperation.Create(["type"], targetType)
    , addUUID = operator.ObjectOperation.Create(["id"], threadUri)
    , initThread = operator.ObjectOperation.Compound([addtype, addUUID])
    , threadPatch = initThread.toJSON();


  initThread.apply(thread)
  wikCompound.apply(wik)

  threadPatch.parentUri = null
  threadPatch.uri = threadUri
  wikPatchJSON.parentUri = parentUri
  wikPatchJSON.uri = wik.uri

  storage.storePatch(wikPatchJSON)
  storage.storePatch(threadPatch)

}

module.exports = factory

},{"./steward.js":3,"./storage.js":4,"node-uuid":131,"substance-operator":132}],3:[function(require,module,exports){
// Publisher/Steward Identity module, facade shim for now

var steward = {}

steward.hashName = "0000000000000000000000000000000000000000000000000000000000000000"

module.exports = steward

},{}],4:[function(require,module,exports){
//
var storage = {}
var io = require('NFD-js').io
storage.storePatch = function(patch){

  io.publish({
    uri: patch.uri,
    type: "object",
    thing: patch,
    version: false
  })
}

module.exports = storage

},{"NFD-js":10}],5:[function(require,module,exports){
var io = require('NFD-js').io
var operator = require('substance-operator')
var factory = require("./factory.js")

var resolveThread = function (wik, uri, callback) {
  var thread = {}

  thread.journal = []
  function assembleThread(journal) {
    console.log(journal)
    for (var i = journal.length - 1; i >= 0; i--) {
      operator.ObjectOperation.fromJSON(journal[i]).apply(thread)
    }
    thread.wik = wik.uri
    callback(thread)
  }
  function recursor(name, patch) {
    thread.journal.push(patch)


    if (patch.parentUri != null) {
      io.fetch({uri: patch.parentUri, type: "object"}, recursor)
    } else {
      assembleThread(thread.journal)
    }
  }

  io.fetch({uri: uri, type: "object"}, recursor)
}

module.exports = resolveThread

},{"./factory.js":2,"NFD-js":10,"substance-operator":132}],6:[function(require,module,exports){
// To allow for simple plugin construction, we reverse engineer patches by diffing an item before and after a change
var storage = require('./storage.js')
  , io = require('NFD-js').io
  , steward = require('./steward.js')
  , objectDiff = require('deep-diff')
  , textDiff = require('diff')
  , operator = require('substance-operator')
  , wikResolver = require('./wikResolver.js')

var spinner = function spinner(before, after) {
  var patches = []
    , Compound = false
    , parentUri = before.id
    , prefixLength = 109 + before.type.length
    , timestamp = Date.now().toString()
    , scrubUri = operator.ObjectOperation.Update(["id"], operator.TextOperation.Delete(prefixLength, before.id.substr(prefixLength)))
    , stampUri = operator.ObjectOperation.Update(["id"], operator.TextOperation.Insert(prefixLength, timestamp))

  if (before.type == "paragraph") {
    var diffList = textDiff.diffWords(before.text, after.text)
      , stringIndex = 0

    for (var i = 0; i < diffList.length; i++ ) {
      if ((diffList[i].added !== true) && (diffList[i].removed !== true)) {
        //nothing has changed for this section of the text; don't generate a patch but do increment the stringIndex
        stringIndex += diffList[i].value.length
      } else if (diffList[i].added == true) {
        patches.push(operator.TextOperation.Insert(stringIndex, diffList[i].value))
        stringIndex += diffList[i].value.length
      } else if (diffList[i].removed == true) {
        patches.push(operator.TextOperation.Delete(stringIndex, diffList[i].value))
      }
    }
    var objectOperation = operator.ObjectOperation.Update(["text"], operator.TextOperation.Compound(patches))
    var preFinalPatchArray = [scrubUri, stampUri, objectOperation]
  } else {
    // do deep diff on whole object
    var diffList = objectDiff.diff(before, after)
    for (var i = 0; i < diffList.length; i++) {
      if (diffList[i].kind == "N") {
        patches.push(operator.ObjectOperation.Create(diffList[i].path, diffList[i].rhs))
      } else if (diffList[i].kind == "D") {
        patches.push(operator.ObjectOperation.Delete(diffList[i].path, diffList[i].lhs))
      } else if (diffList[i].kind == "E") {
        patches.push(operator.ObjectOperation.Update(diffList[i].path, diffList[i].rhs))
      } else if (diffList[i].kind == "A") {
        patches.push(operator.ObjectOperation.Update(diffList[i].path, operator.ArrayOperation.Delete(diffList[i].index, diffList[i].item.lhs)))
        patches.push(operator.ObjectOperation.Update(diffList[i].path, operator.ArrayOperation.Insert(diffList[i].index, diffList[i].item.rhs)))
      }
    }
    var preFinalPatchArray = [scrubUri, stampUri].concat(patches)
  }



      /*  if (diffList[i].item.kind == "N") {
          patches.push(operator.ObjectOperation.Update(diffList[i].path, operator.ArrayOperation.Insert(diffList[i].index, diffList[i].item.rhs)))
        } else if (diffList[i].item.kind == "D") {
          patches.push(operator.ObjectOperation.Update(diffList[i].path, operator.ArrayOperation.Delete(diffList[i].index, diffList[i].item.lhs)))
        } else if ((diffList[i].item.kind == "E") && (diffList[i+1] !== undefined)) {
          console.log("'E' kind within 'A' kind", diffList[i+1], diffList[i])
          if (diffList[i+1].item.rhs == diffList[i].item.lhs) {
            //This is an insertion, not merely an edit
            patches.push(operator.ObjectOperation.Update(diffList[i].path, operator.ArrayOperation.Insert(diffList[i].index, diffList[i].item.rhs)))
            for (var j = i; j < diffList.length; j++) {
              if (diffList[j+1] == undefined){
                i = j;
                continue;
              } else if (diffList[j+1].kind !== "A") {

                i = j
                continue;
              } else if (diffList[j+1].kind == "A") {
                if  (diffList[j+1].item.rhs !== diffList[j].item.lhs) {
                  i = j
                  continue;
                }
              }
            }
          } else if (diffList[i+1].item.lhs == diffList[i].item.rhs) {
            // this is a deletion
            patches.push(operator.ObjectOperation.Update(diffList[i].path, operator.ArrayOperation.Delete(diffList[i].index, diffList[i].item.lhs)))
            for (var j = i; j < diffList.length; j++) {
              if (diffList[j+1] == undefined){
                i = j ;
                continue;
              } else if (diffList[j+1].kind !== "A") {

                i = j ;
                continue;
              } else if (diffList[j+1].kind == "A") {
                if  (diffList[j+1].item.kind == "D") {
                  // clean end to deletion chain
                  i = j;
                  continue
                } else {

                }
                  if ((diffList[j+2] == undefined) || (diffList[j+2].kind !== "A") || (diffList[j+2].item.kind !== "D")) {
                    // we've found the last array operation, and it's not a deletion (which would indicate a clean end to a delection edit chain), so we need to apply it
                    console.log("found unclean end of deletion chain", diffList[j+1])
                    i = j - 1;
                    continue;
                  }
                }
              }
            }
          } else {
            // this is an edit of an existing array item
            patches.push(operator.ObjectOperation.Update(diffList[i].path, operator.ArrayOperation.Delete(diffList[i].index, diffList[i].item.lhs)))
            patches.push(operator.ObjectOperation.Update(diffList[i].path, operator.ArrayOperation.Insert(diffList[i].index, diffList[i].item.rhs)))
          }
        }*/
  var clone = JSON.parse(JSON.stringify(before))
  stampUri.apply(scrubUri.apply(clone))
  console.log
  wikResolver(before.wik, function(wik){
    console.log(wik)
    for (var i = 0; i < wik.story.length; i++) {
      if (wik.story[i] == parentUri) {
        var scrubWikUri = operator.ObjectOperation.Update(["uri"], operator.TextOperation.Delete(112, wik.uri.substr(112)))
          , stampWikUri = operator.ObjectOperation.Update(["uri"], operator.TextOperation.Insert(112, timestamp))
          , change1 = operator.ObjectOperation.Update(["story"], operator.ArrayOperation.Delete(i, wik.story[i]))
          , change2 = operator.ObjectOperation.Update(["story"], operator.ArrayOperation.Insert(i, clone.id))
          , wikCompound = operator.ObjectOperation.Compound([scrubWikUri, stampWikUri, change1, change2])
          , wikToStore = wikCompound.toJSON();


        wikToStore.parentUri = wik.uri
        wikCompound.apply(wik)
        wikToStore.uri = wik.uri
        var wikReferenceScrub = operator.ObjectOperation.Update(["wik"], operator.TextOperation.Delete(112, before.wik.substr(112)))
        var wikReferenceStamp = operator.ObjectOperation.Update(["wik"], operator.TextOperation.Insert(112, timestamp))
        preFinalPatchArray.concat([wikReferenceScrub, wikReferenceStamp])
        var compound = operator.ObjectOperation.Compound(preFinalPatchArray)
        compound.apply(before)
        var toStore = compound.toJSON()
        toStore.parentUri = parentUri
        toStore.uri = before.id
        storage.storePatch(toStore)
        storage.storePatch(wikToStore)
        console.log(wik, before)
        continue;
      }
    }
  })
}

module.exports = spinner

},{"./steward.js":3,"./storage.js":4,"./wikResolver.js":8,"NFD-js":10,"deep-diff":129,"diff":130,"substance-operator":132}],7:[function(require,module,exports){
var operator = require('substance-operator')
var uuidGen = require('node-uuid')
var steward = require('./steward.js')
var factory = require('./factory.js')
var storage = require('./storage.js')


var constructor = function () {
  var wik = {}
    , uuid = uuidGen.v4()
    , baseUri = "/wiki/wik/" + uuid + "/" + steward.hashName + "/" + Date.now()
    , uriPatch = operator.ObjectOperation.Create(["uri"], baseUri)
    , storyPatch = operator.ObjectOperation.Create(["story"], ["FACTORY"])
    , rootCompoundPatch = operator.ObjectOperation.Compound([uriPatch, storyPatch]);

  rootCompoundPatch.uri = baseUri;
  rootCompoundPatch.parentUri = null;
  rootCompoundPatch.apply(wik);
  storage.storePatch(rootCompoundPatch)

  wik.addFactory = factory.add
  wik.createThread = factory.createThread
  return wik;

}

module.exports = constructor

},{"./factory.js":2,"./steward.js":3,"./storage.js":4,"node-uuid":131,"substance-operator":132}],8:[function(require,module,exports){
var io = require('NFD-js').io
var operator = require('substance-operator')
var factory = require("./factory.js")

var resolveWik = function (uri, callback) {
  var wik = {}
  wik.journal = []
  function assembleWik(journal) {
    console.log(journal)
    for (var i = journal.length - 1; i >= 0; i--) {
      operator.ObjectOperation.fromJSON(journal[i]).apply(wik)
    }
    wik.addFactory = factory.add
    callback(wik)
  }
  function recursor(name, patch) {
    wik.journal.push(patch)


    if (patch.parentUri != null) {
      io.fetch({uri: patch.parentUri, type: "object"}, recursor)
    } else {
      assembleWik(wik.journal)
    }
  }

  io.fetch({uri: uri, type: "object"}, recursor)
}

module.exports = resolveWik

},{"./factory.js":2,"NFD-js":10,"substance-operator":132}],9:[function(require,module,exports){
var process=require("__browserify_process");(function(){var e,t,n;(function(r){function d(e,t){return h.call(e,t)}function v(e,t){var n,r,i,s,o,u,a,f,c,h,p,v=t&&t.split("/"),m=l.map,g=/\.js$/,y=m&&m["*"]||{};if(e&&e.charAt(0)===".")if(t){v=v.slice(0,v.length-1),e=e.split("/"),o=e.length-1,l.pkgs&&d(l.pkgs,v[0])&&g.test(e[o])&&(e[o]=e[o].replace(g,"")),e=v.concat(e);for(c=0;c<e.length;c+=1){p=e[c];if(p===".")e.splice(c,1),c-=1;else if(p===".."){if(c===1&&(e[2]===".."||e[0]===".."))break;c>0&&(e.splice(c-1,2),c-=2)}}e=e.join("/")}else e.indexOf("./")===0&&(e=e.substring(2));if((v||y)&&m){n=e.split("/");for(c=n.length;c>0;c-=1){r=n.slice(0,c).join("/");if(v)for(h=v.length;h>0;h-=1){i=m[v.slice(0,h).join("/")];if(i){i=i[r];if(i){s=i,u=c;break}}}if(s)break;!a&&y&&y[r]&&(a=y[r],f=c)}!s&&a&&(s=a,u=f),s&&(n.splice(0,u,s),e=n.join("/"))}return e}function m(e,t){return function(){return s.apply(r,p.call(arguments,0).concat([e,t]))}}function g(e){return function(t){return v(t,e)}}function y(e){return function(t){a[e]=t}}function b(e){if(d(f,e)){var t=f[e];delete f[e],c[e]=!0,i.apply(r,t)}if(!d(a,e)&&!d(c,e))throw new Error("No "+e);return a[e]}function w(e){var t,n=e?e.indexOf("!"):-1;return n>-1&&(t=e.substring(0,n),e=e.substring(n+1,e.length)),[t,e]}function E(e){return function(){return l&&l.config&&l.config[e]||{}}}var i,s,o,u,a={},f={},l={},c={},h=Object.prototype.hasOwnProperty,p=[].slice;o=function(e,t){var n,r=w(e),i=r[0];return e=r[1],i&&(i=v(i,t),n=b(i)),i?n&&n.normalize?e=n.normalize(e,g(t)):e=v(e,t):(e=v(e,t),r=w(e),i=r[0],e=r[1],i&&(n=b(i))),{f:i?i+"!"+e:e,n:e,pr:i,p:n}},u={require:function(e){return m(e)},exports:function(e){var t=a[e];return typeof t!="undefined"?t:a[e]={}},module:function(e){return{id:e,uri:"",exports:a[e],config:E(e)}}},i=function(e,t,n,i){var s,l,h,p,v,g=[],w=typeof n,E;i=i||e;if(w==="undefined"||w==="function"){t=!t.length&&n.length?["require","exports","module"]:t;for(v=0;v<t.length;v+=1){p=o(t[v],i),l=p.f;if(l==="require")g[v]=u.require(e);else if(l==="exports")g[v]=u.exports(e),E=!0;else if(l==="module")s=g[v]=u.module(e);else if(d(a,l)||d(f,l)||d(c,l))g[v]=b(l);else{if(!p.p)throw new Error(e+" missing "+l);p.p.load(p.n,m(i,!0),y(l),{}),g[v]=a[l]}}h=n?n.apply(a[e],g):undefined;if(e)if(s&&s.exports!==r&&s.exports!==a[e])a[e]=s.exports;else if(h!==r||!E)a[e]=h}else e&&(a[e]=n)},e=t=s=function(e,t,n,a,f){var c,h;if(typeof e=="string")return u[e]?u[e](t):b(o(e,t).f);if(!e.splice){l=e,l.deps&&s(l.deps,l.callback),h=l.packages;if(l.packages){l.pkgs={};for(c=0;c<h.length;c++)l.pkgs[h[c].name||h[c]]=!0}if(!t)return;t.splice?(e=t,t=n,n=null):e=r}return t=t||function(){},typeof n=="function"&&(n=a,a=f),a?i(r,e,t,n):setTimeout(function(){i(r,e,t,n)},4),s},s.config=function(e){return s(e)},e._defined=a,n=function(e,t,n){t.splice||(n=t,t=[]),!d(a,e)&&!d(f,e)&&(f[e]=[e,t,n])},n.amd={jQuery:!0}})(),n("node_modules/almond/almond",function(){}),function(){function e(e){var t=e.util=e.util||{};typeof process=="undefined"||!process.nextTick?typeof setImmediate=="function"?(t.setImmediate=setImmediate,t.nextTick=function(e){return setImmediate(e)}):(t.setImmediate=function(e){setTimeout(e,0)},t.nextTick=t.setImmediate):(t.nextTick=process.nextTick,typeof setImmediate=="function"?t.setImmediate=setImmediate:t.setImmediate=t.nextTick),t.isArray=Array.isArray||function(e){return Object.prototype.toString.call(e)==="[object Array]"},t.isArrayBuffer=function(e){return typeof ArrayBuffer!="undefined"&&e instanceof ArrayBuffer};var n=[];typeof Int8Array!="undefined"&&n.push(Int8Array),typeof Uint8Array!="undefined"&&n.push(Uint8Array),typeof Uint8ClampedArray!="undefined"&&n.push(Uint8ClampedArray),typeof Int16Array!="undefined"&&n.push(Int16Array),typeof Uint16Array!="undefined"&&n.push(Uint16Array),typeof Int32Array!="undefined"&&n.push(Int32Array),typeof Uint32Array!="undefined"&&n.push(Uint32Array),typeof Float32Array!="undefined"&&n.push(Float32Array),typeof Float64Array!="undefined"&&n.push(Float64Array),t.isArrayBufferView=function(e){for(var t=0;t<n.length;++t)if(e instanceof n[t])return!0;return!1},t.ByteBuffer=function(e){this.data="",this.read=0;if(typeof e=="string")this.data=e;else if(t.isArrayBuffer(e)||t.isArrayBufferView(e)){var n=new Uint8Array(e);try{this.data=String.fromCharCode.apply(null,n)}catch(r){for(var i=0;i<n.length;++i)this.putByte(n[i])}}},t.ByteBuffer.prototype.length=function(){return this.data.length-this.read},t.ByteBuffer.prototype.isEmpty=function(){return this.length()<=0},t.ByteBuffer.prototype.putByte=function(e){return this.data+=String.fromCharCode(e),this},t.ByteBuffer.prototype.fillWithByte=function(e,t){e=String.fromCharCode(e);var n=this.data;while(t>0)t&1&&(n+=e),t>>>=1,t>0&&(e+=e);return this.data=n,this},t.ByteBuffer.prototype.putBytes=function(e){return this.data+=e,this},t.ByteBuffer.prototype.putString=function(e){return this.data+=t.encodeUtf8(e),this},t.ByteBuffer.prototype.putInt16=function(e){return this.data+=String.fromCharCode(e>>8&255)+String.fromCharCode(e&255),this},t.ByteBuffer.prototype.putInt24=function(e){return this.data+=String.fromCharCode(e>>16&255)+String.fromCharCode(e>>8&255)+String.fromCharCode(e&255),this},t.ByteBuffer.prototype.putInt32=function(e){return this.data+=String.fromCharCode(e>>24&255)+String.fromCharCode(e>>16&255)+String.fromCharCode(e>>8&255)+String.fromCharCode(e&255),this},t.ByteBuffer.prototype.putInt16Le=function(e){return this.data+=String.fromCharCode(e&255)+String.fromCharCode(e>>8&255),this},t.ByteBuffer.prototype.putInt24Le=function(e){return this.data+=String.fromCharCode(e&255)+String.fromCharCode(e>>8&255)+String.fromCharCode(e>>16&255),this},t.ByteBuffer.prototype.putInt32Le=function(e){return this.data+=String.fromCharCode(e&255)+String.fromCharCode(e>>8&255)+String.fromCharCode(e>>16&255)+String.fromCharCode(e>>24&255),this},t.ByteBuffer.prototype.putInt=function(e,t){do t-=8,this.data+=String.fromCharCode(e>>t&255);while(t>0);return this},t.ByteBuffer.prototype.putSignedInt=function(e,t){return e<0&&(e+=2<<t-1),this.putInt(e,t)},t.ByteBuffer.prototype.putBuffer=function(e){return this.data+=e.getBytes(),this},t.ByteBuffer.prototype.getByte=function(){return this.data.charCodeAt(this.read++)},t.ByteBuffer.prototype.getInt16=function(){var e=this.data.charCodeAt(this.read)<<8^this.data.charCodeAt(this.read+1);return this.read+=2,e},t.ByteBuffer.prototype.getInt24=function(){var e=this.data.charCodeAt(this.read)<<16^this.data.charCodeAt(this.read+1)<<8^this.data.charCodeAt(this.read+2);return this.read+=3,e},t.ByteBuffer.prototype.getInt32=function(){var e=this.data.charCodeAt(this.read)<<24^this.data.charCodeAt(this.read+1)<<16^this.data.charCodeAt(this.read+2)<<8^this.data.charCodeAt(this.read+3);return this.read+=4,e},t.ByteBuffer.prototype.getInt16Le=function(){var e=this.data.charCodeAt(this.read)^this.data.charCodeAt(this.read+1)<<8;return this.read+=2,e},t.ByteBuffer.prototype.getInt24Le=function(){var e=this.data.charCodeAt(this.read)^this.data.charCodeAt(this.read+1)<<8^this.data.charCodeAt(this.read+2)<<16;return this.read+=3,e},t.ByteBuffer.prototype.getInt32Le=function(){var e=this.data.charCodeAt(this.read)^this.data.charCodeAt(this.read+1)<<8^this.data.charCodeAt(this.read+2)<<16^this.data.charCodeAt(this.read+3)<<24;return this.read+=4,e},t.ByteBuffer.prototype.getInt=function(e){var t=0;do t=(t<<8)+this.data.charCodeAt(this.read++),e-=8;while(e>0);return t},t.ByteBuffer.prototype.getSignedInt=function(e){var t=this.getInt(e),n=2<<e-2;return t>=n&&(t-=n<<1),t},t.ByteBuffer.prototype.getBytes=function(e){var t;return e?(e=Math.min(this.length(),e),t=this.data.slice(this.read,this.read+e),this.read+=e):e===0?t="":(t=this.read===0?this.data:this.data.slice(this.read),this.clear()),t},t.ByteBuffer.prototype.bytes=function(e){return typeof e=="undefined"?this.data.slice(this.read):this.data.slice(this.read,this.read+e)},t.ByteBuffer.prototype.at=function(e){return this.data.charCodeAt(this.read+e)},t.ByteBuffer.prototype.setAt=function(e,t){return this.data=this.data.substr(0,this.read+e)+String.fromCharCode(t)+this.data.substr(this.read+e+1),this},t.ByteBuffer.prototype.last=function(){return this.data.charCodeAt(this.data.length-1)},t.ByteBuffer.prototype.copy=function(){var e=t.createBuffer(this.data);return e.read=this.read,e},t.ByteBuffer.prototype.compact=function(){return this.read>0&&(this.data=this.data.slice(this.read),this.read=0),this},t.ByteBuffer.prototype.clear=function(){return this.data="",this.read=0,this},t.ByteBuffer.prototype.truncate=function(e){var t=Math.max(0,this.length()-e);return this.data=this.data.substr(this.read,t),this.read=0,this},t.ByteBuffer.prototype.toHex=function(){var e="";for(var t=this.read;t<this.data.length;++t){var n=this.data.charCodeAt(t);n<16&&(e+="0"),e+=n.toString(16)}return e},t.ByteBuffer.prototype.toString=function(){return t.decodeUtf8(this.bytes())},t.createBuffer=function(e,n){return n=n||"raw",e!==undefined&&n==="utf8"&&(e=t.encodeUtf8(e)),new t.ByteBuffer(e)},t.fillString=function(e,t){var n="";while(t>0)t&1&&(n+=e),t>>>=1,t>0&&(e+=e);return n},t.xorBytes=function(e,t,n){var r="",i="",s="",o=0,u=0;for(;n>0;--n,++o)i=e.charCodeAt(o)^t.charCodeAt(o),u>=10&&(r+=s,s="",u=0),s+=String.fromCharCode(i),++u;return r+=s,r},t.hexToBytes=function(e){var t="",n=0;e.length&!0&&(n=1,t+=String.fromCharCode(parseInt(e[0],16)));for(;n<e.length;n+=2)t+=String.fromCharCode(parseInt(e.substr(n,2),16));return t},t.bytesToHex=function(e){return t.createBuffer(e).toHex()},t.int32ToBytes=function(e){return String.fromCharCode(e>>24&255)+String.fromCharCode(e>>16&255)+String.fromCharCode(e>>8&255)+String.fromCharCode(e&255)};var r="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",i=[62,-1,-1,-1,63,52,53,54,55,56,57,58,59,60,61,-1,-1,-1,64,-1,-1,-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,-1,-1,-1,-1,-1,-1,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51];t.encode64=function(e,t){var n="",i="",s,o,u,a=0;while(a<e.length)s=e.charCodeAt(a++),o=e.charCodeAt(a++),u=e.charCodeAt(a++),n+=r.charAt(s>>2),n+=r.charAt((s&3)<<4|o>>4),isNaN(o)?n+="==":(n+=r.charAt((o&15)<<2|u>>6),n+=isNaN(u)?"=":r.charAt(u&63)),t&&n.length>t&&(i+=n.substr(0,t)+"\r\n",n=n.substr(t));return i+=n,i},t.decode64=function(e){e=e.replace(/[^A-Za-z0-9\+\/\=]/g,"");var t="",n,r,s,o,u=0;while(u<e.length)n=i[e.charCodeAt(u++)-43],r=i[e.charCodeAt(u++)-43],s=i[e.charCodeAt(u++)-43],o=i[e.charCodeAt(u++)-43],t+=String.fromCharCode(n<<2|r>>4),s!==64&&(t+=String.fromCharCode((r&15)<<4|s>>2),o!==64&&(t+=String.fromCharCode((s&3)<<6|o)));return t},t.encodeUtf8=function(e){return unescape(encodeURIComponent(e))},t.decodeUtf8=function(e){return decodeURIComponent(escape(e))},t.deflate=function(e,n,r){n=t.decode64(e.deflate(t.encode64(n)).rval);if(r){var i=2,s=n.charCodeAt(1);s&32&&(i=6),n=n.substring(i,n.length-4)}return n},t.inflate=function(e,n,r){var i=e.inflate(t.encode64(n)).rval;return i===null?null:t.decode64(i)};var s=function(e,n,r){if(!e)throw{message:"WebStorage not available."};var i;r===null?i=e.removeItem(n):(r=t.encode64(JSON.stringify(r)),i=e.setItem(n,r));if(typeof i!="undefined"&&i.rval!==!0)throw i.error},o=function(e,n){if(!e)throw{message:"WebStorage not available."};var r=e.getItem(n);if(e.init)if(r.rval===null){if(r.error)throw r.error;r=null}else r=r.rval;return r!==null&&(r=JSON.parse(t.decode64(r))),r},u=function(e,t,n,r){var i=o(e,t);i===null&&(i={}),i[n]=r,s(e,t,i)},a=function(e,t,n){var r=o(e,t);return r!==null&&(r=n in r?r[n]:null),r},f=function(e,t,n){var r=o(e,t);if(r!==null&&n in r){delete r[n];var i=!0;for(var u in r){i=!1;break}i&&(r=null),s(e,t,r)}},l=function(e,t){s(e,t,null)},c=function(e,t,n){var r=null;typeof n=="undefined"&&(n=["web","flash"]);var i,s=!1,o=null;for(var u in n){i=n[u];try{if(i==="flash"||i==="both"){if(t[0]===null)throw{message:"Flash local storage not available."};r=e.apply(this,t),s=i==="flash"}if(i==="web"||i==="both")t[0]=localStorage,r=e.apply(this,t),s=!0}catch(a){o=a}if(s)break}if(!s)throw o;return r};t.setItem=function(e,t,n,r,i){c(u,arguments,i)},t.getItem=function(e,t,n,r){return c(a,arguments,r)},t.removeItem=function(e,t,n,r){c(f,arguments,r)},t.clearItems=function(e,t,n){c(l,arguments,n)},t.parseUrl=function(e){var t=/^(https?):\/\/([^:&^\/]*):?(\d*)(.*)$/g;t.lastIndex=0;var n=t.exec(e),r=n===null?null:{full:e,scheme:n[1],host:n[2],port:n[3],path:n[4]};return r&&(r.fullHost=r.host,r.port?r.port!==80&&r.scheme==="http"?r.fullHost+=":"+r.port:r.port!==443&&r.scheme==="https"&&(r.fullHost+=":"+r.port):r.scheme==="http"?r.port=80:r.scheme==="https"&&(r.port=443),r.full=r.scheme+"://"+r.fullHost),r};var h=null;t.getQueryVariables=function(e){var t=function(e){var t={},n=e.split("&");for(var r=0;r<n.length;r++){var i=n[r].indexOf("="),s,o;i>0?(s=n[r].substring(0,i),o=n[r].substring(i+1)):(s=n[r],o=null),s in t||(t[s]=[]),!(s in Object.prototype)&&o!==null&&t[s].push(unescape(o))}return t},n;return typeof e=="undefined"?(h===null&&(typeof window=="undefined"?h={}:h=t(window.location.search.substring(1))),n=h):n=t(e),n},t.parseFragment=function(e){var n=e,r="",i=e.indexOf("?");i>0&&(n=e.substring(0,i),r=e.substring(i+1));var s=n.split("/");s.length>0&&s[0]===""&&s.shift();var o=r===""?{}:t.getQueryVariables(r);return{pathString:n,queryString:r,path:s,query:o}},t.makeRequest=function(e){var n=t.parseFragment(e),r={path:n.pathString,query:n.queryString,getPath:function(e){return typeof e=="undefined"?n.path:n.path[e]},getQuery:function(e,t){var r;return typeof e=="undefined"?r=n.query:(r=n.query[e],r&&typeof t!="undefined"&&(r=r[t])),r},getQueryLast:function(e,t){var n,i=r.getQuery(e);return i?n=i[i.length-1]:n=t,n}};return r},t.makeLink=function(e,t,n){e=jQuery.isArray(e)?e.join("/"):e;var r=jQuery.param(t||{});return n=n||"",e+(r.length>0?"?"+r:"")+(n.length>0?"#"+n:"")},t.setPath=function(e,t,n){if(typeof e=="object"&&e!==null){var r=0,i=t.length;while(r<i){var s=t[r++];if(r==i)e[s]=n;else{var o=s in e;if(!o||o&&typeof e[s]!="object"||o&&e[s]===null)e[s]={};e=e[s]}}}},t.getPath=function(e,t,n){var r=0,i=t.length,s=!0;while(s&&r<i&&typeof e=="object"&&e!==null){var o=t[r++];s=o in e,s&&(e=e[o])}return s?e:n},t.deletePath=function(e,t){if(typeof e=="object"&&e!==null){var n=0,r=t.length;while(n<r){var i=t[n++];if(n==r)delete e[i];else{if(!(i in e&&typeof e[i]=="object"&&e[i]!==null))break;e=e[i]}}}},t.isEmpty=function(e){for(var t in e)if(e.hasOwnProperty(t))return!1;return!0},t.format=function(e){var t=/%./g,n,r,i=0,s=[],o=0;while(n=t.exec(e)){r=e.substring(o,t.lastIndex-2),r.length>0&&s.push(r),o=t.lastIndex;var u=n[0][1];switch(u){case"s":case"o":i<arguments.length?s.push(arguments[i++ +1]):s.push("<?>");break;case"%":s.push("%");break;default:s.push("<%"+u+"?>")}}return s.push(e.substring(o)),s.join("")},t.formatNumber=function(e,t,n,r){var i=e,s=isNaN(t=Math.abs(t))?2:t,o=n===undefined?",":n,u=r===undefined?".":r,a=i<0?"-":"",f=parseInt(i=Math.abs(+i||0).toFixed(s),10)+"",l=f.length>3?f.length%3:0;return a+(l?f.substr(0,l)+u:"")+f.substr(l).replace(/(\d{3})(?=\d)/g,"$1"+u)+(s?o+Math.abs(i-f).toFixed(s).slice(2):"")},t.formatSize=function(e){return e>=1073741824?e=t.formatNumber(e/1073741824,2,".","")+" GiB":e>=1048576?e=t.formatNumber(e/1048576,2,".","")+" MiB":e>=1024?e=t.formatNumber(e/1024,0)+" KiB":e=t.formatNumber(e,0)+" bytes",e},t.bytesFromIP=function(e){return e.indexOf(".")!==-1?t.bytesFromIPv4(e):e.indexOf(":")!==-1?t.bytesFromIPv6(e):null},t.bytesFromIPv4=function(e){e=e.split(".");if(e.length!==4)return null;var n=t.createBuffer();for(var r=0;r<e.length;++r){var i=parseInt(e[r],10);if(isNaN(i))return null;n.putByte(i)}return n.getBytes()},t.bytesFromIPv6=function(e){var n=0;e=e.split(":").filter(function(e){return e.length===0&&++n,!0});var r=(8-e.length+n)*2,i=t.createBuffer();for(var s=0;s<8;++s){if(!e[s]||e[s].length===0){i.fillWithByte(0,r),r=0;continue}var o=t.hexToBytes(e[s]);o.length<2&&i.putByte(0),i.putBytes(o)}return i.getBytes()},t.bytesToIP=function(e){return e.length===4?t.bytesToIPv4(e):e.length===16?t.bytesToIPv6(e):null},t.bytesToIPv4=function(e){if(e.length!==4)return null;var t=[];for(var n=0;n<e.length;++n)t.push(e.charCodeAt(n));return t.join(".")},t.bytesToIPv6=function(e){if(e.length!==16)return null;var n=[],r=[],i=0;for(var s=0;s<e.length;s+=2){var o=t.bytesToHex(e[s]+e[s+1]);while(o[0]==="0"&&o!=="0")o=o.substr(1);if(o==="0"){var u=r[r.length-1],a=n.length;!u||a!==u.end+1?r.push({start:a,end:a}):(u.end=a,u.end-u.start>r[i].end-r[i].start&&(i=r.length-1))}n.push(o)}if(r.length>0){var f=r[i];f.end-f.start>0&&(n.splice(f.start,f.end-f.start+1,""),f.start===0&&n.unshift(""),f.end===7&&n.push(""))}return n.join(":")}}var r="util";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/util",["require","module"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){var t=!1,n=4,r,i,s,o,u,a=function(){t=!0,s=[0,1,2,4,8,16,32,64,128,27,54];var e=new Array(256);for(var n=0;n<128;++n)e[n]=n<<1,e[n+128]=n+128<<1^283;r=new Array(256),i=new Array(256),o=new Array(4),u=new Array(4);for(var n=0;n<4;++n)o[n]=new Array(256),u[n]=new Array(256);var a=0,f=0,l,c,h,p,d,v,m;for(var n=0;n<256;++n){p=f^f<<1^f<<2^f<<3^f<<4,p=p>>8^p&255^99,r[a]=p,i[p]=a,d=e[p],l=e[a],c=e[l],h=e[c],v=d<<24^p<<16^p<<8^(p^d),m=(l^c^h)<<24^(a^h)<<16^(a^c^h)<<8^(a^l^h);for(var g=0;g<4;++g)o[g][a]=v,u[g][p]=m,v=v<<24|v>>>8,m=m<<24|m>>>8;a===0?a=f=1:(a=l^e[e[e[l^h]]],f^=e[e[f]])}},f=function(e,t){var i=e.slice(0),o,a=1,f=i.length,l=f+6+1,c=n*l;for(var h=f;h<c;++h)o=i[h-1],h%f===0?(o=r[o>>>16&255]<<24^r[o>>>8&255]<<16^r[o&255]<<8^r[o>>>24]^s[a]<<24,a++):f>6&&h%f===4&&(o=r[o>>>24]<<24^r[o>>>16&255]<<16^r[o>>>8&255]<<8^r[o&255]),i[h]=i[h-f]^o;if(t){var p,d=u[0],v=u[1],m=u[2],g=u[3],y=i.slice(0),c=i.length;for(var h=0,b=c-n;h<c;h+=n,b-=n)if(h===0||h===c-n)y[h]=i[b],y[h+1]=i[b+3],y[h+2]=i[b+2],y[h+3]=i[b+1];else for(var w=0;w<n;++w)p=i[b+w],y[h+(3&-w)]=d[r[p>>>24]]^v[r[p>>>16&255]]^m[r[p>>>8&255]]^g[r[p&255]];i=y}return i},l=function(e,t,n,s){var a=e.length/4-1,f,l,c,h,p;s?(f=u[0],l=u[1],c=u[2],h=u[3],p=i):(f=o[0],l=o[1],c=o[2],h=o[3],p=r);var d,v,m,g,y,b,w;d=t[0]^e[0],v=t[s?3:1]^e[1],m=t[2]^e[2],g=t[s?1:3]^e[3];var E=3;for(var S=1;S<a;++S)y=f[d>>>24]^l[v>>>16&255]^c[m>>>8&255]^h[g&255]^e[++E],b=f[v>>>24]^l[m>>>16&255]^c[g>>>8&255]^h[d&255]^e[++E],w=f[m>>>24]^l[g>>>16&255]^c[d>>>8&255]^h[v&255]^e[++E],g=f[g>>>24]^l[d>>>16&255]^c[v>>>8&255]^h[m&255]^e[++E],d=y,v=b,m=w;n[0]=p[d>>>24]<<24^p[v>>>16&255]<<16^p[m>>>8&255]<<8^p[g&255]^e[++E],n[s?3:1]=p[v>>>24]<<24^p[m>>>16&255]<<16^p[g>>>8&255]<<8^p[d&255]^e[++E],n[2]=p[m>>>24]<<24^p[g>>>16&255]<<16^p[d>>>8&255]<<8^p[v&255]^e[++E],n[s?1:3]=p[g>>>24]<<24^p[d>>>16&255]<<16^p[v>>>8&255]<<8^p[m&255]^e[++E]},c=function(r,i,s,o,u){function C(){if(o)for(var e=0;e<n;++e)E[e]=b.getInt32();else for(var e=0;e<n;++e)E[e]=x[e]^b.getInt32();l(g,E,S,o);if(o){for(var e=0;e<n;++e)w.putInt32(x[e]^S[e]);x=E.slice(0)}else{for(var e=0;e<n;++e)w.putInt32(S[e]);x=S}}function k(){l(g,E,S,!1);for(var e=0;e<n;++e)E[e]=b.getInt32();for(var e=0;e<n;++e){var t=E[e]^S[e];o||(E[e]=t),w.putInt32(t)}}function L(){l(g,E,S,!1);for(var e=0;e<n;++e)E[e]=b.getInt32();for(var e=0;e<n;++e)w.putInt32(E[e]^S[e]),E[e]=S[e]}function A(){l(g,E,S,!1);for(var e=n-1;e>=0;--e){if(E[e]!==4294967295){++E[e];break}E[e]=0}for(var e=0;e<n;++e)w.putInt32(b.getInt32()^S[e])}var c=null;t||a(),u=(u||"CBC").toUpperCase();if(typeof r!="string"||r.length!==16&&r.length!==24&&r.length!==32){if(e.util.isArray(r)&&(r.length===16||r.length===24||r.length===32)){var h=r,r=e.util.createBuffer();for(var p=0;p<h.length;++p)r.putByte(h[p])}}else r=e.util.createBuffer(r);if(!e.util.isArray(r)){var h=r;r=[];var d=h.length();if(d===16||d===24||d===32){d>>>=2;for(var p=0;p<d;++p)r.push(h.getInt32())}}if(!e.util.isArray(r)||r.length!==4&&r.length!==6&&r.length!==8)return c;var v=["CFB","OFB","CTR"].indexOf(u)!==-1,m=u==="CBC",g=f(r,o&&!v),y=n<<2,b,w,E,S,x,T,N;c={output:null};if(u==="CBC")N=C;else if(u==="CFB")N=k;else if(u==="OFB")N=L;else{if(u!=="CTR")throw{message:'Unsupported block cipher mode of operation: "'+u+'"'};N=A}return c.update=function(e){T||b.putBuffer(e);while(b.length()>=y||b.length()>0&&T)N()},c.finish=function(e){var t=!0,r=b.length()%y;if(!o)if(e)t=e(y,b,o);else if(m){var i=b.length()===y?y:y-b.length();b.fillWithByte(i,i)}t&&(T=!0,c.update());if(o){m&&(t=r===0);if(t)if(e)t=e(y,w,o);else if(m){var s=w.length(),u=w.at(s-1);u>n<<2?t=!1:w.truncate(u)}}return!m&&!e&&r>0&&w.truncate(y-r),t},c.start=function(t,r){t===null&&(t=x.slice(0));if(typeof t=="string"&&t.length===16)t=e.util.createBuffer(t);else if(e.util.isArray(t)&&t.length===16){var i=t,t=e.util.createBuffer();for(var s=0;s<16;++s)t.putByte(i[s])}if(!e.util.isArray(t)){var i=t;t=new Array(4),t[0]=i.getInt32(),t[1]=i.getInt32(),t[2]=i.getInt32(),t[3]=i.getInt32()}b=e.util.createBuffer(),w=r||e.util.createBuffer(),x=t.slice(0),E=new Array(n),S=new Array(n),T=!1,c.output=w;if(["CFB","OFB","CTR"].indexOf(u)!==-1){for(var s=0;s<n;++s)E[s]=x[s];x=null}},i!==null&&c.start(i,s),c};e.aes=e.aes||{},e.aes.startEncrypting=function(e,t,n,r){return c(e,t,n,!1,r)},e.aes.createEncryptionCipher=function(e,t){return c(e,null,null,!1,t)},e.aes.startDecrypting=function(e,t,n,r){return c(e,t,n,!0,r)},e.aes.createDecryptionCipher=function(e,t){return c(e,null,null,!0,t)},e.aes._expandKey=function(e,n){return t||a(),f(e,n)},e.aes._updateBlock=l}var r="aes";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/aes",["require","module","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){e.pki=e.pki||{};var t=e.pki.oids=e.oids=e.oids||{};t["1.2.840.113549.1.1.1"]="rsaEncryption",t.rsaEncryption="1.2.840.113549.1.1.1",t["1.2.840.113549.1.1.4"]="md5WithRSAEncryption",t.md5WithRSAEncryption="1.2.840.113549.1.1.4",t["1.2.840.113549.1.1.5"]="sha1WithRSAEncryption",t.sha1WithRSAEncryption="1.2.840.113549.1.1.5",t["1.2.840.113549.1.1.7"]="RSAES-OAEP",t["RSAES-OAEP"]="1.2.840.113549.1.1.7",t["1.2.840.113549.1.1.8"]="mgf1",t.mgf1="1.2.840.113549.1.1.8",t["1.2.840.113549.1.1.9"]="pSpecified",t.pSpecified="1.2.840.113549.1.1.9",t["1.2.840.113549.1.1.10"]="RSASSA-PSS",t["RSASSA-PSS"]="1.2.840.113549.1.1.10",t["1.2.840.113549.1.1.11"]="sha256WithRSAEncryption",t.sha256WithRSAEncryption="1.2.840.113549.1.1.11",t["1.2.840.113549.1.1.12"]="sha384WithRSAEncryption",t.sha384WithRSAEncryption="1.2.840.113549.1.1.12",t["1.2.840.113549.1.1.13"]="sha512WithRSAEncryption",t.sha512WithRSAEncryption="1.2.840.113549.1.1.13",t["1.3.14.3.2.7"]="desCBC",t.desCBC="1.3.14.3.2.7",t["1.3.14.3.2.26"]="sha1",t.sha1="1.3.14.3.2.26",t["2.16.840.1.101.3.4.2.1"]="sha256",t.sha256="2.16.840.1.101.3.4.2.1",t["2.16.840.1.101.3.4.2.2"]="sha384",t.sha384="2.16.840.1.101.3.4.2.2",t["2.16.840.1.101.3.4.2.3"]="sha512",t.sha512="2.16.840.1.101.3.4.2.3",t["1.2.840.113549.2.5"]="md5",t.md5="1.2.840.113549.2.5",t["1.2.840.113549.1.7.1"]="data",t.data="1.2.840.113549.1.7.1",t["1.2.840.113549.1.7.2"]="signedData",t.signedData="1.2.840.113549.1.7.2",t["1.2.840.113549.1.7.3"]="envelopedData",t.envelopedData="1.2.840.113549.1.7.3",t["1.2.840.113549.1.7.4"]="signedAndEnvelopedData",t.signedAndEnvelopedData="1.2.840.113549.1.7.4",t["1.2.840.113549.1.7.5"]="digestedData",t.digestedData="1.2.840.113549.1.7.5",t["1.2.840.113549.1.7.6"]="encryptedData",t.encryptedData="1.2.840.113549.1.7.6",t["1.2.840.113549.1.9.1"]="emailAddress",t.emailAddress="1.2.840.113549.1.9.1",t["1.2.840.113549.1.9.2"]="unstructuredName",t.unstructuredName="1.2.840.113549.1.9.2",t["1.2.840.113549.1.9.3"]="contentType",t.contentType="1.2.840.113549.1.9.3",t["1.2.840.113549.1.9.4"]="messageDigest",t.messageDigest="1.2.840.113549.1.9.4",t["1.2.840.113549.1.9.5"]="signingTime",t.signingTime="1.2.840.113549.1.9.5",t["1.2.840.113549.1.9.6"]="counterSignature",t.counterSignature="1.2.840.113549.1.9.6",t["1.2.840.113549.1.9.7"]="challengePassword",t.challengePassword="1.2.840.113549.1.9.7",t["1.2.840.113549.1.9.8"]="unstructuredAddress",t.unstructuredAddress="1.2.840.113549.1.9.8",t["1.2.840.113549.1.9.20"]="friendlyName",t.friendlyName="1.2.840.113549.1.9.20",t["1.2.840.113549.1.9.21"]="localKeyId",t.localKeyId="1.2.840.113549.1.9.21",t["1.2.840.113549.1.9.22.1"]="x509Certificate",t.x509Certificate="1.2.840.113549.1.9.22.1",t["1.2.840.113549.1.12.10.1.1"]="keyBag",t.keyBag="1.2.840.113549.1.12.10.1.1",t["1.2.840.113549.1.12.10.1.2"]="pkcs8ShroudedKeyBag",t.pkcs8ShroudedKeyBag="1.2.840.113549.1.12.10.1.2",t["1.2.840.113549.1.12.10.1.3"]="certBag",t.certBag="1.2.840.113549.1.12.10.1.3",t["1.2.840.113549.1.12.10.1.4"]="crlBag",t.crlBag="1.2.840.113549.1.12.10.1.4",t["1.2.840.113549.1.12.10.1.5"]="secretBag",t.secretBag="1.2.840.113549.1.12.10.1.5",t["1.2.840.113549.1.12.10.1.6"]="safeContentsBag",t.safeContentsBag="1.2.840.113549.1.12.10.1.6",t["1.2.840.113549.1.5.13"]="pkcs5PBES2",t.pkcs5PBES2="1.2.840.113549.1.5.13",t["1.2.840.113549.1.5.12"]="pkcs5PBKDF2",t.pkcs5PBKDF2="1.2.840.113549.1.5.12",t["1.2.840.113549.1.12.1.1"]="pbeWithSHAAnd128BitRC4",t.pbeWithSHAAnd128BitRC4="1.2.840.113549.1.12.1.1",t["1.2.840.113549.1.12.1.2"]="pbeWithSHAAnd40BitRC4",t.pbeWithSHAAnd40BitRC4="1.2.840.113549.1.12.1.2",t["1.2.840.113549.1.12.1.3"]="pbeWithSHAAnd3-KeyTripleDES-CBC",t["pbeWithSHAAnd3-KeyTripleDES-CBC"]="1.2.840.113549.1.12.1.3",t["1.2.840.113549.1.12.1.4"]="pbeWithSHAAnd2-KeyTripleDES-CBC",t["pbeWithSHAAnd2-KeyTripleDES-CBC"]="1.2.840.113549.1.12.1.4",t["1.2.840.113549.1.12.1.5"]="pbeWithSHAAnd128BitRC2-CBC",t["pbeWithSHAAnd128BitRC2-CBC"]="1.2.840.113549.1.12.1.5",t["1.2.840.113549.1.12.1.6"]="pbewithSHAAnd40BitRC2-CBC",t["pbewithSHAAnd40BitRC2-CBC"]="1.2.840.113549.1.12.1.6",t["1.2.840.113549.3.7"]="des-EDE3-CBC",t["des-EDE3-CBC"]="1.2.840.113549.3.7",t["2.16.840.1.101.3.4.1.2"]="aes128-CBC",t["aes128-CBC"]="2.16.840.1.101.3.4.1.2",t["2.16.840.1.101.3.4.1.22"]="aes192-CBC",t["aes192-CBC"]="2.16.840.1.101.3.4.1.22",t["2.16.840.1.101.3.4.1.42"]="aes256-CBC",t["aes256-CBC"]="2.16.840.1.101.3.4.1.42",t["2.5.4.3"]="commonName",t.commonName="2.5.4.3",t["2.5.4.5"]="serialName",t.serialName="2.5.4.5",t["2.5.4.6"]="countryName",t.countryName="2.5.4.6",t["2.5.4.7"]="localityName",t.localityName="2.5.4.7",t["2.5.4.8"]="stateOrProvinceName",t.stateOrProvinceName="2.5.4.8",t["2.5.4.10"]="organizationName",t.organizationName="2.5.4.10",t["2.5.4.11"]="organizationalUnitName",t.organizationalUnitName="2.5.4.11",t["2.16.840.1.113730.1.1"]="nsCertType",t.nsCertType="2.16.840.1.113730.1.1",t["2.5.29.1"]="authorityKeyIdentifier",t["2.5.29.2"]="keyAttributes",t["2.5.29.3"]="certificatePolicies",t["2.5.29.4"]="keyUsageRestriction",t["2.5.29.5"]="policyMapping",t["2.5.29.6"]="subtreesConstraint",t["2.5.29.7"]="subjectAltName",t["2.5.29.8"]="issuerAltName",t["2.5.29.9"]="subjectDirectoryAttributes",t["2.5.29.10"]="basicConstraints",t["2.5.29.11"]="nameConstraints",t["2.5.29.12"]="policyConstraints",t["2.5.29.13"]="basicConstraints",t["2.5.29.14"]="subjectKeyIdentifier",t.subjectKeyIdentifier="2.5.29.14",t["2.5.29.15"]="keyUsage",t.keyUsage="2.5.29.15",t["2.5.29.16"]="privateKeyUsagePeriod",t["2.5.29.17"]="subjectAltName",t.subjectAltName="2.5.29.17",t["2.5.29.18"]="issuerAltName",t.issuerAltName="2.5.29.18",t["2.5.29.19"]="basicConstraints",t.basicConstraints="2.5.29.19",t["2.5.29.20"]="cRLNumber",t["2.5.29.21"]="cRLReason",t["2.5.29.22"]="expirationDate",t["2.5.29.23"]="instructionCode",t["2.5.29.24"]="invalidityDate",t["2.5.29.25"]="cRLDistributionPoints",t["2.5.29.26"]="issuingDistributionPoint",t["2.5.29.27"]="deltaCRLIndicator",t["2.5.29.28"]="issuingDistributionPoint",t["2.5.29.29"]="certificateIssuer",t["2.5.29.30"]="nameConstraints",t["2.5.29.31"]="cRLDistributionPoints",t["2.5.29.32"]="certificatePolicies",t["2.5.29.33"]="policyMappings",t["2.5.29.34"]="policyConstraints",t["2.5.29.35"]="authorityKeyIdentifier",t["2.5.29.36"]="policyConstraints",t["2.5.29.37"]="extKeyUsage",t.extKeyUsage="2.5.29.37",t["2.5.29.46"]="freshestCRL",t["2.5.29.54"]="inhibitAnyPolicy",t["1.3.6.1.5.5.7.3.1"]="serverAuth",t.serverAuth="1.3.6.1.5.5.7.3.1",t["1.3.6.1.5.5.7.3.2"]="clientAuth",t.clientAuth="1.3.6.1.5.5.7.3.2",t["1.3.6.1.5.5.7.3.3"]="codeSigning",t.codeSigning="1.3.6.1.5.5.7.3.3",t["1.3.6.1.5.5.7.3.4"]="emailProtection",t.emailProtection="1.3.6.1.5.5.7.3.4",t["1.3.6.1.5.5.7.3.8"]="timeStamping",t.timeStamping="1.3.6.1.5.5.7.3.8"}var r="oids";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/oids",["require","module"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){var t=e.asn1=e.asn1||{};t.Class={UNIVERSAL:0,APPLICATION:64,CONTEXT_SPECIFIC:128,PRIVATE:192},t.Type={NONE:0,BOOLEAN:1,INTEGER:2,BITSTRING:3,OCTETSTRING:4,NULL:5,OID:6,ODESC:7,EXTERNAL:8,REAL:9,ENUMERATED:10,EMBEDDED:11,UTF8:12,ROID:13,SEQUENCE:16,SET:17,PRINTABLESTRING:19,IA5STRING:22,UTCTIME:23,GENERALIZEDTIME:24,BMPSTRING:30},t.create=function(t,n,r,i){if(e.util.isArray(i)){var s=[];for(var o=0;o<i.length;++o)i[o]!==undefined&&s.push(i[o]);i=s}return{tagClass:t,type:n,constructed:r,composed:r||e.util.isArray(i),value:i}};var n=function(e){var t=e.getByte();if(t===128)return undefined;var n,r=t&128;return r?n=e.getInt((t&127)<<3):n=t,n};t.fromDer=function(r,i){i===undefined&&(i=!0),typeof r=="string"&&(r=e.util.createBuffer(r));if(r.length()<2)throw{message:"Too few bytes to parse DER.",bytes:r.length()};var s=r.getByte(),o=s&192,u=s&31,a=n(r);if(r.length()<a){if(i)throw{message:"Too few bytes to read ASN.1 value.",detail:r.length()+" < "+a};a=r.length()}var f,l=(s&32)===32,c=l;if(!c&&o===t.Class.UNIVERSAL&&u===t.Type.BITSTRING&&a>1){var h=r.read,p=r.getByte();if(p===0){s=r.getByte();var d=s&192;if(d===t.Class.UNIVERSAL||d===t.Class.CONTEXT_SPECIFIC)try{var v=n(r);c=v===a-(r.read-h),c&&(++h,--a)}catch(m){}}r.read=h}if(c){f=[];if(a===undefined)for(;;){if(r.bytes(2)===String.fromCharCode(0,0)){r.getBytes(2);break}f.push(t.fromDer(r,i))}else{var g=r.length();while(a>0)f.push(t.fromDer(r,i)),a-=g-r.length(),g=r.length()}}else{if(a===undefined){if(i)throw{message:"Non-constructed ASN.1 object of indefinite length."};a=r.length()}if(u===t.Type.BMPSTRING){f="";for(var y=0;y<a;y+=2)f+=String.fromCharCode(r.getInt16())}else f=r.getBytes(a)}return t.create(o,u,l,f)},t.toDer=function(n){var r=e.util.createBuffer(),i=n.tagClass|n.type,s=e.util.createBuffer();if(n.composed){n.constructed?i|=32:s.putByte(0);for(var o=0;o<n.value.length;++o)n.value[o]!==undefined&&s.putBuffer(t.toDer(n.value[o]))}else if(n.type===t.Type.BMPSTRING)for(var o=0;o<n.value.length;++o)s.putInt16(n.value.charCodeAt(o));else s.putBytes(n.value);r.putByte(i);if(s.length()<=127)r.putByte(s.length()&127);else{var u=s.length(),a="";do a+=String.fromCharCode(u&255),u>>>=8;while(u>0);r.putByte(a.length|128);for(var o=a.length-1;o>=0;--o)r.putByte(a.charCodeAt(o))}return r.putBuffer(s),r},t.oidToDer=function(t){var n=t.split("."),r=e.util.createBuffer();r.putByte(40*parseInt(n[0],10)+parseInt(n[1],10));var i,s,o,u;for(var a=2;a<n.length;++a){i=!0,s=[],o=parseInt(n[a],10);do u=o&127,o>>>=7,i||(u|=128),s.push(u),i=!1;while(o>0);for(var f=s.length-1;f>=0;--f)r.putByte(s[f])}return r},t.derToOid=function(t){var n;typeof t=="string"&&(t=e.util.createBuffer(t));var r=t.getByte();n=Math.floor(r/40)+"."+r%40;var i=0;while(t.length()>0)r=t.getByte(),i<<=7,r&128?i+=r&127:(n+="."+(i+r),i=0);return n},t.utcTimeToDate=function(e){var t=new Date,n=parseInt(e.substr(0,2),10);n=n>=50?1900+n:2e3+n;var r=parseInt(e.substr(2,2),10)-1,i=parseInt(e.substr(4,2),10),s=parseInt(e.substr(6,2),10),o=parseInt(e.substr(8,2),10),u=0;if(e.length>11){var a=e.charAt(10),f=10;a!=="+"&&a!=="-"&&(u=parseInt(e.substr(10,2),10),f+=2)}t.setUTCFullYear(n,r,i),t.setUTCHours(s,o,u,0);if(f){a=e.charAt(f);if(a==="+"||a==="-"){var l=parseInt(e.substr(f+1,2),10),c=parseInt(e.substr(f+4,2),10),h=l*60+c;h*=6e4,a==="+"?t.setTime(+t-h):t.setTime(+t+h)}}return t},t.generalizedTimeToDate=function(e){var t=new Date,n=parseInt(e.substr(0,4),10),r=parseInt(e.substr(4,2),10)-1,i=parseInt(e.substr(6,2),10),s=parseInt(e.substr(8,2),10),o=parseInt(e.substr(10,2),10),u=parseInt(e.substr(12,2),10),a=0,f=0,l=!1;e.charAt(e.length-1)==="Z"&&(l=!0);var c=e.length-5,h=e.charAt(c);if(h==="+"||h==="-"){var p=parseInt(e.substr(c+1,2),10),d=parseInt(e.substr(c+4,2),10);f=p*60+d,f*=6e4,h==="+"&&(f*=-1),l=!0}return e.charAt(14)==="."&&(a=parseFloat(e.substr(14),10)*1e3),l?(t.setUTCFullYear(n,r,i),t.setUTCHours(s,o,u,a),t.setTime(+t+f)):(t.setFullYear(n,r,i),t.setHours(s,o,u,a)),t},t.dateToUtcTime=function(e){var t="",n=[];n.push((""+e.getUTCFullYear()).substr(2)),n.push(""+(e.getUTCMonth()+1)),n.push(""+e.getUTCDate()),n.push(""+e.getUTCHours()),n.push(""+e.getUTCMinutes()),n.push(""+e.getUTCSeconds());for(var r=0;r<n.length;++r)n[r].length<2&&(t+="0"),t+=n[r];return t+="Z",t},t.integerToDer=function(t){var n=e.util.createBuffer();if(t>=-128&&t<128)return n.putSignedInt(t,8);if(t>=-32768&&t<32768)return n.putSignedInt(t,16);if(t>=-8388608&&t<8388608)return n.putSignedInt(t,24);if(t>=-2147483648&&t<2147483648)return n.putSignedInt(t,32);throw{message:"Integer too large; max is 32-bits.",integer:t}},t.derToInteger=function(t){typeof t=="string"&&(t=e.util.createBuffer(t));var n=t.length()*8;if(n>32)throw{message:"Integer too large; max is 32-bits."};return t.getSignedInt(n)},t.validate=function(n,r,i,s){var o=!1;if(n.tagClass!==r.tagClass&&typeof r.tagClass!="undefined"||n.type!==r.type&&typeof r.type!="undefined")s&&(n.tagClass!==r.tagClass&&s.push("["+r.name+"] "+'Expected tag class "'+r.tagClass+'", got "'+n.tagClass+'"'),n.type!==r.type&&s.push("["+r.name+"] "+'Expected type "'+r.type+'", got "'+n.type+'"'));else if(n.constructed===r.constructed||typeof r.constructed=="undefined"){o=!0;if(r.value&&e.util.isArray(r.value)){var u=0;for(var a=0;o&&a<r.value.length;++a)o=r.value[a].optional||!1,n.value[u]&&(o=t.validate(n.value[u],r.value[a],i,s),o?++u:r.value[a].optional&&(o=!0)),!o&&s&&s.push("["+r.name+"] "+'Tag class "'+r.tagClass+'", type "'+r.type+'" expected value length "'+r.value.length+'", got "'+n.value.length+'"')}o&&i&&(r.capture&&(i[r.capture]=n.value),r.captureAsn1&&(i[r.captureAsn1]=n))}else s&&s.push("["+r.name+"] "+'Expected constructed "'+r.constructed+'", got "'+n.constructed+'"');return o};var r=/[^\\u0000-\\u00ff]/;t.prettyPrint=function(n,i,s){var o="";i=i||0,s=s||2,i>0&&(o+="\n");var u="";for(var a=0;a<i*s;++a)u+=" ";o+=u+"Tag: ";switch(n.tagClass){case t.Class.UNIVERSAL:o+="Universal:";break;case t.Class.APPLICATION:o+="Application:";break;case t.Class.CONTEXT_SPECIFIC:o+="Context-Specific:";break;case t.Class.PRIVATE:o+="Private:"}if(n.tagClass===t.Class.UNIVERSAL){o+=n.type;switch(n.type){case t.Type.NONE:o+=" (None)";break;case t.Type.BOOLEAN:o+=" (Boolean)";break;case t.Type.BITSTRING:o+=" (Bit string)";break;case t.Type.INTEGER:o+=" (Integer)";break;case t.Type.OCTETSTRING:o+=" (Octet string)";break;case t.Type.NULL:o+=" (Null)";break;case t.Type.OID:o+=" (Object Identifier)";break;case t.Type.ODESC:o+=" (Object Descriptor)";break;case t.Type.EXTERNAL:o+=" (External or Instance of)";break;case t.Type.REAL:o+=" (Real)";break;case t.Type.ENUMERATED:o+=" (Enumerated)";break;case t.Type.EMBEDDED:o+=" (Embedded PDV)";break;case t.Type.UTF8:o+=" (UTF8)";break;case t.Type.ROID:o+=" (Relative Object Identifier)";break;case t.Type.SEQUENCE:o+=" (Sequence)";break;case t.Type.SET:o+=" (Set)";break;case t.Type.PRINTABLESTRING:o+=" (Printable String)";break;case t.Type.IA5String:o+=" (IA5String (ASCII))";break;case t.Type.UTCTIME:o+=" (UTC time)";break;case t.Type.GENERALIZEDTIME:o+=" (Generalized time)";break;case t.Type.BMPSTRING:o+=" (BMP String)"}}else o+=n.type;o+="\n",o+=u+"Constructed: "+n.constructed+"\n";if(n.composed){var f=0,l="";for(var a=0;a<n.value.length;++a)n.value[a]!==undefined&&(f+=1,l+=t.prettyPrint(n.value[a],i+1,s),a+1<n.value.length&&(l+=","));o+=u+"Sub values: "+f+l}else{o+=u+"Value: ";if(n.type===t.Type.OID){var c=t.derToOid(n.value);o+=c,e.pki&&e.pki.oids&&c in e.pki.oids&&(o+=" ("+e.pki.oids[c]+")")}if(n.type===t.Type.INTEGER)try{o+=t.derToInteger(n.value)}catch(h){o+="0x"+e.util.bytesToHex(n.value)}else r.test(n.value)?o+="0x"+e.util.createBuffer(n.value,"utf8").toHex():n.value.length===0?o+="[null]":o+=n.value}return o}}var r="asn1";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/asn1",["require","module","./util","./oids"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){var t=e.md5=e.md5||{};e.md=e.md||{},e.md.algorithms=e.md.algorithms||{},e.md.md5=e.md.algorithms.md5=t;var n=null,r=null,i=null,s=null,o=!1,u=function(){n=String.fromCharCode(128),n+=e.util.fillString(String.fromCharCode(0),64),r=[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,1,6,11,0,5,10,15,4,9,14,3,8,13,2,7,12,5,8,11,14,1,4,7,10,13,0,3,6,9,12,15,2,0,7,14,5,12,3,10,1,8,15,6,13,4,11,2,9],i=[7,12,17,22,7,12,17,22,7,12,17,22,7,12,17,22,5,9,14,20,5,9,14,20,5,9,14,20,5,9,14,20,4,11,16,23,4,11,16,23,4,11,16,23,4,11,16,23,6,10,15,21,6,10,15,21,6,10,15,21,6,10,15,21],s=new Array(64);for(var t=0;t<64;++t)s[t]=Math.floor(Math.abs(Math.sin(t+1))*4294967296);o=!0},a=function(e,t,n){var o,u,a,f,l,c,h,p,d=n.length();while(d>=64){u=e.h0,a=e.h1,f=e.h2,l=e.h3;for(p=0;p<16;++p)t[p]=n.getInt32Le(),c=l^a&(f^l),o=u+c+s[p]+t[p],h=i[p],u=l,l=f,f=a,a+=o<<h|o>>>32-h;for(;p<32;++p)c=f^l&(a^f),o=u+c+s[p]+t[r[p]],h=i[p],u=l,l=f,f=a,a+=o<<h|o>>>32-h;for(;p<48;++p)c=a^f^l,o=u+c+s[p]+t[r[p]],h=i[p],u=l,l=f,f=a,a+=o<<h|o>>>32-h;for(;p<64;++p)c=f^(a|~l),o=u+c+s[p]+t[r[p]],h=i[p],u=l,l=f,f=a,a+=o<<h|o>>>32-h;e.h0=e.h0+u&4294967295,e.h1=e.h1+a&4294967295,e.h2=e.h2+f&4294967295,e.h3=e.h3+l&4294967295,d-=64}};t.create=function(){o||u();var t=null,r=e.util.createBuffer(),i=new Array(16),s={algorithm:"md5",blockLength:64,digestLength:16,messageLength:0};return s.start=function(){return s.messageLength=0,r=e.util.createBuffer(),t={h0:1732584193,h1:4023233417,h2:2562383102,h3:271733878},s},s.start(),s.update=function(n,o){return o==="utf8"&&(n=e.util.encodeUtf8(n)),s.messageLength+=n.length,r.putBytes(n),a(t,i,r),(r.read>2048||r.length()===0)&&r.compact(),s},s.digest=function(){var o=s.messageLength,u=e.util.createBuffer();u.putBytes(r.bytes()),u.putBytes(n.substr(0,64-(o+8)%64)),u.putInt32Le(o<<3&4294967295),u.putInt32Le(o>>>29&255);var f={h0:t.h0,h1:t.h1,h2:t.h2,h3:t.h3};a(f,i,u);var l=e.util.createBuffer();return l.putInt32Le(f.h0),l.putInt32Le(f.h1),l.putInt32Le(f.h2),l.putInt32Le(f.h3),l},s}}var r="md5";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/md5",["require","module","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){var t=e.sha1=e.sha1||{};e.md=e.md||{},e.md.algorithms=e.md.algorithms||{},e.md.sha1=e.md.algorithms.sha1=t;var n=null,r=!1,i=function(){n=String.fromCharCode(128),n+=e.util.fillString(String.fromCharCode(0),64),r=!0},s=function(e,t,n){var r,i,s,o,u,a,f,l,c=n.length();while(c>=64){i=e.h0,s=e.h1,o=e.h2,u=e.h3,a=e.h4;for(l=0;l<16;++l)r=n.getInt32(),t[l]=r,f=u^s&(o^u),r=(i<<5|i>>>27)+f+a+1518500249+r,a=u,u=o,o=s<<30|s>>>2,s=i,i=r;for(;l<20;++l)r=t[l-3]^t[l-8]^t[l-14]^t[l-16],r=r<<1|r>>>31,t[l]=r,f=u^s&(o^u),r=(i<<5|i>>>27)+f+a+1518500249+r,a=u,u=o,o=s<<30|s>>>2,s=i,i=r;for(;l<32;++l)r=t[l-3]^t[l-8]^t[l-14]^t[l-16],r=r<<1|r>>>31,t[l]=r,f=s^o^u,r=(i<<5|i>>>27)+f+a+1859775393+r,a=u,u=o,o=s<<30|s>>>2,s=i,i=r;for(;l<40;++l)r=t[l-6]^t[l-16]^t[l-28]^t[l-32],r=r<<2|r>>>30,t[l]=r,f=s^o^u,r=(i<<5|i>>>27)+f+a+1859775393+r,a=u,u=o,o=s<<30|s>>>2,s=i,i=r;for(;l<60;++l)r=t[l-6]^t[l-16]^t[l-28]^t[l-32],r=r<<2|r>>>30,t[l]=r,f=s&o|u&(s^o),r=(i<<5|i>>>27)+f+a+2400959708+r,a=u,u=o,o=s<<30|s>>>2,s=i,i=r;for(;l<80;++l)r=t[l-6]^t[l-16]^t[l-28]^t[l-32],r=r<<2|r>>>30,t[l]=r,f=s^o^u,r=(i<<5|i>>>27)+f+a+3395469782+r,a=u,u=o,o=s<<30|s>>>2,s=i,i=r;e.h0+=i,e.h1+=s,e.h2+=o,e.h3+=u,e.h4+=a,c-=64}};t.create=function(){r||i();var t=null,o=e.util.createBuffer(),u=new Array(80),a={algorithm:"sha1",blockLength:64,digestLength:20,messageLength:0};return a.start=function(){return a.messageLength=0,o=e.util.createBuffer(),t={h0:1732584193,h1:4023233417,h2:2562383102,h3:271733878,h4:3285377520},a},a.start(),a.update=function(n,r){return r==="utf8"&&(n=e.util.encodeUtf8(n)),a.messageLength+=n.length,o.putBytes(n),s(t,u,o),(o.read>2048||o.length()===0)&&o.compact(),a},a.digest=function(){var r=a.messageLength,i=e.util.createBuffer();i.putBytes(o.bytes()),i.putBytes(n.substr(0,64-(r+8)%64)),i.putInt32(r>>>29&255),i.putInt32(r<<3&4294967295);var f={h0:t.h0,h1:t.h1,h2:t.h2,h3:t.h3,h4:t.h4};s(f,u,i);var l=e.util.createBuffer();return l.putInt32(f.h0),l.putInt32(f.h1),l.putInt32(f.h2),l.putInt32(f.h3),l.putInt32(f.h4),l},a}}var r="sha1";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/sha1",["require","module","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){var t=e.sha256=e.sha256||{};e.md=e.md||{},e.md.algorithms=e.md.algorithms||{},e.md.sha256=e.md.algorithms.sha256=t;var n=null,r=!1,i=null,s=function(){n=String.fromCharCode(128),n+=e.util.fillString(String.fromCharCode(0),64),i=[1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298],r=!0},o=function(e,t,n){var r,s,o,u,a,f,l,c,h,p,d,v,m,g,y,b=n.length();while(b>=64){for(l=0;l<16;++l)t[l]=n.getInt32();for(;l<64;++l)r=t[l-2],r=(r>>>17|r<<15)^(r>>>19|r<<13)^r>>>10,s=t[l-15],s=(s>>>7|s<<25)^(s>>>18|s<<14)^s>>>3,t[l]=r+t[l-7]+s+t[l-16]&4294967295;c=e.h0,h=e.h1,p=e.h2,d=e.h3,v=e.h4,m=e.h5,g=e.h6,y=e.h7;for(l=0;l<64;++l)u=(v>>>6|v<<26)^(v>>>11|v<<21)^(v>>>25|v<<7),a=g^v&(m^g),o=(c>>>2|c<<30)^(c>>>13|c<<19)^(c>>>22|c<<10),f=c&h|p&(c^h),r=y+u+a+i[l]+t[l],s=o+f,y=g,g=m,m=v,v=d+r&4294967295,d=p,p=h,h=c,c=r+s&4294967295;e.h0=e.h0+c&4294967295,e.h1=e.h1+h&4294967295,e.h2=e.h2+p&4294967295,e.h3=e.h3+d&4294967295,e.h4=e.h4+v&4294967295,e.h5=e.h5+m&4294967295,e.h6=e.h6+g&4294967295,e.h7=e.h7+y&4294967295,b-=64}};t.create=function(){r||s();var t=null,i=e.util.createBuffer(),u=new Array(64),a={algorithm:"sha256",blockLength:64,digestLength:32,messageLength:0};return a.start=function(){return a.messageLength=0,i=e.util.createBuffer(),t={h0:1779033703,h1:3144134277,h2:1013904242,h3:2773480762,h4:1359893119,h5:2600822924,h6:528734635,h7:1541459225},a},a.start(),a.update=function(n,r){return r==="utf8"&&(n=e.util.encodeUtf8(n)),a.messageLength+=n.length,i.putBytes(n),o(t,u,i),(i.read>2048||i.length()===0)&&i.compact(),a},a.digest=function(){var r=a.messageLength,s=e.util.createBuffer();s.putBytes(i.bytes()),s.putBytes(n.substr(0,64-(r+8)%64)),s.putInt32(r>>>29&255),s.putInt32(r<<3&4294967295);var f={h0:t.h0,h1:t.h1,h2:t.h2,h3:t.h3,h4:t.h4,h5:t.h5,h6:t.h6,h7:t.h7};o(f,u,s);var l=e.util.createBuffer();return l.putInt32(f.h0),l.putInt32(f.h1),l.putInt32(f.h2),l.putInt32(f.h3),l.putInt32(f.h4),l.putInt32(f.h5),l.putInt32(f.h6),l.putInt32(f.h7),l},a}}var r="sha256";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/sha256",["require","module","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){e.md=e.md||{},e.md.algorithms={md5:e.md5,sha1:e.sha1,sha256:e.sha256},e.md.md5=e.md5,e.md.sha1=e.sha1,e.md.sha256=e.sha256}var r="md";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/md",["require","module","./md5","./sha1","./sha256"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){var t=e.hmac=e.hmac||{};t.create=function(){var t=null,n=null,r=null,i=null,s={};return s.start=function(s,o){if(s!==null)if(typeof s=="string"){s=s.toLowerCase();if(!(s in e.md.algorithms))throw'Unknown hash algorithm "'+s+'"';n=e.md.algorithms[s].create()}else n=s;if(o===null)o=t;else{if(typeof o=="string")o=e.util.createBuffer(o);else if(e.util.isArray(o)){var u=o;o=e.util.createBuffer();for(var a=0;a<u.length;++a)o.putByte(u[a])}var f=o.length();f>n.blockLength&&(n.start(),n.update(o.bytes()),o=n.digest()),r=e.util.createBuffer(),i=e.util.createBuffer(),f=o.length();for(var a=0;a<f;++a){var u=o.at(a);r.putByte(54^u),i.putByte(92^u)}if(f<n.blockLength){var u=n.blockLength-f;for(var a=0;a<u;++a)r.putByte(54),i.putByte(92)}t=o,r=r.bytes(),i=i.bytes()}n.start(),n.update(r)},s.update=function(e){n.update(e)},s.getMac=function(){var e=n.digest().bytes();return n.start(),n.update(i),n.update(e),n.digest()},s.digest=s.getMac,s}}var r="hmac";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/hmac",["require","module","./md","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){function n(e){var t=e.name+": ",n=[];for(var r=0;r<e.values.length;++r)n.push(e.values[r].replace(/^(\S+\r\n)/,function(e,t){return" "+t}));t+=n.join(",")+"\r\n";var i=0,s=-1;for(var r=0;r<t.length;++r,++i)if(i>65&&s!==-1){var o=t[s];o===","?(++s,t=t.substr(0,s)+"\r\n "+t.substr(s)):t=t.substr(0,s)+"\r\n"+o+t.substr(s+1),i=r-s-1,s=-1,++r}else if(t[r]===" "||t[r]==="	"||t[r]===",")s=r;return t}function r(e){return e.replace(/^\s+/,"")}var t=e.pem=e.pem||{};t.encode=function(t,r){r=r||{};var i="-----BEGIN "+t.type+"-----\r\n",s;t.procType&&(s={name:"Proc-Type",values:[String(t.procType.version),t.procType.type]},i+=n(s)),t.contentDomain&&(s={name:"Content-Domain",values:[t.contentDomain]},i+=n(s)),t.dekInfo&&(s={name:"DEK-Info",values:[t.dekInfo.algorithm]},t.dekInfo.parameters&&s.values.push(t.dekInfo.parameters),i+=n(s));if(t.headers)for(var o=0;o<t.headers.length;++o)i+=n(t.headers[o]);return t.procType&&(i+="\r\n"),i+=e.util.encode64(t.body,r.maxline||64)+"\r\n",i+="-----END "+t.type+"-----\r\n",i},t.decode=function(t){var n=[],i=/\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g,s=/([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/,o=/\r?\n/,u;for(;;){u=i.exec(t);if(!u)break;var a={type:u[1],procType:null,contentDomain:null,dekInfo:null,headers:[],body:e.util.decode64(u[3])};n.push(a);if(!u[2])continue;var f=u[2].split(o),l=0;while(u&&l<f.length){var c=f[l].replace(/\s+$/,"");for(var h=l+1;h<f.length;++h){var p=f[h];if(!/\s/.test(p[0]))break;c+=p,l=h}u=c.match(s);if(u){var d={name:u[1],values:[]},v=u[2].split(",");for(var m=0;m<v.length;++m)d.values.push(r(v[m]));if(!a.procType){if(d.name!=="Proc-Type")throw{message:'Invalid PEM formatted message. The first encapsulated header must be "Proc-Type".'};if(d.values.length!==2)throw{message:'Invalid PEM formatted message. The "Proc-Type" header must have two subfields.'};a.procType={version:v[0],type:v[1]}}else if(!a.contentDomain&&d.name==="Content-Domain")a.contentDomain=v[0]||"";else if(!a.dekInfo&&d.name==="DEK-Info"){if(d.values.length===0)throw{message:'Invalid PEM formatted message. The "DEK-Info" header must have at least one subfield.'};a.dekInfo={algorithm:v[0],parameters:v[1]||null}}else a.headers.push(d)}++l}if(a.procType==="ENCRYPTED"&&!a.dekInfo)throw{message:'Invalid PEM formatted message. The "DEK-Info" header must be present if "Proc-Type" is "ENCRYPTED".'}}if(n.length===0)throw{message:"Invalid PEM formatted message."};return n}}var r="pem";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/pem",["require","module","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){function f(e){var t=[0,4,536870912,536870916,65536,65540,536936448,536936452,512,516,536871424,536871428,66048,66052,536936960,536936964],n=[0,1,1048576,1048577,67108864,67108865,68157440,68157441,256,257,1048832,1048833,67109120,67109121,68157696,68157697],r=[0,8,2048,2056,16777216,16777224,16779264,16779272,0,8,2048,2056,16777216,16777224,16779264,16779272],i=[0,2097152,134217728,136314880,8192,2105344,134225920,136323072,131072,2228224,134348800,136445952,139264,2236416,134356992,136454144],s=[0,262144,16,262160,0,262144,16,262160,4096,266240,4112,266256,4096,266240,4112,266256],o=[0,1024,32,1056,0,1024,32,1056,33554432,33555456,33554464,33555488,33554432,33555456,33554464,33555488],u=[0,268435456,524288,268959744,2,268435458,524290,268959746,0,268435456,524288,268959744,2,268435458,524290,268959746],a=[0,65536,2048,67584,536870912,536936448,536872960,536938496,131072,196608,133120,198656,537001984,537067520,537004032,537069568],f=[0,262144,0,262144,2,262146,2,262146,33554432,33816576,33554432,33816576,33554434,33816578,33554434,33816578],l=[0,268435456,8,268435464,0,268435456,8,268435464,1024,268436480,1032,268436488,1024,268436480,1032,268436488],c=[0,32,0,32,1048576,1048608,1048576,1048608,8192,8224,8192,8224,1056768,1056800,1056768,1056800],h=[0,16777216,512,16777728,2097152,18874368,2097664,18874880,67108864,83886080,67109376,83886592,69206016,85983232,69206528,85983744],p=[0,4096,134217728,134221824,524288,528384,134742016,134746112,16,4112,134217744,134221840,524304,528400,134742032,134746128],d=[0,4,256,260,0,4,256,260,1,5,257,261,1,5,257,261],v=e.length()>8?3:1,m=[],g=[0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0],y=0,b;for(var w=0;w<v;w++){var E=e.getInt32(),S=e.getInt32();b=(E>>>4^S)&252645135,S^=b,E^=b<<4,b=(S>>>-16^E)&65535,E^=b,S^=b<<-16,b=(E>>>2^S)&858993459,S^=b,E^=b<<2,b=(S>>>-16^E)&65535,E^=b,S^=b<<-16,b=(E>>>1^S)&1431655765,S^=b,E^=b<<1,b=(S>>>8^E)&16711935,E^=b,S^=b<<8,b=(E>>>1^S)&1431655765,S^=b,E^=b<<1,b=E<<8|S>>>20&240,E=S<<24|S<<8&16711680|S>>>8&65280|S>>>24&240,S=b;for(var x=0;x<g.length;x++){g[x]?(E=E<<2|E>>>26,S=S<<2|S>>>26):(E=E<<1|E>>>27,S=S<<1|S>>>27),E&=-15,S&=-15;var T=t[E>>>28]|n[E>>>24&15]|r[E>>>20&15]|i[E>>>16&15]|s[E>>>12&15]|o[E>>>8&15]|u[E>>>4&15],N=a[S>>>28]|f[S>>>24&15]|l[S>>>20&15]|c[S>>>16&15]|h[S>>>12&15]|p[S>>>8&15]|d[S>>>4&15];b=(N>>>16^T)&65535,m[y++]=T^b,m[y++]=N^b<<16}}return m}var t=[16843776,0,65536,16843780,16842756,66564,4,65536,1024,16843776,16843780,1024,16778244,16842756,16777216,4,1028,16778240,16778240,66560,66560,16842752,16842752,16778244,65540,16777220,16777220,65540,0,1028,66564,16777216,65536,16843780,4,16842752,16843776,16777216,16777216,1024,16842756,65536,66560,16777220,1024,4,16778244,66564,16843780,65540,16842752,16778244,16777220,1028,66564,16843776,1028,16778240,16778240,0,65540,66560,0,16842756],n=[-2146402272,-2147450880,32768,1081376,1048576,32,-2146435040,-2147450848,-2147483616,-2146402272,-2146402304,-2147483648,-2147450880,1048576,32,-2146435040,1081344,1048608,-2147450848,0,-2147483648,32768,1081376,-2146435072,1048608,-2147483616,0,1081344,32800,-2146402304,-2146435072,32800,0,1081376,-2146435040,1048576,-2147450848,-2146435072,-2146402304,32768,-2146435072,-2147450880,32,-2146402272,1081376,32,32768,-2147483648,32800,-2146402304,1048576,-2147483616,1048608,-2147450848,-2147483616,1048608,1081344,0,-2147450880,32800,-2147483648,-2146435040,-2146402272,1081344],r=[520,134349312,0,134348808,134218240,0,131592,134218240,131080,134217736,134217736,131072,134349320,131080,134348800,520,134217728,8,134349312,512,131584,134348800,134348808,131592,134218248,131584,131072,134218248,8,134349320,512,134217728,134349312,134217728,131080,520,131072,134349312,134218240,0,512,131080,134349320,134218240,134217736,512,0,134348808,134218248,131072,134217728,134349320,8,131592,131584,134217736,134348800,134218248,520,134348800,131592,8,134348808,131584],i=[8396801,8321,8321,128,8396928,8388737,8388609,8193,0,8396800,8396800,8396929,129,0,8388736,8388609,1,8192,8388608,8396801,128,8388608,8193,8320,8388737,1,8320,8388736,8192,8396928,8396929,129,8388736,8388609,8396800,8396929,129,0,0,8396800,8320,8388736,8388737,1,8396801,8321,8321,128,8396929,129,1,8192,8388609,8193,8396928,8388737,8193,8320,8388608,8396801,128,8388608,8192,8396928],s=[256,34078976,34078720,1107296512,524288,256,1073741824,34078720,1074266368,524288,33554688,1074266368,1107296512,1107820544,524544,1073741824,33554432,1074266112,1074266112,0,1073742080,1107820800,1107820800,33554688,1107820544,1073742080,0,1107296256,34078976,33554432,1107296256,524544,524288,1107296512,256,33554432,1073741824,34078720,1107296512,1074266368,33554688,1073741824,1107820544,34078976,1074266368,256,33554432,1107820544,1107820800,524544,1107296256,1107820800,34078720,0,1074266112,1107296256,524544,33554688,1073742080,524288,0,1074266112,34078976,1073742080],o=[536870928,541065216,16384,541081616,541065216,16,541081616,4194304,536887296,4210704,4194304,536870928,4194320,536887296,536870912,16400,0,4194320,536887312,16384,4210688,536887312,16,541065232,541065232,0,4210704,541081600,16400,4210688,541081600,536870912,536887296,16,541065232,4210688,541081616,4194304,16400,536870928,4194304,536887296,536870912,16400,536870928,541081616,4210688,541065216,4210704,541081600,0,541065232,16,16384,541065216,4210704,16384,4194320,536887312,0,541081600,536870912,4194320,536887312],u=[2097152,69206018,67110914,0,2048,67110914,2099202,69208064,69208066,2097152,0,67108866,2,67108864,69206018,2050,67110912,2099202,2097154,67110912,67108866,69206016,69208064,2097154,69206016,2048,2050,69208066,2099200,2,67108864,2099200,67108864,2099200,2097152,67110914,67110914,69206018,69206018,2,2097154,67108864,67110912,2097152,69208064,2050,2099202,69208064,2050,67108866,69208066,69206016,2099200,0,2,69208066,0,2099202,69206016,2048,67108866,67110912,2048,2097154],a=[268439616,4096,262144,268701760,268435456,268439616,64,268435456,262208,268697600,268701760,266240,268701696,266304,4096,64,268697600,268435520,268439552,4160,266240,262208,268697664,268701696,4160,0,0,268697664,268435520,268439552,266304,262144,266304,262144,268701696,4096,64,268697664,4096,266304,268439552,64,268435520,268697600,268697664,268435456,262144,268439616,0,268701760,262208,268435520,268697600,268439552,268439616,0,268701760,266240,266240,4160,4160,262208,268435456,268701696],l=function(l,c){typeof l=="string"&&(l.length===8||l.length===24)&&(l=e.util.createBuffer(l));var h=f(l),p=1,d=0,v=0,m=0,g=0,y=!1,b=null,w=null,E=h.length===32?3:9,S;E===3?S=c?[0,32,2]:[30,-2,-2]:S=c?[0,32,2,62,30,-2,64,96,2]:[94,62,-2,32,64,2,30,-2,-2];var x=null;return x={start:function(t,n){t?(typeof t=="string"&&t.length===8&&(t=e.util.createBuffer(t)),p=1,d=t.getInt32(),m=t.getInt32()):p=0,y=!1,b=e.util.createBuffer(),w=n||e.util.createBuffer(),x.output=w},update:function(e){y||b.putBuffer(e);while(b.length()>=8){var f,l=b.getInt32(),x=b.getInt32();p===1&&(c?(l^=d,x^=m):(v=d,g=m,d=l,m=x)),f=(l>>>4^x)&252645135,x^=f,l^=f<<4,f=(l>>>16^x)&65535,x^=f,l^=f<<16,f=(x>>>2^l)&858993459,l^=f,x^=f<<2,f=(x>>>8^l)&16711935,l^=f,x^=f<<8,f=(l>>>1^x)&1431655765,x^=f,l^=f<<1,l=l<<1|l>>>31,x=x<<1|x>>>31;for(var T=0;T<E;T+=3){var N=S[T+1],C=S[T+2];for(var k=S[T];k!=N;k+=C){var L=x^h[k],A=(x>>>4|x<<28)^h[k+1];f=l,l=x,x=f^(n[L>>>24&63]|i[L>>>16&63]|o[L>>>8&63]|a[L&63]|t[A>>>24&63]|r[A>>>16&63]|s[A>>>8&63]|u[A&63])}f=l,l=x,x=f}l=l>>>1|l<<31,x=x>>>1|x<<31,f=(l>>>1^x)&1431655765,x^=f,l^=f<<1,f=(x>>>8^l)&16711935,l^=f,x^=f<<8,f=(x>>>2^l)&858993459,l^=f,x^=f<<2,f=(l>>>16^x)&65535,x^=f,l^=f<<16,f=(l>>>4^x)&252645135,x^=f,l^=f<<4,p===1&&(c?(d=l,m=x):(l^=v,x^=g)),w.putInt32(l),w.putInt32(x)}},finish:function(e){var t=!0;if(c)if(e)t=e(8,b,!c);else{var n=b.length()===8?8:8-b.length();b.fillWithByte(n,n)}t&&(y=!0,x.update());if(!c){t=b.length()===0;if(t)if(e)t=e(8,w,!c);else{var r=w.length(),i=w.at(r-1);i>r?t=!1:w.truncate(i)}}return t}},x};e.des=e.des||{},e.des.startEncrypting=function(e,t,n){var r=l(e,!0);return r.start(t,n),r},e.des.createEncryptionCipher=function(e){return l(e,!0)},e.des.startDecrypting=function(e,t,n){var r=l(e,!1);return r.start(t,n),r},e.des.createDecryptionCipher=function(e){return l(e,!1)}}var r="des";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/des",["require","module","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){var t=e.pkcs5=e.pkcs5||{};e.pbkdf2=t.pbkdf2=function(t,n,r,i,s){if(typeof s=="undefined"||s===null)s=e.md.sha1.create();var o=s.digestLength;if(i>4294967295*o)throw{message:"Derived key is too long."};var u=Math.ceil(i/o),a=i-(u-1)*o,f=e.hmac.create();f.start(s,t);var l="",c,h,p;for(var d=1;d<=u;++d){f.start(null,null),f.update(n),f.update(e.util.int32ToBytes(d)),c=p=f.digest().getBytes();for(var v=2;v<=r;++v)f.start(null,null),f.update(p),h=f.digest().getBytes(),c=e.util.xorBytes(c,h,o),p=h;l+=d<u?c:c.substr(0,a)}return l}}var r="pbkdf2";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/pbkdf2",["require","module","./hmac","./md","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){var n=typeof process!="undefined"&&process.versions&&process.versions.node,r=null;!e.disableNativeCode&&n&&(r=t("crypto"));var i=e.prng=e.prng||{};i.create=function(t){function u(e){if(n.pools[0].messageLength>=32)return f(),e();var t=32-n.pools[0].messageLength<<5;n.seedFile(t,function(t,r){if(t)return e(t);n.collect(r),f(),e()})}function a(){if(n.pools[0].messageLength>=32)return f();var e=32-n.pools[0].messageLength<<5;n.collect(n.seedFileSync(e)),f()}function f(){var t=e.md.sha1.create();t.update(n.pools[0].digest().getBytes()),n.pools[0].start();var r=1;for(var i=1;i<32;++i)r=r===31?2147483648:r<<2,r%n.reseeds===0&&(t.update(n.pools[i].digest().getBytes()),n.pools[i].start());var s=t.digest().getBytes();t.start(),t.update(s);var o=t.digest().getBytes();n.key=n.plugin.formatKey(s),n.seed=n.plugin.formatSeed(o),++n.reseeds,n.generated=0,n.time=+(new Date)}function l(t){var n=null;if(typeof window!="undefined"){var r=window.crypto||window.msCrypto;r&&r.getRandomValues&&(n=function(e){return r.getRandomValues(e)})}var i=e.util.createBuffer();if(n)while(i.length()<t){var s=Math.max(1,Math.min(t-i.length(),65536)/4),o=new Uint32Array(Math.floor(s));try{n(o);for(var u=0;u<o.length;++u)i.putInt32(o[u])}catch(a){if(!(typeof QuotaExceededError!="undefined"&&a instanceof QuotaExceededError))throw a}}if(i.length()<t){var f,l,c,h=Math.floor(Math.random()*65536);while(i.length()<t){l=16807*(h&65535),f=16807*(h>>16),l+=(f&32767)<<16,l+=f>>15,l=(l&2147483647)+(l>>31),h=l&4294967295;for(var u=0;u<3;++u)c=h>>>(u<<3),c^=Math.floor(Math.random()*256),i.putByte(String.fromCharCode(c&255))}}return i.getBytes(t)}var n={plugin:t,key:null,seed:null,time:null,reseeds:0,generated:0},i=t.md,s=new Array(32);for(var o=0;o<32;++o)s[o]=i.create();return n.pools=s,n.pool=0,n.generate=function(t,r){function l(c){if(c)return r(c);if(f.length()>=t)return r(null,f.getBytes(t));if(n.generated>=1048576){var h=+(new Date);if(n.time===null||h-n.time>100)n.key=null}if(n.key===null)return u(l);var p=i(n.key,n.seed);n.generated+=p.length,f.putBytes(p),n.key=o(i(n.key,s(n.seed))),n.seed=a(i(n.key,n.seed)),e.util.setImmediate(l)}if(!r)return n.generateSync(t);var i=n.plugin.cipher,s=n.plugin.increment,o=n.plugin.formatKey,a=n.plugin.formatSeed,f=e.util.createBuffer();l()},n.generateSync=function(t){var r=n.plugin.cipher,i=n.plugin.increment,s=n.plugin.formatKey,o=n.plugin.formatSeed,u=e.util.createBuffer();while(u.length()<t){if(n.generated>=1048576){var f=+(new Date);if(n.time===null||f-n.time>100)n.key=null}n.key===null&&a();var l=r(n.key,n.seed);n.generated+=l.length,u.putBytes(l),n.key=s(r(n.key,i(n.seed))),n.seed=o(r(n.key,n.seed))}return u.getBytes(t)},r?(n.seedFile=function(e,t){r.randomBytes(e,function(e,n){if(e)return t(e);t(null,n.toString())})},n.seedFileSync=function(e){return r.randomBytes(e).toString()}):(n.seedFile=function(e,t){try{t(null,l(e))}catch(n){t(n)}},n.seedFileSync=l),n.collect=function(e){var t=e.length;for(var r=0;r<t;++r)n.pools[n.pool].update(e.substr(r,1)),n.pool=n.pool===31?0:n.pool+1},n.collectInt=function(e,t){var r="";for(var i=0;i<t;i+=8)r+=String.fromCharCode(e>>i&255);n.collect(r)},n.registerWorker=function(e){if(e===self)n.seedFile=function(e,t){function n(e){var r=e.data;r.forge&&r.forge.prng&&(self.removeEventListener("message",n),t(r.forge.prng.err,r.forge.prng.bytes))}self.addEventListener("message",n),self.postMessage({forge:{prng:{needed:e}}})};else{function t(t){var r=t.data;r.forge&&r.forge.prng&&n.seedFile(r.forge.prng.needed,function(t,n){e.postMessage({forge:{prng:{err:t,bytes:n}}})})}e.addEventListener("message",t)}},n}}var r="prng";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/prng",["require","module","./md","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){if(e.random&&e.random.getBytes)return;(function(t){var n={},r=new Array(4),i=e.util.createBuffer();n.formatKey=function(t){var n=e.util.createBuffer(t);return t=new Array(4),t[0]=n.getInt32(),t[1]=n.getInt32(),t[2]=n.getInt32(),t[3]=n.getInt32(),e.aes._expandKey(t,!1)},n.formatSeed=function(t){var n=e.util.createBuffer(t);return t=new Array(4),t[0]=n.getInt32(),t[1]=n.getInt32(),t[2]=n.getInt32(),t[3]=n.getInt32(),t},n.cipher=function(t,n){return e.aes._updateBlock(t,n,r,!1),i.putInt32(r[0]),i.putInt32(r[1]),i.putInt32(r[2]),i.putInt32(r[3]),i.getBytes()},n.increment=function(e){return++e[3],e},n.md=e.md.sha1;var s=e.prng.create(n),o=typeof process!="undefined"&&process.versions&&process.versions.node,u=null;if(typeof window!="undefined"){var a=window.crypto||window.msCrypto;a&&a.getRandomValues&&(u=function(e){return a.getRandomValues(e)})}if(e.disableNativeCode||!o&&!u){typeof window=="undefined"||window.document===undefined,s.collectInt(+(new Date),32);if(typeof navigator!="undefined"){var f="";for(var l in navigator)try{typeof navigator[l]=="string"&&(f+=navigator[l])}catch(c){}s.collect(f),f=null}t&&(t().mousemove(function(e){s.collectInt(e.clientX,16),s.collectInt(e.clientY,16)}),t().keypress(function(e){s.collectInt(e.charCode,8)}))}if(!e.random)e.random=s;else for(var l in s)e.random[l]=s[l];e.random.getBytes=function(t,n){return e.random.generate(t,n)},e.random.getBytesSync=function(t){return e.random.generate(t)}})(typeof jQuery!="undefined"?jQuery:null)}var r="random";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/random",["require","module","./aes","./md","./prng","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){var t=[217,120,249,196,25,221,181,237,40,233,253,121,74,160,216,157,198,126,55,131,43,118,83,142,98,76,100,136,68,139,251,162,23,154,89,245,135,179,79,19,97,69,109,141,9,129,125,50,189,143,64,235,134,183,123,11,240,149,33,34,92,107,78,130,84,214,101,147,206,96,178,28,115,86,192,20,167,140,241,220,18,117,202,31,59,190,228,209,66,61,212,48,163,60,182,38,111,191,14,218,70,105,7,87,39,242,29,155,188,148,67,3,248,17,199,246,144,239,62,231,6,195,213,47,200,102,30,215,8,232,234,222,128,82,238,247,132,170,114,172,53,77,106,42,150,26,210,113,90,21,73,116,75,159,208,94,4,24,164,236,194,224,65,110,15,81,203,204,36,145,175,80,161,244,112,57,153,124,58,133,35,184,180,122,252,2,54,91,37,85,151,49,45,93,250,152,227,138,146,174,5,223,41,16,103,108,186,201,211,0,230,207,225,158,168,44,99,22,1,63,88,226,137,169,13,56,52,27,171,51,255,176,187,72,12,95,185,177,205,46,197,243,219,71,229,165,156,119,10,166,32,104,254,127,193,173],n=[1,2,3,5],r=function(e,t){return e<<t&65535|(e&65535)>>16-t},i=function(e,t){return(e&65535)>>t|e<<16-t&65535};e.rc2=e.rc2||{},e.rc2.expandKey=function(n,r){typeof n=="string"&&(n=e.util.createBuffer(n)),r=r||128;var i=n,s=n.length(),o=r,u=Math.ceil(o/8),a=255>>(o&7),f;for(f=s;f<128;f++)i.putByte(t[i.at(f-1)+i.at(f-s)&255]);i.setAt(128-u,t[i.at(128-u)&a]);for(f=127-u;f>=0;f--)i.setAt(f,t[i.at(f+1)^i.at(f+u)]);return i};var s=function(t,s,o){var u=!1,a=null,f=null,l=null,c,h,p,d,v=[];t=e.rc2.expandKey(t,s);for(p=0;p<64;p++)v.push(t.getInt16Le());o?(c=function(e){for(p=0;p<4;p++)e[p]+=v[d]+(e[(p+3)%4]&e[(p+2)%4])+(~e[(p+3)%4]&e[(p+1)%4]),e[p]=r(e[p],n[p]),d++},h=function(e){for(p=0;p<4;p++)e[p]+=v[e[(p+3)%4]&63]}):(c=function(e){for(p=3;p>=0;p--)e[p]=i(e[p],n[p]),e[p]-=v[d]+(e[(p+3)%4]&e[(p+2)%4])+(~e[(p+3)%4]&e[(p+1)%4]),d--},h=function(e){for(p=3;p>=0;p--)e[p]-=v[e[(p+3)%4]&63]});var m=function(e){var t=[];for(p=0;p<4;p++){var n=a.getInt16Le();l!==null&&(o?n^=l.getInt16Le():l.putInt16Le(n)),t.push(n&65535)}d=o?0:63;for(var r=0;r<e.length;r++)for(var i=0;i<e[r][0];i++)e[r][1](t);for(p=0;p<4;p++)l!==null&&(o?l.putInt16Le(t[p]):t[p]^=l.getInt16Le()),f.putInt16Le(t[p])},g=null;return g={start:function(t,n){t&&typeof t=="string"&&(t=e.util.createBuffer(t)),u=!1,a=e.util.createBuffer(),f=n||new e.util.createBuffer,l=t,g.output=f},update:function(e){u||a.putBuffer(e);while(a.length()>=8)m([[5,c],[1,h],[6,c],[1,h],[5,c]])},finish:function(e){var t=!0;if(o)if(e)t=e(8,a,!o);else{var n=a.length()===8?8:8-a.length();a.fillWithByte(n,n)}t&&(u=!0,g.update());if(!o){t=a.length()===0;if(t)if(e)t=e(8,f,!o);else{var r=f.length(),i=f.at(r-1);i>r?t=!1:f.truncate(i)}}return t}},g};e.rc2.startEncrypting=function(t,n,r){var i=e.rc2.createEncryptionCipher(t,128);return i.start(n,r),i},e.rc2.createEncryptionCipher=function(e,t){return s(e,t,!0)},e.rc2.startDecrypting=function(t,n,r){var i=e.rc2.createDecryptionCipher(t,128);return i.start(n,r),i},e.rc2.createDecryptionCipher=function(e,t){return s(e,t,!1)}}var r="rc2";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/rc2",["require","module","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){function i(e,t,n){this.data=[],e!=null&&("number"==typeof e?this.fromNumber(e,t,n):t==null&&"string"!=typeof e?this.fromString(e,256):this.fromString(e,t))}function s(){return new i(null)}function o(e,t,n,r,i,s){while(--s>=0){var o=t*this.data[e++]+n.data[r]+i;i=Math.floor(o/67108864),n.data[r++]=o&67108863}return i}function u(e,t,n,r,i,s){var o=t&32767,u=t>>15;while(--s>=0){var a=this.data[e]&32767,f=this.data[e++]>>15,l=u*a+f*o;a=o*a+((l&32767)<<15)+n.data[r]+(i&1073741823),i=(a>>>30)+(l>>>15)+u*f+(i>>>30),n.data[r++]=a&1073741823}return i}function a(e,t,n,r,i,s){var o=t&16383,u=t>>14;while(--s>=0){var a=this.data[e]&16383,f=this.data[e++]>>14,l=u*a+f*o;a=o*a+((l&16383)<<14)+n.data[r]+i,i=(a>>28)+(l>>14)+u*f,n.data[r++]=a&268435455}return i}function d(e){return l.charAt(e)}function v(e,t){var n=c[e.charCodeAt(t)];return n==null?-1:n}function m(e){for(var t=this.t-1;t>=0;--t)e.data[t]=this.data[t];e.t=this.t,e.s=this.s}function g(e){this.t=1,this.s=e<0?-1:0,e>0?this.data[0]=e:e<-1?this.data[0]=e+this.DV:this.t=0}function y(e){var t=s();return t.fromInt(e),t}function b(e,t){var n;if(t==16)n=4;else if(t==8)n=3;else if(t==256)n=8;else if(t==2)n=1;else if(t==32)n=5;else{if(t!=4){this.fromRadix(e,t);return}n=2}this.t=0,this.s=0;var r=e.length,s=!1,o=0;while(--r>=0){var u=n==8?e[r]&255:v(e,r);if(u<0){e.charAt(r)=="-"&&(s=!0);continue}s=!1,o==0?this.data[this.t++]=u:o+n>this.DB?(this.data[this.t-1]|=(u&(1<<this.DB-o)-1)<<o,this.data[this.t++]=u>>this.DB-o):this.data[this.t-1]|=u<<o,o+=n,o>=this.DB&&(o-=this.DB)}n==8&&(e[0]&128)!=0&&(this.s=-1,o>0&&(this.data[this.t-1]|=(1<<this.DB-o)-1<<o)),this.clamp(),s&&i.ZERO.subTo(this,this)}function w(){var e=this.s&this.DM;while(this.t>0&&this.data[this.t-1]==e)--this.t}function E(e){if(this.s<0)return"-"+this.negate().toString(e);var t;if(e==16)t=4;else if(e==8)t=3;else if(e==2)t=1;else if(e==32)t=5;else{if(e!=4)return this.toRadix(e);t=2}var n=(1<<t)-1,r,i=!1,s="",o=this.t,u=this.DB-o*this.DB%t;if(o-->0){u<this.DB&&(r=this.data[o]>>u)>0&&(i=!0,s=d(r));while(o>=0)u<t?(r=(this.data[o]&(1<<u)-1)<<t-u,r|=this.data[--o]>>(u+=this.DB-t)):(r=this.data[o]>>(u-=t)&n,u<=0&&(u+=this.DB,--o)),r>0&&(i=!0),i&&(s+=d(r))}return i?s:"0"}function S(){var e=s();return i.ZERO.subTo(this,e),e}function x(){return this.s<0?this.negate():this}function T(e){var t=this.s-e.s;if(t!=0)return t;var n=this.t;t=n-e.t;if(t!=0)return this.s<0?-t:t;while(--n>=0)if((t=this.data[n]-e.data[n])!=0)return t;return 0}function N(e){var t=1,n;return(n=e>>>16)!=0&&(e=n,t+=16),(n=e>>8)!=0&&(e=n,t+=8),(n=e>>4)!=0&&(e=n,t+=4),(n=e>>2)!=0&&(e=n,t+=2),(n=e>>1)!=0&&(e=n,t+=1),t}function C(){return this.t<=0?0:this.DB*(this.t-1)+N(this.data[this.t-1]^this.s&this.DM)}function k(e,t){var n;for(n=this.t-1;n>=0;--n)t.data[n+e]=this.data[n];for(n=e-1;n>=0;--n)t.data[n]=0;t.t=this.t+e,t.s=this.s}function L(e,t){for(var n=e;n<this.t;++n)t.data[n-e]=this.data[n];t.t=Math.max(this.t-e,0),t.s=this.s}function A(e,t){var n=e%this.DB,r=this.DB-n,i=(1<<r)-1,s=Math.floor(e/this.DB),o=this.s<<n&this.DM,u;for(u=this.t-1;u>=0;--u)t.data[u+s+1]=this.data[u]>>r|o,o=(this.data[u]&i)<<n;for(u=s-1;u>=0;--u)t.data[u]=0;t.data[s]=o,t.t=this.t+s+1,t.s=this.s,t.clamp()}function O(e,t){t.s=this.s;var n=Math.floor(e/this.DB);if(n>=this.t){t.t=0;return}var r=e%this.DB,i=this.DB-r,s=(1<<r)-1;t.data[0]=this.data[n]>>r;for(var o=n+1;o<this.t;++o)t.data[o-n-1]|=(this.data[o]&s)<<i,t.data[o-n]=this.data[o]>>r;r>0&&(t.data[this.t-n-1]|=(this.s&s)<<i),t.t=this.t-n,t.clamp()}function M(e,t){var n=0,r=0,i=Math.min(e.t,this.t);while(n<i)r+=this.data[n]-e.data[n],t.data[n++]=r&this.DM,r>>=this.DB;if(e.t<this.t){r-=e.s;while(n<this.t)r+=this.data[n],t.data[n++]=r&this.DM,r>>=this.DB;r+=this.s}else{r+=this.s;while(n<e.t)r-=e.data[n],t.data[n++]=r&this.DM,r>>=this.DB;r-=e.s}t.s=r<0?-1:0,r<-1?t.data[n++]=this.DV+r:r>0&&(t.data[n++]=r),t.t=n,t.clamp()}function _(e,t){var n=this.abs(),r=e.abs(),s=n.t;t.t=s+r.t;while(--s>=0)t.data[s]=0;for(s=0;s<r.t;++s)t.data[s+n.t]=n.am(0,r.data[s],t,s,0,n.t);t.s=0,t.clamp(),this.s!=e.s&&i.ZERO.subTo(t,t)}function D(e){var t=this.abs(),n=e.t=2*t.t;while(--n>=0)e.data[n]=0;for(n=0;n<t.t-1;++n){var r=t.am(n,t.data[n],e,2*n,0,1);(e.data[n+t.t]+=t.am(n+1,2*t.data[n],e,2*n+1,r,t.t-n-1))>=t.DV&&(e.data[n+t.t]-=t.DV,e.data[n+t.t+1]=1)}e.t>0&&(e.data[e.t-1]+=t.am(n,t.data[n],e,2*n,0,1)),e.s=0,e.clamp()}function P(e,t,n){var r=e.abs();if(r.t<=0)return;var o=this.abs();if(o.t<r.t){t!=null&&t.fromInt(0),n!=null&&this.copyTo(n);return}n==null&&(n=s());var u=s(),a=this.s,f=e.s,l=this.DB-N(r.data[r.t-1]);l>0?(r.lShiftTo(l,u),o.lShiftTo(l,n)):(r.copyTo(u),o.copyTo(n));var c=u.t,h=u.data[c-1];if(h==0)return;var p=h*(1<<this.F1)+(c>1?u.data[c-2]>>this.F2:0),d=this.FV/p,v=(1<<this.F1)/p,m=1<<this.F2,g=n.t,y=g-c,b=t==null?s():t;u.dlShiftTo(y,b),n.compareTo(b)>=0&&(n.data[n.t++]=1,n.subTo(b,n)),i.ONE.dlShiftTo(c,b),b.subTo(u,u);while(u.t<c)u.data[u.t++]=0;while(--y>=0){var w=n.data[--g]==h?this.DM:Math.floor(n.data[g]*d+(n.data[g-1]+m)*v);if((n.data[g]+=u.am(0,w,n,y,0,c))<w){u.dlShiftTo(y,b),n.subTo(b,n);while(n.data[g]<--w)n.subTo(b,n)}}t!=null&&(n.drShiftTo(c,t),a!=f&&i.ZERO.subTo(t,t)),n.t=c,n.clamp(),l>0&&n.rShiftTo(l,n),a<0&&i.ZERO.subTo(n,n)}function H(e){var t=s();return this.abs().divRemTo(e,null,t),this.s<0&&t.compareTo(i.ZERO)>0&&e.subTo(t,t),t}function B(e){this.m=e}function j(e){return e.s<0||e.compareTo(this.m)>=0?e.mod(this.m):e}function F(e){return e}function I(e){e.divRemTo(this.m,null,e)}function q(e,t,n){e.multiplyTo(t,n),this.reduce(n)}function R(e,t){e.squareTo(t),this.reduce(t)}function U(){if(this.t<1)return 0;var e=this.data[0];if((e&1)==0)return 0;var t=e&3;return t=t*(2-(e&15)*t)&15,t=t*(2-(e&255)*t)&255,t=t*(2-((e&65535)*t&65535))&65535,t=t*(2-e*t%this.DV)%this.DV,t>0?this.DV-t:-t}function z(e){this.m=e,this.mp=e.invDigit(),this.mpl=this.mp&32767,this.mph=this.mp>>15,this.um=(1<<e.DB-15)-1,this.mt2=2*e.t}function W(e){var t=s();return e.abs().dlShiftTo(this.m.t,t),t.divRemTo(this.m,null,t),e.s<0&&t.compareTo(i.ZERO)>0&&this.m.subTo(t,t),t}function X(e){var t=s();return e.copyTo(t),this.reduce(t),t}function V(e){while(e.t<=this.mt2)e.data[e.t++]=0;for(var t=0;t<this.m.t;++t){var n=e.data[t]&32767,r=n*this.mpl+((n*this.mph+(e.data[t]>>15)*this.mpl&this.um)<<15)&e.DM;n=t+this.m.t,e.data[n]+=this.m.am(0,r,e,t,0,this.m.t);while(e.data[n]>=e.DV)e.data[n]-=e.DV,e.data[++n]++}e.clamp(),e.drShiftTo(this.m.t,e),e.compareTo(this.m)>=0&&e.subTo(this.m,e)}function $(e,t){e.squareTo(t),this.reduce(t)}function J(e,t,n){e.multiplyTo(t,n),this.reduce(n)}function K(){return(this.t>0?this.data[0]&1:this.s)==0}function Q(e,t){if(e>4294967295||e<1)return i.ONE;var n=s(),r=s(),o=t.convert(this),u=N(e)-1;o.copyTo(n);while(--u>=0){t.sqrTo(n,r);if((e&1<<u)>0)t.mulTo(r,o,n);else{var a=n;n=r,r=a}}return t.revert(n)}function G(e,t){var n;return e<256||t.isEven()?n=new B(t):n=new z(t),this.exp(e,n)}function Y(){var e=s();return this.copyTo(e),e}function Z(){if(this.s<0){if(this.t==1)return this.data[0]-this.DV;if(this.t==0)return-1}else{if(this.t==1)return this.data[0];if(this.t==0)return 0}return(this.data[1]&(1<<32-this.DB)-1)<<this.DB|this.data[0]}function et(){return this.t==0?this.s:this.data[0]<<24>>24}function tt(){return this.t==0?this.s:this.data[0]<<16>>16}function nt(e){return Math.floor(Math.LN2*this.DB/Math.log(e))}function rt(){return this.s<0?-1:this.t<=0||this.t==1&&this.data[0]<=0?0:1}function it(e){e==null&&(e=10);if(this.signum()==0||e<2||e>36)return"0";var t=this.chunkSize(e),n=Math.pow(e,t),r=y(n),i=s(),o=s(),u="";this.divRemTo(r,i,o);while(i.signum()>0)u=(n+o.intValue()).toString(e).substr(1)+u,i.divRemTo(r,i,o);return o.intValue().toString(e)+u}function st(e,t){this.fromInt(0),t==null&&(t=10);var n=this.chunkSize(t),r=Math.pow(t,n),s=!1,o=0,u=0;for(var a=0;a<e.length;++a){var f=v(e,a);if(f<0){e.charAt(a)=="-"&&this.signum()==0&&(s=!0);continue}u=t*u+f,++o>=n&&(this.dMultiply(r),this.dAddOffset(u,0),o=0,u=0)}o>0&&(this.dMultiply(Math.pow(t,o)),this.dAddOffset(u,0)),s&&i.ZERO.subTo(this,this)}function ot(e,t,n){if("number"==typeof t)if(e<2)this.fromInt(1);else{this.fromNumber(e,n),this.testBit(e-1)||this.bitwiseTo(i.ONE.shiftLeft(e-1),dt,this),this.isEven()&&this.dAddOffset(1,0);while(!this.isProbablePrime(t))this.dAddOffset(2,0),this.bitLength()>e&&this.subTo(i.ONE.shiftLeft(e-1),this)}else{var r=new Array,s=e&7;r.length=(e>>3)+1,t.nextBytes(r),s>0?r[0]&=(1<<s)-1:r[0]=0,this.fromString(r,256)}}function ut(){var e=this.t,t=new Array;t[0]=this.s;var n=this.DB-e*this.DB%8,r,i=0;if(e-->0){n<this.DB&&(r=this.data[e]>>n)!=(this.s&this.DM)>>n&&(t[i++]=r|this.s<<this.DB-n);while(e>=0){n<8?(r=(this.data[e]&(1<<n)-1)<<8-n,r|=this.data[--e]>>(n+=this.DB-8)):(r=this.data[e]>>(n-=8)&255,n<=0&&(n+=this.DB,--e)),(r&128)!=0&&(r|=-256),i==0&&(this.s&128)!=(r&128)&&++i;if(i>0||r!=this.s)t[i++]=r}}return t}function at(e){return this.compareTo(e)==0}function ft(e){return this.compareTo(e)<0?this:e}function lt(e){return this.compareTo(e)>0?this:e}function ct(e,t,n){var r,i,s=Math.min(e.t,this.t);for(r=0;r<s;++r)n.data[r]=t(this.data[r],e.data[r]);if(e.t<this.t){i=e.s&this.DM;for(r=s;r<this.t;++r)n.data[r]=t(this.data[r],i);n.t=this.t}else{i=this.s&this.DM;for(r=s;r<e.t;++r)n.data[r]=t(i,e.data[r]);n.t=e.t}n.s=t(this.s,e.s),n.clamp()}function ht(e,t){return e&t}function pt(e){var t=s();return this.bitwiseTo(e,ht,t),t}function dt(e,t){return e|t}function vt(e){var t=s();return this.bitwiseTo(e,dt,t),t}function mt(e,t){return e^t}function gt(e){var t=s();return this.bitwiseTo(e,mt,t),t}function yt(e,t){return e&~t}function bt(e){var t=s();return this.bitwiseTo(e,yt,t),t}function wt(){var e=s();for(var t=0;t<this.t;++t)e.data[t]=this.DM&~this.data[t];return e.t=this.t,e.s=~this.s,e}function Et(e){var t=s();return e<0?this.rShiftTo(-e,t):this.lShiftTo(e,t),t}function St(e){var t=s();return e<0?this.lShiftTo(-e,t):this.rShiftTo(e,t),t}function xt(e){if(e==0)return-1;var t=0;return(e&65535)==0&&(e>>=16,t+=16),(e&255)==0&&(e>>=8,t+=8),(e&15)==0&&(e>>=4,t+=4),(e&3)==0&&(e>>=2,t+=2),(e&1)==0&&++t,t}function Tt(){for(var e=0;e<this.t;++e)if(this.data[e]!=0)return e*this.DB+xt(this.data[e]);return this.s<0?this.t*this.DB:-1}function Nt(e){var t=0;while(e!=0)e&=e-1,++t;return t}function Ct(){var e=0,t=this.s&this.DM;for(var n=0;n<this.t;++n)e+=Nt(this.data[n]^t);return e}function kt(e){var t=Math.floor(e/this.DB);return t>=this.t?this.s!=0:(this.data[t]&1<<e%this.DB)!=0}function Lt(e,t){var n=i.ONE.shiftLeft(e);return this.bitwiseTo(n,t,n),n}function At(e){return this.changeBit(e,dt)}function Ot(e){return this.changeBit(e,yt)}function Mt(e){return this.changeBit(e,mt)}function _t(e,t){var n=0,r=0,i=Math.min(e.t,this.t);while(n<i)r+=this.data[n]+e.data[n],t.data[n++]=r&this.DM,r>>=this.DB;if(e.t<this.t){r+=e.s;while(n<this.t)r+=this.data[n],t.data[n++]=r&this.DM,r>>=this.DB;r+=this.s}else{r+=this.s;while(n<e.t)r+=e.data[n],t.data[n++]=r&this.DM,r>>=this.DB;r+=e.s}t.s=r<0?-1:0,r>0?t.data[n++]=r:r<-1&&(t.data[n++]=this.DV+r),t.t=n,t.clamp()}function Dt(e){var t=s();return this.addTo(e,t),t}function Pt(e){var t=s();return this.subTo(e,t),t}function Ht(e){var t=s();return this.multiplyTo(e,t),t}function Bt(e){var t=s();return this.divRemTo(e,t,null),t}function jt(e){var t=s();return this.divRemTo(e,null,t),t}function Ft(e){var t=s(),n=s();return this.divRemTo(e,t,n),new Array(t,n)}function It(e){this.data[this.t]=this.am(0,e-1,this,0,0,this.t),++this.t,this.clamp()}function qt(e,t){if(e==0)return;while(this.t<=t)this.data[this.t++]=0;this.data[t]+=e;while(this.data[t]>=this.DV)this.data[t]-=this.DV,++t>=this.t&&(this.data[this.t++]=0),++this.data[t]}function Rt(){}function Ut(e){return e}function zt(e,t,n){e.multiplyTo(t,n)}function Wt(e,t){e.squareTo(t)}function Xt(e){return this.exp(e,new Rt)}function Vt(e,t,n){var r=Math.min(this.t+e.t,t);n.s=0,n.t=r;while(r>0)n.data[--r]=0;var i;for(i=n.t-this.t;r<i;++r)n.data[r+this.t]=this.am(0,e.data[r],n,r,0,this.t);for(i=Math.min(e.t,t);r<i;++r)this.am(0,e.data[r],n,r,0,t-r);n.clamp()}function $t(e,t,n){--t;var r=n.t=this.t+e.t-t;n.s=0;while(--r>=0)n.data[r]=0;for(r=Math.max(t-this.t,0);r<e.t;++r)n.data[this.t+r-t]=this.am(t-r,e.data[r],n,0,0,this.t+r-t);n.clamp(),n.drShiftTo(1,n)}function Jt(e){this.r2=s(),this.q3=s(),i.ONE.dlShiftTo(2*e.t,this.r2),this.mu=this.r2.divide(e),this.m=e}function Kt(e){if(e.s<0||e.t>2*this.m.t)return e.mod(this.m);if(e.compareTo(this.m)<0)return e;var t=s();return e.copyTo(t),this.reduce(t),t}function Qt(e){return e}function Gt(e){e.drShiftTo(this.m.t-1,this.r2),e.t>this.m.t+1&&(e.t=this.m.t+1,e.clamp()),this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3),this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);while(e.compareTo(this.r2)<0)e.dAddOffset(1,this.m.t+1);e.subTo(this.r2,e);while(e.compareTo(this.m)>=0)e.subTo(this.m,e)}function Yt(e,t){e.squareTo(t),this.reduce(t)}function Zt(e,t,n){e.multiplyTo(t,n),this.reduce(n)}function en(e,t){var n=e.bitLength(),r,i=y(1),o;if(n<=0)return i;n<18?r=1:n<48?r=3:n<144?r=4:n<768?r=5:r=6,n<8?o=new B(t):t.isEven()?o=new Jt(t):o=new z(t);var u=new Array,a=3,f=r-1,l=(1<<r)-1;u[1]=o.convert(this);if(r>1){var c=s();o.sqrTo(u[1],c);while(a<=l)u[a]=s(),o.mulTo(c,u[a-2],u[a]),a+=2}var h=e.t-1,p,d=!0,v=s(),m;n=N(e.data[h])-1;while(h>=0){n>=f?p=e.data[h]>>n-f&l:(p=(e.data[h]&(1<<n+1)-1)<<f-n,h>0&&(p|=e.data[h-1]>>this.DB+n-f)),a=r;while((p&1)==0)p>>=1,--a;(n-=a)<0&&(n+=this.DB,--h);if(d)u[p].copyTo(i),d=!1;else{while(a>1)o.sqrTo(i,v),o.sqrTo(v,i),a-=2;a>0?o.sqrTo(i,v):(m=i,i=v,v=m),o.mulTo(v,u[p],i)}while(h>=0&&(e.data[h]&1<<n)==0)o.sqrTo(i,v),m=i,i=v,v=m,--n<0&&(n=this.DB-1,--h)}return o.revert(i)}function tn(e){var t=this.s<0?this.negate():this.clone(),n=e.s<0?e.negate():e.clone();if(t.compareTo(n)<0){var r=t;t=n,n=r}var i=t.getLowestSetBit(),s=n.getLowestSetBit();if(s<0)return t;i<s&&(s=i),s>0&&(t.rShiftTo(s,t),n.rShiftTo(s,n));while(t.signum()>0)(i=t.getLowestSetBit())>0&&t.rShiftTo(i,t),(i=n.getLowestSetBit())>0&&n.rShiftTo(i,n),t.compareTo(n)>=0?(t.subTo(n,t),t.rShiftTo(1,t)):(n.subTo(t,n),n.rShiftTo(1,n));return s>0&&n.lShiftTo(s,n),n}function nn(e){if(e<=0)return 0;var t=this.DV%e,n=this.s<0?e-1:0;if(this.t>0)if(t==0)n=this.data[0]%e;else for(var r=this.t-1;r>=0;--r)n=(t*n+this.data[r])%e;return n}function rn(e){var t=e.isEven();if(this.isEven()&&t||e.signum()==0)return i.ZERO;var n=e.clone(),r=this.clone(),s=y(1),o=y(0),u=y(0),a=y(1);while(n.signum()!=0){while(n.isEven()){n.rShiftTo(1,n);if(t){if(!s.isEven()||!o.isEven())s.addTo(this,s),o.subTo(e,o);s.rShiftTo(1,s)}else o.isEven()||o.subTo(e,o);o.rShiftTo(1,o)}while(r.isEven()){r.rShiftTo(1,r);if(t){if(!u.isEven()||!a.isEven())u.addTo(this,u),a.subTo(e,a);u.rShiftTo(1,u)}else a.isEven()||a.subTo(e,a);a.rShiftTo(1,a)}n.compareTo(r)>=0?(n.subTo(r,n),t&&s.subTo(u,s),o.subTo(a,o)):(r.subTo(n,r),t&&u.subTo(s,u),a.subTo(o,a))}return r.compareTo(i.ONE)!=0?i.ZERO:a.compareTo(e)>=0?a.subtract(e):a.signum()<0?(a.addTo(e,a),a.signum()<0?a.add(e):a):a}function un(e){var t,n=this.abs();if(n.t==1&&n.data[0]<=sn[sn.length-1]){for(t=0;t<sn.length;++t)if(n.data[0]==sn[t])return!0;return!1}if(n.isEven())return!1;t=1;while(t<sn.length){var r=sn[t],i=t+1;while(i<sn.length&&r<on)r*=sn[i++];r=n.modInt(r);while(t<i)if(r%sn[t++]==0)return!1}return n.millerRabin(e)}function an(e){var t=this.subtract(i.ONE),n=t.getLowestSetBit();if(n<=0)return!1;var r=t.shiftRight(n),s=fn(),o;for(var u=0;u<e;++u){do o=new i(this.bitLength(),s);while(o.compareTo(i.ONE)<=0||o.compareTo(t)>=0);var a=o.modPow(r,this);if(a.compareTo(i.ONE)!=0&&a.compareTo(t)!=0){var f=1;while(f++<n&&a.compareTo(t)!=0){a=a.modPowInt(2,this);if(a.compareTo(i.ONE)==0)return!1}if(a.compareTo(t)!=0)return!1}}return!0}function fn(){return{nextBytes:function(e){for(var t=0;t<e.length;++t)e[t]=Math.floor(Math.random()*255)}}}var t,n=0xdeadbeefcafe,r=(n&16777215)==15715070;typeof navigator=="undefined"?(i.prototype.am=a,t=28):r&&navigator.appName=="Microsoft Internet Explorer"?(i.prototype.am=u,t=30):r&&navigator.appName!="Netscape"?(i.prototype.am=o,t=26):(i.prototype.am=a,t=28),i.prototype.DB=t,i.prototype.DM=(1<<t)-1,i.prototype.DV=1<<t;var f=52;i.prototype.FV=Math.pow(2,f),i.prototype.F1=f-t,i.prototype.F2=2*t-f;var l="0123456789abcdefghijklmnopqrstuvwxyz",c=new Array,h,p;h="0".charCodeAt(0);for(p=0;p<=9;++p)c[h++]=p;h="a".charCodeAt(0);for(p=10;p<36;++p)c[h++]=p;h="A".charCodeAt(0);for(p=10;p<36;++p)c[h++]=p;B.prototype.convert=j,B.prototype.revert=F,B.prototype.reduce=I,B.prototype.mulTo=q,B.prototype.sqrTo=R,z.prototype.convert=W,z.prototype.revert=X,z.prototype.reduce=V,z.prototype.mulTo=J,z.prototype.sqrTo=$,i.prototype.copyTo=m,i.prototype.fromInt=g,i.prototype.fromString=b,i.prototype.clamp=w,i.prototype.dlShiftTo=k,i.prototype.drShiftTo=L,i.prototype.lShiftTo=A,i.prototype.rShiftTo=O,i.prototype.subTo=M,i.prototype.multiplyTo=_,i.prototype.squareTo=D,i.prototype.divRemTo=P,i.prototype.invDigit=U,i.prototype.isEven=K,i.prototype.exp=Q,i.prototype.toString=E,i.prototype.negate=S,i.prototype.abs=x,i.prototype.compareTo=T,i.prototype.bitLength=C,i.prototype.mod=H,i.prototype.modPowInt=G,i.ZERO=y(0),i.ONE=y(1),Rt.prototype.convert=Ut,Rt.prototype.revert=Ut,Rt.prototype.mulTo=zt,Rt.prototype.sqrTo=Wt,Jt.prototype.convert=Kt,Jt.prototype.revert=Qt,Jt.prototype.reduce=Gt,Jt.prototype.mulTo=Zt,Jt.prototype.sqrTo=Yt;var sn=[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509],on=(1<<26)/sn[sn.length-1];i.prototype.chunkSize=nt,i.prototype.toRadix=it,i.prototype.fromRadix=st,i.prototype.fromNumber=ot,i.prototype.bitwiseTo=ct,i.prototype.changeBit=Lt,i.prototype.addTo=_t,i.prototype.dMultiply=It,i.prototype.dAddOffset=qt,i.prototype.multiplyLowerTo=Vt,i.prototype.multiplyUpperTo=$t,i.prototype.modInt=nn,i.prototype.millerRabin=an,i.prototype.clone=Y,i.prototype.intValue=Z,i.prototype.byteValue=et,i.prototype.shortValue=tt,i.prototype.signum=rt,i.prototype.toByteArray=ut,i.prototype.equals=at,i.prototype.min=ft,i.prototype.max=lt,i.prototype.and=pt,i.prototype.or=vt,i.prototype.xor=gt,i.prototype.andNot=bt,i.prototype.not=wt,i.prototype.shiftLeft=Et,i.prototype.shiftRight=St,i.prototype.getLowestSetBit=Tt,i.prototype.bitCount=Ct,i.prototype.testBit=kt,i.prototype.setBit=At,i.prototype.clearBit=Ot,i.prototype.flipBit=Mt,i.prototype.add=Dt,i.prototype.subtract=Pt,i.prototype.multiply=Ht,i.prototype.divide=Bt,i.prototype.remainder=jt,i.prototype.divideAndRemainder=Ft,i.prototype.modPow=en,i.prototype.modInverse=rn,i.prototype.pow=Xt,i.prototype.gcd=tn,i.prototype.isProbablePrime=un,e.jsbn=e.jsbn||{},e.jsbn.BigInteger=i}var r="jsbn";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/jsbn",["require","module"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){function n(e,t,n){var r="",i=Math.ceil(t/n.digestLength);for(var s=0;s<i;++s){var o=String.fromCharCode(s>>24&255,s>>16&255,s>>8&255,s&255);n.start(),n.update(e+o),r+=n.digest().getBytes()}return r.substring(0,t)}var t=e.pkcs1=e.pkcs1||{};t.encode_rsa_oaep=function(t,r,i){var s=undefined,o=undefined,u=undefined;typeof i=="string"?(s=i,o=arguments[3]||undefined,u=arguments[4]||undefined):i&&(s=i.label||undefined,o=i.seed||undefined,u=i.md||undefined),u?u.start():u=e.md.sha1.create();var a=Math.ceil(t.n.bitLength()/8),f=a-2*u.digestLength-2;if(r.length>f)throw{message:"RSAES-OAEP input message length is too long.",length:r.length,maxLength:f};s||(s=""),u.update(s,"raw");var l=u.digest(),c="",h=f-r.length;for(var p=0;p<h;p++)c+="\0";var d=l.getBytes()+c+""+r;if(!o)o=e.random.getBytes(u.digestLength);else if(o.length!==u.digestLength)throw{message:"Invalid RSAES-OAEP seed. The seed length must match the digest length.",seedLength:o.length,digestLength:u.digestLength};var v=n(o,a-u.digestLength-1,u),m=e.util.xorBytes(d,v,d.length),g=n(m,u.digestLength,u),y=e.util.xorBytes(o,g,o.length);return"\0"+y+m},t.decode_rsa_oaep=function(t,r,i){var s=undefined,o=undefined;typeof i=="string"?(s=i,o=arguments[3]||undefined):i&&(s=i.label||undefined,o=i.md||undefined);var u=Math.ceil(t.n.bitLength()/8);if(r.length!==u)throw{message:"RSAES-OAEP encoded message length is invalid.",length:r.length,expectedLength:u};o===undefined?o=e.md.sha1.create():o.start();if(u<2*o.digestLength+2)throw{message:"RSAES-OAEP key is too short for the hash function."};s||(s=""),o.update(s,"raw");var a=o.digest().getBytes(),f=r.charAt(0),l=r.substring(1,o.digestLength+1),c=r.substring(1+o.digestLength),h=n(c,o.digestLength,o),p=e.util.xorBytes(l,h,l.length),d=n(p,u-o.digestLength-1,o),v=e.util.xorBytes(c,d,c.length),m=v.substring(0,o.digestLength),g=f!=="\0";for(var y=0;y<o.digestLength;++y)g|=a.charAt(y)!==m.charAt(y);var b=1,w=o.digestLength;for(var E=o.digestLength;E<v.length;E++){var S=v.charCodeAt(E),x=S&1^1,T=b?65534:0;g|=S&T,b&=x,w+=b}if(g||v.charCodeAt(w)!==1)throw{message:"Invalid RSAES-OAEP padding."};return v.substring(w+1)}}var r="pkcs1";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/pkcs1",["require","module","./util","./random","./sha1"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){function c(t,n,r){var i=e.util.createBuffer(),s=Math.ceil(n.n.bitLength()/8);if(t.length>s-11)throw{message:"Message is too long for PKCS#1 v1.5 padding.",length:t.length,max:s-11};i.putByte(0),i.putByte(r);var o=s-3-t.length,u;if(r===0||r===1){u=r===0?0:255;for(var a=0;a<o;++a)i.putByte(u)}else while(o>0){var f=0,l=e.random.getBytes(o);for(var a=0;a<o;++a)u=l.charCodeAt(a),u===0?++f:i.putByte(u);o=f}return i.putByte(0),i.putBytes(t),i}function h(t,n,r,i){var s=Math.ceil(n.n.bitLength()/8),o=e.util.createBuffer(t),u=o.getByte(),a=o.getByte();if(u!==0||r&&a!==0&&a!==1||!r&&a!=2||r&&a===0&&typeof i=="undefined")throw{message:"Encryption block is invalid."};var f=0;if(a===0){f=s-3-i;for(var l=0;l<f;++l)if(o.getByte()!==0)throw{message:"Encryption block is invalid."}}else if(a===1){f=0;while(o.length()>1){if(o.getByte()!==255){--o.read;break}++f}}else if(a===2){f=0;while(o.length()>1){if(o.getByte()===0){--o.read;break}++f}}var c=o.getByte();if(c!==0||f!==s-3-o.length())throw{message:"Encryption block is invalid."};return o.getBytes()}function p(n,i,s){function p(){d(n.pBits,function(e,t){if(e)return s(e);n.p=t,d(n.qBits,v)})}function d(e,r){function p(){var r=e-1,i=new t(e,n.rng);return i.testBit(r)||i.bitwiseTo(t.ONE.shiftLeft(r),h,i),i.dAddOffset(31-i.mod(c).byteValue(),0),i}function v(s){if(d)return;--o;var u=s.data;if(u.found){for(var c=0;c<i.length;++c)i[c].terminate();return d=!0,r(null,new t(u.prime,16))}l.bitLength()>e&&(l=p());var h=l.toString(16);s.target.postMessage({e:n.eInt,hex:h,workLoad:a}),l.dAddOffset(f,0)}var i=[];for(var s=0;s<u;++s)i[s]=new Worker(window.URL.createObjectURL(new Blob([';(function(e,t,n){function i(n,s){if(!t[n]){if(!e[n]){var o=typeof require=="function"&&require;if(!s&&o)return o(n,!0);if(r)return r(n,!0);throw new Error("Cannot find module \'"+n+"\'")}var u=t[n]={exports:{}};e[n][0].call(u.exports,function(t){var r=e[n][1][t];return i(r?r:t)},u,u.exports)}return t[n].exports}var r=typeof require=="function"&&require;for(var s=0;s<n.length;s++)i(n[s]);return i})({1:[function(require,module,exports){\n/**\n * RSA Key Generation Worker.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2013 Digital Bazaar, Inc.\n */\nvar jsbn = require(\'./jsbn.js\');\n\n// prime constants\nvar LOW_PRIMES = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997];\nvar LP_LIMIT = (1 << 26) / LOW_PRIMES[LOW_PRIMES.length - 1];\n\nvar BigInteger = jsbn.BigInteger;\nvar BIG_TWO = new BigInteger(null);\nBIG_TWO.fromInt(2);\n\nself.addEventListener(\'message\', function(e) {\n  var result = findPrime(e.data);\n  self.postMessage(result);\n});\n\n// start receiving ranges to check\nself.postMessage({found: false});\n\n// primes are 30k+i for i = 1, 7, 11, 13, 17, 19, 23, 29\nvar GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];\n\nfunction findPrime(data) {\n  // create BigInteger from given random bytes\n  var num = new BigInteger(data.hex, 16);\n\n  /* Note: All primes are of the form 30k+i for i < 30 and gcd(30, i)=1. The\n    number we are given is always aligned at 30k + 1. Each time the number is\n    determined not to be prime we add to get to the next \'i\', eg: if the number\n    was at 30k + 1 we add 6. */\n  var deltaIdx = 0;\n\n  // find nearest prime\n  var workLoad = data.workLoad;\n  var e = new BigInteger(null);\n  e.fromInt(data.e);\n  for(var i = 0; i < workLoad; ++i) {\n    // do primality test\n    if(isProbablePrime(num)) {\n      // ensure number is coprime with e\n      if(num.subtract(BigInteger.ONE).gcd(e).compareTo(BigInteger.ONE) === 0) {\n        return {found: true, prime: num.toString(16)};\n      }\n    }\n\n    // get next potential prime\n    num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);\n  }\n\n  return {found: false};\n}\n\nfunction isProbablePrime(n) {\n  // divide by low primes, ignore even checks, etc (n alread aligned properly)\n  var i = 1;\n  while(i < LOW_PRIMES.length) {\n    var m = LOW_PRIMES[i];\n    var j = i + 1;\n    while(j < LOW_PRIMES.length && m < LP_LIMIT) {\n      m *= LOW_PRIMES[j++];\n    }\n    m = n.modInt(m);\n    while(i < j) {\n      if(m % LOW_PRIMES[i++] == 0) {\n        return false;\n      }\n    }\n  }\n  return runMillerRabin(n);\n}\n\n// HAC 4.24, Miller-Rabin\nfunction runMillerRabin(n) {\n  // n1 = n - 1\n  var n1 = n.subtract(BigInteger.ONE);\n\n  // get s and d such that n1 = 2^s * d\n  var s = n1.getLowestSetBit();\n  if(s <= 0) {\n    return false;\n  }\n  var d = n1.shiftRight(s);\n\n  var k = _getMillerRabinIterations(n);\n  var prng = getPrng();\n  var a;\n  for(var i = 0; i < k; ++i) {\n    // select witness \'a\' at random from between 1 and n - 1\n    do {\n      a = new BigInteger(n.bitLength(), prng);\n    }\n    while(a.compareTo(BigInteger.ONE) <= 0 || a.compareTo(n1) >= 0);\n\n    /* See if \'a\' is a composite witness. */\n\n    // x = a^d mod n\n    var x = a.modPow(d, n);\n\n    // probably prime\n    if(x.compareTo(BigInteger.ONE) === 0 || x.compareTo(n1) === 0) {\n      continue;\n    }\n\n    var j = s;\n    while(--j) {\n      // x = x^2 mod a\n      x = x.modPowInt(2, n);\n\n      // \'n\' is composite because no previous x == -1 mod n\n      if(x.compareTo(BigInteger.ONE) === 0) {\n        return false;\n      }\n      // x == -1 mod n, so probably prime\n      if(x.compareTo(n1) === 0) {\n        break;\n      }\n    }\n\n    // \'x\' is first_x^(n1/2) and is not +/- 1, so \'n\' is not prime\n    if(j === 0) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n// get pseudo random number generator\nfunction getPrng() {\n  // create prng with api that matches BigInteger secure random\n  return {\n    // x is an array to fill with bytes\n    nextBytes: function(x) {\n      for(var i = 0; i < x.length; ++i) {\n        x[i] = Math.floor(Math.random() * 0xFF);\n      }\n    }\n  };\n}\n\n/**\n * Returns the required number of Miller-Rabin iterations to generate a\n * prime with an error probability of (1/2)^80.\n *\n * See Handbook of Applied Cryptography Chapter 4, Table 4.4.\n *\n * @param bits the bit size.\n *\n * @return the required number of iterations.\n */\nfunction _getMillerRabinIterations(bits) {\n  if(bits <= 100) return 27;\n  if(bits <= 150) return 18;\n  if(bits <= 200) return 15;\n  if(bits <= 250) return 12;\n  if(bits <= 300) return 9;\n  if(bits <= 350) return 8;\n  if(bits <= 400) return 7;\n  if(bits <= 500) return 6;\n  if(bits <= 600) return 5;\n  if(bits <= 800) return 4;\n  if(bits <= 1250) return 3;\n  return 2;\n}\n\n},{"./jsbn.js":2}],2:[function(require,module,exports){\n// Copyright (c) 2005  Tom Wu\n// All Rights Reserved.\n// See "LICENSE" for details.\n\n// Basic JavaScript BN library - subset useful for RSA encryption.\n\n/*\nLicensing (LICENSE)\n-------------------\n\nThis software is covered under the following copyright:\n*/\n/*\n * Copyright (c) 2003-2005  Tom Wu\n * All Rights Reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * "Software"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY\n * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\n *\n * IN NO EVENT SHALL TOM WU BE LIABLE FOR ANY SPECIAL, INCIDENTAL,\n * INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, OR ANY DAMAGES WHATSOEVER\n * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER OR NOT ADVISED OF\n * THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF LIABILITY, ARISING OUT\n * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n *\n * In addition, the following condition applies:\n *\n * All redistributions must retain an intact copy of this copyright notice\n * and disclaimer.\n */\n/*\nAddress all questions regarding this license to:\n\n  Tom Wu\n  tjw@cs.Stanford.EDU\n*/\n\n/* ########## Begin module implementation ########## */\n\n// Bits per digit\nvar dbits;\n\n// JavaScript engine analysis\nvar canary = 0xdeadbeefcafe;\nvar j_lm = ((canary&0xffffff)==0xefcafe);\n\n// (public) Constructor\nfunction BigInteger(a,b,c) {\n  this.data = [];\n  if(a != null)\n    if("number" == typeof a) this.fromNumber(a,b,c);\n    else if(b == null && "string" != typeof a) this.fromString(a,256);\n    else this.fromString(a,b);\n}\n\n// return new, unset BigInteger\nfunction nbi() { return new BigInteger(null); }\n\n// am: Compute w_j += (x*this_i), propagate carries,\n// c is initial carry, returns final carry.\n// c < 3*dvalue, x < 2*dvalue, this_i < dvalue\n// We need to select the fastest one that works in this environment.\n\n// am1: use a single mult and divide to get the high bits,\n// max digit bits should be 26 because\n// max internal value = 2*dvalue^2-2*dvalue (< 2^53)\nfunction am1(i,x,w,j,c,n) {\n  while(--n >= 0) {\n    var v = x*this.data[i++]+w.data[j]+c;\n    c = Math.floor(v/0x4000000);\n    w.data[j++] = v&0x3ffffff;\n  }\n  return c;\n}\n// am2 avoids a big mult-and-extract completely.\n// Max digit bits should be <= 30 because we do bitwise ops\n// on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)\nfunction am2(i,x,w,j,c,n) {\n  var xl = x&0x7fff, xh = x>>15;\n  while(--n >= 0) {\n    var l = this.data[i]&0x7fff;\n    var h = this.data[i++]>>15;\n    var m = xh*l+h*xl;\n    l = xl*l+((m&0x7fff)<<15)+w.data[j]+(c&0x3fffffff);\n    c = (l>>>30)+(m>>>15)+xh*h+(c>>>30);\n    w.data[j++] = l&0x3fffffff;\n  }\n  return c;\n}\n// Alternately, set max digit bits to 28 since some\n// browsers slow down when dealing with 32-bit numbers.\nfunction am3(i,x,w,j,c,n) {\n  var xl = x&0x3fff, xh = x>>14;\n  while(--n >= 0) {\n    var l = this.data[i]&0x3fff;\n    var h = this.data[i++]>>14;\n    var m = xh*l+h*xl;\n    l = xl*l+((m&0x3fff)<<14)+w.data[j]+c;\n    c = (l>>28)+(m>>14)+xh*h;\n    w.data[j++] = l&0xfffffff;\n  }\n  return c;\n}\n\n// node.js (no browser)\nif(typeof(navigator) === \'undefined\')\n{\n   BigInteger.prototype.am = am3;\n   dbits = 28;\n}\nelse if(j_lm && (navigator.appName == "Microsoft Internet Explorer")) {\n  BigInteger.prototype.am = am2;\n  dbits = 30;\n}\nelse if(j_lm && (navigator.appName != "Netscape")) {\n  BigInteger.prototype.am = am1;\n  dbits = 26;\n}\nelse { // Mozilla/Netscape seems to prefer am3\n  BigInteger.prototype.am = am3;\n  dbits = 28;\n}\n\nBigInteger.prototype.DB = dbits;\nBigInteger.prototype.DM = ((1<<dbits)-1);\nBigInteger.prototype.DV = (1<<dbits);\n\nvar BI_FP = 52;\nBigInteger.prototype.FV = Math.pow(2,BI_FP);\nBigInteger.prototype.F1 = BI_FP-dbits;\nBigInteger.prototype.F2 = 2*dbits-BI_FP;\n\n// Digit conversions\nvar BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";\nvar BI_RC = new Array();\nvar rr,vv;\nrr = "0".charCodeAt(0);\nfor(vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;\nrr = "a".charCodeAt(0);\nfor(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\nrr = "A".charCodeAt(0);\nfor(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n\nfunction int2char(n) { return BI_RM.charAt(n); }\nfunction intAt(s,i) {\n  var c = BI_RC[s.charCodeAt(i)];\n  return (c==null)?-1:c;\n}\n\n// (protected) copy this to r\nfunction bnpCopyTo(r) {\n  for(var i = this.t-1; i >= 0; --i) r.data[i] = this.data[i];\n  r.t = this.t;\n  r.s = this.s;\n}\n\n// (protected) set from integer value x, -DV <= x < DV\nfunction bnpFromInt(x) {\n  this.t = 1;\n  this.s = (x<0)?-1:0;\n  if(x > 0) this.data[0] = x;\n  else if(x < -1) this.data[0] = x+this.DV;\n  else this.t = 0;\n}\n\n// return bigint initialized to value\nfunction nbv(i) { var r = nbi(); r.fromInt(i); return r; }\n\n// (protected) set from string and radix\nfunction bnpFromString(s,b) {\n  var k;\n  if(b == 16) k = 4;\n  else if(b == 8) k = 3;\n  else if(b == 256) k = 8; // byte array\n  else if(b == 2) k = 1;\n  else if(b == 32) k = 5;\n  else if(b == 4) k = 2;\n  else { this.fromRadix(s,b); return; }\n  this.t = 0;\n  this.s = 0;\n  var i = s.length, mi = false, sh = 0;\n  while(--i >= 0) {\n    var x = (k==8)?s[i]&0xff:intAt(s,i);\n    if(x < 0) {\n      if(s.charAt(i) == "-") mi = true;\n      continue;\n    }\n    mi = false;\n    if(sh == 0)\n      this.data[this.t++] = x;\n    else if(sh+k > this.DB) {\n      this.data[this.t-1] |= (x&((1<<(this.DB-sh))-1))<<sh;\n      this.data[this.t++] = (x>>(this.DB-sh));\n    }\n    else\n      this.data[this.t-1] |= x<<sh;\n    sh += k;\n    if(sh >= this.DB) sh -= this.DB;\n  }\n  if(k == 8 && (s[0]&0x80) != 0) {\n    this.s = -1;\n    if(sh > 0) this.data[this.t-1] |= ((1<<(this.DB-sh))-1)<<sh;\n  }\n  this.clamp();\n  if(mi) BigInteger.ZERO.subTo(this,this);\n}\n\n// (protected) clamp off excess high words\nfunction bnpClamp() {\n  var c = this.s&this.DM;\n  while(this.t > 0 && this.data[this.t-1] == c) --this.t;\n}\n\n// (public) return string representation in given radix\nfunction bnToString(b) {\n  if(this.s < 0) return "-"+this.negate().toString(b);\n  var k;\n  if(b == 16) k = 4;\n  else if(b == 8) k = 3;\n  else if(b == 2) k = 1;\n  else if(b == 32) k = 5;\n  else if(b == 4) k = 2;\n  else return this.toRadix(b);\n  var km = (1<<k)-1, d, m = false, r = "", i = this.t;\n  var p = this.DB-(i*this.DB)%k;\n  if(i-- > 0) {\n    if(p < this.DB && (d = this.data[i]>>p) > 0) { m = true; r = int2char(d); }\n    while(i >= 0) {\n      if(p < k) {\n        d = (this.data[i]&((1<<p)-1))<<(k-p);\n        d |= this.data[--i]>>(p+=this.DB-k);\n      }\n      else {\n        d = (this.data[i]>>(p-=k))&km;\n        if(p <= 0) { p += this.DB; --i; }\n      }\n      if(d > 0) m = true;\n      if(m) r += int2char(d);\n    }\n  }\n  return m?r:"0";\n}\n\n// (public) -this\nfunction bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; }\n\n// (public) |this|\nfunction bnAbs() { return (this.s<0)?this.negate():this; }\n\n// (public) return + if this > a, - if this < a, 0 if equal\nfunction bnCompareTo(a) {\n  var r = this.s-a.s;\n  if(r != 0) return r;\n  var i = this.t;\n  r = i-a.t;\n  if(r != 0) return (this.s<0)?-r:r;\n  while(--i >= 0) if((r=this.data[i]-a.data[i]) != 0) return r;\n  return 0;\n}\n\n// returns bit length of the integer x\nfunction nbits(x) {\n  var r = 1, t;\n  if((t=x>>>16) != 0) { x = t; r += 16; }\n  if((t=x>>8) != 0) { x = t; r += 8; }\n  if((t=x>>4) != 0) { x = t; r += 4; }\n  if((t=x>>2) != 0) { x = t; r += 2; }\n  if((t=x>>1) != 0) { x = t; r += 1; }\n  return r;\n}\n\n// (public) return the number of bits in "this"\nfunction bnBitLength() {\n  if(this.t <= 0) return 0;\n  return this.DB*(this.t-1)+nbits(this.data[this.t-1]^(this.s&this.DM));\n}\n\n// (protected) r = this << n*DB\nfunction bnpDLShiftTo(n,r) {\n  var i;\n  for(i = this.t-1; i >= 0; --i) r.data[i+n] = this.data[i];\n  for(i = n-1; i >= 0; --i) r.data[i] = 0;\n  r.t = this.t+n;\n  r.s = this.s;\n}\n\n// (protected) r = this >> n*DB\nfunction bnpDRShiftTo(n,r) {\n  for(var i = n; i < this.t; ++i) r.data[i-n] = this.data[i];\n  r.t = Math.max(this.t-n,0);\n  r.s = this.s;\n}\n\n// (protected) r = this << n\nfunction bnpLShiftTo(n,r) {\n  var bs = n%this.DB;\n  var cbs = this.DB-bs;\n  var bm = (1<<cbs)-1;\n  var ds = Math.floor(n/this.DB), c = (this.s<<bs)&this.DM, i;\n  for(i = this.t-1; i >= 0; --i) {\n    r.data[i+ds+1] = (this.data[i]>>cbs)|c;\n    c = (this.data[i]&bm)<<bs;\n  }\n  for(i = ds-1; i >= 0; --i) r.data[i] = 0;\n  r.data[ds] = c;\n  r.t = this.t+ds+1;\n  r.s = this.s;\n  r.clamp();\n}\n\n// (protected) r = this >> n\nfunction bnpRShiftTo(n,r) {\n  r.s = this.s;\n  var ds = Math.floor(n/this.DB);\n  if(ds >= this.t) { r.t = 0; return; }\n  var bs = n%this.DB;\n  var cbs = this.DB-bs;\n  var bm = (1<<bs)-1;\n  r.data[0] = this.data[ds]>>bs;\n  for(var i = ds+1; i < this.t; ++i) {\n    r.data[i-ds-1] |= (this.data[i]&bm)<<cbs;\n    r.data[i-ds] = this.data[i]>>bs;\n  }\n  if(bs > 0) r.data[this.t-ds-1] |= (this.s&bm)<<cbs;\n  r.t = this.t-ds;\n  r.clamp();\n}\n\n// (protected) r = this - a\nfunction bnpSubTo(a,r) {\n  var i = 0, c = 0, m = Math.min(a.t,this.t);\n  while(i < m) {\n    c += this.data[i]-a.data[i];\n    r.data[i++] = c&this.DM;\n    c >>= this.DB;\n  }\n  if(a.t < this.t) {\n    c -= a.s;\n    while(i < this.t) {\n      c += this.data[i];\n      r.data[i++] = c&this.DM;\n      c >>= this.DB;\n    }\n    c += this.s;\n  }\n  else {\n    c += this.s;\n    while(i < a.t) {\n      c -= a.data[i];\n      r.data[i++] = c&this.DM;\n      c >>= this.DB;\n    }\n    c -= a.s;\n  }\n  r.s = (c<0)?-1:0;\n  if(c < -1) r.data[i++] = this.DV+c;\n  else if(c > 0) r.data[i++] = c;\n  r.t = i;\n  r.clamp();\n}\n\n// (protected) r = this * a, r != this,a (HAC 14.12)\n// "this" should be the larger one if appropriate.\nfunction bnpMultiplyTo(a,r) {\n  var x = this.abs(), y = a.abs();\n  var i = x.t;\n  r.t = i+y.t;\n  while(--i >= 0) r.data[i] = 0;\n  for(i = 0; i < y.t; ++i) r.data[i+x.t] = x.am(0,y.data[i],r,i,0,x.t);\n  r.s = 0;\n  r.clamp();\n  if(this.s != a.s) BigInteger.ZERO.subTo(r,r);\n}\n\n// (protected) r = this^2, r != this (HAC 14.16)\nfunction bnpSquareTo(r) {\n  var x = this.abs();\n  var i = r.t = 2*x.t;\n  while(--i >= 0) r.data[i] = 0;\n  for(i = 0; i < x.t-1; ++i) {\n    var c = x.am(i,x.data[i],r,2*i,0,1);\n    if((r.data[i+x.t]+=x.am(i+1,2*x.data[i],r,2*i+1,c,x.t-i-1)) >= x.DV) {\n      r.data[i+x.t] -= x.DV;\n      r.data[i+x.t+1] = 1;\n    }\n  }\n  if(r.t > 0) r.data[r.t-1] += x.am(i,x.data[i],r,2*i,0,1);\n  r.s = 0;\n  r.clamp();\n}\n\n// (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)\n// r != q, this != m.  q or r may be null.\nfunction bnpDivRemTo(m,q,r) {\n  var pm = m.abs();\n  if(pm.t <= 0) return;\n  var pt = this.abs();\n  if(pt.t < pm.t) {\n    if(q != null) q.fromInt(0);\n    if(r != null) this.copyTo(r);\n    return;\n  }\n  if(r == null) r = nbi();\n  var y = nbi(), ts = this.s, ms = m.s;\n  var nsh = this.DB-nbits(pm.data[pm.t-1]);\t// normalize modulus\n  if(nsh > 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); }\n  else { pm.copyTo(y); pt.copyTo(r); }\n  var ys = y.t;\n  var y0 = y.data[ys-1];\n  if(y0 == 0) return;\n  var yt = y0*(1<<this.F1)+((ys>1)?y.data[ys-2]>>this.F2:0);\n  var d1 = this.FV/yt, d2 = (1<<this.F1)/yt, e = 1<<this.F2;\n  var i = r.t, j = i-ys, t = (q==null)?nbi():q;\n  y.dlShiftTo(j,t);\n  if(r.compareTo(t) >= 0) {\n    r.data[r.t++] = 1;\n    r.subTo(t,r);\n  }\n  BigInteger.ONE.dlShiftTo(ys,t);\n  t.subTo(y,y);\t// "negative" y so we can replace sub with am later\n  while(y.t < ys) y.data[y.t++] = 0;\n  while(--j >= 0) {\n    // Estimate quotient digit\n    var qd = (r.data[--i]==y0)?this.DM:Math.floor(r.data[i]*d1+(r.data[i-1]+e)*d2);\n    if((r.data[i]+=y.am(0,qd,r,j,0,ys)) < qd) {\t// Try it out\n      y.dlShiftTo(j,t);\n      r.subTo(t,r);\n      while(r.data[i] < --qd) r.subTo(t,r);\n    }\n  }\n  if(q != null) {\n    r.drShiftTo(ys,q);\n    if(ts != ms) BigInteger.ZERO.subTo(q,q);\n  }\n  r.t = ys;\n  r.clamp();\n  if(nsh > 0) r.rShiftTo(nsh,r);\t// Denormalize remainder\n  if(ts < 0) BigInteger.ZERO.subTo(r,r);\n}\n\n// (public) this mod a\nfunction bnMod(a) {\n  var r = nbi();\n  this.abs().divRemTo(a,null,r);\n  if(this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r,r);\n  return r;\n}\n\n// Modular reduction using "classic" algorithm\nfunction Classic(m) { this.m = m; }\nfunction cConvert(x) {\n  if(x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);\n  else return x;\n}\nfunction cRevert(x) { return x; }\nfunction cReduce(x) { x.divRemTo(this.m,null,x); }\nfunction cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\nfunction cSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\nClassic.prototype.convert = cConvert;\nClassic.prototype.revert = cRevert;\nClassic.prototype.reduce = cReduce;\nClassic.prototype.mulTo = cMulTo;\nClassic.prototype.sqrTo = cSqrTo;\n\n// (protected) return "-1/this % 2^DB"; useful for Mont. reduction\n// justification:\n//         xy == 1 (mod m)\n//         xy =  1+km\n//   xy(2-xy) = (1+km)(1-km)\n// x[y(2-xy)] = 1-k^2m^2\n// x[y(2-xy)] == 1 (mod m^2)\n// if y is 1/x mod m, then y(2-xy) is 1/x mod m^2\n// should reduce x and y(2-xy) by m^2 at each step to keep size bounded.\n// JS multiply "overflows" differently from C/C++, so care is needed here.\nfunction bnpInvDigit() {\n  if(this.t < 1) return 0;\n  var x = this.data[0];\n  if((x&1) == 0) return 0;\n  var y = x&3;\t\t// y == 1/x mod 2^2\n  y = (y*(2-(x&0xf)*y))&0xf;\t// y == 1/x mod 2^4\n  y = (y*(2-(x&0xff)*y))&0xff;\t// y == 1/x mod 2^8\n  y = (y*(2-(((x&0xffff)*y)&0xffff)))&0xffff;\t// y == 1/x mod 2^16\n  // last step - calculate inverse mod DV directly;\n  // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints\n  y = (y*(2-x*y%this.DV))%this.DV;\t\t// y == 1/x mod 2^dbits\n  // we really want the negative inverse, and -DV < y < DV\n  return (y>0)?this.DV-y:-y;\n}\n\n// Montgomery reduction\nfunction Montgomery(m) {\n  this.m = m;\n  this.mp = m.invDigit();\n  this.mpl = this.mp&0x7fff;\n  this.mph = this.mp>>15;\n  this.um = (1<<(m.DB-15))-1;\n  this.mt2 = 2*m.t;\n}\n\n// xR mod m\nfunction montConvert(x) {\n  var r = nbi();\n  x.abs().dlShiftTo(this.m.t,r);\n  r.divRemTo(this.m,null,r);\n  if(x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r,r);\n  return r;\n}\n\n// x/R mod m\nfunction montRevert(x) {\n  var r = nbi();\n  x.copyTo(r);\n  this.reduce(r);\n  return r;\n}\n\n// x = x/R mod m (HAC 14.32)\nfunction montReduce(x) {\n  while(x.t <= this.mt2)\t// pad x so am has enough room later\n    x.data[x.t++] = 0;\n  for(var i = 0; i < this.m.t; ++i) {\n    // faster way of calculating u0 = x.data[i]*mp mod DV\n    var j = x.data[i]&0x7fff;\n    var u0 = (j*this.mpl+(((j*this.mph+(x.data[i]>>15)*this.mpl)&this.um)<<15))&x.DM;\n    // use am to combine the multiply-shift-add into one call\n    j = i+this.m.t;\n    x.data[j] += this.m.am(0,u0,x,i,0,this.m.t);\n    // propagate carry\n    while(x.data[j] >= x.DV) { x.data[j] -= x.DV; x.data[++j]++; }\n  }\n  x.clamp();\n  x.drShiftTo(this.m.t,x);\n  if(x.compareTo(this.m) >= 0) x.subTo(this.m,x);\n}\n\n// r = "x^2/R mod m"; x != r\nfunction montSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\n// r = "xy/R mod m"; x,y != r\nfunction montMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\n\nMontgomery.prototype.convert = montConvert;\nMontgomery.prototype.revert = montRevert;\nMontgomery.prototype.reduce = montReduce;\nMontgomery.prototype.mulTo = montMulTo;\nMontgomery.prototype.sqrTo = montSqrTo;\n\n// (protected) true iff this is even\nfunction bnpIsEven() { return ((this.t>0)?(this.data[0]&1):this.s) == 0; }\n\n// (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)\nfunction bnpExp(e,z) {\n  if(e > 0xffffffff || e < 1) return BigInteger.ONE;\n  var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e)-1;\n  g.copyTo(r);\n  while(--i >= 0) {\n    z.sqrTo(r,r2);\n    if((e&(1<<i)) > 0) z.mulTo(r2,g,r);\n    else { var t = r; r = r2; r2 = t; }\n  }\n  return z.revert(r);\n}\n\n// (public) this^e % m, 0 <= e < 2^32\nfunction bnModPowInt(e,m) {\n  var z;\n  if(e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);\n  return this.exp(e,z);\n}\n\n// protected\nBigInteger.prototype.copyTo = bnpCopyTo;\nBigInteger.prototype.fromInt = bnpFromInt;\nBigInteger.prototype.fromString = bnpFromString;\nBigInteger.prototype.clamp = bnpClamp;\nBigInteger.prototype.dlShiftTo = bnpDLShiftTo;\nBigInteger.prototype.drShiftTo = bnpDRShiftTo;\nBigInteger.prototype.lShiftTo = bnpLShiftTo;\nBigInteger.prototype.rShiftTo = bnpRShiftTo;\nBigInteger.prototype.subTo = bnpSubTo;\nBigInteger.prototype.multiplyTo = bnpMultiplyTo;\nBigInteger.prototype.squareTo = bnpSquareTo;\nBigInteger.prototype.divRemTo = bnpDivRemTo;\nBigInteger.prototype.invDigit = bnpInvDigit;\nBigInteger.prototype.isEven = bnpIsEven;\nBigInteger.prototype.exp = bnpExp;\n\n// public\nBigInteger.prototype.toString = bnToString;\nBigInteger.prototype.negate = bnNegate;\nBigInteger.prototype.abs = bnAbs;\nBigInteger.prototype.compareTo = bnCompareTo;\nBigInteger.prototype.bitLength = bnBitLength;\nBigInteger.prototype.mod = bnMod;\nBigInteger.prototype.modPowInt = bnModPowInt;\n\n// "constants"\nBigInteger.ZERO = nbv(0);\nBigInteger.ONE = nbv(1);\n\n// jsbn2 lib\n\n//Copyright (c) 2005-2009  Tom Wu\n//All Rights Reserved.\n//See "LICENSE" for details (See jsbn.js for LICENSE).\n\n//Extended JavaScript BN functions, required for RSA private ops.\n\n//Version 1.1: new BigInteger("0", 10) returns "proper" zero\n\n//(public)\nfunction bnClone() { var r = nbi(); this.copyTo(r); return r; }\n\n//(public) return value as integer\nfunction bnIntValue() {\nif(this.s < 0) {\n if(this.t == 1) return this.data[0]-this.DV;\n else if(this.t == 0) return -1;\n}\nelse if(this.t == 1) return this.data[0];\nelse if(this.t == 0) return 0;\n// assumes 16 < DB < 32\nreturn ((this.data[1]&((1<<(32-this.DB))-1))<<this.DB)|this.data[0];\n}\n\n//(public) return value as byte\nfunction bnByteValue() { return (this.t==0)?this.s:(this.data[0]<<24)>>24; }\n\n//(public) return value as short (assumes DB>=16)\nfunction bnShortValue() { return (this.t==0)?this.s:(this.data[0]<<16)>>16; }\n\n//(protected) return x s.t. r^x < DV\nfunction bnpChunkSize(r) { return Math.floor(Math.LN2*this.DB/Math.log(r)); }\n\n//(public) 0 if this == 0, 1 if this > 0\nfunction bnSigNum() {\nif(this.s < 0) return -1;\nelse if(this.t <= 0 || (this.t == 1 && this.data[0] <= 0)) return 0;\nelse return 1;\n}\n\n//(protected) convert to radix string\nfunction bnpToRadix(b) {\nif(b == null) b = 10;\nif(this.signum() == 0 || b < 2 || b > 36) return "0";\nvar cs = this.chunkSize(b);\nvar a = Math.pow(b,cs);\nvar d = nbv(a), y = nbi(), z = nbi(), r = "";\nthis.divRemTo(d,y,z);\nwhile(y.signum() > 0) {\n r = (a+z.intValue()).toString(b).substr(1) + r;\n y.divRemTo(d,y,z);\n}\nreturn z.intValue().toString(b) + r;\n}\n\n//(protected) convert from radix string\nfunction bnpFromRadix(s,b) {\nthis.fromInt(0);\nif(b == null) b = 10;\nvar cs = this.chunkSize(b);\nvar d = Math.pow(b,cs), mi = false, j = 0, w = 0;\nfor(var i = 0; i < s.length; ++i) {\n var x = intAt(s,i);\n if(x < 0) {\n   if(s.charAt(i) == "-" && this.signum() == 0) mi = true;\n   continue;\n }\n w = b*w+x;\n if(++j >= cs) {\n   this.dMultiply(d);\n   this.dAddOffset(w,0);\n   j = 0;\n   w = 0;\n }\n}\nif(j > 0) {\n this.dMultiply(Math.pow(b,j));\n this.dAddOffset(w,0);\n}\nif(mi) BigInteger.ZERO.subTo(this,this);\n}\n\n//(protected) alternate constructor\nfunction bnpFromNumber(a,b,c) {\nif("number" == typeof b) {\n // new BigInteger(int,int,RNG)\n if(a < 2) this.fromInt(1);\n else {\n   this.fromNumber(a,c);\n   if(!this.testBit(a-1))  // force MSB set\n     this.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,this);\n   if(this.isEven()) this.dAddOffset(1,0); // force odd\n   while(!this.isProbablePrime(b)) {\n     this.dAddOffset(2,0);\n     if(this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a-1),this);\n   }\n }\n}\nelse {\n // new BigInteger(int,RNG)\n var x = new Array(), t = a&7;\n x.length = (a>>3)+1;\n b.nextBytes(x);\n if(t > 0) x[0] &= ((1<<t)-1); else x[0] = 0;\n this.fromString(x,256);\n}\n}\n\n//(public) convert to bigendian byte array\nfunction bnToByteArray() {\nvar i = this.t, r = new Array();\nr[0] = this.s;\nvar p = this.DB-(i*this.DB)%8, d, k = 0;\nif(i-- > 0) {\n if(p < this.DB && (d = this.data[i]>>p) != (this.s&this.DM)>>p)\n   r[k++] = d|(this.s<<(this.DB-p));\n while(i >= 0) {\n   if(p < 8) {\n     d = (this.data[i]&((1<<p)-1))<<(8-p);\n     d |= this.data[--i]>>(p+=this.DB-8);\n   }\n   else {\n     d = (this.data[i]>>(p-=8))&0xff;\n     if(p <= 0) { p += this.DB; --i; }\n   }\n   if((d&0x80) != 0) d |= -256;\n   if(k == 0 && (this.s&0x80) != (d&0x80)) ++k;\n   if(k > 0 || d != this.s) r[k++] = d;\n }\n}\nreturn r;\n}\n\nfunction bnEquals(a) { return(this.compareTo(a)==0); }\nfunction bnMin(a) { return(this.compareTo(a)<0)?this:a; }\nfunction bnMax(a) { return(this.compareTo(a)>0)?this:a; }\n\n//(protected) r = this op a (bitwise)\nfunction bnpBitwiseTo(a,op,r) {\nvar i, f, m = Math.min(a.t,this.t);\nfor(i = 0; i < m; ++i) r.data[i] = op(this.data[i],a.data[i]);\nif(a.t < this.t) {\n f = a.s&this.DM;\n for(i = m; i < this.t; ++i) r.data[i] = op(this.data[i],f);\n r.t = this.t;\n}\nelse {\n f = this.s&this.DM;\n for(i = m; i < a.t; ++i) r.data[i] = op(f,a.data[i]);\n r.t = a.t;\n}\nr.s = op(this.s,a.s);\nr.clamp();\n}\n\n//(public) this & a\nfunction op_and(x,y) { return x&y; }\nfunction bnAnd(a) { var r = nbi(); this.bitwiseTo(a,op_and,r); return r; }\n\n//(public) this | a\nfunction op_or(x,y) { return x|y; }\nfunction bnOr(a) { var r = nbi(); this.bitwiseTo(a,op_or,r); return r; }\n\n//(public) this ^ a\nfunction op_xor(x,y) { return x^y; }\nfunction bnXor(a) { var r = nbi(); this.bitwiseTo(a,op_xor,r); return r; }\n\n//(public) this & ~a\nfunction op_andnot(x,y) { return x&~y; }\nfunction bnAndNot(a) { var r = nbi(); this.bitwiseTo(a,op_andnot,r); return r; }\n\n//(public) ~this\nfunction bnNot() {\nvar r = nbi();\nfor(var i = 0; i < this.t; ++i) r.data[i] = this.DM&~this.data[i];\nr.t = this.t;\nr.s = ~this.s;\nreturn r;\n}\n\n//(public) this << n\nfunction bnShiftLeft(n) {\nvar r = nbi();\nif(n < 0) this.rShiftTo(-n,r); else this.lShiftTo(n,r);\nreturn r;\n}\n\n//(public) this >> n\nfunction bnShiftRight(n) {\nvar r = nbi();\nif(n < 0) this.lShiftTo(-n,r); else this.rShiftTo(n,r);\nreturn r;\n}\n\n//return index of lowest 1-bit in x, x < 2^31\nfunction lbit(x) {\nif(x == 0) return -1;\nvar r = 0;\nif((x&0xffff) == 0) { x >>= 16; r += 16; }\nif((x&0xff) == 0) { x >>= 8; r += 8; }\nif((x&0xf) == 0) { x >>= 4; r += 4; }\nif((x&3) == 0) { x >>= 2; r += 2; }\nif((x&1) == 0) ++r;\nreturn r;\n}\n\n//(public) returns index of lowest 1-bit (or -1 if none)\nfunction bnGetLowestSetBit() {\nfor(var i = 0; i < this.t; ++i)\n if(this.data[i] != 0) return i*this.DB+lbit(this.data[i]);\nif(this.s < 0) return this.t*this.DB;\nreturn -1;\n}\n\n//return number of 1 bits in x\nfunction cbit(x) {\nvar r = 0;\nwhile(x != 0) { x &= x-1; ++r; }\nreturn r;\n}\n\n//(public) return number of set bits\nfunction bnBitCount() {\nvar r = 0, x = this.s&this.DM;\nfor(var i = 0; i < this.t; ++i) r += cbit(this.data[i]^x);\nreturn r;\n}\n\n//(public) true iff nth bit is set\nfunction bnTestBit(n) {\nvar j = Math.floor(n/this.DB);\nif(j >= this.t) return(this.s!=0);\nreturn((this.data[j]&(1<<(n%this.DB)))!=0);\n}\n\n//(protected) this op (1<<n)\nfunction bnpChangeBit(n,op) {\nvar r = BigInteger.ONE.shiftLeft(n);\nthis.bitwiseTo(r,op,r);\nreturn r;\n}\n\n//(public) this | (1<<n)\nfunction bnSetBit(n) { return this.changeBit(n,op_or); }\n\n//(public) this & ~(1<<n)\nfunction bnClearBit(n) { return this.changeBit(n,op_andnot); }\n\n//(public) this ^ (1<<n)\nfunction bnFlipBit(n) { return this.changeBit(n,op_xor); }\n\n//(protected) r = this + a\nfunction bnpAddTo(a,r) {\nvar i = 0, c = 0, m = Math.min(a.t,this.t);\nwhile(i < m) {\n c += this.data[i]+a.data[i];\n r.data[i++] = c&this.DM;\n c >>= this.DB;\n}\nif(a.t < this.t) {\n c += a.s;\n while(i < this.t) {\n   c += this.data[i];\n   r.data[i++] = c&this.DM;\n   c >>= this.DB;\n }\n c += this.s;\n}\nelse {\n c += this.s;\n while(i < a.t) {\n   c += a.data[i];\n   r.data[i++] = c&this.DM;\n   c >>= this.DB;\n }\n c += a.s;\n}\nr.s = (c<0)?-1:0;\nif(c > 0) r.data[i++] = c;\nelse if(c < -1) r.data[i++] = this.DV+c;\nr.t = i;\nr.clamp();\n}\n\n//(public) this + a\nfunction bnAdd(a) { var r = nbi(); this.addTo(a,r); return r; }\n\n//(public) this - a\nfunction bnSubtract(a) { var r = nbi(); this.subTo(a,r); return r; }\n\n//(public) this * a\nfunction bnMultiply(a) { var r = nbi(); this.multiplyTo(a,r); return r; }\n\n//(public) this / a\nfunction bnDivide(a) { var r = nbi(); this.divRemTo(a,r,null); return r; }\n\n//(public) this % a\nfunction bnRemainder(a) { var r = nbi(); this.divRemTo(a,null,r); return r; }\n\n//(public) [this/a,this%a]\nfunction bnDivideAndRemainder(a) {\nvar q = nbi(), r = nbi();\nthis.divRemTo(a,q,r);\nreturn new Array(q,r);\n}\n\n//(protected) this *= n, this >= 0, 1 < n < DV\nfunction bnpDMultiply(n) {\nthis.data[this.t] = this.am(0,n-1,this,0,0,this.t);\n++this.t;\nthis.clamp();\n}\n\n//(protected) this += n << w words, this >= 0\nfunction bnpDAddOffset(n,w) {\nif(n == 0) return;\nwhile(this.t <= w) this.data[this.t++] = 0;\nthis.data[w] += n;\nwhile(this.data[w] >= this.DV) {\n this.data[w] -= this.DV;\n if(++w >= this.t) this.data[this.t++] = 0;\n ++this.data[w];\n}\n}\n\n//A "null" reducer\nfunction NullExp() {}\nfunction nNop(x) { return x; }\nfunction nMulTo(x,y,r) { x.multiplyTo(y,r); }\nfunction nSqrTo(x,r) { x.squareTo(r); }\n\nNullExp.prototype.convert = nNop;\nNullExp.prototype.revert = nNop;\nNullExp.prototype.mulTo = nMulTo;\nNullExp.prototype.sqrTo = nSqrTo;\n\n//(public) this^e\nfunction bnPow(e) { return this.exp(e,new NullExp()); }\n\n//(protected) r = lower n words of "this * a", a.t <= n\n//"this" should be the larger one if appropriate.\nfunction bnpMultiplyLowerTo(a,n,r) {\nvar i = Math.min(this.t+a.t,n);\nr.s = 0; // assumes a,this >= 0\nr.t = i;\nwhile(i > 0) r.data[--i] = 0;\nvar j;\nfor(j = r.t-this.t; i < j; ++i) r.data[i+this.t] = this.am(0,a.data[i],r,i,0,this.t);\nfor(j = Math.min(a.t,n); i < j; ++i) this.am(0,a.data[i],r,i,0,n-i);\nr.clamp();\n}\n\n//(protected) r = "this * a" without lower n words, n > 0\n//"this" should be the larger one if appropriate.\nfunction bnpMultiplyUpperTo(a,n,r) {\n--n;\nvar i = r.t = this.t+a.t-n;\nr.s = 0; // assumes a,this >= 0\nwhile(--i >= 0) r.data[i] = 0;\nfor(i = Math.max(n-this.t,0); i < a.t; ++i)\n r.data[this.t+i-n] = this.am(n-i,a.data[i],r,0,0,this.t+i-n);\nr.clamp();\nr.drShiftTo(1,r);\n}\n\n//Barrett modular reduction\nfunction Barrett(m) {\n// setup Barrett\nthis.r2 = nbi();\nthis.q3 = nbi();\nBigInteger.ONE.dlShiftTo(2*m.t,this.r2);\nthis.mu = this.r2.divide(m);\nthis.m = m;\n}\n\nfunction barrettConvert(x) {\nif(x.s < 0 || x.t > 2*this.m.t) return x.mod(this.m);\nelse if(x.compareTo(this.m) < 0) return x;\nelse { var r = nbi(); x.copyTo(r); this.reduce(r); return r; }\n}\n\nfunction barrettRevert(x) { return x; }\n\n//x = x mod m (HAC 14.42)\nfunction barrettReduce(x) {\nx.drShiftTo(this.m.t-1,this.r2);\nif(x.t > this.m.t+1) { x.t = this.m.t+1; x.clamp(); }\nthis.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);\nthis.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);\nwhile(x.compareTo(this.r2) < 0) x.dAddOffset(1,this.m.t+1);\nx.subTo(this.r2,x);\nwhile(x.compareTo(this.m) >= 0) x.subTo(this.m,x);\n}\n\n//r = x^2 mod m; x != r\nfunction barrettSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\n//r = x*y mod m; x,y != r\nfunction barrettMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\n\nBarrett.prototype.convert = barrettConvert;\nBarrett.prototype.revert = barrettRevert;\nBarrett.prototype.reduce = barrettReduce;\nBarrett.prototype.mulTo = barrettMulTo;\nBarrett.prototype.sqrTo = barrettSqrTo;\n\n//(public) this^e % m (HAC 14.85)\nfunction bnModPow(e,m) {\nvar i = e.bitLength(), k, r = nbv(1), z;\nif(i <= 0) return r;\nelse if(i < 18) k = 1;\nelse if(i < 48) k = 3;\nelse if(i < 144) k = 4;\nelse if(i < 768) k = 5;\nelse k = 6;\nif(i < 8)\n z = new Classic(m);\nelse if(m.isEven())\n z = new Barrett(m);\nelse\n z = new Montgomery(m);\n\n// precomputation\nvar g = new Array(), n = 3, k1 = k-1, km = (1<<k)-1;\ng[1] = z.convert(this);\nif(k > 1) {\n var g2 = nbi();\n z.sqrTo(g[1],g2);\n while(n <= km) {\n   g[n] = nbi();\n   z.mulTo(g2,g[n-2],g[n]);\n   n += 2;\n }\n}\n\nvar j = e.t-1, w, is1 = true, r2 = nbi(), t;\ni = nbits(e.data[j])-1;\nwhile(j >= 0) {\n if(i >= k1) w = (e.data[j]>>(i-k1))&km;\n else {\n   w = (e.data[j]&((1<<(i+1))-1))<<(k1-i);\n   if(j > 0) w |= e.data[j-1]>>(this.DB+i-k1);\n }\n\n n = k;\n while((w&1) == 0) { w >>= 1; --n; }\n if((i -= n) < 0) { i += this.DB; --j; }\n if(is1) {  // ret == 1, don\'t bother squaring or multiplying it\n   g[w].copyTo(r);\n   is1 = false;\n }\n else {\n   while(n > 1) { z.sqrTo(r,r2); z.sqrTo(r2,r); n -= 2; }\n   if(n > 0) z.sqrTo(r,r2); else { t = r; r = r2; r2 = t; }\n   z.mulTo(r2,g[w],r);\n }\n\n while(j >= 0 && (e.data[j]&(1<<i)) == 0) {\n   z.sqrTo(r,r2); t = r; r = r2; r2 = t;\n   if(--i < 0) { i = this.DB-1; --j; }\n }\n}\nreturn z.revert(r);\n}\n\n//(public) gcd(this,a) (HAC 14.54)\nfunction bnGCD(a) {\nvar x = (this.s<0)?this.negate():this.clone();\nvar y = (a.s<0)?a.negate():a.clone();\nif(x.compareTo(y) < 0) { var t = x; x = y; y = t; }\nvar i = x.getLowestSetBit(), g = y.getLowestSetBit();\nif(g < 0) return x;\nif(i < g) g = i;\nif(g > 0) {\n x.rShiftTo(g,x);\n y.rShiftTo(g,y);\n}\nwhile(x.signum() > 0) {\n if((i = x.getLowestSetBit()) > 0) x.rShiftTo(i,x);\n if((i = y.getLowestSetBit()) > 0) y.rShiftTo(i,y);\n if(x.compareTo(y) >= 0) {\n   x.subTo(y,x);\n   x.rShiftTo(1,x);\n }\n else {\n   y.subTo(x,y);\n   y.rShiftTo(1,y);\n }\n}\nif(g > 0) y.lShiftTo(g,y);\nreturn y;\n}\n\n//(protected) this % n, n < 2^26\nfunction bnpModInt(n) {\nif(n <= 0) return 0;\nvar d = this.DV%n, r = (this.s<0)?n-1:0;\nif(this.t > 0)\n if(d == 0) r = this.data[0]%n;\n else for(var i = this.t-1; i >= 0; --i) r = (d*r+this.data[i])%n;\nreturn r;\n}\n\n//(public) 1/this % m (HAC 14.61)\nfunction bnModInverse(m) {\nvar ac = m.isEven();\nif((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;\nvar u = m.clone(), v = this.clone();\nvar a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);\nwhile(u.signum() != 0) {\n while(u.isEven()) {\n   u.rShiftTo(1,u);\n   if(ac) {\n     if(!a.isEven() || !b.isEven()) { a.addTo(this,a); b.subTo(m,b); }\n     a.rShiftTo(1,a);\n   }\n   else if(!b.isEven()) b.subTo(m,b);\n   b.rShiftTo(1,b);\n }\n while(v.isEven()) {\n   v.rShiftTo(1,v);\n   if(ac) {\n     if(!c.isEven() || !d.isEven()) { c.addTo(this,c); d.subTo(m,d); }\n     c.rShiftTo(1,c);\n   }\n   else if(!d.isEven()) d.subTo(m,d);\n   d.rShiftTo(1,d);\n }\n if(u.compareTo(v) >= 0) {\n   u.subTo(v,u);\n   if(ac) a.subTo(c,a);\n   b.subTo(d,b);\n }\n else {\n   v.subTo(u,v);\n   if(ac) c.subTo(a,c);\n   d.subTo(b,d);\n }\n}\nif(v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;\nif(d.compareTo(m) >= 0) return d.subtract(m);\nif(d.signum() < 0) d.addTo(m,d); else return d;\nif(d.signum() < 0) return d.add(m); else return d;\n}\n\nvar lowprimes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509];\nvar lplim = (1<<26)/lowprimes[lowprimes.length-1];\n\n//(public) test primality with certainty >= 1-.5^t\nfunction bnIsProbablePrime(t) {\nvar i, x = this.abs();\nif(x.t == 1 && x.data[0] <= lowprimes[lowprimes.length-1]) {\n for(i = 0; i < lowprimes.length; ++i)\n   if(x.data[0] == lowprimes[i]) return true;\n return false;\n}\nif(x.isEven()) return false;\ni = 1;\nwhile(i < lowprimes.length) {\n var m = lowprimes[i], j = i+1;\n while(j < lowprimes.length && m < lplim) m *= lowprimes[j++];\n m = x.modInt(m);\n while(i < j) if(m%lowprimes[i++] == 0) return false;\n}\nreturn x.millerRabin(t);\n}\n\n//(protected) true if probably prime (HAC 4.24, Miller-Rabin)\nfunction bnpMillerRabin(t) {\nvar n1 = this.subtract(BigInteger.ONE);\nvar k = n1.getLowestSetBit();\nif(k <= 0) return false;\nvar r = n1.shiftRight(k);\nvar prng = bnGetPrng();\nvar a;\nfor(var i = 0; i < t; ++i) {\n // select witness \'a\' at random from between 1 and n1\n do {\n   a = new BigInteger(this.bitLength(), prng);\n }\n while(a.compareTo(BigInteger.ONE) <= 0 || a.compareTo(n1) >= 0);\n var y = a.modPow(r,this);\n if(y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {\n   var j = 1;\n   while(j++ < k && y.compareTo(n1) != 0) {\n     y = y.modPowInt(2,this);\n     if(y.compareTo(BigInteger.ONE) == 0) return false;\n   }\n   if(y.compareTo(n1) != 0) return false;\n }\n}\nreturn true;\n}\n\n// get pseudo random number generator\nfunction bnGetPrng() {\n  // create prng with api that matches BigInteger secure random\n  return {\n    // x is an array to fill with bytes\n    nextBytes: function(x) {\n      for(var i = 0; i < x.length; ++i) {\n        x[i] = Math.floor(Math.random() * 0xFF);\n      }\n    }\n  };\n}\n\n//protected\nBigInteger.prototype.chunkSize = bnpChunkSize;\nBigInteger.prototype.toRadix = bnpToRadix;\nBigInteger.prototype.fromRadix = bnpFromRadix;\nBigInteger.prototype.fromNumber = bnpFromNumber;\nBigInteger.prototype.bitwiseTo = bnpBitwiseTo;\nBigInteger.prototype.changeBit = bnpChangeBit;\nBigInteger.prototype.addTo = bnpAddTo;\nBigInteger.prototype.dMultiply = bnpDMultiply;\nBigInteger.prototype.dAddOffset = bnpDAddOffset;\nBigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;\nBigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;\nBigInteger.prototype.modInt = bnpModInt;\nBigInteger.prototype.millerRabin = bnpMillerRabin;\n\n//public\nBigInteger.prototype.clone = bnClone;\nBigInteger.prototype.intValue = bnIntValue;\nBigInteger.prototype.byteValue = bnByteValue;\nBigInteger.prototype.shortValue = bnShortValue;\nBigInteger.prototype.signum = bnSigNum;\nBigInteger.prototype.toByteArray = bnToByteArray;\nBigInteger.prototype.equals = bnEquals;\nBigInteger.prototype.min = bnMin;\nBigInteger.prototype.max = bnMax;\nBigInteger.prototype.and = bnAnd;\nBigInteger.prototype.or = bnOr;\nBigInteger.prototype.xor = bnXor;\nBigInteger.prototype.andNot = bnAndNot;\nBigInteger.prototype.not = bnNot;\nBigInteger.prototype.shiftLeft = bnShiftLeft;\nBigInteger.prototype.shiftRight = bnShiftRight;\nBigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;\nBigInteger.prototype.bitCount = bnBitCount;\nBigInteger.prototype.testBit = bnTestBit;\nBigInteger.prototype.setBit = bnSetBit;\nBigInteger.prototype.clearBit = bnClearBit;\nBigInteger.prototype.flipBit = bnFlipBit;\nBigInteger.prototype.add = bnAdd;\nBigInteger.prototype.subtract = bnSubtract;\nBigInteger.prototype.multiply = bnMultiply;\nBigInteger.prototype.divide = bnDivide;\nBigInteger.prototype.remainder = bnRemainder;\nBigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;\nBigInteger.prototype.modPow = bnModPow;\nBigInteger.prototype.modInverse = bnModInverse;\nBigInteger.prototype.pow = bnPow;\nBigInteger.prototype.gcd = bnGCD;\nBigInteger.prototype.isProbablePrime = bnIsProbablePrime;\n\n//BigInteger interfaces not implemented in jsbn:\n\n//BigInteger(int signum, byte[] magnitude)\n//double doubleValue()\n//float floatValue()\n//int hashCode()\n//long longValue()\n//static BigInteger valueOf(long val)\n\nvar jsbn = {};\njsbn.BigInteger = BigInteger;\n\nmodule.exports = jsbn\n\n},{}]},{},[1])\n;'],{type:"text/javascript"})));var o=u,l=p();for(var s=0;s<u;++s)i[s].addEventListener("message",v);var d=!1}function v(e,i){n.q=i;if(n.p.compareTo(n.q)<0){var o=n.p;n.p=n.q,n.q=o}n.p1=n.p.subtract(t.ONE),n.q1=n.q.subtract(t.ONE),n.phi=n.p1.multiply(n.q1);if(n.phi.gcd(n.e).compareTo(t.ONE)!==0){n.p=n.q=null,p();return}n.n=n.p.multiply(n.q);if(n.n.bitLength()!==n.bits){n.q=null,d(n.qBits,v);return}var u=n.e.modInverse(n.phi);n.keys={privateKey:r.rsa.setPrivateKey(n.n,n.e,u,n.p,n.q,u.mod(n.p1),u.mod(n.q1),n.q.modInverse(n.p)),publicKey:r.rsa.setPublicKey(n.n,n.e)},s(null,n.keys)}typeof i=="function"&&(s=i,i={});if(typeof Worker=="undefined"){function o(){if(r.rsa.stepKeyPairGenerationState(n,10))return s(null,n.keys);e.util.setImmediate(o)}return o()}var u=i.workers||2,a=i.workLoad||100,f=a*30/8,l=i.workerScript||"forge/prime.worker.js",c=new t(null);c.fromInt(30);var h=function(e,t){return e|t};p()}function d(t){var n=t.toString(16);return n[0]>="8"&&(n="00"+n),e.util.hexToBytes(n)}function v(e){return e<=100?27:e<=150?18:e<=200?15:e<=250?12:e<=300?9:e<=350?8:e<=400?7:e<=500?6:e<=600?5:e<=800?4:e<=1250?3:2}if(typeof t=="undefined")var t=e.jsbn.BigInteger;var n=e.asn1;e.pki=e.pki||{},e.pki.rsa=e.rsa=e.rsa||{};var r=e.pki,i=[6,4,2,4,2,4,6,2],s={name:"PrivateKeyInfo",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,value:[{name:"PrivateKeyInfo.version",tagClass:n.Class.UNIVERSAL,type:n.Type.INTEGER,constructed:!1,capture:"privateKeyVersion"},{name:"PrivateKeyInfo.privateKeyAlgorithm",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,value:[{name:"AlgorithmIdentifier.algorithm",tagClass:n.Class.UNIVERSAL,type:n.Type.OID,constructed:!1,capture:"privateKeyOid"}]},{name:"PrivateKeyInfo",tagClass:n.Class.UNIVERSAL,type:n.Type.OCTETSTRING,constructed:!1,capture:"privateKey"}]},o={name:"RSAPrivateKey",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,value:[{name:"RSAPrivateKey.version",tagClass:n.Class.UNIVERSAL,type:n.Type.INTEGER,constructed:!1,capture:"privateKeyVersion"},{name:"RSAPrivateKey.modulus",tagClass:n.Class.UNIVERSAL,type:n.Type.INTEGER,constructed:!1,capture:"privateKeyModulus"},{name:"RSAPrivateKey.publicExponent",tagClass:n.Class.UNIVERSAL,type:n.Type.INTEGER,constructed:!1,capture:"privateKeyPublicExponent"},{name:"RSAPrivateKey.privateExponent",tagClass:n.Class.UNIVERSAL,type:n.Type.INTEGER,constructed:!1,capture:"privateKeyPrivateExponent"},{name:"RSAPrivateKey.prime1",tagClass:n.Class.UNIVERSAL,type:n.Type.INTEGER,constructed:!1,capture:"privateKeyPrime1"},{name:"RSAPrivateKey.prime2",tagClass:n.Class.UNIVERSAL,type:n.Type.INTEGER,constructed:!1,capture:"privateKeyPrime2"},{name:"RSAPrivateKey.exponent1",tagClass:n.Class.UNIVERSAL,type:n.Type.INTEGER,constructed:!1,capture:"privateKeyExponent1"},{name:"RSAPrivateKey.exponent2",tagClass:n.Class.UNIVERSAL,type:n.Type.INTEGER,constructed:!1,capture:"privateKeyExponent2"},{name:"RSAPrivateKey.coefficient",tagClass:n.Class.UNIVERSAL,type:n.Type.INTEGER,constructed:!1,capture:"privateKeyCoefficient"}]},u={name:"RSAPublicKey",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,value:[{name:"RSAPublicKey.modulus",tagClass:n.Class.UNIVERSAL,type:n.Type.INTEGER,constructed:!1,capture:"publicKeyModulus"},{name:"RSAPublicKey.exponent",tagClass:n.Class.UNIVERSAL,type:n.Type.INTEGER,constructed:!1,capture:"publicKeyExponent"}]},a=e.pki.rsa.publicKeyValidator={name:"SubjectPublicKeyInfo",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,captureAsn1:"subjectPublicKeyInfo",value:[{name:"SubjectPublicKeyInfo.AlgorithmIdentifier",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,value:[{name:"AlgorithmIdentifier.algorithm",tagClass:n.Class.UNIVERSAL,type:n.Type.OID,constructed:!1,capture:"publicKeyOid"}]},{name:"SubjectPublicKeyInfo.subjectPublicKey",tagClass:n.Class.UNIVERSAL,type:n.Type.BITSTRING,constructed:!1,value:[{name:"SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,optional:!0,captureAsn1:"rsaPublicKey"}]}]},f=function(e){var t;if(e.algorithm in r.oids){t=r.oids[e.algorithm];var i=n.oidToDer(t).getBytes(),s=n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[]),o=n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[]);o.value.push(n.create(n.Class.UNIVERSAL,n.Type.OID,!1,i)),o.value.push(n.create(n.Class.UNIVERSAL,n.Type.NULL,!1,""));var u=n.create(n.Class.UNIVERSAL,n.Type.OCTETSTRING,!1,e.digest().getBytes());return s.value.push(o),s.value.push(u),n.toDer(s).getBytes()}throw{message:"Unknown message digest algorithm.",algorithm:e.algorithm}},l=function(e,n,r){var i;if(r)i=e.modPow(n.e,n.n);else if(!n.p||!n.q)i=e.modPow(n.d,n.n);else{n.dP||(n.dP=n.d.mod(n.p.subtract(t.ONE))),n.dQ||(n.dQ=n.d.mod(n.q.subtract(t.ONE))),n.qInv||(n.qInv=n.q.modInverse(n.p));var s=e.mod(n.p).modPow(n.dP,n.p),o=e.mod(n.q).modPow(n.dQ,n.q);while(s.compareTo(o)<0)s=s.add(n.p);i=s.subtract(o).multiply(n.qInv).mod(n.p).multiply(n.q).add(o)}return i};r.rsa.encrypt=function(n,r,i){var s=i,o,u=Math.ceil(r.n.bitLength()/8);i!==!1&&i!==!0?(s=i===2,o=c(n,r,i)):(o=e.util.createBuffer(),o.putBytes(n));var a=new t(o.toHex(),16),f=l(a,r,s),h=f.toString(16),p=e.util.createBuffer(),d=u-Math.ceil(h.length/2);while(d>0)p.putByte(0),--d;return p.putBytes(e.util.hexToBytes(h)),p.getBytes()},r.rsa.decrypt=function(n,r,i,s){var o=Math.ceil(r.n.bitLength()/8);if(n.length!==o)throw{message:"Encrypted message length is invalid.",length:n.length,expected:o};var u=new t(e.util.createBuffer(n).toHex(),16);if(u.compareTo(r.n)>=0)throw{message:"Encrypted message is invalid."};var a=l(u,r,i),f=a.toString(16),c=e.util.createBuffer(),p=o-Math.ceil(f.length/2);while(p>0)c.putByte(0),--p;return c.putBytes(e.util.hexToBytes(f)),s!==!1?h(c.getBytes(),r,i):c.getBytes()},r.rsa.createKeyPairGenerationState=function(n,r){typeof n=="string"&&(n=parseInt(n,10)),n=n||2048;var i={nextBytes:function(t){var n=e.random.getBytes(t.length);for(var r=0;r<t.length;++r)t[r]=n.charCodeAt(r)}},s={state:0,bits:n,rng:i,eInt:r||65537,e:new t(null),p:null,q:null,qBits:n>>1,pBits:n-(n>>1),pqState:0,num:null,keys:null};return s.e.fromInt(s.eInt),s},r.rsa.stepKeyPairGenerationState=function(e,n){var s=new t(null);s.fromInt(30);var o=0,u=function(e,t){return e|t},a=+(new Date),f,l=0;while(e.keys===null&&(n<=0||l<n)){if(e.state===0){var c=e.p===null?e.pBits:e.qBits,h=c-1;e.pqState===0?(e.num=new t(c,e.rng),e.num.testBit(h)||e.num.bitwiseTo(t.ONE.shiftLeft(h),u,e.num),e.num.dAddOffset(31-e.num.mod(s).byteValue(),0),o=0,++e.pqState):e.pqState===1?e.num.bitLength()>c?e.pqState=0:e.num.isProbablePrime(v(e.num.bitLength()))?++e.pqState:e.num.dAddOffset(i[o++%8],0):e.pqState===2?e.pqState=e.num.subtract(t.ONE).gcd(e.e).compareTo(t.ONE)===0?3:0:e.pqState===3&&(e.pqState=0,e.p===null?e.p=e.num:e.q=e.num,e.p!==null&&e.q!==null&&++e.state,e.num=null)}else if(e.state===1)e.p.compareTo(e.q)<0&&(e.num=e.p,e.p=e.q,e.q=e.num),++e.state;else if(e.state===2)e.p1=e.p.subtract(t.ONE),e.q1=e.q.subtract(t.ONE),e.phi=e.p1.multiply(e.q1),++e.state;else if(e.state===3)e.phi.gcd(e.e).compareTo(t.ONE)===0?++e.state:(e.p=null,e.q=null,e.state=0);else if(e.state===4)e.n=e.p.multiply(e.q),e.n.bitLength()===e.bits?++e.state:(e.q=null,e.state=0);else if(e.state===5){var p=e.e.modInverse(e.phi);e.keys={privateKey:r.rsa.setPrivateKey(e.n,e.e,p,e.p,e.q,p.mod(e.p1),p.mod(e.q1),e.q.modInverse(e.p)),publicKey:r.rsa.setPublicKey(e.n,e.e)}}f=+(new Date),l+=f-a,a=f}return e.keys!==null},r.rsa.generateKeyPair=function(e,t,n,i){arguments.length===1?typeof e=="object"?(n=e,e=undefined):typeof e=="function"&&(i=e,e=undefined):arguments.length===2?(typeof e=="number"?typeof t=="function"?i=t:n=t:(n=e,i=t,e=undefined),t=undefined):arguments.length===3&&(typeof t=="number"?typeof n=="function"&&(i=n,n=undefined):(i=n,n=t,t=undefined)),n=n||{},e===undefined&&(e=n.bits||2048),t===undefined&&(t=n.e||65537);var s=r.rsa.createKeyPairGenerationState(e,t);if(!i)return r.rsa.stepKeyPairGenerationState(s,0),s.keys;p(s,n,i)},r.setRsaPublicKey=r.rsa.setPublicKey=function(t,i){var s={n:t,e:i};return s.encrypt=function(t,n,i){typeof n=="string"?n=n.toUpperCase():n===undefined&&(n="RSAES-PKCS1-V1_5");if(n==="RSAES-PKCS1-V1_5")n={encode:function(e,t,n){return c(e,t,2).getBytes()}};else if(n==="RSA-OAEP"||n==="RSAES-OAEP")n={encode:function(t,n){return e.pkcs1.encode_rsa_oaep(n,t,i)}};else{if(["RAW","NONE","NULL",null].indexOf(n)===-1)throw{message:'Unsupported encryption scheme: "'+n+'".'};n={encode:function(e){return e}}}var o=n.encode(t,s,!0);return r.rsa.encrypt(o,s,!0)},s.verify=function(e,t,i){typeof i=="string"?i=i.toUpperCase():i===undefined&&(i="RSASSA-PKCS1-V1_5");if(i==="RSASSA-PKCS1-V1_5")i={verify:function(e,t){t=h(t,s,!0);var r=n.fromDer(t);return e===r.value[1].value}};else if(i==="NONE"||i==="NULL"||i===null)i={verify:function(e,t){return t=h(t,s,!0),e===t}};var o=r.rsa.decrypt(t,s,!0,!1);return i.verify(e,o,s.n.bitLength())},s},r.setRsaPrivateKey=r.rsa.setPrivateKey=function(t,n,i,s,o,u,a,l){var c={n:t,e:n,d:i,p:s,q:o,dP:u,dQ:a,qInv:l};return c.decrypt=function(t,n,i){typeof n=="string"?n=n.toUpperCase():n===undefined&&(n="RSAES-PKCS1-V1_5");var s=r.rsa.decrypt(t,c,!1,!1);if(n==="RSAES-PKCS1-V1_5")n={decode:h};else if(n==="RSA-OAEP"||n==="RSAES-OAEP")n={decode:function(t,n){return e.pkcs1.decode_rsa_oaep(n,t,i)}};else{if(["RAW","NONE","NULL",null].indexOf(n)===-1)throw{message:'Unsupported encryption scheme: "'+n+'".'};n={decode:function(e){return e}}}return n.decode(s,c,!1)},c.sign=function(e,t){var n=!1;typeof t=="string"&&(t=t.toUpperCase());if(t===undefined||t==="RSASSA-PKCS1-V1_5")t={encode:f},n=1;else if(t==="NONE"||t==="NULL"||t===null)t={encode:function(){return e}},n=1;var i=t.encode(e,c.n.bitLength());return r.rsa.encrypt(i,c,n)},c},r.wrapRsaPrivateKey=function(e){return n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.INTEGER,!1,n.integerToDer(0).getBytes()),n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.OID,!1,n.oidToDer(r.oids.rsaEncryption).getBytes()),n.create(n.Class.UNIVERSAL,n.Type.NULL,!1,"")]),n.create(n.Class.UNIVERSAL,n.Type.OCTETSTRING,!1,n.toDer(e).getBytes())])},r.wrapRsaPrivateKey=function(e){return n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.INTEGER,!1,n.integerToDer(0).getBytes()),n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.OID,!1,n.oidToDer(r.oids.rsaEncryption).getBytes()),n.create(n.Class.UNIVERSAL,n.Type.NULL,!1,"")]),n.create(n.Class.UNIVERSAL,n.Type.OCTETSTRING,!1,n.toDer(e).getBytes())])},r.privateKeyFromAsn1=function(i){var u={},a=[];n.validate(i,s,u,a)&&(i=n.fromDer(e.util.createBuffer(u.privateKey))),u={},a=[];if(!n.validate(i,o,u,a))throw{message:"Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.",errors:a};var f,l,c,h,p,d,v,m;return f=e.util.createBuffer(u.privateKeyModulus).toHex(),l=e.util.createBuffer(u.privateKeyPublicExponent).toHex(),c=e.util.createBuffer(u.privateKeyPrivateExponent).toHex(),h=e.util.createBuffer(u.privateKeyPrime1).toHex(),p=e.util.createBuffer(u.privateKeyPrime2).toHex(),d=e.util.createBuffer(u.privateKeyExponent1).toHex(),v=e.util.createBuffer(u.privateKeyExponent2).toHex(),m=e.util.createBuffer(u.privateKeyCoefficient).toHex(),r.setRsaPrivateKey(new t(f,16),new t(l,16),new t(c,16),new t(h,16),new t(p,16),new t(d,16),new t(v,16),new t(m,16))},r.privateKeyToAsn1=r.privateKeyToRSAPrivateKey=function(e){return n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.INTEGER,!1,n.integerToDer(0).getBytes()),n.create(n.Class.UNIVERSAL,n.Type.INTEGER,!1,d(e.n)),n.create(n.Class.UNIVERSAL,n.Type.INTEGER,!1,d(e.e)),n.create(n.Class.UNIVERSAL,n.Type.INTEGER,!1,d(e.d)),n.create(n.Class.UNIVERSAL,n.Type.INTEGER,!1,d(e.p)),n.create(n.Class.UNIVERSAL,n.Type.INTEGER,!1,d(e.q)),n.create(n.Class.UNIVERSAL,n.Type.INTEGER,!1,d(e.dP)),n.create(n.Class.UNIVERSAL,n.Type.INTEGER,!1,d(e.dQ)),n.create(n.Class.UNIVERSAL,n.Type.INTEGER,!1,d(e.qInv))])},r.publicKeyFromAsn1=function(i){var s={},o=[];if(n.validate(i,a,s,o)){var f=n.derToOid(s.publicKeyOid);if(f!==r.oids.rsaEncryption)throw{message:"Cannot read public key. Unknown OID.",oid:f};i=s.rsaPublicKey}o=[];if(!n.validate(i,u,s,o))throw{message:"Cannot read public key. ASN.1 object does not contain an RSAPublicKey.",errors:o};var l=e.util.createBuffer(s.publicKeyModulus).toHex(),c=e.util.createBuffer(s.publicKeyExponent).toHex();return r.setRsaPublicKey(new t(l,16),new t(c,16))},r.publicKeyToAsn1=r.publicKeyToSubjectPublicKeyInfo=function(e){return n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.OID,!1,n.oidToDer(r.oids.rsaEncryption).getBytes()),n.create(n.Class.UNIVERSAL,n.Type.NULL,!1,"")]),n.create(n.Class.UNIVERSAL,n.Type.BITSTRING,!1,[r.publicKeyToRSAPublicKey(e)])])},r.publicKeyToRSAPublicKey=function(e){return n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.INTEGER,!1,d(e.n)),n.create(n.Class.UNIVERSAL,n.Type.INTEGER,!1,d(e.e))])}}var r="rsa";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/rsa",["require","module","./asn1","./oids","./random","./util","./jsbn","./pkcs1"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){function a(e,t,n){var r=[f(e+t)];for(var i=16,s=1;i<n;++s,i+=16)r.push(f(r[s-1]+e+t));return r.join("").substr(0,n)}function f(t){return e.md.md5.create().update(t).digest().getBytes()}if(typeof t=="undefined")var t=e.jsbn.BigInteger;var n=e.asn1,r=e.pki=e.pki||{};r.pbe=e.pbe=e.pbe||{};var i=r.oids,s={name:"EncryptedPrivateKeyInfo",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,value:[{name:"EncryptedPrivateKeyInfo.encryptionAlgorithm",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,value:[{name:"AlgorithmIdentifier.algorithm",tagClass:n.Class.UNIVERSAL,type:n.Type.OID,constructed:!1,capture:"encryptionOid"},{name:"AlgorithmIdentifier.parameters",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,captureAsn1:"encryptionParams"}]},{name:"EncryptedPrivateKeyInfo.encryptedData",tagClass:n.Class.UNIVERSAL,type:n.Type.OCTETSTRING,constructed:!1,capture:"encryptedData"}]},o={name:"PBES2Algorithms",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,value:[{name:"PBES2Algorithms.keyDerivationFunc",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,value:[{name:"PBES2Algorithms.keyDerivationFunc.oid",tagClass:n.Class.UNIVERSAL,type:n.Type.OID,constructed:!1,capture:"kdfOid"},{name:"PBES2Algorithms.params",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,value:[{name:"PBES2Algorithms.params.salt",tagClass:n.Class.UNIVERSAL,type:n.Type.OCTETSTRING,constructed:!1,capture:"kdfSalt"},{name:"PBES2Algorithms.params.iterationCount",tagClass:n.Class.UNIVERSAL,type:n.Type.INTEGER,onstructed:!0,capture:"kdfIterationCount"}]}]},{name:"PBES2Algorithms.encryptionScheme",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,value:[{name:"PBES2Algorithms.encryptionScheme.oid",tagClass:n.Class.UNIVERSAL,type:n.Type.OID,constructed:!1,capture:"encOid"},{name:"PBES2Algorithms.encryptionScheme.iv",tagClass:n.Class.UNIVERSAL,type:n.Type.OCTETSTRING,constructed:!1,capture:"encIv"}]}]},u={name:"pkcs-12PbeParams",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,value:[{name:"pkcs-12PbeParams.salt",tagClass:n.Class.UNIVERSAL,type:n.Type.OCTETSTRING,constructed:!1,capture:"salt"},{name:"pkcs-12PbeParams.iterations",tagClass:n.Class.UNIVERSAL,type:n.Type.INTEGER,constructed:!1,capture:"iterations"}]};r.encryptPrivateKeyInfo=function(t,s,o){o=o||{},o.saltSize=o.saltSize||8,o.count=o.count||2048,o.algorithm=o.algorithm||"aes128";var u=e.random.getBytes(o.saltSize),a=o.count,f=n.integerToDer(a),l,c,h;if(o.algorithm.indexOf("aes")===0){var p;if(o.algorithm==="aes128")l=16,p=i["aes128-CBC"];else if(o.algorithm==="aes192")l=24,p=i["aes192-CBC"];else{if(o.algorithm!=="aes256")throw{message:"Cannot encrypt private key. Unknown encryption algorithm.",algorithm:o.algorithm};l=32,p=i["aes256-CBC"]}var d=e.pkcs5.pbkdf2(s,u,a,l),v=e.random.getBytes(16),m=e.aes.createEncryptionCipher(d);m.start(v),m.update(n.toDer(t)),m.finish(),h=m.output.getBytes(),c=n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.OID,!1,n.oidToDer(i.pkcs5PBES2).getBytes()),n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.OID,!1,n.oidToDer(i.pkcs5PBKDF2).getBytes()),n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.OCTETSTRING,!1,u),n.create(n.Class.UNIVERSAL,n.Type.INTEGER,!1,f.getBytes())])]),n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.OID,!1,n.oidToDer(p).getBytes()),n.create(n.Class.UNIVERSAL,n.Type.OCTETSTRING,!1,v)])])])}else{if(o.algorithm!=="3des")throw{message:"Cannot encrypt private key. Unknown encryption algorithm.",algorithm:o.algorithm};l=24;var g=new e.util.ByteBuffer(u),d=r.pbe.generatePkcs12Key(s,g,1,a,l),v=r.pbe.generatePkcs12Key(s,g,2,a,l),m=e.des.createEncryptionCipher(d);m.start(v),m.update(n.toDer(t)),m.finish(),h=m.output.getBytes(),c=n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.OID,!1,n.oidToDer(i["pbeWithSHAAnd3-KeyTripleDES-CBC"]).getBytes()),n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.OCTETSTRING,!1,u),n.create(n.Class.UNIVERSAL,n.Type.INTEGER,!1,f.getBytes())])])}var y=n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[c,n.create(n.Class.UNIVERSAL,n.Type.OCTETSTRING,!1,h)]);return y},r.decryptPrivateKeyInfo=function(t,i){var o=null,u={},a=[];if(!n.validate(t,s,u,a))throw{message:"Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo.",errors:a};var f=n.derToOid(u.encryptionOid),l=r.pbe.getCipher(f,u.encryptionParams,i),c=e.util.createBuffer(u.encryptedData);return l.update(c),l.finish()&&(o=n.fromDer(l.output)),o},r.encryptedPrivateKeyToPem=function(t,r){var i={type:"ENCRYPTED PRIVATE KEY",body:n.toDer(t).getBytes()};return e.pem.encode(i,{maxline:r})},r.encryptedPrivateKeyFromPem=function(t){var r=e.pem.decode(t)[0];if(r.type!=="ENCRYPTED PRIVATE KEY")throw{message:'Could not convert encrypted private key from PEM; PEM header type is "ENCRYPTED PRIVATE KEY".',headerType:r.type};if(r.procType&&r.procType.type==="ENCRYPTED")throw{message:"Could not convert encrypted private key from PEM; PEM is encrypted."};return n.fromDer(r.body)},r.encryptRsaPrivateKey=function(t,i,s){s=s||{};if(!s.legacy){var o=r.wrapRsaPrivateKey(r.privateKeyToAsn1(t));return o=r.encryptPrivateKeyInfo(o,i,s),r.encryptedPrivateKeyToPem(o)}var u,f,l,c;switch(s.algorithm){case"aes128":u="AES-128-CBC",l=16,f=e.random.getBytes(16),c=e.aes.createEncryptionCipher;break;case"aes192":u="AES-192-CBC",l=24,f=e.random.getBytes(16),c=e.aes.createEncryptionCipher;break;case"aes256":u="AES-256-CBC",l=32,f=e.random.getBytes(16),c=e.aes.createEncryptionCipher;break;case"3des":u="DES-EDE3-CBC",l=24,f=e.random.getBytes(8),c=e.des.createEncryptionCipher;break;default:throw{message:'Could not encrypt RSA private key; unsupported encryption algorithm "'+s.algorithm+'".',algorithm:s.algorithm}}var h=a(i,f.substr(0,8),l),p=c(h);p.start(f),p.update(n.toDer(r.privateKeyToAsn1(t))),p.finish();var d={type:"RSA PRIVATE KEY",procType:{version:"4",type:"ENCRYPTED"},dekInfo:{algorithm:u,parameters:e.util.bytesToHex(f).toUpperCase()},body:p.output.getBytes()};return e.pem.encode(d)},r.decryptRsaPrivateKey=function(t,i){var s=null,o=e.pem.decode(t)[0];if(o.type!=="ENCRYPTED PRIVATE KEY"&&o.type!=="PRIVATE KEY"&&o.type!=="RSA PRIVATE KEY")throw{message:'Could not convert private key from PEM; PEM header type is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".',headerType:o.type};if(o.procType&&o.procType.type==="ENCRYPTED"){var u,f;switch(o.dekInfo.algorithm){case"DES-EDE3-CBC":u=24,f=e.des.createDecryptionCipher;break;case"AES-128-CBC":u=16,f=e.aes.createDecryptionCipher;break;case"AES-192-CBC":u=24,f=e.aes.createDecryptionCipher;break;case"AES-256-CBC":u=32,f=e.aes.createDecryptionCipher;break;case"RC2-40-CBC":u=5,f=function(t){return e.rc2.createDecryptionCipher(t,40)};break;case"RC2-64-CBC":u=8,f=function(t){return e.rc2.createDecryptionCipher(t,64)};break;case"RC2-128-CBC":u=16,f=function(t){return e.rc2.createDecryptionCipher(t,128)};break;default:throw{message:'Could not decrypt private key; unsupported encryption algorithm "'+o.dekInfo.algorithm+'".',algorithm:o.dekInfo.algorithm}}var l=e.util.hexToBytes(o.dekInfo.parameters),c=a(i,l.substr(0,8),u),h=f(c);h.start(l),h.update(e.util.createBuffer(o.body));if(!h.finish())return s;s=h.output.getBytes()}else s=o.body;return o.type==="ENCRYPTED PRIVATE KEY"?s=r.decryptPrivateKeyInfo(n.fromDer(s),i):s=n.fromDer(s),s!==null&&(s=r.privateKeyFromAsn1(s)),s},r.pbe.generatePkcs12Key=function(t,n,r,i,s,o){var u,a;if(typeof o=="undefined"||o===null)o=e.md.sha1.create();var f=o.digestLength,l=o.blockLength,c=new e.util.ByteBuffer,h=new e.util.ByteBuffer;for(a=0;a<t.length;a++)h.putInt16(t.charCodeAt(a));h.putInt16(0);var p=h.length(),d=n.length(),v=new e.util.ByteBuffer;v.fillWithByte(r,l);var m=l*Math.ceil(d/l),g=new e.util.ByteBuffer;for(a=0;a<m;a++)g.putByte(n.at(a%d));var y=l*Math.ceil(p/l),b=new e.util.ByteBuffer;for(a=0;a<y;a++)b.putByte(h.at(a%p));var w=g;w.putBuffer(b);var E=Math.ceil(s/f);for(var S=1;S<=E;S++){var x=new e.util.ByteBuffer;x.putBytes(v.bytes()),x.putBytes(w.bytes());for(var T=0;T<i;T++)o.start(),o.update(x.getBytes()),x=o.digest();var N=new e.util.ByteBuffer;for(a=0;a<l;a++)N.putByte(x.at(a%f));var C=Math.ceil(d/l)+Math.ceil(p/l),k=new e.util.ByteBuffer;for(u=0;u<C;u++){var L=new e.util.ByteBuffer(w.getBytes(l)),A=511;for(a=N.length()-1;a>=0;a--)A>>=8,A+=N.at(a)+L.at(a),L.setAt(a,A&255);k.putBuffer(L)}w=k,c.putBuffer(x)}return c.truncate(c.length()-s),c},r.pbe.getCipher=function(e,t,n){switch(e){case r.oids.pkcs5PBES2:return r.pbe.getCipherForPBES2(e,t,n);case r.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:case r.oids["pbewithSHAAnd40BitRC2-CBC"]:return r.pbe.getCipherForPKCS12PBE(e,t,n);default:throw{message:"Cannot read encrypted PBE data block. Unsupported OID.",oid:e,supportedOids:["pkcs5PBES2","pbeWithSHAAnd3-KeyTripleDES-CBC","pbewithSHAAnd40BitRC2-CBC"]}}},r.pbe.getCipherForPBES2=function(t,i,s){var u={},a=[];if(!n.validate(i,o,u,a))throw{message:"Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.",errors:a};t=n.derToOid(u.kdfOid);if(t!==r.oids.pkcs5PBKDF2)throw{message:"Cannot read encrypted private key. Unsupported key derivation function OID.",oid:t,supportedOids:["pkcs5PBKDF2"]};t=n.derToOid(u.encOid);if(t!==r.oids["aes128-CBC"]&&t!==r.oids["aes192-CBC"]&&t!==r.oids["aes256-CBC"])throw{message:"Cannot read encrypted private key. Unsupported encryption scheme OID.",oid:t,supportedOids:["aes128-CBC","aes192-CBC","aes256-CBC"]};var f=u.kdfSalt,l=e.util.createBuffer(u.kdfIterationCount);l=l.getInt(l.length()<<3);var c;t===r.oids["aes128-CBC"]?c=16:t===r.oids["aes192-CBC"]?c=24:t===r.oids["aes256-CBC"]&&(c=32);var h=e.pkcs5.pbkdf2(s,f,l,c),p=u.encIv,d=e.aes.createDecryptionCipher(h);return d.start(p),d},r.pbe.getCipherForPKCS12PBE=function(t,i,s){var o={},a=[];if(!n.validate(i,u,o,a))throw{message:"Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.",errors:a};var f=e.util.createBuffer(o.salt),l=e.util.createBuffer(o.iterations);l=l.getInt(l.length()<<3);var c,h,p;switch(t){case r.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:c=24,h=8,p=e.des.startDecrypting;break;case r.oids["pbewithSHAAnd40BitRC2-CBC"]:c=5,h=8,p=function(t,n){var r=e.rc2.createDecryptionCipher(t,40);return r.start(n,null),r};break;default:throw{message:"Cannot read PKCS #12 PBE data block. Unsupported OID.",oid:t}}var d=r.pbe.generatePkcs12Key(s,f,1,l,c),v=r.pbe.generatePkcs12Key(s,f,2,l,h);return p(d,v)}}var r="pbe";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/pbe",["require","module","./aes","./asn1","./des","./md","./oids","./pem","./pbkdf2","./random","./rc2","./rsa","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){var t=e.asn1,n=e.pkcs7asn1=e.pkcs7asn1||{};e.pkcs7=e.pkcs7||{},e.pkcs7.asn1=n;var r={name:"ContentInfo",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"ContentInfo.ContentType",tagClass:t.Class.UNIVERSAL,type:t.Type.OID,constructed:!1,capture:"contentType"},{name:"ContentInfo.content",tagClass:t.Class.CONTEXT_SPECIFIC,type:0,constructed:!0,optional:!0,captureAsn1:"content"}]};n.contentInfoValidator=r;var i={name:"EncryptedContentInfo",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"EncryptedContentInfo.contentType",tagClass:t.Class.UNIVERSAL,type:t.Type.OID,constructed:!1,capture:"contentType"},{name:"EncryptedContentInfo.contentEncryptionAlgorithm",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"EncryptedContentInfo.contentEncryptionAlgorithm.algorithm",tagClass:t.Class.UNIVERSAL,type:t.Type.OID,constructed:!1,capture:"encAlgorithm"},{name:"EncryptedContentInfo.contentEncryptionAlgorithm.parameter",tagClass:t.Class.UNIVERSAL,captureAsn1:"encParameter"}]},{name:"EncryptedContentInfo.encryptedContent",tagClass:t.Class.CONTEXT_SPECIFIC,type:0,capture:"encryptedContent"}]};n.envelopedDataValidator={name:"EnvelopedData",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"EnvelopedData.Version",tagClass:t.Class.UNIVERSAL,type:t.Type.INTEGER,constructed:!1,capture:"version"},{name:"EnvelopedData.RecipientInfos",tagClass:t.Class.UNIVERSAL,type:t.Type.SET,constructed:!0,captureAsn1:"recipientInfos"}].concat(i)},n.encryptedDataValidator={name:"EncryptedData",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"EncryptedData.Version",tagClass:t.Class.UNIVERSAL,type:t.Type.INTEGER,constructed:!1,capture:"version"}].concat(i)};var s={name:"SignerInfo",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"SignerInfo.Version",tagClass:t.Class.UNIVERSAL,type:t.Type.INTEGER,constructed:!1},{name:"SignerInfo.IssuerAndSerialNumber",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0},{name:"SignerInfo.DigestAlgorithm",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0},{name:"SignerInfo.AuthenticatedAttributes",tagClass:t.Class.CONTEXT_SPECIFIC,type:0,constructed:!0,optional:!0,capture:"authenticatedAttributes"},{name:"SignerInfo.DigestEncryptionAlgorithm",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0},{name:"SignerInfo.EncryptedDigest",tagClass:t.Class.UNIVERSAL,type:t.Type.OCTETSTRING,constructed:!1,capture:"signature"},{name:"SignerInfo.UnauthenticatedAttributes",tagClass:t.Class.CONTEXT_SPECIFIC,type:1,constructed:!0,optional:!0}]};n.signedDataValidator={name:"SignedData",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"SignedData.Version",tagClass:t.Class.UNIVERSAL,type:t.Type.INTEGER,constructed:!1,capture:"version"},{name:"SignedData.DigestAlgorithms",tagClass:t.Class.UNIVERSAL,type:t.Type.SET,constructed:!0,captureAsn1:"digestAlgorithms"},r,{name:"SignedData.Certificates",tagClass:t.Class.CONTEXT_SPECIFIC,type:0,optional:!0,captureAsn1:"certificates"},{name:"SignedData.CertificateRevocationLists",tagClass:t.Class.CONTEXT_SPECIFIC,type:1,optional:!0,captureAsn1:"crls"},{name:"SignedData.SignerInfos",tagClass:t.Class.UNIVERSAL,type:t.Type.SET,capture:"signerInfos",optional:!0,value:[s]}]},n.recipientInfoValidator={name:"RecipientInfo",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"RecipientInfo.version",tagClass:t.Class.UNIVERSAL,type:t.Type.INTEGER,constructed:!1,capture:"version"},{name:"RecipientInfo.issuerAndSerial",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"RecipientInfo.issuerAndSerial.issuer",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,captureAsn1:"issuer"},{name:"RecipientInfo.issuerAndSerial.serialNumber",tagClass:t.Class.UNIVERSAL,type:t.Type.INTEGER,constructed:!1,capture:"serial"}]},{name:"RecipientInfo.keyEncryptionAlgorithm",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"RecipientInfo.keyEncryptionAlgorithm.algorithm",tagClass:t.Class.UNIVERSAL,type:t.Type.OID,constructed:!1,capture:"encAlgorithm"},{name:"RecipientInfo.keyEncryptionAlgorithm.parameter",tagClass:t.Class.UNIVERSAL,constructed:!1,captureAsn1:"encParameter"}]},{name:"RecipientInfo.encryptedKey",tagClass:t.Class.UNIVERSAL,type:t.Type.OCTETSTRING,constructed:!1,capture:"encKey"}]}}var r="pkcs7asn1";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/pkcs7asn1",["require","module","./asn1","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){e.mgf=e.mgf||{};var t=e.mgf.mgf1=e.mgf1=e.mgf1||{};t.create=function(t){var n={generate:function(n,r){var i=new e.util.ByteBuffer,s=Math.ceil(r/t.digestLength);for(var o=0;o<s;o++){var u=new e.util.ByteBuffer;u.putInt32(o),t.start(),t.update(n+u.getBytes()),i.putBuffer(t.digest())}return i.truncate(i.length()-r),i.getBytes()}};return n}}var r="mgf1";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/mgf1",["require","module","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){e.mgf=e.mgf||{},e.mgf.mgf1=e.mgf1}var r="mgf";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/mgf",["require","module","./mgf1"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){var t=e.pss=e.pss||{};t.create=function(t,n,r){var i=t.digestLength,s={};return s.verify=function(s,o,u){var a,f=u-1,l=Math.ceil(f/8);o=o.substr(-l);if(l<i+r+2)throw{message:"Inconsistent parameters to PSS signature verification."};if(o.charCodeAt(l-1)!==188)throw{message:"Encoded message does not end in 0xBC."};var c=l-i-1,h=o.substr(0,c),p=o.substr(c,i),d=65280>>8*l-f&255;if((h.charCodeAt(0)&d)!==0)throw{message:"Bits beyond keysize not zero as expected."};var v=n.generate(p,c),m="";for(a=0;a<c;a++)m+=String.fromCharCode(h.charCodeAt(a)^v.charCodeAt(a));m=String.fromCharCode(m.charCodeAt(0)&~d)+m.substr(1);var g=l-i-r-2;for(a=0;a<g;a++)if(m.charCodeAt(a)!==0)throw{message:"Leftmost octets not zero as expected"};if(m.charCodeAt(g)!==1)throw{message:"Inconsistent PSS signature, 0x01 marker not found"};var y=m.substr(-r),b=new e.util.ByteBuffer;b.fillWithByte(0,8),b.putBytes(s),b.putBytes(y),t.start(),t.update(b.getBytes());var w=t.digest().getBytes();return p===w},s.encode=function(s,o){var u,a=o-1,f=Math.ceil(a/8),l=s.digest().getBytes();if(f<i+r+2)throw{message:"Message is too long to encrypt"};var c=e.random.getBytes(r),h=new e.util.ByteBuffer;h.fillWithByte(0,8),h.putBytes(l),h.putBytes(c),t.start(),t.update(h.getBytes());var p=t.digest().getBytes(),d=new e.util.ByteBuffer;d.fillWithByte(0,f-r-i-2),d.putByte(1),d.putBytes(c);var v=d.getBytes(),m=f-i-1,g=n.generate(p,m),y="";for(u=0;u<m;u++)y+=String.fromCharCode(v.charCodeAt(u)^g.charCodeAt(u));var b=65280>>8*f-a&255;return y=String.fromCharCode(y.charCodeAt(0)&~b)+y.substr(1),y+p+String.fromCharCode(188)},s}}var r="pss";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/pss",["require","module","./random","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){function l(e,t){typeof t=="string"&&(t={shortName:t});var n=null,r;for(var i=0;n===null&&i<e.attributes.length;++i)r=e.attributes[i],t.type&&t.type===r.type?n=r:t.name&&t.name===r.name?n=r:t.shortName&&t.shortName===r.shortName&&(n=r);return n}function p(n){var r=t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[]),i,s,o=n.attributes;for(var u=0;u<o.length;++u){i=o[u];var a=i.value,f=t.Type.PRINTABLESTRING;"valueTagClass"in i&&(f=i.valueTagClass,f===t.Type.UTF8&&(a=e.util.encodeUtf8(a))),s=t.create(t.Class.UNIVERSAL,t.Type.SET,!0,[t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(i.type).getBytes()),t.create(t.Class.UNIVERSAL,f,!1,a)])]),r.value.push(s)}return r}function d(e){var n=t.create(t.Class.CONTEXT_SPECIFIC,3,!0,[]),r=t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[]);n.value.push(r);var i,s;for(var o=0;o<e.length;++o){i=e[o],s=t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[]),r.value.push(s),s.value.push(t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(i.id).getBytes())),i.critical&&s.value.push(t.create(t.Class.UNIVERSAL,t.Type.BOOLEAN,!1,String.fromCharCode(255)));var u=i.value;typeof i.value!="string"&&(u=t.toDer(u).getBytes()),s.value.push(t.create(t.Class.UNIVERSAL,t.Type.OCTETSTRING,!1,u))}return n}function v(n){var r={};for(var i=0;i<n.length;++i){var s=n[i];console.log("attr",s);if(s.shortName&&(s.valueTagClass===t.Type.UTF8||s.valueTagClass===t.Type.PRINTABLESTRING||s.valueTagClass===t.Type.IA5String)){var o=s.value;s.valueTagClass===t.Type.UTF8&&(o=e.util.encodeUtf8(s.value)),s.shortName in r?e.util.isArray(r[s.shortName])?r[s.shortName].push(o):r[s.shortName]=[r[s.shortName],o]:r[s.shortName]=o}}return r}function m(e){var t;for(var r=0;r<e.length;++r){t=e[r],typeof t.name=="undefined"&&(t.type&&t.type in n.oids?t.name=n.oids[t.type]:t.shortName&&t.shortName in i&&(t.name=n.oids[i[t.shortName]]));if(typeof t.type=="undefined"){if(!(t.name&&t.name in n.oids))throw{message:"Attribute type not specified.",attribute:t};t.type=n.oids[t.name]}typeof t.shortName=="undefined"&&t.name&&t.name in i&&(t.shortName=i[t.name]);if(typeof t.value=="undefined")throw{message:"Attribute value not specified.",attribute:t}}}function g(e,n){switch(e){case r["RSASSA-PSS"]:var i=[];return n.hash.algorithmOid!==undefined&&i.push(t.create(t.Class.CONTEXT_SPECIFIC,0,!0,[t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(n.hash.algorithmOid).getBytes()),t.create(t.Class.UNIVERSAL,t.Type.NULL,!1,"")])])),n.mgf.algorithmOid!==undefined&&i.push(t.create(t.Class.CONTEXT_SPECIFIC,1,!0,[t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(n.mgf.algorithmOid).getBytes()),t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(n.mgf.hash.algorithmOid).getBytes()),t.create(t.Class.UNIVERSAL,t.Type.NULL,!1,"")])])])),n.saltLength!==undefined&&i.push(t.create(t.Class.CONTEXT_SPECIFIC,2,!0,[t.create(t.Class.UNIVERSAL,t.Type.INTEGER,!1,t.integerToDer(n.saltLength).getBytes())])),t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,i);default:return t.create(t.Class.UNIVERSAL,t.Type.NULL,!1,"")}}function y(n){var r=t.create(t.Class.CONTEXT_SPECIFIC,0,!0,[]);if(n.attributes.length===0)return r;var i=n.attributes;for(var s=0;s<i.length;++s){var o=i[s],u=o.value,a=t.Type.UTF8;"valueTagClass"in o&&(a=o.valueTagClass),a===t.Type.UTF8&&(u=e.util.encodeUtf8(u));var f=t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(o.type).getBytes()),t.create(t.Class.UNIVERSAL,t.Type.SET,!0,[t.create(t.Class.UNIVERSAL,a,!1,u)])]);r.value.push(f)}return r}var t=e.asn1,n=e.pki=e.pki||{},r=n.oids,i={};i.CN=r.commonName,i.commonName="CN",i.C=r.countryName,i.countryName="C",i.L=r.localityName,i.localityName="L",i.ST=r.stateOrProvinceName,i.stateOrProvinceName="ST",i.O=r.organizationName,i.organizationName="O",i.OU=r.organizationalUnitName,i.organizationalUnitName="OU",i.E=r.emailAddress,i.emailAddress="E";var s=e.pki.rsa.publicKeyValidator,o={name:"Certificate",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"Certificate.TBSCertificate",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,captureAsn1:"tbsCertificate",value:[{name:"Certificate.TBSCertificate.version",tagClass:t.Class.CONTEXT_SPECIFIC,type:0,constructed:!0,optional:!0,value:[{name:"Certificate.TBSCertificate.version.integer",tagClass:t.Class.UNIVERSAL,type:t.Type.INTEGER,constructed:!1,capture:"certVersion"}]},{name:"Certificate.TBSCertificate.serialNumber",tagClass:t.Class.UNIVERSAL,type:t.Type.INTEGER,constructed:!1,capture:"certSerialNumber"},{name:"Certificate.TBSCertificate.signature",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"Certificate.TBSCertificate.signature.algorithm",tagClass:t.Class.UNIVERSAL,type:t.Type.OID,constructed:!1,capture:"certinfoSignatureOid"},{name:"Certificate.TBSCertificate.signature.parameters",tagClass:t.Class.UNIVERSAL,optional:!0,captureAsn1:"certinfoSignatureParams"}]},{name:"Certificate.TBSCertificate.issuer",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,captureAsn1:"certIssuer"},{name:"Certificate.TBSCertificate.validity",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"Certificate.TBSCertificate.validity.notBefore (utc)",tagClass:t.Class.UNIVERSAL,type:t.Type.UTCTIME,constructed:!1,optional:!0,capture:"certValidity1UTCTime"},{name:"Certificate.TBSCertificate.validity.notBefore (generalized)",tagClass:t.Class.UNIVERSAL,type:t.Type.GENERALIZEDTIME,constructed:!1,optional:!0,capture:"certValidity2GeneralizedTime"},{name:"Certificate.TBSCertificate.validity.notAfter (utc)",tagClass:t.Class.UNIVERSAL,type:t.Type.UTCTIME,constructed:!1,optional:!0,capture:"certValidity3UTCTime"},{name:"Certificate.TBSCertificate.validity.notAfter (generalized)",tagClass:t.Class.UNIVERSAL,type:t.Type.GENERALIZEDTIME,constructed:!1,optional:!0,capture:"certValidity4GeneralizedTime"}]},{name:"Certificate.TBSCertificate.subject",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,captureAsn1:"certSubject"},s,{name:"Certificate.TBSCertificate.issuerUniqueID",tagClass:t.Class.CONTEXT_SPECIFIC,type:1,constructed:!0,optional:!0,value:[{name:"Certificate.TBSCertificate.issuerUniqueID.id",tagClass:t.Class.UNIVERSAL,type:t.Type.BITSTRING,constructed:!1,capture:"certIssuerUniqueId"}]},{name:"Certificate.TBSCertificate.subjectUniqueID",tagClass:t.Class.CONTEXT_SPECIFIC,type:2,constructed:!0,optional:!0,value:[{name:"Certificate.TBSCertificate.subjectUniqueID.id",tagClass:t.Class.UNIVERSAL,type:t.Type.BITSTRING,constructed:!1,capture:"certSubjectUniqueId"}]},{name:"Certificate.TBSCertificate.extensions",tagClass:t.Class.CONTEXT_SPECIFIC,type:3,constructed:!0,captureAsn1:"certExtensions",optional:!0}]},{name:"Certificate.signatureAlgorithm",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"Certificate.signatureAlgorithm.algorithm",tagClass:t.Class.UNIVERSAL,type:t.Type.OID,constructed:!1,capture:"certSignatureOid"},{name:"Certificate.TBSCertificate.signature.parameters",tagClass:t.Class.UNIVERSAL,optional:!0,captureAsn1:"certSignatureParams"}]},{name:"Certificate.signatureValue",tagClass:t.Class.UNIVERSAL,type:t.Type.BITSTRING,constructed:!1,capture:"certSignature"}]},u={name:"rsapss",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"rsapss.hashAlgorithm",tagClass:t.Class.CONTEXT_SPECIFIC,type:0,constructed:!0,value:[{name:"rsapss.hashAlgorithm.AlgorithmIdentifier",tagClass:t.Class.UNIVERSAL,type:t.Class.SEQUENCE,constructed:!0,optional:!0,value:[{name:"rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm",tagClass:t.Class.UNIVERSAL,type:t.Type.OID,constructed:!1,capture:"hashOid"}]}]},{name:"rsapss.maskGenAlgorithm",tagClass:t.Class.CONTEXT_SPECIFIC,type:1,constructed:!0,value:[{name:"rsapss.maskGenAlgorithm.AlgorithmIdentifier",tagClass:t.Class.UNIVERSAL,type:t.Class.SEQUENCE,constructed:!0,optional:!0,value:[{name:"rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm",tagClass:t.Class.UNIVERSAL,type:t.Type.OID,constructed:!1,capture:"maskGenOid"},{name:"rsapss.maskGenAlgorithm.AlgorithmIdentifier.params",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm",tagClass:t.Class.UNIVERSAL,type:t.Type.OID,constructed:!1,capture:"maskGenHashOid"}]}]}]},{name:"rsapss.saltLength",tagClass:t.Class.CONTEXT_SPECIFIC,type:2,optional:!0,value:[{name:"rsapss.saltLength.saltLength",tagClass:t.Class.UNIVERSAL,type:t.Class.INTEGER,constructed:!1,capture:"saltLength"}]},{name:"rsapss.trailerField",tagClass:t.Class.CONTEXT_SPECIFIC,type:3,optional:!0,value:[{name:"rsapss.trailer.trailer",tagClass:t.Class.UNIVERSAL,type:t.Class.INTEGER,constructed:!1,capture:"trailer"}]}]},a={name:"CertificationRequestInfo",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,captureAsn1:"certificationRequestInfo",value:[{name:"CertificationRequestInfo.integer",tagClass:t.Class.UNIVERSAL,type:t.Type.INTEGER,constructed:!1,capture:"certificationRequestInfoVersion"},{name:"CertificationRequestInfo.subject",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,captureAsn1:"certificationRequestInfoSubject"},s,{name:"CertificationRequestInfo.attributes",tagClass:t.Class.CONTEXT_SPECIFIC,type:0,constructed:!0,optional:!0,capture:"certificationRequestInfoAttributes",value:[{name:"CertificationRequestInfo.attributes",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"CertificationRequestInfo.attributes.type",tagClass:t.Class.UNIVERSAL,type:t.Type.OID,constructed:!1},{name:"CertificationRequestInfo.attributes.value",tagClass:t.Class.UNIVERSAL,type:t.Type.SET,constructed:!0}]}]}]},f={name:"CertificationRequest",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,captureAsn1:"csr",value:[a,{name:"CertificationRequest.signatureAlgorithm",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"CertificationRequest.signatureAlgorithm.algorithm",tagClass:t.Class.UNIVERSAL,type:t.Type.OID,constructed:!1,capture:"csrSignatureOid"},{name:"CertificationRequest.signatureAlgorithm.parameters",tagClass:t.Class.UNIVERSAL,optional:!0,captureAsn1:"csrSignatureParams"}]},{name:"CertificationRequest.signature",tagClass:t.Class.UNIVERSAL,type:t.Type.BITSTRING,constructed:!1,capture:"csrSignature"}]};n.RDNAttributesAsArray=function(e,n){var s=[],o,u,a;for(var f=0;f<e.value.length;++f){o=e.value[f];for(var l=0;l<o.value.length;++l)a={},u=o.value[l],a.type=t.derToOid(u.value[0].value),a.value=u.value[1].value,a.valueTagClass=u.value[1].type,a.type in r&&(a.name=r[a.type],a.name in i&&(a.shortName=i[a.name])),n&&(n.update(a.type),n.update(a.value)),s.push(a)}return s},n.CRIAttributesAsArray=function(e){var n=[];for(var s=0;s<e.length;++s){var o=e[s],u=t.derToOid(o.value[0].value),a=o.value[1].value;for(var f=0;f<a.length;++f){var l={};l.type=u,l.value=a[f].value,l.valueTagClass=a[f].type,l.type in r&&(l.name=r[l.type],l.name in i&&(l.shortName=i[l.name])),n.push(l)}}return n};var c=function(n){var i=[],s,o,u;for(var a=0;a<n.value.length;++a){u=n.value[a];for(var f=0;f<u.value.length;++f){o=u.value[f],s={},s.id=t.derToOid(o.value[0].value),s.critical=!1,o.value[1].type===t.Type.BOOLEAN?(s.critical=o.value[1].value.charCodeAt(0)!==0,s.value=o.value[2].value):s.value=o.value[1].value;if(s.id in r){s.name=r[s.id];if(s.name==="keyUsage"){var l=t.fromDer(s.value),c=0,h=0;l.value.length>1&&(c=l.value.charCodeAt(1),h=l.value.length>2?l.value.charCodeAt(2):0),s.digitalSignature=(c&128)===128,s.nonRepudiation=(c&64)===64,s.keyEncipherment=(c&32)===32,s.dataEncipherment=(c&16)===16,s.keyAgreement=(c&8)===8,s.keyCertSign=(c&4)===4,s.cRLSign=(c&2)===2,s.encipherOnly=(c&1)===1,s.decipherOnly=(h&128)===128}else if(s.name==="basicConstraints"){var l=t.fromDer(s.value);l.value.length>0&&l.value[0].type===t.Type.BOOLEAN?s.cA=l.value[0].value.charCodeAt(0)!==0:s.cA=!1;var p=null;l.value.length>0&&l.value[0].type===t.Type.INTEGER?p=l.value[0].value:l.value.length>1&&(p=l.value[1].value),p!==null&&(s.pathLenConstraint=t.derToInteger(p))}else if(s.name==="extKeyUsage"){var l=t.fromDer(s.value);for(var d=0;d<l.value.length;++d){var v=t.derToOid(l.value[d].value);v in r?s[r[v]]=!0:s[v]=!0}}else if(s.name==="nsCertType"){var l=t.fromDer(s.value),c=0;l.value.length>1&&(c=l.value.charCodeAt(1)),s.client=(c&128)===128,s.server=(c&64)===64,s.email=(c&32)===32,s.objsign=(c&16)===16,s.reserved=(c&8)===8,s.sslCA=(c&4)===4,s.emailCA=(c&2)===2,s.objCA=(c&1)===1}else if(s.name==="subjectAltName"||s.name==="issuerAltName"){s.altNames=[];var m,l=t.fromDer(s.value);for(var g=0;g<l.value.length;++g){m=l.value[g];var y={type:m.type,value:m.value};s.altNames.push(y);switch(m.type){case 1:case 2:case 6:break;case 7:y.ip=e.util.bytesToIP(m.value);break;case 8:y.oid=t.derToOid(m.value);break;default:}}}else if(s.name==="subjectKeyIdentifier"){var l=t.fromDer(s.value);s.subjectKeyIdentifier=e.util.bytesToHex(l.value)}}i.push(s)}}return i},h=function(e,n,i){var s={};if(e!==r["RSASSA-PSS"])return s;i&&(s={hash:{algorithmOid:r.sha1},mgf:{algorithmOid:r.mgf1,hash:{algorithmOid:r.sha1}},saltLength:20});var o={},a=[];if(!t.validate(n,u,o,a))throw{message:"Cannot read RSASSA-PSS parameter block.",errors:a};return o.hashOid!==undefined&&(s.hash=s.hash||{},s.hash.algorithmOid=t.derToOid(o.hashOid)),o.maskGenOid!==undefined&&(s.mgf=s.mgf||{},s.mgf.algorithmOid=t.derToOid(o.maskGenOid),s.mgf.hash=s.mgf.hash||{},s.mgf.hash.algorithmOid=t.derToOid(o.maskGenHashOid)),o.saltLength!==undefined&&(s.saltLength=o.saltLength.charCodeAt(0)),s};n.certificateFromPem=function(r,i,s){var o=e.pem.decode(r)[0];if(o.type!=="CERTIFICATE"&&o.type!=="X509 CERTIFICATE"&&o.type!=="TRUSTED CERTIFICATE")throw{message:'Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".',headerType:o.type};if(o.procType&&o.procType.type==="ENCRYPTED")throw{message:"Could not convert certificate from PEM; PEM is encrypted."};var u=t.fromDer(o.body,s);return n.certificateFromAsn1(u,i)},n.certificateToPem=function(r,i){var s={type:"CERTIFICATE",body:t.toDer(n.certificateToAsn1(r)).getBytes()};return e.pem.encode(s,{maxline:i})},n.publicKeyFromPem=function(r){var i=e.pem.decode(r)[0];if(i.type!=="PUBLIC KEY"&&i.type!=="RSA PUBLIC KEY")throw{message:'Could not convert public key from PEM; PEM header type is not "PUBLIC KEY" or "RSA PUBLIC KEY".',headerType:i.type};if(i.procType&&i.procType.type==="ENCRYPTED")throw{message:"Could not convert public key from PEM; PEM is encrypted."};var s=t.fromDer(i.body);return n.publicKeyFromAsn1(s)},n.publicKeyToPem=function(r,i){var s={type:"PUBLIC KEY",body:t.toDer(n.publicKeyToAsn1(r)).getBytes()};return e.pem.encode(s,{maxline:i})},n.publicKeyToRSAPublicKeyPem=function(r,i){var s={type:"RSA PUBLIC KEY",body:t.toDer(n.publicKeyToRSAPublicKey(r)).getBytes()};return e.pem.encode(s,{maxline:i})},n.certificationRequestFromPem=function(r,i,s){var o=e.pem.decode(r)[0];if(o.type!=="CERTIFICATE REQUEST")throw{message:'Could not convert certification request from PEM; PEM header type is not "CERTIFICATE REQUEST".',headerType:o.type};if(o.procType&&o.procType.type==="ENCRYPTED")throw{message:"Could not convert certification request from PEM; PEM is encrypted."};var u=t.fromDer(o.body,s);return n.certificationRequestFromAsn1(u,i)},n.certificationRequestToPem=function(r,i){var s={type:"CERTIFICATE REQUEST",body:t.toDer(n.certificationRequestToAsn1(r)).getBytes()};return e.pem.encode(s,{maxline:i})},n.createCertificate=function(){var i={};return i.version=2,i.serialNumber="00",i.signatureOid=null,i.signature=null,i.siginfo={},i.siginfo.algorithmOid=null,i.validity={},i.validity.notBefore=new Date,i.validity.notAfter=new Date,i.issuer={},i.issuer.getField=function(e){return l(i.issuer,e)},i.issuer.addField=function(e){m([e]),i.issuer.attributes.push(e)},i.issuer.attributes=[],i.issuer.hash=null,i.subject={},i.subject.getField=function(e){return l(i.subject,e)},i.subject.addField=function(e){m([e]),i.subject.attributes.push(e)},i.subject.attributes=[],i.subject.hash=null,i.extensions=[],i.publicKey=null,i.md=null,i.setSubject=function(e,t){m(e),i.subject.attributes=e,delete i.subject.uniqueId,t&&(i.subject.uniqueId=t),i.subject.hash=null},i.setIssuer=function(e,t){m(e),i.issuer.attributes=e,delete i.issuer.uniqueId,t&&(i.issuer.uniqueId=t),i.issuer.hash=null},i.setExtensions=function(s){var o;for(var u=0;u<s.length;++u){o=s[u],typeof o.name=="undefined"&&o.id&&o.id in n.oids&&(o.name=n.oids[o.id]);if(typeof o.id=="undefined"){if(!(o.name&&o.name in n.oids))throw{message:"Extension ID not specified.",extension:o};o.id=n.oids[o.name]}if(typeof o.value=="undefined"){if(o.name==="keyUsage"){var a=0,f=0,l=0;o.digitalSignature&&(f|=128,a=7),o.nonRepudiation&&(f|=64,a=6),o.keyEncipherment&&(f|=32,a=5),o.dataEncipherment&&(f|=16,a=4),o.keyAgreement&&(f|=8,a=3),o.keyCertSign&&(f|=4,a=2),o.cRLSign&&(f|=2,a=1),o.encipherOnly&&(f|=1,a=0),o.decipherOnly&&(l|=128,a=7);var c=String.fromCharCode(a);l!==0?c+=String.fromCharCode(f)+String.fromCharCode(l):f!==0&&(c+=String.fromCharCode(f)),o.value=t.create(t.Class.UNIVERSAL,t.Type.BITSTRING,!1,c)}else if(o.name==="basicConstraints")o.value=t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[]),o.cA&&o.value.value.push(t.create(t.Class.UNIVERSAL,t.Type.BOOLEAN,!1,String.fromCharCode(255))),"pathLenConstraint"in o&&o.value.value.push(t.create(t.Class.UNIVERSAL,t.Type.INTEGER,!1,t.integerToDer(o.pathLenConstraint).getBytes()));else if(o.name==="extKeyUsage"){o.value=t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[]);var h=o.value.value;for(var p in o){if(o[p]!==!0)continue;p in r?h.push(t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(r[p]).getBytes())):p.indexOf(".")!==-1&&h.push(t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(p).getBytes()))}}else if(o.name==="nsCertType"){var a=0,f=0;o.client&&(f|=128,a=7),o.server&&(f|=64,a=6),o.email&&(f|=32,a=5),o.objsign&&(f|=16,a=4),o.reserved&&(f|=8,a=3),o.sslCA&&(f|=4,a=2),o.emailCA&&(f|=2,a=1),o.objCA&&(f|=1,a=0);var c=String.fromCharCode(a);f!==0&&(c+=String.fromCharCode(f)),o.value=t.create(t.Class.UNIVERSAL,t.Type.BITSTRING,!1,c)}else if(o.name==="subjectAltName"||o.name==="issuerAltName"){o.value=t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[]);var d;for(var v=0;v<o.altNames.length;++v){d=o.altNames[v];var c=d.value;if(d.type===7&&d.ip){c=e.util.bytesFromIP(d.ip);if(c===null)throw{message:'Extension "ip" value is not a valid IPv4 or IPv6 address.',extension:o}}else d.type===8&&(d.oid?c=t.oidToDer(t.oidToDer(d.oid)):c=t.oidToDer(c));o.value.value.push(t.create(t.Class.CONTEXT_SPECIFIC,d.type,!1,c))}}else if(o.name==="subjectKeyIdentifier"){var m=i.generateSubjectKeyIdentifier();o.subjectKeyIdentifier=m.toHex(),o.value=t.create(t.Class.UNIVERSAL,t.Type.OCTETSTRING,!1,m.getBytes())}if(typeof o.value=="undefined")throw{message:"Extension value not specified.",extension:o}}}i.extensions=s},i.getExtension=function(e){typeof e=="string"&&(e={name:e});var t=null,n;for(var r=0;t===null&&r<i.extensions.length;++r)n=i.extensions[r],e.id&&n.id===e.id?t=n:e.name&&n.name===e.name&&(t=n);return t},i.sign=function(s,o){i.md=o||e.md.sha1.create();var u=r[i.md.algorithm+"WithRSAEncryption"];if(!u)throw{message:"Could not compute certificate digest. Unknown message digest algorithm OID.",algorithm:i.md.algorithm};i.signatureOid=i.siginfo.algorithmOid=u,i.tbsCertificate=n.getTBSCertificate(i);var a=t.toDer(i.tbsCertificate);i.md.update(a.getBytes()),i.signature=s.sign(i.md)},i.verify=function(s){var o=!1;if(!i.issued(s)){var u=s.issuer,a=i.subject;throw{message:"The parent certificate did not issue the given child certificate; the child certificate's issuer does not match the parent's subject.",expectedIssuer:u.attributes,actualIssuer:a.attributes}}var f=s.md;if(f===null){if(s.signatureOid in r){var l=r[s.signatureOid];switch(l){case"sha1WithRSAEncryption":f=e.md.sha1.create();break;case"md5WithRSAEncryption":f=e.md.md5.create();break;case"sha256WithRSAEncryption":f=e.md.sha256.create();break;case"RSASSA-PSS":f=e.md.sha256.create()}}if(f===null)throw{message:"Could not compute certificate digest. Unknown signature OID.",signatureOid:s.signatureOid};var c=s.tbsCertificate||n.getTBSCertificate(s),h=t.toDer(c);f.update(h.getBytes())}if(f!==null){var p=undefined;switch(s.signatureOid){case r.sha1WithRSAEncryption:p=undefined;break;case r["RSASSA-PSS"]:var d,v;d=r[s.signatureParameters.mgf.hash.algorithmOid];if(d===undefined||e.md[d]===undefined)throw{message:"Unsupported MGF hash function.",oid:s.signatureParameters.mgf.hash.algorithmOid,name:d};v=r[s.signatureParameters.mgf.algorithmOid];if(v===undefined||e.mgf[v]===undefined)throw{message:"Unsupported MGF function.",oid:s.signatureParameters.mgf.algorithmOid,name:v};v=e.mgf[v].create(e.md[d].create()),d=r[s.signatureParameters.hash.algorithmOid];if(d===undefined||e.md[d]===undefined)throw{message:"Unsupported RSASSA-PSS hash function.",oid:s.signatureParameters.hash.algorithmOid,name:d};p=e.pss.create(e.md[d].create(),v,s.signatureParameters.saltLength)}o=i.publicKey.verify(f.digest().getBytes(),s.signature,p)}return o},i.isIssuer=function(e){var t=!1,n=i.issuer,r=e.subject;if(n.hash&&r.hash)t=n.hash===r.hash;else if(n.attributes.length===r.attributes.length){t=!0;var s,o;for(var u=0;t&&u<n.attributes.length;++u){s=n.attributes[u],o=r.attributes[u];if(s.type!==o.type||s.value!==o.value)t=!1}}return t},i.issued=function(e){return e.isIssuer(i)},i.generateSubjectKeyIdentifier=function(){var r=t.toDer(n.publicKeyToRSAPublicKey(i.publicKey)),s=e.md.sha1.create();return s.update(r.getBytes()),s.digest()},i.verifySubjectKeyIdentifier=function(){var t=r.subjectKeyIdentifier;for(var n=0;n<i.extensions.length;++n){var s=i.extensions[n];if(s.id===t){var o=i.generateSubjectKeyIdentifier().getBytes();return e.util.hexToBytes(s.subjectKeyIdentifier)===o}}return!1},i},n.certificateFromAsn1=function(i,s){var u={},a=[];if(!t.validate(i,o,u,a))throw{message:"Cannot read X.509 certificate. ASN.1 object is not an X509v3 Certificate.",errors:a};if(typeof u.certSignature!="string"){var f="\0";for(var p=0;p<u.certSignature.length;++p)f+=t.toDer(u.certSignature[p]).getBytes();u.certSignature=f}var d=t.derToOid(u.publicKeyOid);if(d!==n.oids.rsaEncryption)throw{message:"Cannot read public key. OID is not RSA."};var v=n.createCertificate();v.version=u.certVersion?u.certVersion.charCodeAt(0):0;var g=e.util.createBuffer(u.certSerialNumber);v.serialNumber=g.toHex(),v.signatureOid=e.asn1.derToOid(u.certSignatureOid),v.signatureParameters=h(v.signatureOid,u.certSignatureParams,!0),v.siginfo.algorithmOid=e.asn1.derToOid(u.certinfoSignatureOid),v.siginfo.parameters=h(v.siginfo.algorithmOid,u.certinfoSignatureParams,!1);var y=e.util.createBuffer(u.certSignature);++y.read,v.signature=y.getBytes();var b=[];u.certValidity1UTCTime!==undefined&&b.push(t.utcTimeToDate(u.certValidity1UTCTime)),u.certValidity2GeneralizedTime!==undefined&&b.push(t.generalizedTimeToDate(u.certValidity2GeneralizedTime)),u.certValidity3UTCTime!==undefined&&b.push(t.utcTimeToDate(u.certValidity3UTCTime)),u.certValidity4GeneralizedTime!==undefined&&b.push(t.generalizedTimeToDate(u.certValidity4GeneralizedTime));if(b.length>2)throw{message:"Cannot read notBefore/notAfter validity times; more than two times were provided in the certificate."};if(b.length<2)throw{message:"Cannot read notBefore/notAfter validity times; they were not provided as either UTCTime or GeneralizedTime."};v.validity.notBefore=b[0],v.validity.notAfter=b[1],v.tbsCertificate=u.tbsCertificate;if(s){v.md=null;if(v.signatureOid in r){var d=r[v.signatureOid];switch(d){case"sha1WithRSAEncryption":v.md=e.md.sha1.create();break;case"md5WithRSAEncryption":v.md=e.md.md5.create();break;case"sha256WithRSAEncryption":v.md=e.md.sha256.create();break;case"RSASSA-PSS":v.md=e.md.sha256.create()}}if(v.md===null)throw{message:"Could not compute certificate digest. Unknown signature OID.",signatureOid:v.signatureOid};var w=t.toDer(v.tbsCertificate);v.md.update(w.getBytes())}var E=e.md.sha1.create();v.issuer.getField=function(e){return l(v.issuer,e)},v.issuer.addField=function(e){m([e]),v.issuer.attributes.push(e)},v.issuer.attributes=n.RDNAttributesAsArray(u.certIssuer,E),u.certIssuerUniqueId&&(v.issuer.uniqueId=u.certIssuerUniqueId),v.issuer.hash=E.digest().toHex();var S=e.md.sha1.create();return v.subject.getField=function(e){return l(v.subject,e)},v.subject.addField=function(e){m([e]),v.subject.attributes.push(e)},v.subject.attributes=n.RDNAttributesAsArray(u.certSubject,S),u.certSubjectUniqueId&&(v.subject.uniqueId=u.certSubjectUniqueId),v.subject.hash=S.digest().toHex(),u.certExtensions?v.extensions=c(u.certExtensions):v.extensions=[],v.publicKey=n.publicKeyFromAsn1(u.subjectPublicKeyInfo),v},n.certificationRequestFromAsn1=function(i,s){var o={},u=[];if(!t.validate(i,f,o,u))throw{message:"Cannot read PKCS#10 certificate request. ASN.1 object is not a PKCS#10 CertificationRequest.",errors:u};if(typeof o.csrSignature!="string"){var a="\0";for(var c=0;c<o.csrSignature.length;++c)a+=t.toDer(o.csrSignature[c]).getBytes();o.csrSignature=a}var p=t.derToOid(o.publicKeyOid);if(p!==n.oids.rsaEncryption)throw{message:"Cannot read public key. OID is not RSA."};var d=n.createCertificationRequest();d.version=o.csrVersion?o.csrVersion.charCodeAt(0):0,d.signatureOid=e.asn1.derToOid(o.csrSignatureOid),d.signatureParameters=h(d.signatureOid,o.csrSignatureParams,!0),d.siginfo.algorithmOid=e.asn1.derToOid(o.csrSignatureOid),d.siginfo.parameters=h(d.siginfo.algorithmOid,o.csrSignatureParams,!1);var v=e.util.createBuffer(o.csrSignature);++v.read,d.signature=v.getBytes(),d.certificationRequestInfo=o.certificationRequestInfo;if(s){d.md=null;if(d.signatureOid in r){var p=r[d.signatureOid];switch(p){case"sha1WithRSAEncryption":d.md=e.md.sha1.create();break;case"md5WithRSAEncryption":d.md=e.md.md5.create();break;case"sha256WithRSAEncryption":d.md=e.md.sha256.create();break;case"RSASSA-PSS":d.md=e.md.sha256.create()}}if(d.md===null)throw{message:"Could not compute certification request digest. Unknown signature OID.",signatureOid:d.signatureOid};var g=t.toDer(d.certificationRequestInfo);d.md.update(g.getBytes())}var y=e.md.sha1.create();return d.subject.getField=function(e){return l(d.subject,e)},d.subject.addField=function(e){m([e]),d.subject.attributes.push(e)},d.subject.attributes=n.RDNAttributesAsArray(o.certificationRequestInfoSubject,y),d.subject.hash=y.digest().toHex(),d.publicKey=n.publicKeyFromAsn1(o.subjectPublicKeyInfo),d.getAttribute=function(e){return l(d.attributes,e)},d.addAttribute=function(e){m([e]),d.attributes.push(e)},d.attributes=n.CRIAttributesAsArray(o.certificationRequestInfoAttributes),d},n.createCertificationRequest=function(){var i={};return i.version=0,i.signatureOid=null,i.signature=null,i.siginfo={},i.siginfo.algorithmOid=null,i.subject={},i.subject.getField=function(e){return l(i.subject,e)},i.subject.addField=function(e){m([e]),i.subject.attributes.push(e)},i.subject.attributes=[],i.subject.hash=null,i.publicKey=null,i.attributes=[],i.getAttribute=function(e){return l(i.attributes,e)},i.addAttribute=function(e){m([e]),i.attributes.push(e)},i.md=null,i.setSubject=function(e){m(e),i.subject.attributes=e,i.subject.hash=null},i.setAttributes=function(e){m(e),i.attributes=e},i.sign=function(s,o){i.md=o||e.md.sha1.create();var u=r[i.md.algorithm+"WithRSAEncryption"];if(!u)throw{message:"Could not compute certification request digest. Unknown message digest algorithm OID.",algorithm:i.md.algorithm};i.signatureOid=i.siginfo.algorithmOid=u,i.certificationRequestInfo=n.getCertificationRequestInfo(i);var a=t.toDer(i.certificationRequestInfo);i.md.update(a.getBytes()),i.signature=s.sign(i.md)},i.verify=function(){var s=!1,o=i.md;if(o===null){if(i.signatureOid in r){var u=r[i.signatureOid];switch(u){case"sha1WithRSAEncryption":o=e.md.sha1.create();break;case"md5WithRSAEncryption":o=e.md.md5.create();break;case"sha256WithRSAEncryption":o=e.md.sha256.create();break;case"RSASSA-PSS":o=e.md.sha256.create()}}if(o===null)throw{message:"Could not compute certification request digest. Unknown signature OID.",signatureOid:i.signatureOid};var a=i.certificationRequestInfo||n.getCertificationRequestInfo(i),f=t.toDer(a);o.update(f.getBytes())}if(o!==null){var l;switch(i.signatureOid){case r.sha1WithRSAEncryption:break;case r["RSASSA-PSS"]:var c,h;c=r[i.signatureParameters.mgf.hash.algorithmOid];if(c===undefined||e.md[c]===undefined)throw{message:"Unsupported MGF hash function.",oid:i.signatureParameters.mgf.hash.algorithmOid,name:c};h=r[i.signatureParameters.mgf.algorithmOid];if(h===undefined||e.mgf[h]===undefined)throw{message:"Unsupported MGF function.",oid:i.signatureParameters.mgf.algorithmOid,name:h};h=e.mgf[h].create(e.md[c].create()),c=r[i.signatureParameters.hash.algorithmOid];if(c===undefined||e.md[c]===undefined)throw{message:"Unsupported RSASSA-PSS hash function.",oid:i.signatureParameters.hash.algorithmOid,name:c};l=e.pss.create(e.md[c].create(),h,i.signatureParameters.saltLength)}s=i.publicKey.verify(o.digest().getBytes(),i.signature,l)}return s},i},n.getTBSCertificate=function(r){var i=t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.CONTEXT_SPECIFIC,0,!0,[t.create(t.Class.UNIVERSAL,t.Type.INTEGER,!1,t.integerToDer(r.version).getBytes())]),t.create(t.Class.UNIVERSAL,t.Type.INTEGER,!1,e.util.hexToBytes(r.serialNumber)),t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(r.siginfo.algorithmOid).getBytes()),g(r.siginfo.algorithmOid,r.siginfo.parameters)]),p(r.issuer),t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.UTCTIME,!1,t.dateToUtcTime(r.validity.notBefore)),t.create(t.Class.UNIVERSAL,t.Type.UTCTIME,!1,t.dateToUtcTime(r.validity.notAfter))]),p(r.subject),n.publicKeyToAsn1(r.publicKey)]);return r.issuer.uniqueId&&i.value.push(t.create(t.Class.CONTEXT_SPECIFIC,1,!0,[t.create(t.Class.UNIVERSAL,t.Type.BITSTRING,!1,String.fromCharCode(0)+r.issuer.uniqueId)])),r.subject.uniqueId&&i.value.push(t.create(t.Class.CONTEXT_SPECIFIC,2,!0,[t.create(t.Class.UNIVERSAL,t.Type.BITSTRING,!1,String.fromCharCode(0)+r.subject.uniqueId)])),r.extensions.length>0&&i.value.push(d(r.extensions)),i},n.getCertificationRequestInfo=function(e){var r=t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.INTEGER,!1,t.integerToDer(e.version).getBytes()),p(e.subject),n.publicKeyToAsn1(e.publicKey),y(e)]);return r},n.distinguishedNameToAsn1=function(e){return p(e)},n.certificateToAsn1=function(e){var r=e.tbsCertificate||n.getTBSCertificate(e);return t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[r,t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(e.signatureOid).getBytes()),g(e.signatureOid,e.signatureParameters)]),t.create(t.Class.UNIVERSAL,t.Type.BITSTRING,!1,String.fromCharCode(0)+e.signature)])},n.certificationRequestToAsn1=function(e){var r=e.certificationRequestInfo||n.getCertificationRequestInfo(e);return t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[r,t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(e.signatureOid).getBytes()),g(e.signatureOid,e.signatureParameters)]),t.create(t.Class.UNIVERSAL,t.Type.BITSTRING,!1,String.fromCharCode(0)+e.signature)])},n.createCaStore=function(t){var r={certs:{}};r.getIssuer=function(t){var i=null;if(!t.issuer.hash){var s=e.md.sha1.create();t.issuer.attributes=n.RDNAttributesAsArray(p(t.issuer),s),t.issuer.hash=s.digest().toHex()}if(t.issuer.hash in r.certs){i=r.certs[t.issuer.hash];if(e.util.isArray(i))throw{message:"Resolving multiple issuer matches not implemented yet."}}return i},r.addCertificate=function(t){typeof t=="string"&&(t=e.pki.certificateFromPem(t));if(!t.subject.hash){var i=e.md.sha1.create();t.subject.attributes=n.RDNAttributesAsArray(p(t.subject),i),t.subject.hash=i.digest().toHex()}if(t.subject.hash in r.certs){var s=r.certs[t.subject.hash];e.util.isArray(s)||(s=[s]),s.push(t)}else r.certs[t.subject.hash]=t};if(t)for(var i=0;i<t.length;++i){var s=t[i];r.addCertificate(s)}return r},n.certificateError={bad_certificate:"forge.pki.BadCertificate",unsupported_certificate:"forge.pki.UnsupportedCertificate",certificate_revoked:"forge.pki.CertificateRevoked",certificate_expired:"forge.pki.CertificateExpired",certificate_unknown:"forge.pki.CertificateUnknown",unknown_ca:"forge.pki.UnknownCertificateAuthority"},n.verifyCertificateChain=function(t,r,i){r=r.slice(0);var s=r.slice(0),o=new Date,u=!0,a=null,f=0,l=null;do{var c=r.shift();if(o<c.validity.notBefore||o>c.validity.notAfter)a={message:"Certificate is not valid yet or has expired.",error:n.certificateError.certificate_expired,notBefore:c.validity.notBefore,notAfter:c.validity.notAfter,now:o};else{var h=!1;if(r.length>0){l=r[0];try{h=l.verify(c)}catch(p){}}else{var d=t.getIssuer(c);if(d===null)a={message:"Certificate is not trusted.",error:n.certificateError.unknown_ca};else{e.util.isArray(d)||(d=[d]);while(!h&&d.length>0){l=d.shift();try{h=l.verify(c)}catch(p){}}}}a===null&&!h&&(a={message:"Certificate signature is invalid.",error:n.certificateError.bad_certificate})}a===null&&!c.isIssuer(l)&&(a={message:"Certificate issuer is invalid.",error:n.certificateError.bad_certificate});if(a===null){var v={keyUsage:!0,basicConstraints:!0};for(var m=0;a===null&&m<c.extensions.length;++m){var g=c.extensions[m];g.critical&&!(g.name in v)&&(a={message:"Certificate has an unsupported critical extension.",error:n.certificateError.unsupported_certificate})}}if(!u||r.length===0&&!l){var y=c.getExtension("basicConstraints"),b=c.getExtension("keyUsage");b!==null&&(!b.keyCertSign||y===null)&&(a={message:"Certificate keyUsage or basicConstraints conflict or indicate that the certificate is not a CA. If the certificate is the only one in the chain or isn't the first then the certificate must be a valid CA.",error:n.certificateError.bad_certificate}),a===null&&y!==null&&!y.cA&&(a={message:"Certificate basicConstraints indicates the certificate is not a CA.",error:n.certificateError.bad_certificate});if(a===null&&b!==null&&"pathLenConstraint"in y){var w=0;for(var m=1;m<r.length-1;++m)r[m].isIssuer(r[m])&&++w;var E=y.pathLenConstraint+1;r.length-w>E&&(a={message:"Certificate basicConstraints pathLenConstraint violated.",error:n.certificateError.bad_certificate})}}var S=a===null?!0:a.error,x=i?i(S,f,s):S;if(x!==!0){S===!0&&(a={message:"The application rejected the certificate.",error:n.certificateError.bad_certificate});if(x||x===0)typeof x=="object"&&!e.util.isArray(x)?(x.message&&(a.message=x.message),x.error&&(a.error=x.error)):typeof x=="string"&&(a.error=x);throw a}a=null,u=!1,++f}while(r.length>0);return!0}}var r="x509";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n.pki}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/x509",["require","module","./aes","./asn1","./des","./md","./mgf","./oids","./pem","./pss","./rsa","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){function f(e,t,n,r){var i=[];for(var s=0;s<e.length;s++)for(var o=0;o<e[s].safeBags.length;o++){var u=e[s].safeBags[o];if(r!==undefined&&u.type!==r)continue;u.attributes[t]!==undefined&&u.attributes[t].indexOf(n)>=0&&i.push(u)}return i}function l(e,r,s,o){r=t.fromDer(r,s);if(r.tagClass!==t.Class.UNIVERSAL||r.type!==t.Type.SEQUENCE||r.constructed!==!0)throw{message:"PKCS#12 AuthenticatedSafe expected to be a SEQUENCE OF ContentInfo"};for(var u=0;u<r.value.length;u++){var a=r.value[u],f={},l=[];if(!t.validate(a,i,f,l))throw{message:"Cannot read ContentInfo.",errors:l};var p={encrypted:!1},d=null,v=f.content.value[0];switch(t.derToOid(f.contentType)){case n.oids.data:if(v.tagClass!==t.Class.UNIVERSAL||v.type!==t.Type.OCTETSTRING)throw{message:"PKCS#12 SafeContents Data is not an OCTET STRING."};d=v.value;break;case n.oids.encryptedData:if(o===undefined)throw{message:"Found PKCS#12 Encrypted SafeContents Data but no password available."};d=c(v,o),p.encrypted=!0;break;default:throw{message:"Unsupported PKCS#12 contentType.",contentType:t.derToOid(f.contentType)}}p.safeBags=h(d,s,o),e.safeContents.push(p)}}function c(r,i){var s={},o=[];if(!t.validate(r,e.pkcs7.asn1.encryptedDataValidator,s,o))throw{message:"Cannot read EncryptedContentInfo. ",errors:o};var u=t.derToOid(s.contentType);if(u!==n.oids.data)throw{message:"PKCS#12 EncryptedContentInfo ContentType is not Data.",oid:u};u=t.derToOid(s.encAlgorithm);var a=n.pbe.getCipher(u,s.encParameter,i),f=e.util.createBuffer(s.encryptedContent);a.update(f);if(!a.finish())throw{message:"Failed to decrypt PKCS#12 SafeContents."};return a.output.getBytes()}function h(e,r,i){e=t.fromDer(e,r);if(e.tagClass!==t.Class.UNIVERSAL||e.type!==t.Type.SEQUENCE||e.constructed!==!0)throw{message:"PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag"};var s=[];for(var u=0;u<e.value.length;u++){var f=e.value[u],l={},c=[];if(!t.validate(f,o,l,c))throw{message:"Cannot read SafeBag.",errors:c};var h={type:t.derToOid(l.bagId),attributes:p(l.bagAttributes)};s.push(h);var d,v,m=l.bagValue.value[0];switch(h.type){case n.oids.pkcs8ShroudedKeyBag:if(i===undefined)throw{message:"Found PKCS#8 ShroudedKeyBag but no password available."};m=n.decryptPrivateKeyInfo(m,i);if(m===null)throw{message:"Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?"};case n.oids.keyBag:h.key=n.privateKeyFromAsn1(m);continue;case n.oids.certBag:d=a,v=function(){if(t.derToOid(l.certId)!==n.oids.x509Certificate)throw{message:"Unsupported certificate type, only X.509 supported.",oid:t.derToOid(l.certId)};h.cert=n.certificateFromAsn1(t.fromDer(l.cert,r),!0)};break;default:throw{message:"Unsupported PKCS#12 SafeBag type.",oid:h.type}}if(d!==undefined&&!t.validate(m,d,l,c))throw{message:"Cannot read PKCS#12 "+d.name,errors:c};v()}return s}function p(e){var r={};if(e!==undefined)for(var i=0;i<e.length;++i){var s={},o=[];if(!t.validate(e[i],u,s,o))throw{message:"Cannot read PKCS#12 BagAttribute.",errors:o};var a=t.derToOid(s.oid);if(n.oids[a]===undefined)continue;r[n.oids[a]]=[];for(var f=0;f<s.values.length;++f)r[n.oids[a]].push(s.values[f].value)}return r}var t=e.asn1,n=e.pki,r=e.pkcs12=e.pkcs12||{},i={name:"ContentInfo",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"ContentInfo.contentType",tagClass:t.Class.UNIVERSAL,type:t.Type.OID,constructed:!1,capture:"contentType"},{name:"ContentInfo.content",tagClass:t.Class.CONTEXT_SPECIFIC,constructed:!0,captureAsn1:"content"}]},s={name:"PFX",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"PFX.version",tagClass:t.Class.UNIVERSAL,type:t.Type.INTEGER,constructed:!1,capture:"version"},i,{name:"PFX.macData",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,optional:!0,captureAsn1:"mac",value:[{name:"PFX.macData.mac",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"PFX.macData.mac.digestAlgorithm",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"PFX.macData.mac.digestAlgorithm.algorithm",tagClass:t.Class.UNIVERSAL,type:t.Type.OID,constructed:!1,capture:"macAlgorithm"},{name:"PFX.macData.mac.digestAlgorithm.parameters",tagClass:t.Class.UNIVERSAL,captureAsn1:"macAlgorithmParameters"}]},{name:"PFX.macData.mac.digest",tagClass:t.Class.UNIVERSAL,type:t.Type.OCTETSTRING,constructed:!1,capture:"macDigest"}]},{name:"PFX.macData.macSalt",tagClass:t.Class.UNIVERSAL,type:t.Type.OCTETSTRING,constructed:!1,capture:"macSalt"},{name:"PFX.macData.iterations",tagClass:t.Class.UNIVERSAL,type:t.Type.INTEGER,constructed:!1,optional:!0,capture:"macIterations"}]}]},o={name:"SafeBag",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"SafeBag.bagId",tagClass:t.Class.UNIVERSAL,type:t.Type.OID,constructed:!1,capture:"bagId"},{name:"SafeBag.bagValue",tagClass:t.Class.CONTEXT_SPECIFIC,constructed:!0,captureAsn1:"bagValue"},{name:"SafeBag.bagAttributes",tagClass:t.Class.UNIVERSAL,type:t.Type.SET,constructed:!0,optional:!0,capture:"bagAttributes"}]},u={name:"Attribute",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"Attribute.attrId",tagClass:t.Class.UNIVERSAL,type:t.Type.OID,constructed:!1,capture:"oid"},{name:"Attribute.attrValues",tagClass:t.Class.UNIVERSAL,type:t.Type.SET,constructed:!0,capture:"values"}]},a={name:"CertBag",tagClass:t.Class.UNIVERSAL,type:t.Type.SEQUENCE,constructed:!0,value:[{name:"CertBag.certId",tagClass:t.Class.UNIVERSAL,type:t.Type.OID,constructed:!1,capture:"certId"},{name:"CertBag.certValue",tagClass:t.Class.CONTEXT_SPECIFIC,constructed:!0,value:[{name:"CertBag.certValue[0]",tagClass:t.Class.UNIVERSAL,type:t.Class.OCTETSTRING,constructed:!1,capture:"cert"}]}]};r.pkcs12FromAsn1=function(i,o,u){typeof o=="string"?(u=o,o=!0):o===undefined&&(o=!0);var a={},c=[];if(!t.validate(i,s,a,c))throw{message:"Cannot read PKCS#12 PFX. ASN.1 object is not an PKCS#12 PFX.",errors:c};var h={version:a.version.charCodeAt(0),safeContents:[],getBags:function(t){var n={},r;return"localKeyId"in t?r=t.localKeyId:"localKeyIdHex"in t&&(r=e.util.hexToBytes(t.localKeyIdHex)),r!==undefined&&(n.localKeyId=f(h.safeContents,"localKeyId",r,t.bagType)),"friendlyName"in t&&(n.friendlyName=f(h.safeContents,"friendlyName",t.friendlyName,t.bagType)),n},getBagsByFriendlyName:function(e,t){return f(h.safeContents,"friendlyName",e,t)},getBagsByLocalKeyId:function(e,t){return f(h.safeContents,"localKeyId",e,t)}};if(a.version.charCodeAt(0)!==3)throw{message:"PKCS#12 PFX of version other than 3 not supported.",version:a.version.charCodeAt(0)};if(t.derToOid(a.contentType)!==n.oids.data)throw{message:"Only PKCS#12 PFX in password integrity mode supported.",oid:t.derToOid(a.contentType)};var p=a.content.value[0];if(p.tagClass!==t.Class.UNIVERSAL||p.type!==t.Type.OCTETSTRING)throw{message:"PKCS#12 authSafe content data is not an OCTET STRING."};if(a.mac){var d=null,v=0,m=t.derToOid(a.macAlgorithm);switch(m){case n.oids.sha1:d=e.md.sha1.create(),v=20;break;case n.oids.sha256:d=e.md.sha256.create(),v=32;break;case n.oids.sha384:d=e.md.sha384.create(),v=48;break;case n.oids.sha512:d=e.md.sha512.create(),v=64;break;case n.oids.md5:d=e.md.md5.create(),v=16}if(d===null)throw{message:"PKCS#12 uses unsupported MAC algorithm: "+m};var g=new e.util.ByteBuffer(a.macSalt),y="macIterations"in a?parseInt(e.util.bytesToHex(a.macIterations),16):1,b=r.generateKey(u||"",g,3,y,v,d),w=e.hmac.create();w.start(d,b),w.update(p.value);var E=w.getMac();if(E.getBytes()!==a.macDigest)throw{message:"PKCS#12 MAC could not be verified. Invalid password?"}}return l(h,p.value,o,u),h},r.toPkcs12Asn1=function(i,s,o,u){u=u||{},u.saltSize=u.saltSize||8,u.count=u.count||2048,u.algorithm=u.algorithm||u.encAlgorithm||"aes128","useMac"in u||(u.useMac=!0),"localKeyId"in u||(u.localKeyId=null),"generateLocalKeyId"in u||(u.generateLocalKeyId=!0);var a=u.localKeyId,f;if(a!==null)a=e.util.hexToBytes(a);else if(u.generateLocalKeyId)if(s){var l=e.util.isArray(s)?s[0]:s;typeof l=="string"&&(l=n.certificateFromPem(l));var c=e.md.sha1.create();c.update(t.toDer(n.certificateToAsn1(l)).getBytes()),a=c.digest().getBytes()}else a=e.random.getBytes(20);var h=[];a!==null&&h.push(t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(n.oids.localKeyId).getBytes()),t.create(t.Class.UNIVERSAL,t.Type.SET,!0,[t.create(t.Class.UNIVERSAL,t.Type.OCTETSTRING,!1,a)])])),"friendlyName"in u&&h.push(t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(n.oids.friendlyName).getBytes()),t.create(t.Class.UNIVERSAL,t.Type.SET,!0,[t.create(t.Class.UNIVERSAL,t.Type.BMPSTRING,!1,u.friendlyName)])])),h.length>0&&(f=t.create(t.Class.UNIVERSAL,t.Type.SET,!0,h));var p=[],d=[];s!==null&&(e.util.isArray(s)?d=s:d=[s]);var v=[];for(var m=0;m<d.length;++m){s=d[m],typeof s=="string"&&(s=n.certificateFromPem(s));var g=m===0?f:undefined,y=n.certificateToAsn1(s),b=t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(n.oids.certBag).getBytes()),t.create(t.Class.CONTEXT_SPECIFIC,0,!0,[t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(n.oids.x509Certificate).getBytes()),t.create(t.Class.CONTEXT_SPECIFIC,0,!0,[t.create(t.Class.UNIVERSAL,t.Type.OCTETSTRING,!1,t.toDer(y).getBytes())])])]),g]);v.push(b)}if(v.length>0){var w=t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,v),E=t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(n.oids.data).getBytes()),t.create(t.Class.CONTEXT_SPECIFIC,0,!0,[t.create(t.Class.UNIVERSAL,t.Type.OCTETSTRING,!1,t.toDer(w).getBytes())])]);p.push(E)}var S=null;if(i!==null){var x=n.wrapRsaPrivateKey(n.privateKeyToAsn1(i));o===null?S=t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(n.oids.keyBag).getBytes()),t.create(t.Class.CONTEXT_SPECIFIC,0,!0,[x]),f]):S=t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(n.oids.pkcs8ShroudedKeyBag).getBytes()),t.create(t.Class.CONTEXT_SPECIFIC,0,!0,[n.encryptPrivateKeyInfo(x,o,u)]),f]);var T=t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[S]),N=t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(n.oids.data).getBytes()),t.create(t.Class.CONTEXT_SPECIFIC,0,!0,[t.create(t.Class.UNIVERSAL,t.Type.OCTETSTRING,!1,t.toDer(T).getBytes())])]);p.push(N)}var C=t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,p),k;if(u.useMac){var c=e.md.sha1.create(),L=new e.util.ByteBuffer(e.random.getBytes(u.saltSize)),A=u.count,i=r.generateKey(o||"",L,3,A,20),O=e.hmac.create();O.start(c,i),O.update(t.toDer(C).getBytes());var M=O.getMac();k=t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(n.oids.sha1).getBytes()),t.create(t.Class.UNIVERSAL,t.Type.NULL,!1,"")]),t.create(t.Class.UNIVERSAL,t.Type.OCTETSTRING,!1,M.getBytes())]),t.create(t.Class.UNIVERSAL,t.Type.OCTETSTRING,!1,L.getBytes()),t.create(t.Class.UNIVERSAL,t.Type.INTEGER,!1,t.integerToDer(A).getBytes())])}return t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.INTEGER,!1,t.integerToDer(3).getBytes()),t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(n.oids.data).getBytes()),t.create(t.Class.CONTEXT_SPECIFIC,0,!0,[t.create(t.Class.UNIVERSAL,t.Type.OCTETSTRING,!1,t.toDer(C).getBytes())])]),k])},r.generateKey=e.pbe.generatePkcs12Key}var r="pkcs12";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/pkcs12",["require","module","./asn1","./hmac","./oids","./pkcs7asn1","./pbe","./random","./rsa","./sha1","./util","./x509"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){var t=e.asn1,n=e.pki=e.pki||{};n.pemToDer=function(t){var n=e.pem.decode(t)[0];if(n.procType&&n.procType.type==="ENCRYPTED")throw{message:"Could not convert PEM to DER; PEM is encrypted."};return e.util.createBuffer(n.body)},n.privateKeyFromPem=function(r){var i=e.pem.decode(r)[0];if(i.type!=="PRIVATE KEY"&&i.type!=="RSA PRIVATE KEY")throw{message:'Could not convert private key from PEM; PEM header type is not "PRIVATE KEY" or "RSA PRIVATE KEY".',headerType:i.type};if(i.procType&&i.procType.type==="ENCRYPTED")throw{message:"Could not convert private key from PEM; PEM is encrypted."};var s=t.fromDer(i.body);return n.privateKeyFromAsn1(s)},n.privateKeyToPem=function(r,i){var s={type:"RSA PRIVATE KEY",body:t.toDer(n.privateKeyToAsn1(r)).getBytes()};return e.pem.encode(s,{maxline:i})}}var r="pki";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/pki",["require","module","./asn1","./oids","./pbe","./pem","./pbkdf2","./pkcs12","./pss","./rsa","./util","./x509"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){var t=function(t,n,r,i){var s=e.util.createBuffer(),o=t.length>>1,u=o+(t.length&1),a=t.substr(0,u),f=t.substr(o,u),l=e.util.createBuffer(),c=e.hmac.create();r=n+r;var h=Math.ceil(i/16),p=Math.ceil(i/20);c.start("MD5",a);var d=e.util.createBuffer();l.putBytes(r);for(var v=0;v<h;++v)c.start(null,null),c.update(l.getBytes()),l.putBuffer(c.digest()),c.start(null,null),c.update(l.bytes()+r),d.putBuffer(c.digest());c.start("SHA1",f);var m=e.util.createBuffer();l.clear(),l.putBytes(r);for(var v=0;v<p;++v)c.start(null,null),c.update(l.getBytes()),l.putBuffer(c.digest()),c.start(null,null),c.update(l.bytes()+r),m.putBuffer(c.digest());return s.putBytes(e.util.xorBytes(d.getBytes(),m.getBytes(),i)),s},n=function(e,t,n,r){},r=function(t,n,r){var i=e.hmac.create();i.start("SHA1",t);var s=e.util.createBuffer();return s.putInt32(n[0]),s.putInt32(n[1]),s.putByte(r.type),s.putByte(r.version.major),s.putByte(r.version.minor),s.putInt16(r.length),s.putBytes(r.fragment.bytes()),i.update(s.getBytes()),i.digest().getBytes()},i=function(t,n,r){var i=!1;try{var s=t.deflate(n.fragment.getBytes());n.fragment=e.util.createBuffer(s),n.length=s.length,i=!0}catch(o){}return i},s=function(t,n,r){var i=!1;try{var s=t.inflate(n.fragment.getBytes());n.fragment=e.util.createBuffer(s),n.length=s.length,i=!0}catch(o){}return i},o=function(t,n){var r=0;switch(n){case 1:r=t.getByte();break;case 2:r=t.getInt16();break;case 3:r=t.getInt24();break;case 4:r=t.getInt32()}return e.util.createBuffer(t.getBytes(r))},u=function(e,t,n){e.putInt(n.length(),t<<3),e.putBuffer(n)},a={};a.Version={major:3,minor:1},a.MaxFragment=15360,a.ConnectionEnd={server:0,client:1},a.PRFAlgorithm={tls_prf_sha256:0},a.BulkCipherAlgorithm={none:null,rc4:0,des3:1,aes:2},a.CipherType={stream:0,block:1,aead:2},a.MACAlgorithm={none:null,hmac_md5:0,hmac_sha1:1,hmac_sha256:2,hmac_sha384:3,hmac_sha512:4},a.CompressionMethod={none:0,deflate:1},a.ContentType={change_cipher_spec:20,alert:21,handshake:22,application_data:23},a.HandshakeType={hello_request:0,client_hello:1,server_hello:2,certificate:11,server_key_exchange:12,certificate_request:13,server_hello_done:14,certificate_verify:15,client_key_exchange:16,finished:20},a.Alert={},a.Alert.Level={warning:1,fatal:2},a.Alert.Description={close_notify:0,unexpected_message:10,bad_record_mac:20,decryption_failed:21,record_overflow:22,decompression_failure:30,handshake_failure:40,bad_certificate:42,unsupported_certificate:43,certificate_revoked:44,certificate_expired:45,certificate_unknown:46,illegal_parameter:47,unknown_ca:48,access_denied:49,decode_error:50,decrypt_error:51,export_restriction:60,protocol_version:70,insufficient_security:71,internal_error:80,user_canceled:90,no_renegotiation:100},a.CipherSuites={},a.getCipherSuite=function(e){var t=null;for(var n in a.CipherSuites){var r=a.CipherSuites[n];if(r.id[0]===e.charCodeAt(0)&&r.id[1]===e.charCodeAt(1)){t=r;break}}return t},a.handleUnexpected=function(e,t){var n=!e.open&&e.entity===a.ConnectionEnd.client;n||e.error(e,{message:"Unexpected message. Received TLS record out of order.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.unexpected_message}})},a.handleHelloRequest=function(e,t,n){!e.handshaking&&e.handshakes>0&&(a.queue(e,a.createAlert({level:a.Alert.Level.warning,description:a.Alert.Description.no_renegotiation})),a.flush(e)),e.process()},a.parseHelloMessage=function(t,n,r){var i=null,s=t.entity===a.ConnectionEnd.client;if(r<38)t.error(t,{message:s?"Invalid ServerHello message. Message too short.":"Invalid ClientHello message. Message too short.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.illegal_parameter}});else{var u=n.fragment,f=u.length();i={version:{major:u.getByte(),minor:u.getByte()},random:e.util.createBuffer(u.getBytes(32)),session_id:o(u,1),extensions:[]},s?(i.cipher_suite=u.getBytes(2),i.compression_method=u.getByte()):(i.cipher_suites=o(u,2),i.compression_methods=o(u,1)),f=r-(f-u.length());if(f>0){var l=o(u,2);while(l.length()>0)i.extensions.push({type:[l.getByte(),l.getByte()],data:o(l,2)});if(!s)for(var c=0;c<i.extensions.length;++c){var h=i.extensions[c];if(h.type[0]===0&&h.type[1]===0){var p=o(h.data,2);while(p.length()>0){var d=p.getByte();if(d!==0)break;t.session.serverNameList.push(o(p,2).getBytes())}}}}(i.version.major!==a.Version.major||i.version.minor!==a.Version.minor)&&t.error(t,{message:"Incompatible TLS version.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.protocol_version}});if(s)t.session.cipherSuite=a.getCipherSuite(i.cipher_suite);else{var v=e.util.createBuffer(i.cipher_suites.bytes());while(v.length()>0){t.session.cipherSuite=a.getCipherSuite(v.getBytes(2));if(t.session.cipherSuite!==null)break}}if(t.session.cipherSuite===null)return t.error(t,{message:"No cipher suites in common.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.handshake_failure},cipherSuite:e.util.bytesToHex(i.cipher_suite)});s?t.session.compressionMethod=i.compression_method:t.session.compressionMethod=a.CompressionMethod.none}return i},a.createSecurityParameters=function(e,t){var n=e.entity===a.ConnectionEnd.client,r=t.random.bytes(),i=n?e.session.sp.client_random:r,s=n?r:a.createRandom().getBytes();e.session.sp={entity:e.entity,prf_algorithm:a.PRFAlgorithm.tls_prf_sha256,bulk_cipher_algorithm:null,cipher_type:null,enc_key_length:null,block_length:null,fixed_iv_length:null,record_iv_length:null,mac_algorithm:null,mac_length:null,mac_key_length:null,compression_algorithm:e.session.compressionMethod,pre_master_secret:null,master_secret:null,client_random:i,server_random:s}},a.handleServerHello=function(e,t,n){var r=a.parseHelloMessage(e,t,n);if(!e.fail){var i=r.session_id.bytes();i.length>0&&i===e.session.id?(e.expect=d,e.session.resuming=!0,e.session.sp.server_random=r.random.bytes()):(e.expect=l,e.session.resuming=!1,a.createSecurityParameters(e,r)),e.session.id=i,e.process()}},a.handleClientHello=function(t,n,r){var i=a.parseHelloMessage(t,n,r);if(!t.fail){var s=i.session_id.bytes(),o=null;t.sessionCache&&(o=t.sessionCache.getSession(s),o===null&&(s="")),s.length===0&&(s=e.random.getBytes(32)),t.session.id=s,t.session.clientHelloVersion=i.version,t.session.sp=o?o.sp:{},o!==null?(t.expect=S,t.session.resuming=!0,t.session.sp.client_random=i.random.bytes()):(t.expect=t.verifyClient!==!1?b:w,t.session.resuming=!1,a.createSecurityParameters(t,i)),t.open=!0,a.queue(t,a.createRecord({type:a.ContentType.handshake,data:a.createServerHello(t)})),t.session.resuming?(a.queue(t,a.createRecord({type:a.ContentType.change_cipher_spec,data:a.createChangeCipherSpec()})),t.state.pending=a.createConnectionState(t),t.state.current.write=t.state.pending.write,a.queue(t,a.createRecord({type:a.ContentType.handshake,data:a.createFinished(t)}))):(a.queue(t,a.createRecord({type:a.ContentType.handshake,data:a.createCertificate(t)})),t.fail||(a.queue(t,a.createRecord({type:a.ContentType.handshake,data:a.createServerKeyExchange(t)})),t.verifyClient!==!1&&a.queue(t,a.createRecord({type:a.ContentType.handshake,data:a.createCertificateRequest(t)})),a.queue(t,a.createRecord({type:a.ContentType.handshake,data:a.createServerHelloDone(t)})))),a.flush(t),t.process()}},a.handleCertificate=function(t,n,r){if(r<3)t.error(t,{message:"Invalid Certificate message. Message too short.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.illegal_parameter}});else{var i=n.fragment,s={certificate_list:o(i,3)},u,f,l=[];try{while(s.certificate_list.length()>0)u=o(s.certificate_list,3),f=e.asn1.fromDer(u),u=e.pki.certificateFromAsn1(f,!0),l.push(u)}catch(h){t.error(t,{message:"Could not parse certificate list.",cause:h,send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.bad_certificate}})}if(!t.fail){var p=t.entity===a.ConnectionEnd.client;!p&&t.verifyClient!==!0||l.length!==0?l.length===0?t.expect=p?c:w:(p?t.session.serverCertificate=l[0]:t.session.clientCertificate=l[0],a.verifyCertificateChain(t,l)&&(t.expect=p?c:w)):t.error(t,{message:p?"No server certificate provided.":"No client certificate provided.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.illegal_parameter}}),t.process()}}},a.handleServerKeyExchange=function(e,t,n){n>0?e.error(e,{message:"Invalid key parameters. Only RSA is supported.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.unsupported_certificate}}):(e.expect=h,e.process())},a.handleClientKeyExchange=function(t,n,r){if(r<48)t.error(t,{message:"Invalid key parameters. Only RSA is supported.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.unsupported_certificate}});else{var i=n.fragment,s={enc_pre_master_secret:o(i,2).getBytes()},u=null;if(t.getPrivateKey)try{u=t.getPrivateKey(t,t.session.serverCertificate),u=e.pki.privateKeyFromPem(u)}catch(f){t.error(t,{message:"Could not get private key.",cause:f,send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.internal_error}})}if(u===null)t.error(t,{message:"No private key set.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.internal_error}});else try{var l=t.session.sp;l.pre_master_secret=u.decrypt(s.enc_pre_master_secret);var c=t.session.clientHelloVersion;if(c.major!==l.pre_master_secret.charCodeAt(0)||c.minor!==l.pre_master_secret.charCodeAt(1))throw{message:"TLS version rollback attack detected."}}catch(f){l.pre_master_secret=e.random.getBytes(48)}}t.fail||(t.expect=S,t.session.clientCertificate!==null&&(t.expect=E),t.process())},a.handleCertificateRequest=function(e,t,n){if(n<3)e.error(e,{message:"Invalid CertificateRequest. Message too short.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.illegal_parameter}});else{var r=t.fragment,i={certificate_types:o(r,1),certificate_authorities:o(r,2)};e.session.certificateRequest=i,e.expect=p,e.process()}},a.handleCertificateVerify=function(t,n,r){if(r<2)t.error(t,{message:"Invalid CertificateVerify. Message too short.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.illegal_parameter}});else{var i=n.fragment;i.read-=4;var s=i.bytes();i.read+=4;var u={signature:o(i,2).getBytes()},f=e.util.createBuffer();f.putBuffer(t.session.md5.digest()),f.putBuffer(t.session.sha1.digest()),f=f.getBytes();try{var l=t.session.clientCertificate;if(!l.publicKey.verify(f,u.signature,"NONE"))throw{message:"CertificateVerify signature does not match."};t.session.md5.update(s),t.session.sha1.update(s)}catch(c){t.error(t,{message:"Bad signature in CertificateVerify.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.handshake_failure}})}t.fail||(t.expect=S,t.process())}},a.handleServerHelloDone=function(t,n,r){if(r>0)t.error(t,{message:"Invalid ServerHelloDone message. Invalid length.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.record_overflow}});else if(t.serverCertificate===null){var i={message:"No server certificate provided. Not enough security.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.insufficient_security}},s=t.verify(t,i.alert.description,depth,[]);if(s===!0)i=null;else{if(s||s===0)typeof s=="object"&&!e.util.isArray(s)?(s.message&&(i.message=s.message),s.alert&&(i.alert.description=s.alert)):typeof s=="number"&&(i.alert.description=s);t.error(t,i)}}!t.fail&&t.session.certificateRequest!==null&&(n=a.createRecord({type:a.ContentType.handshake,data:a.createCertificate(t)}),a.queue(t,n));if(!t.fail){n=a.createRecord({type:a.ContentType.handshake,data:a.createClientKeyExchange(t)}),a.queue(t,n),t.expect=g;var o=function(e,t){e.session.certificateRequest!==null&&e.session.clientCertificate!==null&&a.queue(e,a.createRecord({type:a.ContentType.handshake,data:a.createCertificateVerify(e,t)})),a.queue(e,a.createRecord({type:a.ContentType.change_cipher_spec,data:a.createChangeCipherSpec()})),e.state.pending=a.createConnectionState(e),e.state.current.write=e.state.pending.write,a.queue(e,a.createRecord({type:a.ContentType.handshake,data:a.createFinished(e)})),e.expect=d,a.flush(e),e.process()};t.session.certificateRequest===null||t.session.clientCertificate===null?o(t,null):a.getClientSignature(t,o)}},a.handleChangeCipherSpec=function(e,t){if(t.fragment.getByte()!==1)e.error(e,{message:"Invalid ChangeCipherSpec message received.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.illegal_parameter}});else{var n=e.entity===a.ConnectionEnd.client;if(e.session.resuming&&n||!e.session.resuming&&!n)e.state.pending=a.createConnectionState(e);e.state.current.read=e.state.pending.read;if(!e.session.resuming&&n||e.session.resuming&&!n)e.state.pending=null;e.expect=n?v:x,e.process()}},a.handleFinished=function(n,r,i){var s=r.fragment;s.read-=4;var o=s.bytes();s.read+=4;var u=r.fragment.getBytes();s=e.util.createBuffer(),s.putBuffer(n.session.md5.digest()),s.putBuffer(n.session.sha1.digest());var f=n.entity===a.ConnectionEnd.client,l=f?"server finished":"client finished",c=n.session.sp,h=12,p=t;s=p(c.master_secret,l,s.getBytes(),h);if(s.getBytes()!==u)n.error(n,{message:"Invalid verify_data in Finished message.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.decrypt_error}});else{n.session.md5.update(o),n.session.sha1.update(o);if(n.session.resuming&&f||!n.session.resuming&&!f)a.queue(n,a.createRecord({type:a.ContentType.change_cipher_spec,data:a.createChangeCipherSpec()})),n.state.current.write=n.state.pending.write,n.state.pending=null,a.queue(n,a.createRecord({type:a.ContentType.handshake,data:a.createFinished(n)}));n.expect=f?m:T,n.handshaking=!1,++n.handshakes,n.peerCertificate=f?n.session.serverCertificate:n.session.clientCertificate,n.sessionCache?(n.session={id:n.session.id,sp:n.session.sp},n.session.sp.keys=null):n.session=null,a.flush(n),n.isConnected=!0,n.connected(n),n.process()}},a.handleAlert=function(e,t){var n=t.fragment,r={level:n.getByte(),description:n.getByte()},i;switch(r.description){case a.Alert.Description.close_notify:i="Connection closed.";break;case a.Alert.Description.unexpected_message:i="Unexpected message.";break;case a.Alert.Description.bad_record_mac:i="Bad record MAC.";break;case a.Alert.Description.decryption_failed:i="Decryption failed.";break;case a.Alert.Description.record_overflow:i="Record overflow.";break;case a.Alert.Description.decompression_failure:i="Decompression failed.";break;case a.Alert.Description.handshake_failure:i="Handshake failure.";break;case a.Alert.Description.bad_certificate:i="Bad certificate.";break;case a.Alert.Description.unsupported_certificate:i="Unsupported certificate.";break;case a.Alert.Description.certificate_revoked:i="Certificate revoked.";break;case a.Alert.Description.certificate_expired:i="Certificate expired.";break;case a.Alert.Description.certificate_unknown:i="Certificate unknown.";break;case a.Alert.Description.illegal_parameter:i="Illegal parameter.";break;case a.Alert.Description.unknown_ca:i="Unknown certificate authority.";break;case a.Alert.Description.access_denied:i="Access denied.";break;case a.Alert.Description.decode_error:i="Decode error.";break;case a.Alert.Description.decrypt_error:i="Decrypt error.";break;case a.Alert.Description.export_restriction:i="Export restriction.";break;case a.Alert.Description.protocol_version:i="Unsupported protocol version.";break;case a.Alert.Description.insufficient_security:i="Insufficient security.";break;case a.Alert.Description.internal_error:i="Internal error.";break;case a.Alert.Description.user_canceled:i="User canceled.";break;case a.Alert.Description.no_renegotiation:i="Renegotiation not supported.";break;default:i="Unknown error."}r.description===a.Alert.Description.close_notify?e.close():(e.error(e,{message:i,send:!1,origin:e.entity===a.ConnectionEnd.client?"server":"client",alert:r}),e.process())},a.handleHandshake=function(t,n){var r=n.fragment,i=r.getByte(),s=r.getInt24();if(s>r.length())t.fragmented=n,n.fragment=e.util.createBuffer(),r.read-=4,t.process();else{t.fragmented=null,r.read-=4;var o=r.bytes(s+4);r.read+=4,i in I[t.entity][t.expect]?(t.entity===a.ConnectionEnd.server&&!t.open&&!t.fail&&(t.handshaking=!0,t.session={serverNameList:[],cipherSuite:null,compressionMethod:null,serverCertificate:null,clientCertificate:null,md5:e.md.md5.create(),sha1:e.md.sha1.create()}),i!==a.HandshakeType.hello_request&&i!==a.HandshakeType.certificate_verify&&i!==a.HandshakeType.finished&&(t.session.md5.update(o),t.session.sha1.update(o)),I[t.entity][t.expect][i](t,n,s)):a.handleUnexpected(t,n)}},a.handleApplicationData=function(e,t){e.data.putBuffer(t.fragment),e.dataReady(e),e.process()};var f=0,l=1,c=2,h=3,p=4,d=5,v=6,m=7,g=8,y=0,b=1,w=2,E=3,S=4,x=5,T=6,N=7,C=a.handleUnexpected,k=a.handleChangeCipherSpec,L=a.handleAlert,A=a.handleHandshake,O=a.handleApplicationData,M=[];M[a.ConnectionEnd.client]=[[C,L,A,C],[C,L,A,C],[C,L,A,C],[C,L,A,C],[C,L,A,C],[k,L,C,C],[C,L,A,C],[C,L,A,O],[C,L,A,C]],M[a.ConnectionEnd.server]=[[C,L,A,C],[C,L,A,C],[C,L,A,C],[C,L,A,C],[k,L,C,C],[C,L,A,C],[C,L,A,O],[C,L,A,C]];var _=a.handleHelloRequest,D=a.handleServerHello,P=a.handleCertificate,H=a.handleServerKeyExchange,B=a.handleCertificateRequest,j=a.handleServerHelloDone,F=a.handleFinished,I=[];I[a.ConnectionEnd.client]=[[C,C,D,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C],[_,C,C,C,C,C,C,C,C,C,C,P,H,B,j,C,C,C,C,C,C],[_,C,C,C,C,C,C,C,C,C,C,C,H,B,j,C,C,C,C,C,C],[_,C,C,C,C,C,C,C,C,C,C,C,C,B,j,C,C,C,C,C,C],[_,C,C,C,C,C,C,C,C,C,C,C,C,C,j,C,C,C,C,C,C],[_,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C],[_,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,F],[_,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C],[_,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C]];var q=a.handleClientHello,R=a.handleClientKeyExchange,U=a.handleCertificateVerify;I[a.ConnectionEnd.server]=[[C,q,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C],[C,C,C,C,C,C,C,C,C,C,C,P,C,C,C,C,C,C,C,C,C],[C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,R,C,C,C,C],[C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,U,C,C,C,C,C],[C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C],[C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,F],[C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C],[C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C]],a.generateKeys=function(e,n){var r=t,i=n.client_random+n.server_random;e.session.resuming||(n.master_secret=r(n.pre_master_secret,"master secret",i,48).bytes(),n.pre_master_secret=null),i=n.server_random+n.client_random;var s=2*n.mac_key_length+2*n.enc_key_length+2*n.fixed_iv_length,o=r(n.master_secret,"key expansion",i,s);return{client_write_MAC_key:o.getBytes(n.mac_key_length),server_write_MAC_key:o.getBytes(n.mac_key_length),client_write_key:o.getBytes(n.enc_key_length),server_write_key:o.getBytes(n.enc_key_length),client_write_IV:o.getBytes(n.fixed_iv_length),server_write_IV:o.getBytes(n.fixed_iv_length)}},a.createConnectionState=function(e){var t=e.entity===a.ConnectionEnd.client,n=function(){var e={sequenceNumber:[0,0],macKey:null,macLength:0,macFunction:null,cipherState:null,cipherFunction:function(e){return!0},compressionState:null,compressFunction:function(e){return!0},updateSequenceNumber:function(){e.sequenceNumber[1]===4294967295?(e.sequenceNumber[1]=0,++e.sequenceNumber[0]):++e.sequenceNumber[1]}};return e},r={read:n(),write:n()};r.read.update=function(e,t){return r.read.cipherFunction(t,r.read)?r.read.compressFunction(e,t,r.read)||e.error(e,{message:"Could not decompress record.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.decompression_failure}}):e.error(e,{message:"Could not decrypt record or bad MAC.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.bad_record_mac}}),!e.fail},r.write.update=function(e,t){return r.write.compressFunction(e,t,r.write)?r.write.cipherFunction(t,r.write)||e.error(e,{message:"Could not encrypt record.",send:!1,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.internal_error}}):e.error(e,{message:"Could not compress record.",send:!1,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.internal_error}}),!e.fail};if(e.session){var o=e.session.sp;e.session.cipherSuite.initSecurityParameters(o),o.keys=a.generateKeys(e,o),r.read.macKey=t?o.keys.server_write_MAC_key:o.keys.client_write_MAC_key,r.write.macKey=t?o.keys.client_write_MAC_key:o.keys.server_write_MAC_key,e.session.cipherSuite.initConnectionState(r,e,o);switch(o.compression_algorithm){case a.CompressionMethod.none:break;case a.CompressionMethod.deflate:r.read.compressFunction=s,r.write.compressFunction=i;break;default:throw{message:"Unsupported compression algorithm."}}}return r},a.createRandom=function(){var t=new Date,n=+t+t.getTimezoneOffset()*6e4,r=e.util.createBuffer();return r.putInt32(n),r.putBytes(e.random.getBytes(28)),r},a.createRecord=function(e){if(!e.data)return null;var t={type:e.type,version:{major:a.Version.major,minor:a.Version.minor},length:e.data.length(),fragment:e.data};return t},a.createAlert=function(t){var n=e.util.createBuffer();return n.putByte(t.level),n.putByte(t.description),a.createRecord({type:a.ContentType.alert,data:n})},a.createClientHello=function(t){var n=e.util.createBuffer();for(var r=0;r<t.cipherSuites.length;++r){var i=t.cipherSuites[r];n.putByte(i.id[0]),n.putByte(i.id[1])}var s=n.length(),o=e.util.createBuffer();o.putByte(a.CompressionMethod.none);var f=o.length(),l=e.util.createBuffer();if(t.virtualHost){var c=e.util.createBuffer();c.putByte(0),c.putByte(0);var h=e.util.createBuffer();h.putByte(0),u(h,2,e.util.createBuffer(t.virtualHost));var p=e.util.createBuffer();u(p,2,h),u(c,2,p),l.putBuffer(c)}var d=l.length();d>0&&(d+=2);var v=t.session.id,m=v.length+1+2+4+28+2+s+1+f+d,g=e.util.createBuffer();return g.putByte(a.HandshakeType.client_hello),g.putInt24(m),g.putByte(a.Version.major),g.putByte(a.Version.minor),g.putBytes(t.session.sp.client_random),u(g,1,e.util.createBuffer(v)),u(g,2,n),u(g,1,o),d>0&&u(g,2,l),g},a.createServerHello=function(t){var n=t.session.id,r=n.length+1+2+4+28+2+1,i=e.util.createBuffer();return i.putByte(a.HandshakeType.server_hello),i.putInt24(r),i.putByte(a.Version.major),i.putByte(a.Version.minor),i.putBytes(t.session.sp.server_random),u(i,1,e.util.createBuffer(n)),i.putByte(t.session.cipherSuite.id[0]),i.putByte(t.session.cipherSuite.id[1]),i.putByte(t.session.compressionMethod),i},a.createCertificate=function(t){var n=t.entity===a.ConnectionEnd.client,r=null;t.getCertificate&&(r=t.getCertificate(t,n?t.session.certificateRequest:t.session.serverNameList));var i=e.util.createBuffer();if(r!==null)try{e.util.isArray(r)||(r=[r]);var s=null;for(var o=0;o<r.length;++o){var f=e.pem.decode(r[o])[0];if(f.type!=="CERTIFICATE"&&f.type!=="X509 CERTIFICATE"&&f.type!=="TRUSTED CERTIFICATE")throw{message:'Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".',headerType:f.type};if(f.procType&&f.procType.type==="ENCRYPTED")throw{message:"Could not convert certificate from PEM; PEM is encrypted."};var l=e.util.createBuffer(f.body);s===null&&(s=e.asn1.fromDer(l.bytes(),!1));var c=e.util.createBuffer();u(c,3,l),i.putBuffer(c)}r=e.pki.certificateFromAsn1(s),n?t.session.clientCertificate=r:t.session.serverCertificate=r}catch(h){return t.error(t,{message:"Could not send certificate list.",cause:h,send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.bad_certificate}})}var p=3+i.length(),d=e.util.createBuffer();return d.putByte(a.HandshakeType.certificate),d.putInt24(p),u(d,3,i),d},a.createClientKeyExchange=function(t){var n=e.util.createBuffer();n.putByte(a.Version.major),n.putByte(a.Version.minor),n.putBytes(e.random.getBytes(46));var r=t.session.sp;r.pre_master_secret=n.getBytes();var i=t.session.serverCertificate.publicKey;n=i.encrypt(r.pre_master_secret);var s=n.length+2,o=e.util.createBuffer();return o.putByte(a.HandshakeType.client_key_exchange),o.putInt24(s),o.putInt16(n.length),o.putBytes(n),o},a.createServerKeyExchange=function(t){var n=0,r=e.util.createBuffer();return n>0&&(r.putByte(a.HandshakeType.server_key_exchange),r.putInt24(n)),r},a.getClientSignature=function(t,n){var r=e.util.createBuffer();r.putBuffer(t.session.md5.digest()),r.putBuffer(t.session.sha1.digest()),r=r.getBytes(),t.getSignature=t.getSignature||function(t,n,r){var i=null;if(t.getPrivateKey)try{i=t.getPrivateKey(t,t.session.clientCertificate),i=e.pki.privateKeyFromPem(i)}catch(s){t.error(t,{message:"Could not get private key.",cause:s,send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.internal_error}})}i===null?t.error(t,{message:"No private key set.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.internal_error}}):n=i.sign(n,null),r(t,n)},t.getSignature(t,r,n)},a.createCertificateVerify=function(t,n){var r=n.length+2,i=e.util.createBuffer();return i.putByte(a.HandshakeType.certificate_verify),i.putInt24(r),i.putInt16(n.length),i.putBytes(n),i},a.createCertificateRequest=function(t){var n=e.util.createBuffer();n.putByte(1);var r=e.util.createBuffer();for(var i in t.caStore.certs){var s=t.caStore.certs[i],o=e.pki.distinguishedNameToAsn1(s.subject);r.putBuffer(e.asn1.toDer(o))}var f=1+n.length()+2+r.length(),l=e.util.createBuffer();return l.putByte(a.HandshakeType.certificate_request),l.putInt24(f),u(l,1,n),u(l,2,r),l},a.createServerHelloDone=function(t){var n=e.util.createBuffer();return n.putByte(a.HandshakeType.server_hello_done),n.putInt24(0),n},a.createChangeCipherSpec=function(){var t=e.util.createBuffer();return t.putByte(1),t},a.createFinished=function(n){var r=e.util.createBuffer();r.putBuffer(n.session.md5.digest()),r.putBuffer(n.session.sha1.digest());var i=n.entity===a.ConnectionEnd.client,s=n.session.sp,o=12,u=t,f=i?"client finished":"server finished";r=u(s.master_secret,f,r.getBytes(),o);var l=e.util.createBuffer();return l.putByte(a.HandshakeType.finished),l.putInt24(r.length()),l.putBuffer(r),l},a.queue=function(t,n){if(!n)return;if(n.type===a.ContentType.handshake){var r=n.fragment.bytes();t.session.md5.update(r),t.session.sha1.update(r),r=null}var i;if(n.fragment.length()<=a.MaxFragment)i=[n];else{i=[];var s=n.fragment.bytes();while(s.length>a.MaxFragment)i.push(a.createRecord({type:n.type,data:e.util.createBuffer(s.slice(0,a.MaxFragment))})),s=s.slice(a.MaxFragment);s.length>0&&i.push(a.createRecord({type:n.type,data:e.util.createBuffer(s)}))}for(var o=0;o<i.length&&!t.fail;++o){var u=i[o],f=t.state.current.write;f.update(t,u)&&t.records.push(u)}},a.flush=function(e){for(var t=0;t<e.records.length;++t){var n=e.records[t];e.tlsData.putByte(n.type),e.tlsData.putByte(n.version.major),e.tlsData.putByte(n.version.minor),e.tlsData.putInt16(n.fragment.length()),e.tlsData.putBuffer(e.records[t].fragment)}return e.records=[],e.tlsDataReady(e)};var z=function(t){switch(t){case!0:return!0;case e.pki.certificateError.bad_certificate:return a.Alert.Description.bad_certificate;case e.pki.certificateError.unsupported_certificate:return a.Alert.Description.unsupported_certificate;case e.pki.certificateError.certificate_revoked:return a.Alert.Description.certificate_revoked;case e.pki.certificateError.certificate_expired:return a.Alert.Description.certificate_expired;case e.pki.certificateError.certificate_unknown:return a.Alert.Description.certificate_unknown;case e.pki.certificateError.unknown_ca:return a.Alert.Description.unknown_ca;default:return a.Alert.Description.bad_certificate}},W=function(t){switch(t){case!0:return!0;case a.Alert.Description.bad_certificate:return e.pki.certificateError.bad_certificate;case a.Alert.Description.unsupported_certificate:return e.pki.certificateError.unsupported_certificate;case a.Alert.Description.certificate_revoked:return e.pki.certificateError.certificate_revoked;case a.Alert.Description.certificate_expired:return e.pki.certificateError.certificate_expired;case a.Alert.Description.certificate_unknown:return e.pki.certificateError.certificate_unknown;case a.Alert.Description.unknown_ca:return e.pki.certificateError.unknown_ca;default:return e.pki.certificateError.bad_certificate}};a.verifyCertificateChain=function(t,n){try{e.pki.verifyCertificateChain(t.caStore,n,function(r,i,s){var o=z(r),u=t.verify(t,r,i,s);if(u!==!0){if(typeof u=="object"&&!e.util.isArray(u)){var f={message:"The application rejected the certificate.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.bad_certificate}};throw u.message&&(f.message=u.message),u.alert&&(f.alert.description=u.alert),f}u!==r&&(u=W(u))}return u})}catch(r){if(typeof r!="object"||e.util.isArray(r))r={send:!0,alert:{level:a.Alert.Level.fatal,description:z(r)}};"send"in r||(r.send=!0),"alert"in r||(r.alert={level:a.Alert.Level.fatal,description:z(r.error)}),t.error(t,r)}return!t.fail},a.createSessionCache=function(t,n){var r=null;if(t&&t.getSession&&t.setSession&&t.order)r=t;else{r={},r.cache=t||{},r.capacity=Math.max(n||100,1),r.order=[];for(var i in t)r.order.length<=n?r.order.push(i):delete t[i];r.getSession=function(t){var n=null,i=null;t?i=e.util.bytesToHex(t):r.order.length>0&&(i=r.order[0]);if(i!==null&&i in r.cache){n=r.cache[i],delete r.cache[i];for(var s in r.order)if(r.order[s]===i){r.order.splice(s,1);break}}return n},r.setSession=function(t,n){if(r.order.length===r.capacity){var i=r.order.shift();delete r.cache[i]}var i=e.util.bytesToHex(t);r.order.push(i),r.cache[i]=n}}return r},a.createConnection=function(t){var n=null;t.caStore?e.util.isArray(t.caStore)?n=e.pki.createCaStore(t.caStore):n=t.caStore:n=e.pki.createCaStore();var r=t.cipherSuites||null;if(r===null){r=[];for(var i in a.CipherSuites)r.push(a.CipherSuites[i])}var s=t.server||!1?a.ConnectionEnd.server:a.ConnectionEnd.client,o=t.sessionCache?a.createSessionCache(t.sessionCache):null,u={entity:s,sessionId:t.sessionId,caStore:n,sessionCache:o,cipherSuites:r,connected:t.connected,virtualHost:t.virtualHost||null,verifyClient:t.verifyClient||!1,verify:t.verify||function(e,t,n,r){return t},getCertificate:t.getCertificate||null,getPrivateKey:t.getPrivateKey||null,getSignature:t.getSignature||null,input:e.util.createBuffer(),tlsData:e.util.createBuffer(),data:e.util.createBuffer(),tlsDataReady:t.tlsDataReady,dataReady:t.dataReady,closed:t.closed,error:function(e,n){n.origin=n.origin||(e.entity===a.ConnectionEnd.client?"client":"server"),n.send&&(a.queue(e,a.createAlert(n.alert)),a.flush(e));var r=n.fatal!==!1;r&&(e.fail=!0),t.error(e,n),r&&e.close(!1)},deflate:t.deflate||null,inflate:t.inflate||null};u.reset=function(e){u.record=null,u.session=null,u.peerCertificate=null,u.state={pending:null,current:null},u.expect=u.entity===a.ConnectionEnd.client?f:y,u.fragmented=null,u.records=[],u.open=!1,u.handshakes=0,u.handshaking=!1,u.isConnected=!1,u.fail=!e&&typeof e!="undefined",u.input.clear(),u.tlsData.clear(),u.data.clear(),u.state.current=a.createConnectionState(u)},u.reset();var l=function(e,t){var n=t.type-a.ContentType.change_cipher_spec,r=M[e.entity][e.expect];n in r?r[n](e,t):a.handleUnexpected(e,t)},c=function(t){var n=0,r=t.input,i=r.length();return i<5?n=5-i:(t.record={type:r.getByte(),version:{major:r.getByte(),minor:r.getByte()},length:r.getInt16(),fragment:e.util.createBuffer(),ready:!1},(t.record.version.major!==a.Version.major||t.record.version.minor!==a.Version.minor)&&t.error(t,{message:"Incompatible TLS version.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.protocol_version}})),n},h=function(e){var t=0,n=e.input,r=n.length();if(r<e.record.length)t=e.record.length-r;else{e.record.fragment.putBytes(n.getBytes(e.record.length)),n.compact();var i=e.state.current.read;i.update(e,e.record)&&(e.fragmented!==null&&(e.fragmented.type===e.record.type?(e.fragmented.fragment.putBuffer(e.record.fragment),e.record=e.fragmented):e.error(e,{message:"Invalid fragmented record.",send:!0,alert:{level:a.Alert.Level.fatal,description:a.Alert.Description.unexpected_message}})),e.record.ready=!0)}return t};return u.handshake=function(t){if(u.entity!==a.ConnectionEnd.client)u.error(u,{message:"Cannot initiate handshake as a server.",fatal:!1});else if(u.handshaking)u.error(u,{message:"Handshake already in progress.",fatal:!1});else{u.fail&&!u.open&&u.handshakes===0&&(u.fail=!1),u.handshaking=!0,t=t||"";var n=null;t.length>0&&(u.sessionCache&&(n=u.sessionCache.getSession(t)),n===null&&(t="")),t.length===0&&u.sessionCache&&(n=u.sessionCache.getSession(),n!==null&&(t=n.id)),u.session={id:t,cipherSuite:null,compressionMethod:null,serverCertificate:null,certificateRequest:null,clientCertificate:null,sp:n?n.sp:{},md5:e.md.md5.create(),sha1:e.md.sha1.create()},u.session.sp.client_random=a.createRandom().getBytes(),u.open=!0,a.queue(u,a.createRecord({type:a.ContentType.handshake,data:a.createClientHello(u)})),a.flush(u)}},u.process=function(e){var t=0;return e&&u.input.putBytes(e),u.fail||(u.record!==null&&u.record.ready&&u.record.fragment.isEmpty()&&(u.record=null),u.record===null&&(t=c(u)),!u.fail&&u.record!==null&&!u.record.ready&&(t=h(u)),!u.fail&&u.record!==null&&u.record.ready&&l(u,u.record)),t},u.prepare=function(t){return a.queue(u,a.createRecord({type:a.ContentType.application_data,data:e.util.createBuffer(t)})),a.flush(u)},u.close=function(e){!u.fail&&u.sessionCache&&u.session&&u.sessionCache.setSession(u.session.id,u.session);if(u.open){u.open=!1,u.input.clear();if(u.isConnected||u.handshaking)u.isConnected=u.handshaking=!1,a.queue(u,a.createAlert({level:a.Alert.Level.warning,description:a.Alert.Description.close_notify})),a.flush(u);u.closed(u)}u.reset(e)},u},e.tls=e.tls||{};for(var X in a)typeof a[X]!="function"&&(e.tls[X]=a[X]);e.tls.prf_tls1=t,e.tls.hmac_sha1=r,e.tls.createSessionCache=a.createSessionCache,e.tls.createConnection=a.createConnection}var r="tls";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/tls",["require","module","./asn1","./hmac","./md","./pem","./pki","./random","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){function n(n,i,s){var u=i.entity===e.tls.ConnectionEnd.client;n.read.cipherState={init:!1,cipher:e.aes.createDecryptionCipher(u?s.keys.server_write_key:s.keys.client_write_key),iv:u?s.keys.server_write_IV:s.keys.client_write_IV},n.write.cipherState={init:!1,cipher:e.aes.createEncryptionCipher(u?s.keys.client_write_key:s.keys.server_write_key),iv:u?s.keys.client_write_IV:s.keys.server_write_IV},n.read.cipherFunction=o,n.write.cipherFunction=r,n.read.macLength=n.write.macLength=s.mac_length,n.read.macFunction=n.write.macFunction=t.hmac_sha1}function r(t,n){var r=!1,s=n.macFunction(n.macKey,n.sequenceNumber,t);t.fragment.putBytes(s),n.updateSequenceNumber();var o;t.version.minor>1?o=e.random.getBytes(16):o=n.cipherState.init?null:n.cipherState.iv,n.cipherState.init=!0;var u=n.cipherState.cipher;return u.start(o),t.version.minor>1&&u.output.putBytes(o),u.update(t.fragment),u.finish(i)&&(t.fragment=u.output,t.length=t.fragment.length(),r=!0),r}function i(e,t,n){if(!n){var r=e-t.length()%e;t.fillWithByte(r-1,r)}return!0}function s(e,t,n){var r=!0;if(n){var i=t.length(),s=t.last();for(var o=i-1-s;o<i-1;++o)r=r&&t.at(o)==s;r&&t.truncate(s+1)}return r}function o(t,n){var r=!1,i=n.cipherState.init?null:n.cipherState.iv;n.cipherState.init=!0;var o=n.cipherState.cipher;o.start(i),o.update(t.fragment),r=o.finish(s);var u=n.macLength,a="";for(var f=0;f<u;++f)a+=String.fromCharCode(0);var l=o.output.length();l>=u?(t.fragment=o.output.getBytes(l-u),a=o.output.getBytes(u)):t.fragment=o.output.getBytes(),t.fragment=e.util.createBuffer(t.fragment),t.length=t.fragment.length();var c=n.macFunction(n.macKey,n.sequenceNumber,t);return n.updateSequenceNumber(),r=c===a&&r,r}var t=e.tls;t.CipherSuites.TLS_RSA_WITH_AES_128_CBC_SHA={id:[0,47],name:"TLS_RSA_WITH_AES_128_CBC_SHA",initSecurityParameters:function(e){e.bulk_cipher_algorithm=t.BulkCipherAlgorithm.aes,e.cipher_type=t.CipherType.block,e.enc_key_length=16,e.block_length=16,e.fixed_iv_length=16,e.record_iv_length=16,e.mac_algorithm=t.MACAlgorithm.hmac_sha1,e.mac_length=20,e.mac_key_length=20},initConnectionState:n},t.CipherSuites.TLS_RSA_WITH_AES_256_CBC_SHA={id:[0,53],name:"TLS_RSA_WITH_AES_256_CBC_SHA",initSecurityParameters:function(e){e.bulk_cipher_algorithm=t.BulkCipherAlgorithm.aes,e.cipher_type=t.CipherType.block,e.enc_key_length=32,e.block_length=16,e.fixed_iv_length=16,e.record_iv_length=16,e.mac_algorithm=t.MACAlgorithm.hmac_sha1,e.mac_length=20,e.mac_key_length=20},initConnectionState:n}}var r="aesCipherSuites";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/aesCipherSuites",["require","module","./aes","./tls"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){e.debug=e.debug||{},e.debug.storage={},e.debug.get=function(t,n){var r;return typeof t=="undefined"?r=e.debug.storage:t in e.debug.storage&&(typeof n=="undefined"?r=e.debug.storage[t]:r=e.debug.storage[t][n]),r},e.debug.set=function(t,n,r){t in e.debug.storage||(e.debug.storage[t]={}),e.debug.storage[t][n]=r},e.debug.clear=function(t,n){typeof t=="undefined"?e.debug.storage={}:t in e.debug.storage&&(typeof n=="undefined"?delete e.debug.storage[t]:delete e.debug.storage[t][n])}}var r="debug";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/debug",["require","module"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){e.log=e.log||{},e.log.levels=["none","error","warning","info","debug","verbose","max"];var t={},n=[],r=null;e.log.LEVEL_LOCKED=2,e.log.NO_LEVEL_CHECK=4,e.log.INTERPOLATE=8;for(var i=0;i<e.log.levels.length;++i){var s=e.log.levels[i];t[s]={index:i,name:s.toUpperCase()}}e.log.logMessage=function(r){var i=t[r.level].index;for(var s=0;s<n.length;++s){var o=n[s];if(o.flags&e.log.NO_LEVEL_CHECK)o.f(r);else{var u=t[o.level].index;i<=u&&o.f(o,r)}}},e.log.prepareStandard=function(e){"standard"in e||(e.standard=t[e.level].name+" ["+e.category+"] "+e.message)},e.log.prepareFull=function(t){if(!("full"in t)){var n=[t.message];n=n.concat([]||t.arguments),t.full=e.util.format.apply(this,n)}},e.log.prepareStandardFull=function(t){"standardFull"in t||(e.log.prepareStandard(t),t.standardFull=t.standard)};var o=["error","warning","info","debug","verbose"];for(var i=0;i<o.length;++i)(function(t){e.log[t]=function(n,r){var i=Array.prototype.slice.call(arguments).slice(2),s={timestamp:new Date,level:t,category:n,message:r,arguments:i};e.log.logMessage(s)}})(o[i]);e.log.makeLogger=function(t){var n={flags:0,f:t};return e.log.setLevel(n,"none"),n},e.log.setLevel=function(t,n){var r=!1;if(t&&!(t.flags&e.log.LEVEL_LOCKED))for(var i=0;i<e.log.levels.length;++i){var s=e.log.levels[i];if(n==s){t.level=n,r=!0;break}}return r},e.log.lock=function(t,n){typeof n=="undefined"||n?t.flags|=e.log.LEVEL_LOCKED:t.flags&=~e.log.LEVEL_LOCKED},e.log.addLogger=function(e){n.push(e)};if(typeof console!="undefined"&&"log"in console){var u;if(console.error&&console.warn&&console.info&&console.debug){var a={error:console.error,warning:console.warn,info:console.info,debug:console.debug,verbose:console.debug},f=function(t,n){e.log.prepareStandard(n);var r=a[n.level],i=[n.standard];i=i.concat(n.arguments.slice()),r.apply(console,i)};u=e.log.makeLogger(f)}else{var f=function(t,n){e.log.prepareStandardFull(n),console.log(n.standardFull)};u=e.log.makeLogger(f)}e.log.setLevel(u,"debug"),e.log.addLogger(u),r=u}else console={log:function(){}};if(r!==null){var l=e.util.getQueryVariables();"console.level"in l&&e.log.setLevel(r,l["console.level"].slice(-1)[0]);if("console.lock"in l){var c=l["console.lock"].slice(-1)[0];c=="true"&&e.log.lock(r)}}e.log.consoleLogger=r}var r="log";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/log",["require","module","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){var t=e.asn1,n=e.pkcs7=e.pkcs7||{};n.messageFromPem=function(r){var i=e.pem.decode(r)[0];if(i.type!=="PKCS7")throw{message:'Could not convert PKCS#7 message from PEM; PEM header type is not "PKCS#7".',headerType:i.type};if(i.procType&&i.procType.type==="ENCRYPTED")throw{message:"Could not convert PKCS#7 message from PEM; PEM is encrypted."};var s=t.fromDer(i.body);return n.messageFromAsn1(s)},n.messageToPem=function(n,r){var i={type:"PKCS7",body:t.toDer(n.toAsn1()).getBytes()};return e.pem.encode(i,{maxline:r})},n.messageFromAsn1=function(r){var i={},s=[];if(!t.validate(r,n.asn1.contentInfoValidator,i,s))throw{message:"Cannot read PKCS#7 message. ASN.1 object is not an PKCS#7 ContentInfo.",errors:s};var o=t.derToOid(i.contentType),u;switch(o){case e.pki.oids.envelopedData:u=n.createEnvelopedData();break;case e.pki.oids.encryptedData:u=n.createEncryptedData();break;case e.pki.oids.signedData:u=n.createSignedData();break;default:throw{message:"Cannot read PKCS#7 message. ContentType with OID "+o+" is not (yet) supported."}}return u.fromAsn1(i.content.value[0]),u};var r=function(r){var i={},s=[];if(!t.validate(r,n.asn1.recipientInfoValidator,i,s))throw{message:"Cannot read PKCS#7 message. ASN.1 object is not an PKCS#7 EnvelopedData.",errors:s};return{version:i.version.charCodeAt(0),issuer:e.pki.RDNAttributesAsArray(i.issuer),serialNumber:e.util.createBuffer(i.serial).toHex(),encryptedContent:{algorithm:t.derToOid(i.encAlgorithm),parameter:i.encParameter.value,content:i.encKey}}},i=function(n){return t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.INTEGER,!1,t.integerToDer(n.version).getBytes()),t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[e.pki.distinguishedNameToAsn1({attributes:n.issuer}),t.create(t.Class.UNIVERSAL,t.Type.INTEGER,!1,e.util.hexToBytes(n.serialNumber))]),t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(n.encryptedContent.algorithm).getBytes()),t.create(t.Class.UNIVERSAL,t.Type.NULL,!1,"")]),t.create(t.Class.UNIVERSAL,t.Type.OCTETSTRING,!1,n.encryptedContent.content)])},s=function(e){var t=[];for(var n=0;n<e.length;n++)t.push(r(e[n]));return t},o=function(e){var t=[];for(var n=0;n<e.length;n++)t.push(i(e[n]));return t},u=function(n){return[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(e.pki.oids.data).getBytes()),t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(n.algorithm).getBytes()),t.create(t.Class.UNIVERSAL,t.Type.OCTETSTRING,!1,n.parameter.getBytes())]),t.create(t.Class.CONTEXT_SPECIFIC,0,!0,[t.create(t.Class.UNIVERSAL,t.Type.OCTETSTRING,!1,n.content.getBytes())])]},a=function(n,r,i){var s={},o=[];if(!t.validate(r,i,s,o))throw{message:"Cannot read PKCS#7 message. ASN.1 object is not a supported PKCS#7 message.",errors:o};var u=t.derToOid(s.contentType);if(u!==e.pki.oids.data)throw{message:"Unsupported PKCS#7 message. Only wrapped ContentType Data supported."};if(s.encryptedContent){var a="";if(e.util.isArray(s.encryptedContent))for(var f=0;f<s.encryptedContent.length;++f){if(s.encryptedContent[f].type!==t.Type.OCTETSTRING)throw{message:"Malformed PKCS#7 message, expecting encrypted content constructed of only OCTET STRING objects."};a+=s.encryptedContent[f].value}else a=s.encryptedContent;n.encryptedContent={algorithm:t.derToOid(s.encAlgorithm),parameter:e.util.createBuffer(s.encParameter.value),content:e.util.createBuffer(a)}}if(s.content){var a="";if(e.util.isArray(s.content))for(var f=0;f<s.content.length;++f){if(s.content[f].type!==t.Type.OCTETSTRING)throw{message:"Malformed PKCS#7 message, expecting content constructed of only OCTET STRING objects."};a+=s.content[f].value}else a=s.content;n.content=e.util.createBuffer(a)}return n.version=s.version.charCodeAt(0),n.rawCapture=s,s},f=function(t){if(t.encryptedContent.key===undefined)throw{message:"Symmetric key not available."};if(t.content===undefined){var n;switch(t.encryptedContent.algorithm){case e.pki.oids["aes128-CBC"]:case e.pki.oids["aes192-CBC"]:case e.pki.oids["aes256-CBC"]:n=e.aes.createDecryptionCipher(t.encryptedContent.key);break;case e.pki.oids.desCBC:case e.pki.oids["des-EDE3-CBC"]:n=e.des.createDecryptionCipher(t.encryptedContent.key);break;default:throw{message:"Unsupported symmetric cipher, OID "+t.encryptedContent.algorithm}}n.start(t.encryptedContent.parameter),n.update(t.encryptedContent.content);if(!n.finish())throw{message:"Symmetric decryption failed."};t.content=n.output}};n.createSignedData=function(){var r=null;return r={type:e.pki.oids.signedData,version:1,certificates:[],crls:[],digestAlgorithmIdentifiers:[],contentInfo:null,signerInfos:[],fromAsn1:function(t){a(r,t,n.asn1.signedDataValidator),r.certificates=[],r.crls=[],r.digestAlgorithmIdentifiers=[],r.contentInfo=null,r.signerInfos=[];var i=r.rawCapture.certificates.value;for(var s=0;s<i.length;++s)r.certificates.push(e.pki.certificateFromAsn1(i[s]))},toAsn1:function(){if("content"in r)throw"Signing PKCS#7 content not yet implemented.";r.contentInfo||r.sign();var n=[];for(var i=0;i<r.certificates.length;++i)n.push(e.pki.certificateToAsn1(r.certificates[0]));var s=[];return t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(r.type).getBytes()),t.create(t.Class.CONTEXT_SPECIFIC,0,!0,[t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.INTEGER,!1,t.integerToDer(r.version).getBytes()),t.create(t.Class.UNIVERSAL,t.Type.SET,!0,r.digestAlgorithmIdentifiers),r.contentInfo,t.create(t.Class.CONTEXT_SPECIFIC,0,!0,n),t.create(t.Class.CONTEXT_SPECIFIC,1,!0,s),t.create(t.Class.UNIVERSAL,t.Type.SET,!0,r.signerInfos)])])])},sign:function(n){if("content"in r)throw"PKCS#7 signing not yet implemented.";typeof r.content!="object"&&(r.contentInfo=t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(e.pki.oids.data).getBytes())]),"content"in r&&r.contentInfo.value.push(t.create(t.Class.CONTEXT_SPECIFIC,0,!0,[t.create(t.Class.UNIVERSAL,t.Type.OCTETSTRING,!1,r.content)])))},verify:function(){throw"PKCS#7 signature verification not yet implemented."},addCertificate:function(t){typeof t=="string"&&(t=e.pki.certificateFromPem(t)),r.certificates.push(t)},addCertificateRevokationList:function(e){throw"PKCS#7 CRL support not yet implemented."}},r},n.createEncryptedData=function(){var t=null;return t={type:e.pki.oids.encryptedData,version:0,encryptedContent:{algorithm:e.pki.oids["aes256-CBC"]},fromAsn1:function(e){a(t,e,n.asn1.encryptedDataValidator)},decrypt:function(e){e!==undefined&&(t.encryptedContent.key=e),f(t)}},t},n.createEnvelopedData=function(){var r=null;return r={type:e.pki.oids.envelopedData,version:0,recipients:[],encryptedContent:{algorithm:e.pki.oids["aes256-CBC"]},fromAsn1:function(e){var t=a(r,e,n.asn1.envelopedDataValidator);r.recipients=s(t.recipientInfos.value)},toAsn1:function(){return t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.OID,!1,t.oidToDer(r.type).getBytes()),t.create(t.Class.CONTEXT_SPECIFIC,0,!0,[t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,[t.create(t.Class.UNIVERSAL,t.Type.INTEGER,!1,t.integerToDer(r.version).getBytes()),t.create(t.Class.UNIVERSAL,t.Type.SET,!0,o(r.recipients)),t.create(t.Class.UNIVERSAL,t.Type.SEQUENCE,!0,u(r.encryptedContent))])])])},findRecipient:function(e){var t=e.issuer.attributes;for(var n=0;n<r.recipients.length;++n){var i=r.recipients[n],s=i.issuer;if(i.serialNumber!==e.serialNumber)continue;if(s.length!==t.length)continue;var o=!0;for(var u=0;u<t.length;++u)if(s[u].type!==t[u].type||s[u].value!==t[u].value){o=!1;break}if(o)return i}return null},decrypt:function(t,n){if(r.encryptedContent.key===undefined&&t!==undefined&&n!==undefined)switch(t.encryptedContent.algorithm){case e.pki.oids.rsaEncryption:case e.pki.oids.desCBC:var i=n.decrypt(t.encryptedContent.content);r.encryptedContent.key=e.util.createBuffer(i);break;default:throw{message:"Unsupported asymmetric cipher, OID "+t.encryptedContent.algorithm}}f(r)},addRecipient:function(t){r.recipients.push({version:0,issuer:t.subject.attributes,serialNumber:t.serialNumber,encryptedContent:{algorithm:e.pki.oids.rsaEncryption,key:t.publicKey}})},encrypt:function(t,n){if(r.encryptedContent.content===undefined){n=n||r.encryptedContent.algorithm,t=t||r.encryptedContent.key;var i,s,o;switch(n){case e.pki.oids["aes128-CBC"]:i=16,s=16,o=e.aes.createEncryptionCipher;break;case e.pki.oids["aes192-CBC"]:i=24,s=16,o=e.aes.createEncryptionCipher;break;case e.pki.oids["aes256-CBC"]:i=32,s=16,o=e.aes.createEncryptionCipher;break;case e.pki.oids["des-EDE3-CBC"]:i=24,s=8,o=e.des.createEncryptionCipher;break;default:throw{message:"Unsupported symmetric cipher, OID "+n}}if(t===undefined)t=e.util.createBuffer(e.random.getBytes(i));else if(t.length()!=i)throw{message:"Symmetric key has wrong length, got "+t.length()+" bytes, expected "+i};r.encryptedContent.algorithm=n,r.encryptedContent.key=t,r.encryptedContent.parameter=e.util.createBuffer(e.random.getBytes(s));var u=o(t);u.start(r.encryptedContent.parameter.copy()),u.update(r.content);if(!u.finish())throw{message:"Symmetric encryption failed."};r.encryptedContent.content=u.output}for(var a=0;a<r.recipients.length;a++){var f=r.recipients[a];if(f.encryptedContent.content!==undefined)continue;switch(f.encryptedContent.algorithm){case e.pki.oids.rsaEncryption:f.encryptedContent.content=f.encryptedContent.key.encrypt(r.encryptedContent.key.data);break;default:throw{message:"Unsupported asymmetric cipher, OID "+f.encryptedContent.algorithm}}}}},r}}var r="pkcs7";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/pkcs7",["require","module","./aes","./asn1","./des","./oids","./pem","./pkcs7asn1","./random","./util","./x509"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){function e(e){var t="forge.task",n=0,r={},i=0;e.debug.set(t,"tasks",r);var s={};e.debug.set(t,"queues",s);var o="?",u=30,a=20,f="ready",l="running",c="blocked",h="sleeping",p="done",d="error",v="stop",m="start",g="block",y="unblock",b="sleep",w="wakeup",E="cancel",S="fail",x={};x[f]={},x[f][v]=f,x[f][m]=l,x[f][E]=p,x[f][S]=d,x[l]={},x[l][v]=f,x[l][m]=l,x[l][g]=c,x[l][y]=l,x[l][b]=h,x[l][w]=l,x[l][E]=p,x[l][S]=d,x[c]={},x[c][v]=c,x[c][m]=c,x[c][g]=c,x[c][y]=c,x[c][b]=c,x[c][w]=c,x[c][E]=p,x[c][S]=d,x[h]={},x[h][v]=h,x[h][m]=h,x[h][g]=h,x[h][y]=h,x[h][b]=h,x[h][w]=h,x[h][E]=p,x[h][S]=d,x[p]={},x[p][v]=p,x[p][m]=p,x[p][g]=p,x[p][y]=p,x[p][b]=p,x[p][w]=p,x[p][E]=p,x[p][S]=d,x[d]={},x[d][v]=d,x[d][m]=d,x[d][g]=d,x[d][y]=d,x[d][b]=d,x[d][w]=d,x[d][E]=d,x[d][S]=d;var T=function(s){this.id=-1,this.name=s.name||o,this.parent=s.parent||null,this.run=s.run,this.subtasks=[],this.error=!1,this.state=f,this.blocks=0,this.timeoutId=null,this.swapTime=null,this.userData=null,this.id=i++,r[this.id]=this,n>=1&&e.log.verbose(t,"[%s][%s] init",this.id,this.name,this)};T.prototype.debug=function(n){n=n||"",e.log.debug(t,n,"[%s][%s] task:",this.id,this.name,this,"subtasks:",this.subtasks.length,"queue:",s)},T.prototype.next=function(e,t){typeof e=="function"&&(t=e,e=this.name);var n=new T({run:t,name:e,parent:this});return n.state=l,n.type=this.type,n.successCallback=this.successCallback||null,n.failureCallback=this.failureCallback||null,this.subtasks.push(n),this},T.prototype.parallel=function(t,n){return e.util.isArray(t)&&(n=t,t=this.name),this.next(t,function(r){var i=r;i.block(n.length);var s=function(t,r){e.task.start({type:t,run:function(e){n[r](e)},success:function(e){i.unblock()},failure:function(e){i.unblock()}})};for(var o=0;o<n.length;o++){var u=t+"__parallel-"+r.id+"-"+o,a=o;s(u,a)}})},T.prototype.stop=function(){this.state=x[this.state][v]},T.prototype.start=function(){this.error=!1,this.state=x[this.state][m],this.state===l&&(this.start=new Date,this.run(this),C(this,0))},T.prototype.block=function(e){e=typeof e=="undefined"?1:e,this.blocks+=e,this.blocks>0&&(this.state=x[this.state][g])},T.prototype.unblock=function(e){return e=typeof e=="undefined"?1:e,this.blocks-=e,this.blocks===0&&this.state!==p&&(this.state=l,C(this,0)),this.blocks},T.prototype.sleep=function(e){e=typeof e=="undefined"?0:e,this.state=x[this.state][b];var t=this;this.timeoutId=setTimeout(function(){t.timeoutId=null,t.state=l,C(t,0)},e)},T.prototype.wait=function(e){e.wait(this)},T.prototype.wakeup=function(){this.state===h&&(cancelTimeout(this.timeoutId),this.timeoutId=null,this.state=l,C(this,0))},T.prototype.cancel=function(){this.state=x[this.state][E],this.permitsNeeded=0,this.timeoutId!==null&&(cancelTimeout(this.timeoutId),this.timeoutId=null),this.subtasks=[]},T.prototype.fail=function(e){this.error=!0,k(this,!0);if(e)e.error=this.error,e.swapTime=this.swapTime,e.userData=this.userData,C(e,0);else{if(this.parent!==null){var t=this.parent;while(t.parent!==null)t.error=this.error,t.swapTime=this.swapTime,t.userData=this.userData,t=t.parent;k(t,!0)}this.failureCallback&&this.failureCallback(this)}};var N=function(e){e.error=!1,e.state=x[e.state][m],setTimeout(function(){e.state===l&&(e.swapTime=+(new Date),e.run(e),C(e,0))},0)},C=function(e,t){var n=t>u||+(new Date)-e.swapTime>a,r=function(t){t++;if(e.state===l){n&&(e.swapTime=+(new Date));if(e.subtasks.length>0){var r=e.subtasks.shift();r.error=e.error,r.swapTime=e.swapTime,r.userData=e.userData,r.run(r),r.error||C(r,t)}else k(e),e.error||e.parent!==null&&(e.parent.error=e.error,e.parent.swapTime=e.swapTime,e.parent.userData=e.userData,C(e.parent,t))}};n?setTimeout(r,0):r(t)},k=function(i,o){i.state=p,delete r[i.id],n>=1&&e.log.verbose(t,"[%s][%s] finish",i.id,i.name,i),i.parent===null&&(i.type in s?s[i.type].length===0?e.log.error(t,"[%s][%s] task queue empty [%s]",i.id,i.name,i.type):s[i.type][0]!==i?e.log.error(t,"[%s][%s] task not first in queue [%s]",i.id,i.name,i.type):(s[i.type].shift(),s[i.type].length===0?(n>=1&&e.log.verbose(t,"[%s][%s] delete queue [%s]",i.id,i.name,i.type),delete s[i.type]):(n>=1&&e.log.verbose(t,"[%s][%s] queue start next [%s] remain:%s",i.id,i.name,i.type,s[i.type].length),s[i.type][0].start())):e.log.error(t,"[%s][%s] task queue missing [%s]",i.id,i.name,i.type),o||(i.error&&i.failureCallback?i.failureCallback(i):!i.error&&i.successCallback&&i.successCallback(i)))};e.task=e.task||{},e.task.start=function(r){var i=new T({run:r.run,name:r.name||o});i.type=r.type,i.successCallback=r.success||null,i.failureCallback=r.failure||null,i.type in s?s[r.type].push(i):(n>=1&&e.log.verbose(t,"[%s][%s] create queue [%s]",i.id,i.name,i.type),s[i.type]=[i],N(i))},e.task.cancel=function(e){e in s&&(s[e]=[s[e][0]])},e.task.createCondition=function(){var e={tasks:{}};return e.wait=function(t){t.id in e.tasks||(t.block(),e.tasks[t.id]=t)},e.notify=function(){var t=e.tasks;e.tasks={};for(var n in t)t[n].unblock()},e}}var r="task";if(typeof n!="function"){if(typeof module!="object"||!module.exports)return typeof forge=="undefined"&&(forge={}),e(forge);var i=!0;n=function(e,n){n(t,module)}}var s,o=function(t,n){n.exports=function(n){var i=s.map(function(e){return t(e)}).concat(e);n=n||{},n.defined=n.defined||{};if(n.defined[r])return n[r];n.defined[r]=!0;for(var o=0;o<i.length;++o)i[o](n);return n[r]}},u=n;n=function(e,t){return s=typeof e=="string"?t.slice(2):e.slice(2),i?(delete n,u.apply(null,Array.prototype.slice.call(arguments,0))):(n=u,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/task",["require","module","./debug","./log","./util"],function(){o.apply(null,Array.prototype.slice.call(arguments,0))})}(),function(){var e="forge";if(typeof n!="function"){if(typeof module!="object"||!module.exports){typeof forge=="undefined"&&(forge={disableNativeCode:!1});return}var r=!0;n=function(e,n){n(t,module)}}var i,s=function(t,n){n.exports=function(n){var r=i.map(function(e){return t(e)});n=n||{},n.defined=n.defined||{};if(n.defined[e])return n[e];n.defined[e]=!0;for(var s=0;s<r.length;++s)r[s](n);return n},n.exports.disableNativeCode=!1,n.exports(n.exports)},o=n;n=function(e,t){return i=typeof e=="string"?t.slice(2):e.slice(2),r?(delete n,o.apply(null,Array.prototype.slice.call(arguments,0))):(n=o,n.apply(null,Array.prototype.slice.call(arguments,0)))},n("js/forge",["require","module","./aes","./aesCipherSuites","./asn1","./debug","./des","./hmac","./log","./pbkdf2","./pem","./pkcs7","./pkcs1","./pkcs12","./pki","./prng","./pss","./random","./rc2","./task","./tls","./util","./md","./mgf1"],function(){s.apply(null,Array.prototype.slice.call(arguments,0))})}(),window.forge=t("js/forge")})();
},{"__browserify_process":160}],10:[function(require,module,exports){
var ndn = require('./lib/main.js');

module.exports = ndn;

},{"./lib/main.js":12}],11:[function(require,module,exports){
var LOG = 0
module.exports = LOG;

},{}],12:[function(require,module,exports){

var nfd = new Worker(window.URL.createObjectURL(new Blob([';(function(e,t,n){function i(n,s){if(!t[n]){if(!e[n]){var o=typeof require=="function"&&require;if(!s&&o)return o(n,!0);if(r)return r(n,!0);throw new Error("Cannot find module \'"+n+"\'")}var u=t[n]={exports:{}};e[n][0].call(u.exports,function(t){var r=e[n][1][t];return i(r?r:t)},u,u.exports)}return t[n].exports}var r=typeof require=="function"&&require;for(var s=0;s<n.length;s++)i(n[s]);return i})({1:[function(require,module,exports){\nvar LOG = 0\nmodule.exports = LOG;\n\n},{}],2:[function(require,module,exports){\nvar window = undefined\nvar ndn = require(\'ndn-browser-shim\');\nndn.globalKeyManager = require(\'./ndn-keyManager.js\');\nndn.forwarderFace = require(\'./ndn-ForwarderFace.js\');\nndn.MessageChannelTransport = require(\'./ndn-MessageChannelTransport.js\');\nndn.FIB = require(\'./ndn-FIB.js\')\nndn.Faces = require(\'./ndn-Faces.js\')\nvar LOG = require(\'./LOG.js\');\nvar utils = require(\'./utils.js\')\nvar Faces = require(\'./ndn-Faces.js\')\n\nvar strategy = require(\'./ndn-strategy.js\');\n\nvar options = {}\noptions.prefix = "wiki";\n\nonmessage = function(e) {\n  console.log(e)\n  if (e.data.init == true) {\n    console.log(\'setting app prefix\')\n    options.prefix = e.data.prefix\n    var Bootstrap = new ndn.forwarderFace({host:"localhost", port:9696})\n    Bootstrap.selfReg(new ndn.Name(\'ndnx\'))\n    Bootstrap.registerPrefix(new ndn.Name(\'ndnx\'), Bootstrap.interestHandler)\n    ndn.Faces.add(Bootstrap)\n  } else if (e.data.port == "keyPort") {\n    ndn.keyPort = e.ports[0]\n\t\tndn.keyPort.onmessage = getKeysFromUI;\n\t} else if (e.data.port == "RTCPort") {\n\n    var rtcPort = e.ports[0]\n    initFace(rtcPort, e.data.ndndid, new ndn.Name(\'ndnx\'))\n\n  } else if (e.data.port == "ndnxPort") {\n\n    var prefix = new ndn.Name([\'ndnx\', ndn.id])\n    initFace(e.ports[0], ndn.id, prefix)\n\n  } else if (e.data.port == "ioPort") {\n    initFace(e.ports[0], ndn.id, new ndn.Name(options.prefix));\n  } else if (e.data.port == "repoPort") {\n    var prefix = new ndn.Name(options.prefix);\n    initFace(e.ports[0], ndn.id, prefix)\n  } else if (e.data.port == "modulePort") {\n    initFace(e.ports[0], ndn.id, new ndn.Name(e.data.prefix))\n  } else if (e.data.ndnx == "selfreg") {\n    registerPrefixFromInterest(e.data.interest)\n  } else if (e.data.command == "reqReg") {\n    expressPrefixRegistrationInterest(e.data.uri, e.data.ndndid)\n  }\n}\n\nfunction expressPrefixRegistrationInterest(uri, ndndid) {\n   var name = new ndn.Name([\'ndnx\', ndndid, \'selfreg\'])\n   var myKey = ndn.globalKeyManager.getKey()\n   var myID = myKey.publicKeyDigest\n   var fe = new ndn.ForwardingEntry(\'selfreg\', new ndn.Name(uri), myID, null, null, null);\n   var encoder = new ndn.BinaryXMLEncoder()\n   console.log(\'created entry and encoder\')\n   fe.to_ndnb(encoder)\n   var bytes = encoder.getReducedOstream();\n   var d = new ndn.Data(new ndn.Name(\'fe\'), new ndn.SignedInfo(), bytes);\n   d.signedInfo.setFields()\n   d.sign()\n\n\n   function onData(inst, co) {\n     console.log(\'got response from selfReg, \', co)\n   }\n\n   var nfblob = d.encode()\n   name.append(nfblob)\n   var interest = new ndn.Interest(name);\n   utils.setNonce(interest)\n   console.log(\'got right interest, \',interest)\n   for(i = 0; i < ndn.FIB.length; i++ ){\n    if ((ndn.FIB[i].ndndid != undefined) && (ndn.FIB[i].ndndid.toString() == ndndid.toString())) {\n      console.log(\'found proper face to express registration command\')\n      ndn.FIB[i].expressInterest(interest, onData, null)\n      continue\n    };\n  };\n}\n\n\nfunction registerPrefixFromInterest(interest){\n  console.log(interest)\n  var nfblob = interest.name.components[3].value\n  var d = new ndn.Data();\n  d.decode(nfblob)\n  console.log(d)\n  var fe = new ndn.ForwardingEntry();\n\n  var decoder = new ndn.BinaryXMLDecoder(d.content);\n  console.log(decoder)\n  fe.from_ndnb(decoder)\n  console.log(d)\n  var ndndID = d.signedInfo.publisher.publisherPublicKeyDigest;\n  fe.ndndID = ndndID\n  for(i = 0; i < ndn.Faces.list.length; i++ ){\n    if ((ndn.Faces.list[i].ndndid != (null || undefined)) && (ndn.FIB[i].ndndid.toString() == ndndID.toString())) {\n      fe.faceID = i\n      console.log(\'found face that requested selfReg\')\n      ndn.Faces.list[i].selfReg(fe.prefixName)\n      var toRespondTo = ndn.faces.list[i]\n      continue\n    };\n  };\n  var response = new ndn.ForwardingEntry(\'selfreg\', fe.prefixName, ndndID, fe.faceID, fe.flags, fe.lifetime);\n  var encoder = new ndn.BinaryXMLEncoder();\n  console.log(response)\n  response.to_ndnb(encoder);\n  var bytes = encoder.getReducedOstream();\n\n  var si = new ndn.SignedInfo();\n\n  var respdata = new ndn.Data(new ndn.Name(interest.name), si, bytes);\n  respdata.signedInfo.setFields()\n  respdata.sign();\n  var enc = respdata.encode()\n  toRespondTo.transport.send(enc)\n}\n\nfunction getKeysFromUI(e){\n  ndn.globalKeyManager.certificate = e.data[0]\n  ndn.globalKeyManager.publicKey = e.data[1]\n  ndn.globalKeyManager.privateKey = e.data[2]\n  var key = ndn.globalKeyManager.getKey()\n  ndn.id = key.publicKeyDigest\n  ndn.keyPort.postMessage(ndn.id)\n}\n\nfunction initFace(port, ndndid, prefix) {\n  var transport = new ndn.MessageChannelTransport.transport(port)\n  var face = new ndn.forwarderFace({host: 1, port: 1, getTransport: function(){return transport}})\n  face.transport.connect(face, function(){\n    console.log(\'connecting face \')\n    strategy.onNewFace(face)\n    ndn.Faces.add(face)\n    if (prefix != undefined){\n      ndn.FIB.put(new ndn.ForwardingEntry(\'selfreg\', prefix, ndndid, face.id, null, null))\n    }\n\n  })\n  strategy.onNewFace(face)\n}\n\n\n\n},{"./LOG.js":1,"./ndn-FIB.js":6,"./ndn-Faces.js":7,"./ndn-ForwarderFace.js":4,"./ndn-MessageChannelTransport.js":5,"./ndn-keyManager.js":3,"./ndn-strategy.js":9,"./utils.js":8,"ndn-browser-shim":10}],11:[function(require,module,exports){\nvar proc = {}\nmodule.exports = proc;\nvar msCh = new MessageChannel()\n\nvar queue = [];\nmsCh.port1.onmessage = function(ev) {\n  var source = ev.source;\n  if ( ev.data === \'proc-tick\') {\n    if (queue.length > 0) {\n      var fn = queue.shift();\n      fn();\n    }\n  }\n}\nproc.nextTick = function nextTick(fn) {\n      queue.push(fn);\n      msCh.port2.postMessage(\'proc-tick\');\n    };\n\n\n},{}],12:[function(require,module,exports){\nrequire=(function(e,t,n,r){function i(r){if(!n[r]){if(!t[r]){if(e)return e(r);throw new Error("Cannot find module \'"+r+"\'")}var s=n[r]={exports:{}};t[r][0](function(e){var n=t[r][1][e];return i(n?n:e)},s,s.exports)}return n[r].exports}for(var s=0;s<r.length;s++)i(r[s]);return i})(typeof require!=="undefined"&&require,{1:[function(require,module,exports){\nexports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {\n  var e, m,\n      eLen = nBytes * 8 - mLen - 1,\n      eMax = (1 << eLen) - 1,\n      eBias = eMax >> 1,\n      nBits = -7,\n      i = isBE ? 0 : (nBytes - 1),\n      d = isBE ? 1 : -1,\n      s = buffer[offset + i];\n\n  i += d;\n\n  e = s & ((1 << (-nBits)) - 1);\n  s >>= (-nBits);\n  nBits += eLen;\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);\n\n  m = e & ((1 << (-nBits)) - 1);\n  e >>= (-nBits);\n  nBits += mLen;\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);\n\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity);\n  } else {\n    m = m + Math.pow(2, mLen);\n    e = e - eBias;\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n};\n\nexports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {\n  var e, m, c,\n      eLen = nBytes * 8 - mLen - 1,\n      eMax = (1 << eLen) - 1,\n      eBias = eMax >> 1,\n      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),\n      i = isBE ? (nBytes - 1) : 0,\n      d = isBE ? -1 : 1,\n      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;\n\n  value = Math.abs(value);\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0;\n    e = eMax;\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2);\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * Math.pow(2, 1 - eBias);\n    }\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n      e = 0;\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);\n\n  e = (e << mLen) | m;\n  eLen += mLen;\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);\n\n  buffer[offset + i - d] |= s * 128;\n};\n\n},{}],2:[function(require,module,exports){\n(function(){// UTILITY\nvar util = require(\'util\');\nvar Buffer = require("buffer").Buffer;\nvar pSlice = Array.prototype.slice;\n\nfunction objectKeys(object) {\n  if (Object.keys) return Object.keys(object);\n  var result = [];\n  for (var name in object) {\n    if (Object.prototype.hasOwnProperty.call(object, name)) {\n      result.push(name);\n    }\n  }\n  return result;\n}\n\n// 1. The assert module provides functions that throw\n// AssertionError\'s when particular conditions are not met. The\n// assert module must conform to the following interface.\n\nvar assert = module.exports = ok;\n\n// 2. The AssertionError is defined in assert.\n// new assert.AssertionError({ message: message,\n//                             actual: actual,\n//                             expected: expected })\n\nassert.AssertionError = function AssertionError(options) {\n  this.name = \'AssertionError\';\n  this.message = options.message;\n  this.actual = options.actual;\n  this.expected = options.expected;\n  this.operator = options.operator;\n  var stackStartFunction = options.stackStartFunction || fail;\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, stackStartFunction);\n  }\n};\nutil.inherits(assert.AssertionError, Error);\n\nfunction replacer(key, value) {\n  if (value === undefined) {\n    return \'\' + value;\n  }\n  if (typeof value === \'number\' && (isNaN(value) || !isFinite(value))) {\n    return value.toString();\n  }\n  if (typeof value === \'function\' || value instanceof RegExp) {\n    return value.toString();\n  }\n  return value;\n}\n\nfunction truncate(s, n) {\n  if (typeof s == \'string\') {\n    return s.length < n ? s : s.slice(0, n);\n  } else {\n    return s;\n  }\n}\n\nassert.AssertionError.prototype.toString = function() {\n  if (this.message) {\n    return [this.name + \':\', this.message].join(\' \');\n  } else {\n    return [\n      this.name + \':\',\n      truncate(JSON.stringify(this.actual, replacer), 128),\n      this.operator,\n      truncate(JSON.stringify(this.expected, replacer), 128)\n    ].join(\' \');\n  }\n};\n\n// assert.AssertionError instanceof Error\n\nassert.AssertionError.__proto__ = Error.prototype;\n\n// At present only the three keys mentioned above are used and\n// understood by the spec. Implementations or sub modules can pass\n// other keys to the AssertionError\'s constructor - they will be\n// ignored.\n\n// 3. All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided.  All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n\nfunction fail(actual, expected, message, operator, stackStartFunction) {\n  throw new assert.AssertionError({\n    message: message,\n    actual: actual,\n    expected: expected,\n    operator: operator,\n    stackStartFunction: stackStartFunction\n  });\n}\n\n// EXTENSION! allows for well behaved errors defined elsewhere.\nassert.fail = fail;\n\n// 4. Pure assertion tests whether a value is truthy, as determined\n// by !!guard.\n// assert.ok(guard, message_opt);\n// This statement is equivalent to assert.equal(true, guard,\n// message_opt);. To test strictly for the value true, use\n// assert.strictEqual(true, guard, message_opt);.\n\nfunction ok(value, message) {\n  if (!!!value) fail(value, true, message, \'==\', assert.ok);\n}\nassert.ok = ok;\n\n// 5. The equality assertion tests shallow, coercive equality with\n// ==.\n// assert.equal(actual, expected, message_opt);\n\nassert.equal = function equal(actual, expected, message) {\n  if (actual != expected) fail(actual, expected, message, \'==\', assert.equal);\n};\n\n// 6. The non-equality assertion tests for whether two objects are not equal\n// with != assert.notEqual(actual, expected, message_opt);\n\nassert.notEqual = function notEqual(actual, expected, message) {\n  if (actual == expected) {\n    fail(actual, expected, message, \'!=\', assert.notEqual);\n  }\n};\n\n// 7. The equivalence assertion tests a deep equality relation.\n// assert.deepEqual(actual, expected, message_opt);\n\nassert.deepEqual = function deepEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected)) {\n    fail(actual, expected, message, \'deepEqual\', assert.deepEqual);\n  }\n};\n\nfunction _deepEqual(actual, expected) {\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n\n  } else if (Buffer.isBuffer(actual) && Buffer.isBuffer(expected)) {\n    if (actual.length != expected.length) return false;\n\n    for (var i = 0; i < actual.length; i++) {\n      if (actual[i] !== expected[i]) return false;\n    }\n\n    return true;\n\n  // 7.2. If the expected value is a Date object, the actual value is\n  // equivalent if it is also a Date object that refers to the same time.\n  } else if (actual instanceof Date && expected instanceof Date) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3. Other pairs that do not both pass typeof value == \'object\',\n  // equivalence is determined by ==.\n  } else if (typeof actual != \'object\' && typeof expected != \'object\') {\n    return actual == expected;\n\n  // 7.4. For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical \'prototype\' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else {\n    return objEquiv(actual, expected);\n  }\n}\n\nfunction isUndefinedOrNull(value) {\n  return value === null || value === undefined;\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) == \'[object Arguments]\';\n}\n\nfunction objEquiv(a, b) {\n  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))\n    return false;\n  // an identical \'prototype\' property.\n  if (a.prototype !== b.prototype) return false;\n  //~~~I\'ve managed to break Object.keys through screwy arguments passing.\n  //   Converting to array solves the problem.\n  if (isArguments(a)) {\n    if (!isArguments(b)) {\n      return false;\n    }\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return _deepEqual(a, b);\n  }\n  try {\n    var ka = objectKeys(a),\n        kb = objectKeys(b),\n        key, i;\n  } catch (e) {//happens when one is a string literal and the other isn\'t\n    return false;\n  }\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length != kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!_deepEqual(a[key], b[key])) return false;\n  }\n  return true;\n}\n\n// 8. The non-equivalence assertion tests for any deep inequality.\n// assert.notDeepEqual(actual, expected, message_opt);\n\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected)) {\n    fail(actual, expected, message, \'notDeepEqual\', assert.notDeepEqual);\n  }\n};\n\n// 9. The strict equality assertion tests strict equality, as determined by ===.\n// assert.strictEqual(actual, expected, message_opt);\n\nassert.strictEqual = function strictEqual(actual, expected, message) {\n  if (actual !== expected) {\n    fail(actual, expected, message, \'===\', assert.strictEqual);\n  }\n};\n\n// 10. The strict non-equality assertion tests for strict inequality, as\n// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);\n\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n  if (actual === expected) {\n    fail(actual, expected, message, \'!==\', assert.notStrictEqual);\n  }\n};\n\nfunction expectedException(actual, expected) {\n  if (!actual || !expected) {\n    return false;\n  }\n\n  if (expected instanceof RegExp) {\n    return expected.test(actual);\n  } else if (actual instanceof expected) {\n    return true;\n  } else if (expected.call({}, actual) === true) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction _throws(shouldThrow, block, expected, message) {\n  var actual;\n\n  if (typeof expected === \'string\') {\n    message = expected;\n    expected = null;\n  }\n\n  try {\n    block();\n  } catch (e) {\n    actual = e;\n  }\n\n  message = (expected && expected.name ? \' (\' + expected.name + \').\' : \'.\') +\n            (message ? \' \' + message : \'.\');\n\n  if (shouldThrow && !actual) {\n    fail(\'Missing expected exception\' + message);\n  }\n\n  if (!shouldThrow && expectedException(actual, expected)) {\n    fail(\'Got unwanted exception\' + message);\n  }\n\n  if ((shouldThrow && actual && expected &&\n      !expectedException(actual, expected)) || (!shouldThrow && actual)) {\n    throw actual;\n  }\n}\n\n// 11. Expected to throw an error:\n// assert.throws(block, Error_opt, message_opt);\n\nassert.throws = function(block, /*optional*/error, /*optional*/message) {\n  _throws.apply(this, [true].concat(pSlice.call(arguments)));\n};\n\n// EXTENSION! This is annoying to write outside this module.\nassert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {\n  _throws.apply(this, [false].concat(pSlice.call(arguments)));\n};\n\nassert.ifError = function(err) { if (err) {throw err;}};\n\n})()\n},{"util":3,"buffer":4}],"buffer-browserify":[function(require,module,exports){\nmodule.exports=require(\'q9TxCC\');\n},{}],"q9TxCC":[function(require,module,exports){\n(function(){function SlowBuffer (size) {\n    this.length = size;\n};\n\nvar assert = require(\'assert\');\n\nexports.INSPECT_MAX_BYTES = 50;\n\n\nfunction toHex(n) {\n  if (n < 16) return \'0\' + n.toString(16);\n  return n.toString(16);\n}\n\nfunction utf8ToBytes(str) {\n  var byteArray = [];\n  for (var i = 0; i < str.length; i++)\n    if (str.charCodeAt(i) <= 0x7F)\n      byteArray.push(str.charCodeAt(i));\n    else {\n      var h = encodeURIComponent(str.charAt(i)).substr(1).split(\'%\');\n      for (var j = 0; j < h.length; j++)\n        byteArray.push(parseInt(h[j], 16));\n    }\n\n  return byteArray;\n}\n\nfunction asciiToBytes(str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++ )\n    // Node\'s code seems to be doing this and not & 0x7F..\n    byteArray.push( str.charCodeAt(i) & 0xFF );\n\n  return byteArray;\n}\n\nfunction base64ToBytes(str) {\n  return require("base64-js").toByteArray(str);\n}\n\nSlowBuffer.byteLength = function (str, encoding) {\n  switch (encoding || "utf8") {\n    case \'hex\':\n      return str.length / 2;\n\n    case \'utf8\':\n    case \'utf-8\':\n      return utf8ToBytes(str).length;\n\n    case \'ascii\':\n    case \'binary\':\n      return str.length;\n\n    case \'base64\':\n      return base64ToBytes(str).length;\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n};\n\nfunction blitBuffer(src, dst, offset, length) {\n  var pos, i = 0;\n  while (i < length) {\n    if ((i+offset >= dst.length) || (i >= src.length))\n      break;\n\n    dst[i + offset] = src[i];\n    i++;\n  }\n  return i;\n}\n\nSlowBuffer.prototype.utf8Write = function (string, offset, length) {\n  var bytes, pos;\n  return SlowBuffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);\n};\n\nSlowBuffer.prototype.asciiWrite = function (string, offset, length) {\n  var bytes, pos;\n  return SlowBuffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);\n};\n\nSlowBuffer.prototype.binaryWrite = SlowBuffer.prototype.asciiWrite;\n\nSlowBuffer.prototype.base64Write = function (string, offset, length) {\n  var bytes, pos;\n  return SlowBuffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);\n};\n\nSlowBuffer.prototype.base64Slice = function (start, end) {\n  var bytes = Array.prototype.slice.apply(this, arguments)\n  return require("base64-js").fromByteArray(bytes);\n}\n\nfunction decodeUtf8Char(str) {\n  try {\n    return decodeURIComponent(str);\n  } catch (err) {\n    return String.fromCharCode(0xFFFD); // UTF 8 invalid char\n  }\n}\n\nSlowBuffer.prototype.utf8Slice = function () {\n  var bytes = Array.prototype.slice.apply(this, arguments);\n  var res = "";\n  var tmp = "";\n  var i = 0;\n  while (i < bytes.length) {\n    if (bytes[i] <= 0x7F) {\n      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);\n      tmp = "";\n    } else\n      tmp += "%" + bytes[i].toString(16);\n\n    i++;\n  }\n\n  return res + decodeUtf8Char(tmp);\n}\n\nSlowBuffer.prototype.asciiSlice = function () {\n  var bytes = Array.prototype.slice.apply(this, arguments);\n  var ret = "";\n  for (var i = 0; i < bytes.length; i++)\n    ret += String.fromCharCode(bytes[i]);\n  return ret;\n}\n\nSlowBuffer.prototype.binarySlice = SlowBuffer.prototype.asciiSlice;\n\nSlowBuffer.prototype.inspect = function() {\n  var out = [],\n      len = this.length;\n  for (var i = 0; i < len; i++) {\n    out[i] = toHex(this[i]);\n    if (i == exports.INSPECT_MAX_BYTES) {\n      out[i + 1] = \'...\';\n      break;\n    }\n  }\n  return \'<SlowBuffer \' + out.join(\' \') + \'>\';\n};\n\n\nSlowBuffer.prototype.hexSlice = function(start, end) {\n  var len = this.length;\n\n  if (!start || start < 0) start = 0;\n  if (!end || end < 0 || end > len) end = len;\n\n  var out = \'\';\n  for (var i = start; i < end; i++) {\n    out += toHex(this[i]);\n  }\n  return out;\n};\n\n\nSlowBuffer.prototype.toString = function(encoding, start, end) {\n  encoding = String(encoding || \'utf8\').toLowerCase();\n  start = +start || 0;\n  if (typeof end == \'undefined\') end = this.length;\n\n  // Fastpath empty strings\n  if (+end == start) {\n    return \'\';\n  }\n\n  switch (encoding) {\n    case \'hex\':\n      return this.hexSlice(start, end);\n\n    case \'utf8\':\n    case \'utf-8\':\n      return this.utf8Slice(start, end);\n\n    case \'ascii\':\n      return this.asciiSlice(start, end);\n\n    case \'binary\':\n      return this.binarySlice(start, end);\n\n    case \'base64\':\n      return this.base64Slice(start, end);\n\n    case \'ucs2\':\n    case \'ucs-2\':\n      return this.ucs2Slice(start, end);\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n};\n\n\nSlowBuffer.prototype.hexWrite = function(string, offset, length) {\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length;\n  if (strLen % 2) {\n    throw new Error(\'Invalid hex string\');\n  }\n  if (length > strLen / 2) {\n    length = strLen / 2;\n  }\n  for (var i = 0; i < length; i++) {\n    var byte = parseInt(string.substr(i * 2, 2), 16);\n    if (isNaN(byte)) throw new Error(\'Invalid hex string\');\n    this[offset + i] = byte;\n  }\n  SlowBuffer._charsWritten = i * 2;\n  return i;\n};\n\n\nSlowBuffer.prototype.write = function(string, offset, length, encoding) {\n  // Support both (string, offset, length, encoding)\n  // and the legacy (string, encoding, offset, length)\n  if (isFinite(offset)) {\n    if (!isFinite(length)) {\n      encoding = length;\n      length = undefined;\n    }\n  } else {  // legacy\n    var swap = encoding;\n    encoding = offset;\n    offset = length;\n    length = swap;\n  }\n\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n  encoding = String(encoding || \'utf8\').toLowerCase();\n\n  switch (encoding) {\n    case \'hex\':\n      return this.hexWrite(string, offset, length);\n\n    case \'utf8\':\n    case \'utf-8\':\n      return this.utf8Write(string, offset, length);\n\n    case \'ascii\':\n      return this.asciiWrite(string, offset, length);\n\n    case \'binary\':\n      return this.binaryWrite(string, offset, length);\n\n    case \'base64\':\n      return this.base64Write(string, offset, length);\n\n    case \'ucs2\':\n    case \'ucs-2\':\n      return this.ucs2Write(string, offset, length);\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n};\n\n\n// slice(start, end)\nSlowBuffer.prototype.slice = function(start, end) {\n  if (end === undefined) end = this.length;\n\n  if (end > this.length) {\n    throw new Error(\'oob\');\n  }\n  if (start > end) {\n    throw new Error(\'oob\');\n  }\n\n  return new Buffer(this, end - start, +start);\n};\n\nSlowBuffer.prototype.copy = function(target, targetstart, sourcestart, sourceend) {\n  var temp = [];\n  for (var i=sourcestart; i<sourceend; i++) {\n    assert.ok(typeof this[i] !== \'undefined\', "copying undefined buffer bytes!");\n    temp.push(this[i]);\n  }\n\n  for (var i=targetstart; i<targetstart+temp.length; i++) {\n    target[i] = temp[i-targetstart];\n  }\n};\n\nSlowBuffer.prototype.fill = function(value, start, end) {\n  if (end > this.length) {\n    throw new Error(\'oob\');\n  }\n  if (start > end) {\n    throw new Error(\'oob\');\n  }\n\n  for (var i = start; i < end; i++) {\n    this[i] = value;\n  }\n}\n\nfunction coerce(length) {\n  // Coerce length to a number (possibly NaN), round up\n  // in case it\'s fractional (e.g. 123.456) then do a\n  // double negate to coerce a NaN to 0. Easy, right?\n  length = ~~Math.ceil(+length);\n  return length < 0 ? 0 : length;\n}\n\n\n// Buffer\n\nfunction Buffer(subject, encoding, offset) {\n  if (!(this instanceof Buffer)) {\n    return new Buffer(subject, encoding, offset);\n  }\n\n  var type;\n\n  // Are we slicing?\n  if (typeof offset === \'number\') {\n    this.length = coerce(encoding);\n    this.parent = subject;\n    this.offset = offset;\n  } else {\n    // Find the length\n    switch (type = typeof subject) {\n      case \'number\':\n        this.length = coerce(subject);\n        break;\n\n      case \'string\':\n        this.length = Buffer.byteLength(subject, encoding);\n        break;\n\n      case \'object\': // Assume object is an array\n        this.length = coerce(subject.length);\n        break;\n\n      default:\n        throw new Error(\'First argument needs to be a number, \' +\n                        \'array or string.\');\n    }\n\n    if (this.length > Buffer.poolSize) {\n      // Big buffer, just alloc one.\n      this.parent = new SlowBuffer(this.length);\n      this.offset = 0;\n\n    } else {\n      // Small buffer.\n      if (!pool || pool.length - pool.used < this.length) allocPool();\n      this.parent = pool;\n      this.offset = pool.used;\n      pool.used += this.length;\n    }\n\n    // Treat array-ish objects as a byte array.\n    if (isArrayIsh(subject)) {\n      for (var i = 0; i < this.length; i++) {\n        if (subject instanceof Buffer) {\n          this.parent[i + this.offset] = subject.readUInt8(i);\n        }\n        else {\n          this.parent[i + this.offset] = subject[i];\n        }\n      }\n    } else if (type == \'string\') {\n      // We are a string\n      this.length = this.write(subject, 0, encoding);\n    }\n  }\n\n}\n\nfunction isArrayIsh(subject) {\n  return Array.isArray(subject) || Buffer.isBuffer(subject) ||\n         subject && typeof subject === \'object\' &&\n         typeof subject.length === \'number\';\n}\n\nexports.SlowBuffer = SlowBuffer;\nexports.Buffer = Buffer;\n\nBuffer.poolSize = 8 * 1024;\nvar pool;\n\nfunction allocPool() {\n  pool = new SlowBuffer(Buffer.poolSize);\n  pool.used = 0;\n}\n\n\n// Static methods\nBuffer.isBuffer = function isBuffer(b) {\n  return b instanceof Buffer || b instanceof SlowBuffer;\n};\n\nBuffer.concat = function (list, totalLength) {\n  if (!Array.isArray(list)) {\n    throw new Error("Usage: Buffer.concat(list, [totalLength])\\n \\\n      list should be an Array.");\n  }\n\n  if (list.length === 0) {\n    return new Buffer(0);\n  } else if (list.length === 1) {\n    return list[0];\n  }\n\n  if (typeof totalLength !== \'number\') {\n    totalLength = 0;\n    for (var i = 0; i < list.length; i++) {\n      var buf = list[i];\n      totalLength += buf.length;\n    }\n  }\n\n  var buffer = new Buffer(totalLength);\n  var pos = 0;\n  for (var i = 0; i < list.length; i++) {\n    var buf = list[i];\n    buf.copy(buffer, pos);\n    pos += buf.length;\n  }\n  return buffer;\n};\n\n// Inspect\nBuffer.prototype.inspect = function inspect() {\n  var out = [],\n      len = this.length;\n\n  for (var i = 0; i < len; i++) {\n    out[i] = toHex(this.parent[i + this.offset]);\n    if (i == exports.INSPECT_MAX_BYTES) {\n      out[i + 1] = \'...\';\n      break;\n    }\n  }\n\n  return \'<Buffer \' + out.join(\' \') + \'>\';\n};\n\n\nBuffer.prototype.get = function get(i) {\n  if (i < 0 || i >= this.length) throw new Error(\'oob\');\n  return this.parent[this.offset + i];\n};\n\n\nBuffer.prototype.set = function set(i, v) {\n  if (i < 0 || i >= this.length) throw new Error(\'oob\');\n  return this.parent[this.offset + i] = v;\n};\n\n\n// write(string, offset = 0, length = buffer.length-offset, encoding = \'utf8\')\nBuffer.prototype.write = function(string, offset, length, encoding) {\n  // Support both (string, offset, length, encoding)\n  // and the legacy (string, encoding, offset, length)\n  if (isFinite(offset)) {\n    if (!isFinite(length)) {\n      encoding = length;\n      length = undefined;\n    }\n  } else {  // legacy\n    var swap = encoding;\n    encoding = offset;\n    offset = length;\n    length = swap;\n  }\n\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n  encoding = String(encoding || \'utf8\').toLowerCase();\n\n  var ret;\n  switch (encoding) {\n    case \'hex\':\n      ret = this.parent.hexWrite(string, this.offset + offset, length);\n      break;\n\n    case \'utf8\':\n    case \'utf-8\':\n      ret = this.parent.utf8Write(string, this.offset + offset, length);\n      break;\n\n    case \'ascii\':\n      ret = this.parent.asciiWrite(string, this.offset + offset, length);\n      break;\n\n    case \'binary\':\n      ret = this.parent.binaryWrite(string, this.offset + offset, length);\n      break;\n\n    case \'base64\':\n      // Warning: maxLength not taken into account in base64Write\n      ret = this.parent.base64Write(string, this.offset + offset, length);\n      break;\n\n    case \'ucs2\':\n    case \'ucs-2\':\n      ret = this.parent.ucs2Write(string, this.offset + offset, length);\n      break;\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n\n  Buffer._charsWritten = SlowBuffer._charsWritten;\n\n  return ret;\n};\n\n\n// toString(encoding, start=0, end=buffer.length)\nBuffer.prototype.toString = function(encoding, start, end) {\n  encoding = String(encoding || \'utf8\').toLowerCase();\n\n  if (typeof start == \'undefined\' || start < 0) {\n    start = 0;\n  } else if (start > this.length) {\n    start = this.length;\n  }\n\n  if (typeof end == \'undefined\' || end > this.length) {\n    end = this.length;\n  } else if (end < 0) {\n    end = 0;\n  }\n\n  start = start + this.offset;\n  end = end + this.offset;\n\n  switch (encoding) {\n    case \'hex\':\n      return this.parent.hexSlice(start, end);\n\n    case \'utf8\':\n    case \'utf-8\':\n      return this.parent.utf8Slice(start, end);\n\n    case \'ascii\':\n      return this.parent.asciiSlice(start, end);\n\n    case \'binary\':\n      return this.parent.binarySlice(start, end);\n\n    case \'base64\':\n      return this.parent.base64Slice(start, end);\n\n    case \'ucs2\':\n    case \'ucs-2\':\n      return this.parent.ucs2Slice(start, end);\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n};\n\n\n// byteLength\nBuffer.byteLength = SlowBuffer.byteLength;\n\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function fill(value, start, end) {\n  value || (value = 0);\n  start || (start = 0);\n  end || (end = this.length);\n\n  if (typeof value === \'string\') {\n    value = value.charCodeAt(0);\n  }\n  if (!(typeof value === \'number\') || isNaN(value)) {\n    throw new Error(\'value is not a number\');\n  }\n\n  if (end < start) throw new Error(\'end < start\');\n\n  // Fill 0 bytes; we\'re done\n  if (end === start) return 0;\n  if (this.length == 0) return 0;\n\n  if (start < 0 || start >= this.length) {\n    throw new Error(\'start out of bounds\');\n  }\n\n  if (end < 0 || end > this.length) {\n    throw new Error(\'end out of bounds\');\n  }\n\n  return this.parent.fill(value,\n                          start + this.offset,\n                          end + this.offset);\n};\n\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function(target, target_start, start, end) {\n  var source = this;\n  start || (start = 0);\n  end || (end = this.length);\n  target_start || (target_start = 0);\n\n  if (end < start) throw new Error(\'sourceEnd < sourceStart\');\n\n  // Copy 0 bytes; we\'re done\n  if (end === start) return 0;\n  if (target.length == 0 || source.length == 0) return 0;\n\n  if (target_start < 0 || target_start >= target.length) {\n    throw new Error(\'targetStart out of bounds\');\n  }\n\n  if (start < 0 || start >= source.length) {\n    throw new Error(\'sourceStart out of bounds\');\n  }\n\n  if (end < 0 || end > source.length) {\n    throw new Error(\'sourceEnd out of bounds\');\n  }\n\n  // Are we oob?\n  if (end > this.length) {\n    end = this.length;\n  }\n\n  if (target.length - target_start < end - start) {\n    end = target.length - target_start + start;\n  }\n\n  return this.parent.copy(target.parent,\n                          target_start + target.offset,\n                          start + this.offset,\n                          end + this.offset);\n};\n\n\n// slice(start, end)\nBuffer.prototype.slice = function(start, end) {\n  if (end === undefined) end = this.length;\n  if (end > this.length) throw new Error(\'oob\');\n  if (start > end) throw new Error(\'oob\');\n\n  return new Buffer(this.parent, end - start, +start + this.offset);\n};\n\n\n// Legacy methods for backwards compatibility.\n\nBuffer.prototype.utf8Slice = function(start, end) {\n  return this.toString(\'utf8\', start, end);\n};\n\nBuffer.prototype.binarySlice = function(start, end) {\n  return this.toString(\'binary\', start, end);\n};\n\nBuffer.prototype.asciiSlice = function(start, end) {\n  return this.toString(\'ascii\', start, end);\n};\n\nBuffer.prototype.utf8Write = function(string, offset) {\n  return this.write(string, offset, \'utf8\');\n};\n\nBuffer.prototype.binaryWrite = function(string, offset) {\n  return this.write(string, offset, \'binary\');\n};\n\nBuffer.prototype.asciiWrite = function(string, offset) {\n  return this.write(string, offset, \'ascii\');\n};\n\nBuffer.prototype.readUInt8 = function(offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  if (offset >= buffer.length) return;\n\n  return buffer.parent[buffer.offset + offset];\n};\n\nfunction readUInt16(buffer, offset, isBigEndian, noAssert) {\n  var val = 0;\n\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 1 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  if (offset >= buffer.length) return 0;\n\n  if (isBigEndian) {\n    val = buffer.parent[buffer.offset + offset] << 8;\n    if (offset + 1 < buffer.length) {\n      val |= buffer.parent[buffer.offset + offset + 1];\n    }\n  } else {\n    val = buffer.parent[buffer.offset + offset];\n    if (offset + 1 < buffer.length) {\n      val |= buffer.parent[buffer.offset + offset + 1] << 8;\n    }\n  }\n\n  return val;\n}\n\nBuffer.prototype.readUInt16LE = function(offset, noAssert) {\n  return readUInt16(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readUInt16BE = function(offset, noAssert) {\n  return readUInt16(this, offset, true, noAssert);\n};\n\nfunction readUInt32(buffer, offset, isBigEndian, noAssert) {\n  var val = 0;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  if (offset >= buffer.length) return 0;\n\n  if (isBigEndian) {\n    if (offset + 1 < buffer.length)\n      val = buffer.parent[buffer.offset + offset + 1] << 16;\n    if (offset + 2 < buffer.length)\n      val |= buffer.parent[buffer.offset + offset + 2] << 8;\n    if (offset + 3 < buffer.length)\n      val |= buffer.parent[buffer.offset + offset + 3];\n    val = val + (buffer.parent[buffer.offset + offset] << 24 >>> 0);\n  } else {\n    if (offset + 2 < buffer.length)\n      val = buffer.parent[buffer.offset + offset + 2] << 16;\n    if (offset + 1 < buffer.length)\n      val |= buffer.parent[buffer.offset + offset + 1] << 8;\n    val |= buffer.parent[buffer.offset + offset];\n    if (offset + 3 < buffer.length)\n      val = val + (buffer.parent[buffer.offset + offset + 3] << 24 >>> 0);\n  }\n\n  return val;\n}\n\nBuffer.prototype.readUInt32LE = function(offset, noAssert) {\n  return readUInt32(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readUInt32BE = function(offset, noAssert) {\n  return readUInt32(this, offset, true, noAssert);\n};\n\n\n/*\n * Signed integer types, yay team! A reminder on how two\'s complement actually\n * works. The first bit is the signed bit, i.e. tells us whether or not the\n * number should be positive or negative. If the two\'s complement value is\n * positive, then we\'re done, as it\'s equivalent to the unsigned representation.\n *\n * Now if the number is positive, you\'re pretty much done, you can just leverage\n * the unsigned translations and return those. Unfortunately, negative numbers\n * aren\'t quite that straightforward.\n *\n * At first glance, one might be inclined to use the traditional formula to\n * translate binary numbers between the positive and negative values in two\'s\n * complement. (Though it doesn\'t quite work for the most negative value)\n * Mainly:\n *  - invert all the bits\n *  - add one to the result\n *\n * Of course, this doesn\'t quite work in Javascript. Take for example the value\n * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of\n * course, Javascript will do the following:\n *\n * > ~0xff80\n * -65409\n *\n * Whoh there, Javascript, that\'s not quite right. But wait, according to\n * Javascript that\'s perfectly correct. When Javascript ends up seeing the\n * constant 0xff80, it has no notion that it is actually a signed number. It\n * assumes that we\'ve input the unsigned value 0xff80. Thus, when it does the\n * binary negation, it casts it into a signed value, (positive 0xff80). Then\n * when you perform binary negation on that, it turns it into a negative number.\n *\n * Instead, we\'re going to have to use the following general formula, that works\n * in a rather Javascript friendly way. I\'m glad we don\'t support this kind of\n * weird numbering scheme in the kernel.\n *\n * (BIT-MAX - (unsigned)val + 1) * -1\n *\n * The astute observer, may think that this doesn\'t make sense for 8-bit numbers\n * (really it isn\'t necessary for them). However, when you get 16-bit numbers,\n * you do. Let\'s go back to our prior example and see how this will look:\n *\n * (0xffff - 0xff80 + 1) * -1\n * (0x007f + 1) * -1\n * (0x0080) * -1\n */\nBuffer.prototype.readInt8 = function(offset, noAssert) {\n  var buffer = this;\n  var neg;\n\n  if (!noAssert) {\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  if (offset >= buffer.length) return;\n\n  neg = buffer.parent[buffer.offset + offset] & 0x80;\n  if (!neg) {\n    return (buffer.parent[buffer.offset + offset]);\n  }\n\n  return ((0xff - buffer.parent[buffer.offset + offset] + 1) * -1);\n};\n\nfunction readInt16(buffer, offset, isBigEndian, noAssert) {\n  var neg, val;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 1 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  val = readUInt16(buffer, offset, isBigEndian, noAssert);\n  neg = val & 0x8000;\n  if (!neg) {\n    return val;\n  }\n\n  return (0xffff - val + 1) * -1;\n}\n\nBuffer.prototype.readInt16LE = function(offset, noAssert) {\n  return readInt16(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readInt16BE = function(offset, noAssert) {\n  return readInt16(this, offset, true, noAssert);\n};\n\nfunction readInt32(buffer, offset, isBigEndian, noAssert) {\n  var neg, val;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  val = readUInt32(buffer, offset, isBigEndian, noAssert);\n  neg = val & 0x80000000;\n  if (!neg) {\n    return (val);\n  }\n\n  return (0xffffffff - val + 1) * -1;\n}\n\nBuffer.prototype.readInt32LE = function(offset, noAssert) {\n  return readInt32(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readInt32BE = function(offset, noAssert) {\n  return readInt32(this, offset, true, noAssert);\n};\n\nfunction readFloat(buffer, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  return require(\'./buffer_ieee754\').readIEEE754(buffer, offset, isBigEndian,\n      23, 4);\n}\n\nBuffer.prototype.readFloatLE = function(offset, noAssert) {\n  return readFloat(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readFloatBE = function(offset, noAssert) {\n  return readFloat(this, offset, true, noAssert);\n};\n\nfunction readDouble(buffer, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset + 7 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  return require(\'./buffer_ieee754\').readIEEE754(buffer, offset, isBigEndian,\n      52, 8);\n}\n\nBuffer.prototype.readDoubleLE = function(offset, noAssert) {\n  return readDouble(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readDoubleBE = function(offset, noAssert) {\n  return readDouble(this, offset, true, noAssert);\n};\n\n\n/*\n * We have to make sure that the value is a valid integer. This means that it is\n * non-negative. It has no fractional component and that it does not exceed the\n * maximum allowed value.\n *\n *      value           The number to check for validity\n *\n *      max             The maximum value\n */\nfunction verifuint(value, max) {\n  assert.ok(typeof (value) == \'number\',\n      \'cannot write a non-number as a number\');\n\n  assert.ok(value >= 0,\n      \'specified a negative value for writing an unsigned value\');\n\n  assert.ok(value <= max, \'value is larger than maximum value for type\');\n\n  assert.ok(Math.floor(value) === value, \'value has a fractional component\');\n}\n\nBuffer.prototype.writeUInt8 = function(value, offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset < buffer.length,\n        \'trying to write beyond buffer length\');\n\n    verifuint(value, 0xff);\n  }\n\n  if (offset < buffer.length) {\n    buffer.parent[buffer.offset + offset] = value;\n  }\n};\n\nfunction writeUInt16(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 1 < buffer.length,\n        \'trying to write beyond buffer length\');\n\n    verifuint(value, 0xffff);\n  }\n\n  for (var i = 0; i < Math.min(buffer.length - offset, 2); i++) {\n    buffer.parent[buffer.offset + offset + i] =\n        (value & (0xff << (8 * (isBigEndian ? 1 - i : i)))) >>>\n            (isBigEndian ? 1 - i : i) * 8;\n  }\n\n}\n\nBuffer.prototype.writeUInt16LE = function(value, offset, noAssert) {\n  writeUInt16(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeUInt16BE = function(value, offset, noAssert) {\n  writeUInt16(this, value, offset, true, noAssert);\n};\n\nfunction writeUInt32(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'trying to write beyond buffer length\');\n\n    verifuint(value, 0xffffffff);\n  }\n\n  for (var i = 0; i < Math.min(buffer.length - offset, 4); i++) {\n    buffer.parent[buffer.offset + offset + i] =\n        (value >>> (isBigEndian ? 3 - i : i) * 8) & 0xff;\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function(value, offset, noAssert) {\n  writeUInt32(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeUInt32BE = function(value, offset, noAssert) {\n  writeUInt32(this, value, offset, true, noAssert);\n};\n\n\n/*\n * We now move onto our friends in the signed number category. Unlike unsigned\n * numbers, we\'re going to have to worry a bit more about how we put values into\n * arrays. Since we are only worrying about signed 32-bit values, we\'re in\n * slightly better shape. Unfortunately, we really can\'t do our favorite binary\n * & in this system. It really seems to do the wrong thing. For example:\n *\n * > -32 & 0xff\n * 224\n *\n * What\'s happening above is really: 0xe0 & 0xff = 0xe0. However, the results of\n * this aren\'t treated as a signed number. Ultimately a bad thing.\n *\n * What we\'re going to want to do is basically create the unsigned equivalent of\n * our representation and pass that off to the wuint* functions. To do that\n * we\'re going to do the following:\n *\n *  - if the value is positive\n *      we can pass it directly off to the equivalent wuint\n *  - if the value is negative\n *      we do the following computation:\n *         mb + val + 1, where\n *         mb   is the maximum unsigned value in that byte size\n *         val  is the Javascript negative integer\n *\n *\n * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If\n * you do out the computations:\n *\n * 0xffff - 128 + 1\n * 0xffff - 127\n * 0xff80\n *\n * You can then encode this value as the signed version. This is really rather\n * hacky, but it should work and get the job done which is our goal here.\n */\n\n/*\n * A series of checks to make sure we actually have a signed 32-bit number\n */\nfunction verifsint(value, max, min) {\n  assert.ok(typeof (value) == \'number\',\n      \'cannot write a non-number as a number\');\n\n  assert.ok(value <= max, \'value larger than maximum allowed value\');\n\n  assert.ok(value >= min, \'value smaller than minimum allowed value\');\n\n  assert.ok(Math.floor(value) === value, \'value has a fractional component\');\n}\n\nfunction verifIEEE754(value, max, min) {\n  assert.ok(typeof (value) == \'number\',\n      \'cannot write a non-number as a number\');\n\n  assert.ok(value <= max, \'value larger than maximum allowed value\');\n\n  assert.ok(value >= min, \'value smaller than minimum allowed value\');\n}\n\nBuffer.prototype.writeInt8 = function(value, offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifsint(value, 0x7f, -0x80);\n  }\n\n  if (value >= 0) {\n    buffer.writeUInt8(value, offset, noAssert);\n  } else {\n    buffer.writeUInt8(0xff + value + 1, offset, noAssert);\n  }\n};\n\nfunction writeInt16(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 1 < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifsint(value, 0x7fff, -0x8000);\n  }\n\n  if (value >= 0) {\n    writeUInt16(buffer, value, offset, isBigEndian, noAssert);\n  } else {\n    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);\n  }\n}\n\nBuffer.prototype.writeInt16LE = function(value, offset, noAssert) {\n  writeInt16(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeInt16BE = function(value, offset, noAssert) {\n  writeInt16(this, value, offset, true, noAssert);\n};\n\nfunction writeInt32(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifsint(value, 0x7fffffff, -0x80000000);\n  }\n\n  if (value >= 0) {\n    writeUInt32(buffer, value, offset, isBigEndian, noAssert);\n  } else {\n    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);\n  }\n}\n\nBuffer.prototype.writeInt32LE = function(value, offset, noAssert) {\n  writeInt32(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeInt32BE = function(value, offset, noAssert) {\n  writeInt32(this, value, offset, true, noAssert);\n};\n\nfunction writeFloat(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);\n  }\n\n  require(\'./buffer_ieee754\').writeIEEE754(buffer, value, offset, isBigEndian,\n      23, 4);\n}\n\nBuffer.prototype.writeFloatLE = function(value, offset, noAssert) {\n  writeFloat(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeFloatBE = function(value, offset, noAssert) {\n  writeFloat(this, value, offset, true, noAssert);\n};\n\nfunction writeDouble(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 7 < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);\n  }\n\n  require(\'./buffer_ieee754\').writeIEEE754(buffer, value, offset, isBigEndian,\n      52, 8);\n}\n\nBuffer.prototype.writeDoubleLE = function(value, offset, noAssert) {\n  writeDouble(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeDoubleBE = function(value, offset, noAssert) {\n  writeDouble(this, value, offset, true, noAssert);\n};\n\nSlowBuffer.prototype.readUInt8 = Buffer.prototype.readUInt8;\nSlowBuffer.prototype.readUInt16LE = Buffer.prototype.readUInt16LE;\nSlowBuffer.prototype.readUInt16BE = Buffer.prototype.readUInt16BE;\nSlowBuffer.prototype.readUInt32LE = Buffer.prototype.readUInt32LE;\nSlowBuffer.prototype.readUInt32BE = Buffer.prototype.readUInt32BE;\nSlowBuffer.prototype.readInt8 = Buffer.prototype.readInt8;\nSlowBuffer.prototype.readInt16LE = Buffer.prototype.readInt16LE;\nSlowBuffer.prototype.readInt16BE = Buffer.prototype.readInt16BE;\nSlowBuffer.prototype.readInt32LE = Buffer.prototype.readInt32LE;\nSlowBuffer.prototype.readInt32BE = Buffer.prototype.readInt32BE;\nSlowBuffer.prototype.readFloatLE = Buffer.prototype.readFloatLE;\nSlowBuffer.prototype.readFloatBE = Buffer.prototype.readFloatBE;\nSlowBuffer.prototype.readDoubleLE = Buffer.prototype.readDoubleLE;\nSlowBuffer.prototype.readDoubleBE = Buffer.prototype.readDoubleBE;\nSlowBuffer.prototype.writeUInt8 = Buffer.prototype.writeUInt8;\nSlowBuffer.prototype.writeUInt16LE = Buffer.prototype.writeUInt16LE;\nSlowBuffer.prototype.writeUInt16BE = Buffer.prototype.writeUInt16BE;\nSlowBuffer.prototype.writeUInt32LE = Buffer.prototype.writeUInt32LE;\nSlowBuffer.prototype.writeUInt32BE = Buffer.prototype.writeUInt32BE;\nSlowBuffer.prototype.writeInt8 = Buffer.prototype.writeInt8;\nSlowBuffer.prototype.writeInt16LE = Buffer.prototype.writeInt16LE;\nSlowBuffer.prototype.writeInt16BE = Buffer.prototype.writeInt16BE;\nSlowBuffer.prototype.writeInt32LE = Buffer.prototype.writeInt32LE;\nSlowBuffer.prototype.writeInt32BE = Buffer.prototype.writeInt32BE;\nSlowBuffer.prototype.writeFloatLE = Buffer.prototype.writeFloatLE;\nSlowBuffer.prototype.writeFloatBE = Buffer.prototype.writeFloatBE;\nSlowBuffer.prototype.writeDoubleLE = Buffer.prototype.writeDoubleLE;\nSlowBuffer.prototype.writeDoubleBE = Buffer.prototype.writeDoubleBE;\n\n})()\n},{"assert":2,"./buffer_ieee754":1,"base64-js":5}],3:[function(require,module,exports){\nvar events = require(\'events\');\n\nexports.isArray = isArray;\nexports.isDate = function(obj){return Object.prototype.toString.call(obj) === \'[object Date]\'};\nexports.isRegExp = function(obj){return Object.prototype.toString.call(obj) === \'[object RegExp]\'};\n\n\nexports.print = function () {};\nexports.puts = function () {};\nexports.debug = function() {};\n\nexports.inspect = function(obj, showHidden, depth, colors) {\n  var seen = [];\n\n  var stylize = function(str, styleType) {\n    // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\n    var styles =\n        { \'bold\' : [1, 22],\n          \'italic\' : [3, 23],\n          \'underline\' : [4, 24],\n          \'inverse\' : [7, 27],\n          \'white\' : [37, 39],\n          \'grey\' : [90, 39],\n          \'black\' : [30, 39],\n          \'blue\' : [34, 39],\n          \'cyan\' : [36, 39],\n          \'green\' : [32, 39],\n          \'magenta\' : [35, 39],\n          \'red\' : [31, 39],\n          \'yellow\' : [33, 39] };\n\n    var style =\n        { \'special\': \'cyan\',\n          \'number\': \'blue\',\n          \'boolean\': \'yellow\',\n          \'undefined\': \'grey\',\n          \'null\': \'bold\',\n          \'string\': \'green\',\n          \'date\': \'magenta\',\n          // "name": intentionally not styling\n          \'regexp\': \'red\' }[styleType];\n\n    if (style) {\n      return \'\\033[\' + styles[style][0] + \'m\' + str +\n             \'\\033[\' + styles[style][1] + \'m\';\n    } else {\n      return str;\n    }\n  };\n  if (! colors) {\n    stylize = function(str, styleType) { return str; };\n  }\n\n  function format(value, recurseTimes) {\n    // Provide a hook for user-specified inspect functions.\n    // Check that value is an object with an inspect function on it\n    if (value && typeof value.inspect === \'function\' &&\n        // Filter out the util module, it\'s inspect function is special\n        value !== exports &&\n        // Also filter out any prototype objects using the circular check.\n        !(value.constructor && value.constructor.prototype === value)) {\n      return value.inspect(recurseTimes);\n    }\n\n    // Primitive types cannot have properties\n    switch (typeof value) {\n      case \'undefined\':\n        return stylize(\'undefined\', \'undefined\');\n\n      case \'string\':\n        var simple = \'\\\'\' + JSON.stringify(value).replace(/^"|"$/g, \'\')\n                                                 .replace(/\'/g, "\\\\\'")\n                                                 .replace(/\\\\"/g, \'"\') + \'\\\'\';\n        return stylize(simple, \'string\');\n\n      case \'number\':\n        return stylize(\'\' + value, \'number\');\n\n      case \'boolean\':\n        return stylize(\'\' + value, \'boolean\');\n    }\n    // For some reason typeof null is "object", so special case here.\n    if (value === null) {\n      return stylize(\'null\', \'null\');\n    }\n\n    // Look up the keys of the object.\n    var visible_keys = Object_keys(value);\n    var keys = showHidden ? Object_getOwnPropertyNames(value) : visible_keys;\n\n    // Functions without properties can be shortcutted.\n    if (typeof value === \'function\' && keys.length === 0) {\n      if (isRegExp(value)) {\n        return stylize(\'\' + value, \'regexp\');\n      } else {\n        var name = value.name ? \': \' + value.name : \'\';\n        return stylize(\'[Function\' + name + \']\', \'special\');\n      }\n    }\n\n    // Dates without properties can be shortcutted\n    if (isDate(value) && keys.length === 0) {\n      return stylize(value.toUTCString(), \'date\');\n    }\n\n    var base, type, braces;\n    // Determine the object type\n    if (isArray(value)) {\n      type = \'Array\';\n      braces = [\'[\', \']\'];\n    } else {\n      type = \'Object\';\n      braces = [\'{\', \'}\'];\n    }\n\n    // Make functions say that they are functions\n    if (typeof value === \'function\') {\n      var n = value.name ? \': \' + value.name : \'\';\n      base = (isRegExp(value)) ? \' \' + value : \' [Function\' + n + \']\';\n    } else {\n      base = \'\';\n    }\n\n    // Make dates with properties first say the date\n    if (isDate(value)) {\n      base = \' \' + value.toUTCString();\n    }\n\n    if (keys.length === 0) {\n      return braces[0] + base + braces[1];\n    }\n\n    if (recurseTimes < 0) {\n      if (isRegExp(value)) {\n        return stylize(\'\' + value, \'regexp\');\n      } else {\n        return stylize(\'[Object]\', \'special\');\n      }\n    }\n\n    seen.push(value);\n\n    var output = keys.map(function(key) {\n      var name, str;\n      if (value.__lookupGetter__) {\n        if (value.__lookupGetter__(key)) {\n          if (value.__lookupSetter__(key)) {\n            str = stylize(\'[Getter/Setter]\', \'special\');\n          } else {\n            str = stylize(\'[Getter]\', \'special\');\n          }\n        } else {\n          if (value.__lookupSetter__(key)) {\n            str = stylize(\'[Setter]\', \'special\');\n          }\n        }\n      }\n      if (visible_keys.indexOf(key) < 0) {\n        name = \'[\' + key + \']\';\n      }\n      if (!str) {\n        if (seen.indexOf(value[key]) < 0) {\n          if (recurseTimes === null) {\n            str = format(value[key]);\n          } else {\n            str = format(value[key], recurseTimes - 1);\n          }\n          if (str.indexOf(\'\\n\') > -1) {\n            if (isArray(value)) {\n              str = str.split(\'\\n\').map(function(line) {\n                return \'  \' + line;\n              }).join(\'\\n\').substr(2);\n            } else {\n              str = \'\\n\' + str.split(\'\\n\').map(function(line) {\n                return \'   \' + line;\n              }).join(\'\\n\');\n            }\n          }\n        } else {\n          str = stylize(\'[Circular]\', \'special\');\n        }\n      }\n      if (typeof name === \'undefined\') {\n        if (type === \'Array\' && key.match(/^\\d+$/)) {\n          return str;\n        }\n        name = JSON.stringify(\'\' + key);\n        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {\n          name = name.substr(1, name.length - 2);\n          name = stylize(name, \'name\');\n        } else {\n          name = name.replace(/\'/g, "\\\\\'")\n                     .replace(/\\\\"/g, \'"\')\n                     .replace(/(^"|"$)/g, "\'");\n          name = stylize(name, \'string\');\n        }\n      }\n\n      return name + \': \' + str;\n    });\n\n    seen.pop();\n\n    var numLinesEst = 0;\n    var length = output.reduce(function(prev, cur) {\n      numLinesEst++;\n      if (cur.indexOf(\'\\n\') >= 0) numLinesEst++;\n      return prev + cur.length + 1;\n    }, 0);\n\n    if (length > 50) {\n      output = braces[0] +\n               (base === \'\' ? \'\' : base + \'\\n \') +\n               \' \' +\n               output.join(\',\\n  \') +\n               \' \' +\n               braces[1];\n\n    } else {\n      output = braces[0] + base + \' \' + output.join(\', \') + \' \' + braces[1];\n    }\n\n    return output;\n  }\n  return format(obj, (typeof depth === \'undefined\' ? 2 : depth));\n};\n\n\nfunction isArray(ar) {\n  return ar instanceof Array ||\n         Array.isArray(ar) ||\n         (ar && ar !== Object.prototype && isArray(ar.__proto__));\n}\n\n\nfunction isRegExp(re) {\n  return re instanceof RegExp ||\n    (typeof re === \'object\' && Object.prototype.toString.call(re) === \'[object RegExp]\');\n}\n\n\nfunction isDate(d) {\n  if (d instanceof Date) return true;\n  if (typeof d !== \'object\') return false;\n  var properties = Date.prototype && Object_getOwnPropertyNames(Date.prototype);\n  var proto = d.__proto__ && Object_getOwnPropertyNames(d.__proto__);\n  return JSON.stringify(proto) === JSON.stringify(properties);\n}\n\nfunction pad(n) {\n  return n < 10 ? \'0\' + n.toString(10) : n.toString(10);\n}\n\nvar months = [\'Jan\', \'Feb\', \'Mar\', \'Apr\', \'May\', \'Jun\', \'Jul\', \'Aug\', \'Sep\',\n              \'Oct\', \'Nov\', \'Dec\'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(\':\');\n  return [d.getDate(), months[d.getMonth()], time].join(\' \');\n}\n\nexports.log = function (msg) {};\n\nexports.pump = null;\n\nvar Object_keys = Object.keys || function (obj) {\n    var res = [];\n    for (var key in obj) res.push(key);\n    return res;\n};\n\nvar Object_getOwnPropertyNames = Object.getOwnPropertyNames || function (obj) {\n    var res = [];\n    for (var key in obj) {\n        if (Object.hasOwnProperty.call(obj, key)) res.push(key);\n    }\n    return res;\n};\n\nvar Object_create = Object.create || function (prototype, properties) {\n    // from es5-shim\n    var object;\n    if (prototype === null) {\n        object = { \'__proto__\' : null };\n    }\n    else {\n        if (typeof prototype !== \'object\') {\n            throw new TypeError(\n                \'typeof prototype[\' + (typeof prototype) + \'] != \\\'object\\\'\'\n            );\n        }\n        var Type = function () {};\n        Type.prototype = prototype;\n        object = new Type();\n        object.__proto__ = prototype;\n    }\n    if (typeof properties !== \'undefined\' && Object.defineProperties) {\n        Object.defineProperties(object, properties);\n    }\n    return object;\n};\n\nexports.inherits = function(ctor, superCtor) {\n  ctor.super_ = superCtor;\n  ctor.prototype = Object_create(superCtor.prototype, {\n    constructor: {\n      value: ctor,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n};\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (typeof f !== \'string\') {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(exports.inspect(arguments[i]));\n    }\n    return objects.join(\' \');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === \'%%\') return \'%\';\n    if (i >= len) return x;\n    switch (x) {\n      case \'%s\': return String(args[i++]);\n      case \'%d\': return Number(args[i++]);\n      case \'%j\': return JSON.stringify(args[i++]);\n      default:\n        return x;\n    }\n  });\n  for(var x = args[i]; i < len; x = args[++i]){\n    if (x === null || typeof x !== \'object\') {\n      str += \' \' + x;\n    } else {\n      str += \' \' + exports.inspect(x);\n    }\n  }\n  return str;\n};\n\n},{"events":6}],5:[function(require,module,exports){\n(function (exports) {\n\t\'use strict\';\n\n\tvar lookup = \'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\';\n\n\tfunction b64ToByteArray(b64) {\n\t\tvar i, j, l, tmp, placeHolders, arr;\n\t\n\t\tif (b64.length % 4 > 0) {\n\t\t\tthrow \'Invalid string. Length must be a multiple of 4\';\n\t\t}\n\n\t\t// the number of equal signs (place holders)\n\t\t// if there are two placeholders, than the two characters before it\n\t\t// represent one byte\n\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t// this is just a cheap hack to not do indexOf twice\n\t\tplaceHolders = b64.indexOf(\'=\');\n\t\tplaceHolders = placeHolders > 0 ? b64.length - placeHolders : 0;\n\n\t\t// base64 is 4/3 + up to two characters of the original data\n\t\tarr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);\n\n\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length;\n\n\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);\n\t\t\tarr.push((tmp & 0xFF0000) >> 16);\n\t\t\tarr.push((tmp & 0xFF00) >> 8);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t}\n\n\t\tif (placeHolders === 2) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t} else if (placeHolders === 1) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);\n\t\t\tarr.push((tmp >> 8) & 0xFF);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t}\n\n\t\treturn arr;\n\t}\n\n\tfunction uint8ToBase64(uint8) {\n\t\tvar i,\n\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\toutput = "",\n\t\t\ttemp, length;\n\n\t\tfunction tripletToBase64 (num) {\n\t\t\treturn lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n\t\t};\n\n\t\t// go through the array every three bytes, we\'ll deal with trailing stuff later\n\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);\n\t\t\toutput += tripletToBase64(temp);\n\t\t}\n\n\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\tswitch (extraBytes) {\n\t\t\tcase 1:\n\t\t\t\ttemp = uint8[uint8.length - 1];\n\t\t\t\toutput += lookup[temp >> 2];\n\t\t\t\toutput += lookup[(temp << 4) & 0x3F];\n\t\t\t\toutput += \'==\';\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);\n\t\t\t\toutput += lookup[temp >> 10];\n\t\t\t\toutput += lookup[(temp >> 4) & 0x3F];\n\t\t\t\toutput += lookup[(temp << 2) & 0x3F];\n\t\t\t\toutput += \'=\';\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn output;\n\t}\n\n\tmodule.exports.toByteArray = b64ToByteArray;\n\tmodule.exports.fromByteArray = uint8ToBase64;\n}());\n\n},{}],7:[function(require,module,exports){\nexports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {\n  var e, m,\n      eLen = nBytes * 8 - mLen - 1,\n      eMax = (1 << eLen) - 1,\n      eBias = eMax >> 1,\n      nBits = -7,\n      i = isBE ? 0 : (nBytes - 1),\n      d = isBE ? 1 : -1,\n      s = buffer[offset + i];\n\n  i += d;\n\n  e = s & ((1 << (-nBits)) - 1);\n  s >>= (-nBits);\n  nBits += eLen;\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);\n\n  m = e & ((1 << (-nBits)) - 1);\n  e >>= (-nBits);\n  nBits += mLen;\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);\n\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity);\n  } else {\n    m = m + Math.pow(2, mLen);\n    e = e - eBias;\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n};\n\nexports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {\n  var e, m, c,\n      eLen = nBytes * 8 - mLen - 1,\n      eMax = (1 << eLen) - 1,\n      eBias = eMax >> 1,\n      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),\n      i = isBE ? (nBytes - 1) : 0,\n      d = isBE ? -1 : 1,\n      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;\n\n  value = Math.abs(value);\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0;\n    e = eMax;\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2);\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * Math.pow(2, 1 - eBias);\n    }\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n      e = 0;\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);\n\n  e = (e << mLen) | m;\n  eLen += mLen;\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);\n\n  buffer[offset + i - d] |= s * 128;\n};\n\n},{}],8:[function(require,module,exports){\n// shim for using process in browser\n\nvar process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== \'undefined\'\n    && window.setImmediate;\n    var canPost = typeof window !== \'undefined\'\n    && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    if (canPost) {\n        var queue = [];\n        window.addEventListener(\'message\', function (ev) {\n            if (ev.source === window && ev.data === \'process-tick\') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage(\'process-tick\', \'*\');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = \'browser\';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nprocess.binding = function (name) {\n    throw new Error(\'process.binding is not supported\');\n}\n\n// TODO(shtylman)\nprocess.cwd = function () { return \'/\' };\nprocess.chdir = function (dir) {\n    throw new Error(\'process.chdir is not supported\');\n};\n\n},{}],6:[function(require,module,exports){\n(function(process){if (!process.EventEmitter) process.EventEmitter = function () {};\n\nvar EventEmitter = exports.EventEmitter = process.EventEmitter;\nvar isArray = typeof Array.isArray === \'function\'\n    ? Array.isArray\n    : function (xs) {\n        return Object.prototype.toString.call(xs) === \'[object Array]\'\n    }\n;\nfunction indexOf (xs, x) {\n    if (xs.indexOf) return xs.indexOf(x);\n    for (var i = 0; i < xs.length; i++) {\n        if (x === xs[i]) return i;\n    }\n    return -1;\n}\n\n// By default EventEmitters will print a warning if more than\n// 10 listeners are added to it. This is a useful default which\n// helps finding memory leaks.\n//\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nvar defaultMaxListeners = 10;\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!this._events) this._events = {};\n  this._events.maxListeners = n;\n};\n\n\nEventEmitter.prototype.emit = function(type) {\n  // If there is no \'error\' event listener then throw.\n  if (type === \'error\') {\n    if (!this._events || !this._events.error ||\n        (isArray(this._events.error) && !this._events.error.length))\n    {\n      if (arguments[1] instanceof Error) {\n        throw arguments[1]; // Unhandled \'error\' event\n      } else {\n        throw new Error("Uncaught, unspecified \'error\' event.");\n      }\n      return false;\n    }\n  }\n\n  if (!this._events) return false;\n  var handler = this._events[type];\n  if (!handler) return false;\n\n  if (typeof handler == \'function\') {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        var args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n    return true;\n\n  } else if (isArray(handler)) {\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    var listeners = handler.slice();\n    for (var i = 0, l = listeners.length; i < l; i++) {\n      listeners[i].apply(this, args);\n    }\n    return true;\n\n  } else {\n    return false;\n  }\n};\n\n// EventEmitter is defined in src/node_events.cc\n// EventEmitter.prototype.emit() is also defined there.\nEventEmitter.prototype.addListener = function(type, listener) {\n  if (\'function\' !== typeof listener) {\n    throw new Error(\'addListener only takes instances of Function\');\n  }\n\n  if (!this._events) this._events = {};\n\n  // To avoid recursion in the case that type == "newListeners"! Before\n  // adding it to the listeners, first emit "newListeners".\n  this.emit(\'newListener\', type, listener);\n\n  if (!this._events[type]) {\n    // Optimize the case of one listener. Don\'t need the extra array object.\n    this._events[type] = listener;\n  } else if (isArray(this._events[type])) {\n\n    // Check for listener leak\n    if (!this._events[type].warned) {\n      var m;\n      if (this._events.maxListeners !== undefined) {\n        m = this._events.maxListeners;\n      } else {\n        m = defaultMaxListeners;\n      }\n\n      if (m && m > 0 && this._events[type].length > m) {\n        this._events[type].warned = true;\n        console.error(\'(node) warning: possible EventEmitter memory \' +\n                      \'leak detected. %d listeners added. \' +\n                      \'Use emitter.setMaxListeners() to increase limit.\',\n                      this._events[type].length);\n        console.trace();\n      }\n    }\n\n    // If we\'ve already got an array, just append.\n    this._events[type].push(listener);\n  } else {\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  var self = this;\n  self.on(type, function g() {\n    self.removeListener(type, g);\n    listener.apply(this, arguments);\n  });\n\n  return this;\n};\n\nEventEmitter.prototype.removeListener = function(type, listener) {\n  if (\'function\' !== typeof listener) {\n    throw new Error(\'removeListener only takes instances of Function\');\n  }\n\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (!this._events || !this._events[type]) return this;\n\n  var list = this._events[type];\n\n  if (isArray(list)) {\n    var i = indexOf(list, listener);\n    if (i < 0) return this;\n    list.splice(i, 1);\n    if (list.length == 0)\n      delete this._events[type];\n  } else if (this._events[type] === listener) {\n    delete this._events[type];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  if (arguments.length === 0) {\n    this._events = {};\n    return this;\n  }\n\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (type && this._events && this._events[type]) this._events[type] = null;\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  if (!this._events) this._events = {};\n  if (!this._events[type]) this._events[type] = [];\n  if (!isArray(this._events[type])) {\n    this._events[type] = [this._events[type]];\n  }\n  return this._events[type];\n};\n\n})(require("__browserify_process"))\n},{"__browserify_process":8}],4:[function(require,module,exports){\n(function(){function SlowBuffer (size) {\n    this.length = size;\n};\n\nvar assert = require(\'assert\');\n\nexports.INSPECT_MAX_BYTES = 50;\n\n\nfunction toHex(n) {\n  if (n < 16) return \'0\' + n.toString(16);\n  return n.toString(16);\n}\n\nfunction utf8ToBytes(str) {\n  var byteArray = [];\n  for (var i = 0; i < str.length; i++)\n    if (str.charCodeAt(i) <= 0x7F)\n      byteArray.push(str.charCodeAt(i));\n    else {\n      var h = encodeURIComponent(str.charAt(i)).substr(1).split(\'%\');\n      for (var j = 0; j < h.length; j++)\n        byteArray.push(parseInt(h[j], 16));\n    }\n\n  return byteArray;\n}\n\nfunction asciiToBytes(str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++ )\n    // Node\'s code seems to be doing this and not & 0x7F..\n    byteArray.push( str.charCodeAt(i) & 0xFF );\n\n  return byteArray;\n}\n\nfunction base64ToBytes(str) {\n  return require("base64-js").toByteArray(str);\n}\n\nSlowBuffer.byteLength = function (str, encoding) {\n  switch (encoding || "utf8") {\n    case \'hex\':\n      return str.length / 2;\n\n    case \'utf8\':\n    case \'utf-8\':\n      return utf8ToBytes(str).length;\n\n    case \'ascii\':\n      return str.length;\n\n    case \'base64\':\n      return base64ToBytes(str).length;\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n};\n\nfunction blitBuffer(src, dst, offset, length) {\n  var pos, i = 0;\n  while (i < length) {\n    if ((i+offset >= dst.length) || (i >= src.length))\n      break;\n\n    dst[i + offset] = src[i];\n    i++;\n  }\n  return i;\n}\n\nSlowBuffer.prototype.utf8Write = function (string, offset, length) {\n  var bytes, pos;\n  return SlowBuffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);\n};\n\nSlowBuffer.prototype.asciiWrite = function (string, offset, length) {\n  var bytes, pos;\n  return SlowBuffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);\n};\n\nSlowBuffer.prototype.base64Write = function (string, offset, length) {\n  var bytes, pos;\n  return SlowBuffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);\n};\n\nSlowBuffer.prototype.base64Slice = function (start, end) {\n  var bytes = Array.prototype.slice.apply(this, arguments)\n  return require("base64-js").fromByteArray(bytes);\n}\n\nfunction decodeUtf8Char(str) {\n  try {\n    return decodeURIComponent(str);\n  } catch (err) {\n    return String.fromCharCode(0xFFFD); // UTF 8 invalid char\n  }\n}\n\nSlowBuffer.prototype.utf8Slice = function () {\n  var bytes = Array.prototype.slice.apply(this, arguments);\n  var res = "";\n  var tmp = "";\n  var i = 0;\n  while (i < bytes.length) {\n    if (bytes[i] <= 0x7F) {\n      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);\n      tmp = "";\n    } else\n      tmp += "%" + bytes[i].toString(16);\n\n    i++;\n  }\n\n  return res + decodeUtf8Char(tmp);\n}\n\nSlowBuffer.prototype.asciiSlice = function () {\n  var bytes = Array.prototype.slice.apply(this, arguments);\n  var ret = "";\n  for (var i = 0; i < bytes.length; i++)\n    ret += String.fromCharCode(bytes[i]);\n  return ret;\n}\n\nSlowBuffer.prototype.inspect = function() {\n  var out = [],\n      len = this.length;\n  for (var i = 0; i < len; i++) {\n    out[i] = toHex(this[i]);\n    if (i == exports.INSPECT_MAX_BYTES) {\n      out[i + 1] = \'...\';\n      break;\n    }\n  }\n  return \'<SlowBuffer \' + out.join(\' \') + \'>\';\n};\n\n\nSlowBuffer.prototype.hexSlice = function(start, end) {\n  var len = this.length;\n\n  if (!start || start < 0) start = 0;\n  if (!end || end < 0 || end > len) end = len;\n\n  var out = \'\';\n  for (var i = start; i < end; i++) {\n    out += toHex(this[i]);\n  }\n  return out;\n};\n\n\nSlowBuffer.prototype.toString = function(encoding, start, end) {\n  encoding = String(encoding || \'utf8\').toLowerCase();\n  start = +start || 0;\n  if (typeof end == \'undefined\') end = this.length;\n\n  // Fastpath empty strings\n  if (+end == start) {\n    return \'\';\n  }\n\n  switch (encoding) {\n    case \'hex\':\n      return this.hexSlice(start, end);\n\n    case \'utf8\':\n    case \'utf-8\':\n      return this.utf8Slice(start, end);\n\n    case \'ascii\':\n      return this.asciiSlice(start, end);\n\n    case \'binary\':\n      return this.binarySlice(start, end);\n\n    case \'base64\':\n      return this.base64Slice(start, end);\n\n    case \'ucs2\':\n    case \'ucs-2\':\n      return this.ucs2Slice(start, end);\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n};\n\n\nSlowBuffer.prototype.hexWrite = function(string, offset, length) {\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length;\n  if (strLen % 2) {\n    throw new Error(\'Invalid hex string\');\n  }\n  if (length > strLen / 2) {\n    length = strLen / 2;\n  }\n  for (var i = 0; i < length; i++) {\n    var byte = parseInt(string.substr(i * 2, 2), 16);\n    if (isNaN(byte)) throw new Error(\'Invalid hex string\');\n    this[offset + i] = byte;\n  }\n  SlowBuffer._charsWritten = i * 2;\n  return i;\n};\n\n\nSlowBuffer.prototype.write = function(string, offset, length, encoding) {\n  // Support both (string, offset, length, encoding)\n  // and the legacy (string, encoding, offset, length)\n  if (isFinite(offset)) {\n    if (!isFinite(length)) {\n      encoding = length;\n      length = undefined;\n    }\n  } else {  // legacy\n    var swap = encoding;\n    encoding = offset;\n    offset = length;\n    length = swap;\n  }\n\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n  encoding = String(encoding || \'utf8\').toLowerCase();\n\n  switch (encoding) {\n    case \'hex\':\n      return this.hexWrite(string, offset, length);\n\n    case \'utf8\':\n    case \'utf-8\':\n      return this.utf8Write(string, offset, length);\n\n    case \'ascii\':\n      return this.asciiWrite(string, offset, length);\n\n    case \'binary\':\n      return this.binaryWrite(string, offset, length);\n\n    case \'base64\':\n      return this.base64Write(string, offset, length);\n\n    case \'ucs2\':\n    case \'ucs-2\':\n      return this.ucs2Write(string, offset, length);\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n};\n\n\n// slice(start, end)\nSlowBuffer.prototype.slice = function(start, end) {\n  if (end === undefined) end = this.length;\n\n  if (end > this.length) {\n    throw new Error(\'oob\');\n  }\n  if (start > end) {\n    throw new Error(\'oob\');\n  }\n\n  return new Buffer(this, end - start, +start);\n};\n\nSlowBuffer.prototype.copy = function(target, targetstart, sourcestart, sourceend) {\n  var temp = [];\n  for (var i=sourcestart; i<sourceend; i++) {\n    assert.ok(typeof this[i] !== \'undefined\', "copying undefined buffer bytes!");\n    temp.push(this[i]);\n  }\n\n  for (var i=targetstart; i<targetstart+temp.length; i++) {\n    target[i] = temp[i-targetstart];\n  }\n};\n\nfunction coerce(length) {\n  // Coerce length to a number (possibly NaN), round up\n  // in case it\'s fractional (e.g. 123.456) then do a\n  // double negate to coerce a NaN to 0. Easy, right?\n  length = ~~Math.ceil(+length);\n  return length < 0 ? 0 : length;\n}\n\n\n// Buffer\n\nfunction Buffer(subject, encoding, offset) {\n  if (!(this instanceof Buffer)) {\n    return new Buffer(subject, encoding, offset);\n  }\n\n  var type;\n\n  // Are we slicing?\n  if (typeof offset === \'number\') {\n    this.length = coerce(encoding);\n    this.parent = subject;\n    this.offset = offset;\n  } else {\n    // Find the length\n    switch (type = typeof subject) {\n      case \'number\':\n        this.length = coerce(subject);\n        break;\n\n      case \'string\':\n        this.length = Buffer.byteLength(subject, encoding);\n        break;\n\n      case \'object\': // Assume object is an array\n        this.length = coerce(subject.length);\n        break;\n\n      default:\n        throw new Error(\'First argument needs to be a number, \' +\n                        \'array or string.\');\n    }\n\n    if (this.length > Buffer.poolSize) {\n      // Big buffer, just alloc one.\n      this.parent = new SlowBuffer(this.length);\n      this.offset = 0;\n\n    } else {\n      // Small buffer.\n      if (!pool || pool.length - pool.used < this.length) allocPool();\n      this.parent = pool;\n      this.offset = pool.used;\n      pool.used += this.length;\n    }\n\n    // Treat array-ish objects as a byte array.\n    if (isArrayIsh(subject)) {\n      for (var i = 0; i < this.length; i++) {\n        this.parent[i + this.offset] = subject[i];\n      }\n    } else if (type == \'string\') {\n      // We are a string\n      this.length = this.write(subject, 0, encoding);\n    }\n  }\n\n}\n\nfunction isArrayIsh(subject) {\n  return Array.isArray(subject) || Buffer.isBuffer(subject) ||\n         subject && typeof subject === \'object\' &&\n         typeof subject.length === \'number\';\n}\n\nexports.SlowBuffer = SlowBuffer;\nexports.Buffer = Buffer;\n\nBuffer.poolSize = 8 * 1024;\nvar pool;\n\nfunction allocPool() {\n  pool = new SlowBuffer(Buffer.poolSize);\n  pool.used = 0;\n}\n\n\n// Static methods\nBuffer.isBuffer = function isBuffer(b) {\n  return b instanceof Buffer || b instanceof SlowBuffer;\n};\n\nBuffer.concat = function (list, totalLength) {\n  if (!Array.isArray(list)) {\n    throw new Error("Usage: Buffer.concat(list, [totalLength])\\n \\\n      list should be an Array.");\n  }\n\n  if (list.length === 0) {\n    return new Buffer(0);\n  } else if (list.length === 1) {\n    return list[0];\n  }\n\n  if (typeof totalLength !== \'number\') {\n    totalLength = 0;\n    for (var i = 0; i < list.length; i++) {\n      var buf = list[i];\n      totalLength += buf.length;\n    }\n  }\n\n  var buffer = new Buffer(totalLength);\n  var pos = 0;\n  for (var i = 0; i < list.length; i++) {\n    var buf = list[i];\n    buf.copy(buffer, pos);\n    pos += buf.length;\n  }\n  return buffer;\n};\n\n// Inspect\nBuffer.prototype.inspect = function inspect() {\n  var out = [],\n      len = this.length;\n\n  for (var i = 0; i < len; i++) {\n    out[i] = toHex(this.parent[i + this.offset]);\n    if (i == exports.INSPECT_MAX_BYTES) {\n      out[i + 1] = \'...\';\n      break;\n    }\n  }\n\n  return \'<Buffer \' + out.join(\' \') + \'>\';\n};\n\n\nBuffer.prototype.get = function get(i) {\n  if (i < 0 || i >= this.length) throw new Error(\'oob\');\n  return this.parent[this.offset + i];\n};\n\n\nBuffer.prototype.set = function set(i, v) {\n  if (i < 0 || i >= this.length) throw new Error(\'oob\');\n  return this.parent[this.offset + i] = v;\n};\n\n\n// write(string, offset = 0, length = buffer.length-offset, encoding = \'utf8\')\nBuffer.prototype.write = function(string, offset, length, encoding) {\n  // Support both (string, offset, length, encoding)\n  // and the legacy (string, encoding, offset, length)\n  if (isFinite(offset)) {\n    if (!isFinite(length)) {\n      encoding = length;\n      length = undefined;\n    }\n  } else {  // legacy\n    var swap = encoding;\n    encoding = offset;\n    offset = length;\n    length = swap;\n  }\n\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n  encoding = String(encoding || \'utf8\').toLowerCase();\n\n  var ret;\n  switch (encoding) {\n    case \'hex\':\n      ret = this.parent.hexWrite(string, this.offset + offset, length);\n      break;\n\n    case \'utf8\':\n    case \'utf-8\':\n      ret = this.parent.utf8Write(string, this.offset + offset, length);\n      break;\n\n    case \'ascii\':\n      ret = this.parent.asciiWrite(string, this.offset + offset, length);\n      break;\n\n    case \'binary\':\n      ret = this.parent.binaryWrite(string, this.offset + offset, length);\n      break;\n\n    case \'base64\':\n      // Warning: maxLength not taken into account in base64Write\n      ret = this.parent.base64Write(string, this.offset + offset, length);\n      break;\n\n    case \'ucs2\':\n    case \'ucs-2\':\n      ret = this.parent.ucs2Write(string, this.offset + offset, length);\n      break;\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n\n  Buffer._charsWritten = SlowBuffer._charsWritten;\n\n  return ret;\n};\n\n\n// toString(encoding, start=0, end=buffer.length)\nBuffer.prototype.toString = function(encoding, start, end) {\n  encoding = String(encoding || \'utf8\').toLowerCase();\n\n  if (typeof start == \'undefined\' || start < 0) {\n    start = 0;\n  } else if (start > this.length) {\n    start = this.length;\n  }\n\n  if (typeof end == \'undefined\' || end > this.length) {\n    end = this.length;\n  } else if (end < 0) {\n    end = 0;\n  }\n\n  start = start + this.offset;\n  end = end + this.offset;\n\n  switch (encoding) {\n    case \'hex\':\n      return this.parent.hexSlice(start, end);\n\n    case \'utf8\':\n    case \'utf-8\':\n      return this.parent.utf8Slice(start, end);\n\n    case \'ascii\':\n      return this.parent.asciiSlice(start, end);\n\n    case \'binary\':\n      return this.parent.binarySlice(start, end);\n\n    case \'base64\':\n      return this.parent.base64Slice(start, end);\n\n    case \'ucs2\':\n    case \'ucs-2\':\n      return this.parent.ucs2Slice(start, end);\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n};\n\n\n// byteLength\nBuffer.byteLength = SlowBuffer.byteLength;\n\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function fill(value, start, end) {\n  value || (value = 0);\n  start || (start = 0);\n  end || (end = this.length);\n\n  if (typeof value === \'string\') {\n    value = value.charCodeAt(0);\n  }\n  if (!(typeof value === \'number\') || isNaN(value)) {\n    throw new Error(\'value is not a number\');\n  }\n\n  if (end < start) throw new Error(\'end < start\');\n\n  // Fill 0 bytes; we\'re done\n  if (end === start) return 0;\n  if (this.length == 0) return 0;\n\n  if (start < 0 || start >= this.length) {\n    throw new Error(\'start out of bounds\');\n  }\n\n  if (end < 0 || end > this.length) {\n    throw new Error(\'end out of bounds\');\n  }\n\n  return this.parent.fill(value,\n                          start + this.offset,\n                          end + this.offset);\n};\n\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function(target, target_start, start, end) {\n  var source = this;\n  start || (start = 0);\n  end || (end = this.length);\n  target_start || (target_start = 0);\n\n  if (end < start) throw new Error(\'sourceEnd < sourceStart\');\n\n  // Copy 0 bytes; we\'re done\n  if (end === start) return 0;\n  if (target.length == 0 || source.length == 0) return 0;\n\n  if (target_start < 0 || target_start >= target.length) {\n    throw new Error(\'targetStart out of bounds\');\n  }\n\n  if (start < 0 || start >= source.length) {\n    throw new Error(\'sourceStart out of bounds\');\n  }\n\n  if (end < 0 || end > source.length) {\n    throw new Error(\'sourceEnd out of bounds\');\n  }\n\n  // Are we oob?\n  if (end > this.length) {\n    end = this.length;\n  }\n\n  if (target.length - target_start < end - start) {\n    end = target.length - target_start + start;\n  }\n\n  return this.parent.copy(target.parent,\n                          target_start + target.offset,\n                          start + this.offset,\n                          end + this.offset);\n};\n\n\n// slice(start, end)\nBuffer.prototype.slice = function(start, end) {\n  if (end === undefined) end = this.length;\n  if (end > this.length) throw new Error(\'oob\');\n  if (start > end) throw new Error(\'oob\');\n\n  return new Buffer(this.parent, end - start, +start + this.offset);\n};\n\n\n// Legacy methods for backwards compatibility.\n\nBuffer.prototype.utf8Slice = function(start, end) {\n  return this.toString(\'utf8\', start, end);\n};\n\nBuffer.prototype.binarySlice = function(start, end) {\n  return this.toString(\'binary\', start, end);\n};\n\nBuffer.prototype.asciiSlice = function(start, end) {\n  return this.toString(\'ascii\', start, end);\n};\n\nBuffer.prototype.utf8Write = function(string, offset) {\n  return this.write(string, offset, \'utf8\');\n};\n\nBuffer.prototype.binaryWrite = function(string, offset) {\n  return this.write(string, offset, \'binary\');\n};\n\nBuffer.prototype.asciiWrite = function(string, offset) {\n  return this.write(string, offset, \'ascii\');\n};\n\nBuffer.prototype.readUInt8 = function(offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  return buffer.parent[buffer.offset + offset];\n};\n\nfunction readUInt16(buffer, offset, isBigEndian, noAssert) {\n  var val = 0;\n\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 1 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  if (isBigEndian) {\n    val = buffer.parent[buffer.offset + offset] << 8;\n    val |= buffer.parent[buffer.offset + offset + 1];\n  } else {\n    val = buffer.parent[buffer.offset + offset];\n    val |= buffer.parent[buffer.offset + offset + 1] << 8;\n  }\n\n  return val;\n}\n\nBuffer.prototype.readUInt16LE = function(offset, noAssert) {\n  return readUInt16(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readUInt16BE = function(offset, noAssert) {\n  return readUInt16(this, offset, true, noAssert);\n};\n\nfunction readUInt32(buffer, offset, isBigEndian, noAssert) {\n  var val = 0;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  if (isBigEndian) {\n    val = buffer.parent[buffer.offset + offset + 1] << 16;\n    val |= buffer.parent[buffer.offset + offset + 2] << 8;\n    val |= buffer.parent[buffer.offset + offset + 3];\n    val = val + (buffer.parent[buffer.offset + offset] << 24 >>> 0);\n  } else {\n    val = buffer.parent[buffer.offset + offset + 2] << 16;\n    val |= buffer.parent[buffer.offset + offset + 1] << 8;\n    val |= buffer.parent[buffer.offset + offset];\n    val = val + (buffer.parent[buffer.offset + offset + 3] << 24 >>> 0);\n  }\n\n  return val;\n}\n\nBuffer.prototype.readUInt32LE = function(offset, noAssert) {\n  return readUInt32(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readUInt32BE = function(offset, noAssert) {\n  return readUInt32(this, offset, true, noAssert);\n};\n\n\n/*\n * Signed integer types, yay team! A reminder on how two\'s complement actually\n * works. The first bit is the signed bit, i.e. tells us whether or not the\n * number should be positive or negative. If the two\'s complement value is\n * positive, then we\'re done, as it\'s equivalent to the unsigned representation.\n *\n * Now if the number is positive, you\'re pretty much done, you can just leverage\n * the unsigned translations and return those. Unfortunately, negative numbers\n * aren\'t quite that straightforward.\n *\n * At first glance, one might be inclined to use the traditional formula to\n * translate binary numbers between the positive and negative values in two\'s\n * complement. (Though it doesn\'t quite work for the most negative value)\n * Mainly:\n *  - invert all the bits\n *  - add one to the result\n *\n * Of course, this doesn\'t quite work in Javascript. Take for example the value\n * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of\n * course, Javascript will do the following:\n *\n * > ~0xff80\n * -65409\n *\n * Whoh there, Javascript, that\'s not quite right. But wait, according to\n * Javascript that\'s perfectly correct. When Javascript ends up seeing the\n * constant 0xff80, it has no notion that it is actually a signed number. It\n * assumes that we\'ve input the unsigned value 0xff80. Thus, when it does the\n * binary negation, it casts it into a signed value, (positive 0xff80). Then\n * when you perform binary negation on that, it turns it into a negative number.\n *\n * Instead, we\'re going to have to use the following general formula, that works\n * in a rather Javascript friendly way. I\'m glad we don\'t support this kind of\n * weird numbering scheme in the kernel.\n *\n * (BIT-MAX - (unsigned)val + 1) * -1\n *\n * The astute observer, may think that this doesn\'t make sense for 8-bit numbers\n * (really it isn\'t necessary for them). However, when you get 16-bit numbers,\n * you do. Let\'s go back to our prior example and see how this will look:\n *\n * (0xffff - 0xff80 + 1) * -1\n * (0x007f + 1) * -1\n * (0x0080) * -1\n */\nBuffer.prototype.readInt8 = function(offset, noAssert) {\n  var buffer = this;\n  var neg;\n\n  if (!noAssert) {\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  neg = buffer.parent[buffer.offset + offset] & 0x80;\n  if (!neg) {\n    return (buffer.parent[buffer.offset + offset]);\n  }\n\n  return ((0xff - buffer.parent[buffer.offset + offset] + 1) * -1);\n};\n\nfunction readInt16(buffer, offset, isBigEndian, noAssert) {\n  var neg, val;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 1 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  val = readUInt16(buffer, offset, isBigEndian, noAssert);\n  neg = val & 0x8000;\n  if (!neg) {\n    return val;\n  }\n\n  return (0xffff - val + 1) * -1;\n}\n\nBuffer.prototype.readInt16LE = function(offset, noAssert) {\n  return readInt16(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readInt16BE = function(offset, noAssert) {\n  return readInt16(this, offset, true, noAssert);\n};\n\nfunction readInt32(buffer, offset, isBigEndian, noAssert) {\n  var neg, val;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  val = readUInt32(buffer, offset, isBigEndian, noAssert);\n  neg = val & 0x80000000;\n  if (!neg) {\n    return (val);\n  }\n\n  return (0xffffffff - val + 1) * -1;\n}\n\nBuffer.prototype.readInt32LE = function(offset, noAssert) {\n  return readInt32(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readInt32BE = function(offset, noAssert) {\n  return readInt32(this, offset, true, noAssert);\n};\n\nfunction readFloat(buffer, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  return require(\'./buffer_ieee754\').readIEEE754(buffer, offset, isBigEndian,\n      23, 4);\n}\n\nBuffer.prototype.readFloatLE = function(offset, noAssert) {\n  return readFloat(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readFloatBE = function(offset, noAssert) {\n  return readFloat(this, offset, true, noAssert);\n};\n\nfunction readDouble(buffer, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset + 7 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  return require(\'./buffer_ieee754\').readIEEE754(buffer, offset, isBigEndian,\n      52, 8);\n}\n\nBuffer.prototype.readDoubleLE = function(offset, noAssert) {\n  return readDouble(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readDoubleBE = function(offset, noAssert) {\n  return readDouble(this, offset, true, noAssert);\n};\n\n\n/*\n * We have to make sure that the value is a valid integer. This means that it is\n * non-negative. It has no fractional component and that it does not exceed the\n * maximum allowed value.\n *\n *      value           The number to check for validity\n *\n *      max             The maximum value\n */\nfunction verifuint(value, max) {\n  assert.ok(typeof (value) == \'number\',\n      \'cannot write a non-number as a number\');\n\n  assert.ok(value >= 0,\n      \'specified a negative value for writing an unsigned value\');\n\n  assert.ok(value <= max, \'value is larger than maximum value for type\');\n\n  assert.ok(Math.floor(value) === value, \'value has a fractional component\');\n}\n\nBuffer.prototype.writeUInt8 = function(value, offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset < buffer.length,\n        \'trying to write beyond buffer length\');\n\n    verifuint(value, 0xff);\n  }\n\n  buffer.parent[buffer.offset + offset] = value;\n};\n\nfunction writeUInt16(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 1 < buffer.length,\n        \'trying to write beyond buffer length\');\n\n    verifuint(value, 0xffff);\n  }\n\n  if (isBigEndian) {\n    buffer.parent[buffer.offset + offset] = (value & 0xff00) >>> 8;\n    buffer.parent[buffer.offset + offset + 1] = value & 0x00ff;\n  } else {\n    buffer.parent[buffer.offset + offset + 1] = (value & 0xff00) >>> 8;\n    buffer.parent[buffer.offset + offset] = value & 0x00ff;\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function(value, offset, noAssert) {\n  writeUInt16(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeUInt16BE = function(value, offset, noAssert) {\n  writeUInt16(this, value, offset, true, noAssert);\n};\n\nfunction writeUInt32(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'trying to write beyond buffer length\');\n\n    verifuint(value, 0xffffffff);\n  }\n\n  if (isBigEndian) {\n    buffer.parent[buffer.offset + offset] = (value >>> 24) & 0xff;\n    buffer.parent[buffer.offset + offset + 1] = (value >>> 16) & 0xff;\n    buffer.parent[buffer.offset + offset + 2] = (value >>> 8) & 0xff;\n    buffer.parent[buffer.offset + offset + 3] = value & 0xff;\n  } else {\n    buffer.parent[buffer.offset + offset + 3] = (value >>> 24) & 0xff;\n    buffer.parent[buffer.offset + offset + 2] = (value >>> 16) & 0xff;\n    buffer.parent[buffer.offset + offset + 1] = (value >>> 8) & 0xff;\n    buffer.parent[buffer.offset + offset] = value & 0xff;\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function(value, offset, noAssert) {\n  writeUInt32(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeUInt32BE = function(value, offset, noAssert) {\n  writeUInt32(this, value, offset, true, noAssert);\n};\n\n\n/*\n * We now move onto our friends in the signed number category. Unlike unsigned\n * numbers, we\'re going to have to worry a bit more about how we put values into\n * arrays. Since we are only worrying about signed 32-bit values, we\'re in\n * slightly better shape. Unfortunately, we really can\'t do our favorite binary\n * & in this system. It really seems to do the wrong thing. For example:\n *\n * > -32 & 0xff\n * 224\n *\n * What\'s happening above is really: 0xe0 & 0xff = 0xe0. However, the results of\n * this aren\'t treated as a signed number. Ultimately a bad thing.\n *\n * What we\'re going to want to do is basically create the unsigned equivalent of\n * our representation and pass that off to the wuint* functions. To do that\n * we\'re going to do the following:\n *\n *  - if the value is positive\n *      we can pass it directly off to the equivalent wuint\n *  - if the value is negative\n *      we do the following computation:\n *         mb + val + 1, where\n *         mb   is the maximum unsigned value in that byte size\n *         val  is the Javascript negative integer\n *\n *\n * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If\n * you do out the computations:\n *\n * 0xffff - 128 + 1\n * 0xffff - 127\n * 0xff80\n *\n * You can then encode this value as the signed version. This is really rather\n * hacky, but it should work and get the job done which is our goal here.\n */\n\n/*\n * A series of checks to make sure we actually have a signed 32-bit number\n */\nfunction verifsint(value, max, min) {\n  assert.ok(typeof (value) == \'number\',\n      \'cannot write a non-number as a number\');\n\n  assert.ok(value <= max, \'value larger than maximum allowed value\');\n\n  assert.ok(value >= min, \'value smaller than minimum allowed value\');\n\n  assert.ok(Math.floor(value) === value, \'value has a fractional component\');\n}\n\nfunction verifIEEE754(value, max, min) {\n  assert.ok(typeof (value) == \'number\',\n      \'cannot write a non-number as a number\');\n\n  assert.ok(value <= max, \'value larger than maximum allowed value\');\n\n  assert.ok(value >= min, \'value smaller than minimum allowed value\');\n}\n\nBuffer.prototype.writeInt8 = function(value, offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifsint(value, 0x7f, -0x80);\n  }\n\n  if (value >= 0) {\n    buffer.writeUInt8(value, offset, noAssert);\n  } else {\n    buffer.writeUInt8(0xff + value + 1, offset, noAssert);\n  }\n};\n\nfunction writeInt16(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 1 < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifsint(value, 0x7fff, -0x8000);\n  }\n\n  if (value >= 0) {\n    writeUInt16(buffer, value, offset, isBigEndian, noAssert);\n  } else {\n    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);\n  }\n}\n\nBuffer.prototype.writeInt16LE = function(value, offset, noAssert) {\n  writeInt16(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeInt16BE = function(value, offset, noAssert) {\n  writeInt16(this, value, offset, true, noAssert);\n};\n\nfunction writeInt32(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifsint(value, 0x7fffffff, -0x80000000);\n  }\n\n  if (value >= 0) {\n    writeUInt32(buffer, value, offset, isBigEndian, noAssert);\n  } else {\n    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);\n  }\n}\n\nBuffer.prototype.writeInt32LE = function(value, offset, noAssert) {\n  writeInt32(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeInt32BE = function(value, offset, noAssert) {\n  writeInt32(this, value, offset, true, noAssert);\n};\n\nfunction writeFloat(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);\n  }\n\n  require(\'./buffer_ieee754\').writeIEEE754(buffer, value, offset, isBigEndian,\n      23, 4);\n}\n\nBuffer.prototype.writeFloatLE = function(value, offset, noAssert) {\n  writeFloat(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeFloatBE = function(value, offset, noAssert) {\n  writeFloat(this, value, offset, true, noAssert);\n};\n\nfunction writeDouble(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 7 < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);\n  }\n\n  require(\'./buffer_ieee754\').writeIEEE754(buffer, value, offset, isBigEndian,\n      52, 8);\n}\n\nBuffer.prototype.writeDoubleLE = function(value, offset, noAssert) {\n  writeDouble(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeDoubleBE = function(value, offset, noAssert) {\n  writeDouble(this, value, offset, true, noAssert);\n};\n\nSlowBuffer.prototype.readUInt8 = Buffer.prototype.readUInt8;\nSlowBuffer.prototype.readUInt16LE = Buffer.prototype.readUInt16LE;\nSlowBuffer.prototype.readUInt16BE = Buffer.prototype.readUInt16BE;\nSlowBuffer.prototype.readUInt32LE = Buffer.prototype.readUInt32LE;\nSlowBuffer.prototype.readUInt32BE = Buffer.prototype.readUInt32BE;\nSlowBuffer.prototype.readInt8 = Buffer.prototype.readInt8;\nSlowBuffer.prototype.readInt16LE = Buffer.prototype.readInt16LE;\nSlowBuffer.prototype.readInt16BE = Buffer.prototype.readInt16BE;\nSlowBuffer.prototype.readInt32LE = Buffer.prototype.readInt32LE;\nSlowBuffer.prototype.readInt32BE = Buffer.prototype.readInt32BE;\nSlowBuffer.prototype.readFloatLE = Buffer.prototype.readFloatLE;\nSlowBuffer.prototype.readFloatBE = Buffer.prototype.readFloatBE;\nSlowBuffer.prototype.readDoubleLE = Buffer.prototype.readDoubleLE;\nSlowBuffer.prototype.readDoubleBE = Buffer.prototype.readDoubleBE;\nSlowBuffer.prototype.writeUInt8 = Buffer.prototype.writeUInt8;\nSlowBuffer.prototype.writeUInt16LE = Buffer.prototype.writeUInt16LE;\nSlowBuffer.prototype.writeUInt16BE = Buffer.prototype.writeUInt16BE;\nSlowBuffer.prototype.writeUInt32LE = Buffer.prototype.writeUInt32LE;\nSlowBuffer.prototype.writeUInt32BE = Buffer.prototype.writeUInt32BE;\nSlowBuffer.prototype.writeInt8 = Buffer.prototype.writeInt8;\nSlowBuffer.prototype.writeInt16LE = Buffer.prototype.writeInt16LE;\nSlowBuffer.prototype.writeInt16BE = Buffer.prototype.writeInt16BE;\nSlowBuffer.prototype.writeInt32LE = Buffer.prototype.writeInt32LE;\nSlowBuffer.prototype.writeInt32BE = Buffer.prototype.writeInt32BE;\nSlowBuffer.prototype.writeFloatLE = Buffer.prototype.writeFloatLE;\nSlowBuffer.prototype.writeFloatBE = Buffer.prototype.writeFloatBE;\nSlowBuffer.prototype.writeDoubleLE = Buffer.prototype.writeDoubleLE;\nSlowBuffer.prototype.writeDoubleBE = Buffer.prototype.writeDoubleBE;\n\n})()\n},{"assert":2,"./buffer_ieee754":7,"base64-js":9}],9:[function(require,module,exports){\n(function (exports) {\n\t\'use strict\';\n\n\tvar lookup = \'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\';\n\n\tfunction b64ToByteArray(b64) {\n\t\tvar i, j, l, tmp, placeHolders, arr;\n\t\n\t\tif (b64.length % 4 > 0) {\n\t\t\tthrow \'Invalid string. Length must be a multiple of 4\';\n\t\t}\n\n\t\t// the number of equal signs (place holders)\n\t\t// if there are two placeholders, than the two characters before it\n\t\t// represent one byte\n\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t// this is just a cheap hack to not do indexOf twice\n\t\tplaceHolders = b64.indexOf(\'=\');\n\t\tplaceHolders = placeHolders > 0 ? b64.length - placeHolders : 0;\n\n\t\t// base64 is 4/3 + up to two characters of the original data\n\t\tarr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);\n\n\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length;\n\n\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);\n\t\t\tarr.push((tmp & 0xFF0000) >> 16);\n\t\t\tarr.push((tmp & 0xFF00) >> 8);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t}\n\n\t\tif (placeHolders === 2) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t} else if (placeHolders === 1) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);\n\t\t\tarr.push((tmp >> 8) & 0xFF);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t}\n\n\t\treturn arr;\n\t}\n\n\tfunction uint8ToBase64(uint8) {\n\t\tvar i,\n\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\toutput = "",\n\t\t\ttemp, length;\n\n\t\tfunction tripletToBase64 (num) {\n\t\t\treturn lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n\t\t};\n\n\t\t// go through the array every three bytes, we\'ll deal with trailing stuff later\n\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);\n\t\t\toutput += tripletToBase64(temp);\n\t\t}\n\n\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\tswitch (extraBytes) {\n\t\t\tcase 1:\n\t\t\t\ttemp = uint8[uint8.length - 1];\n\t\t\t\toutput += lookup[temp >> 2];\n\t\t\t\toutput += lookup[(temp << 4) & 0x3F];\n\t\t\t\toutput += \'==\';\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);\n\t\t\t\toutput += lookup[temp >> 10];\n\t\t\t\toutput += lookup[(temp >> 4) & 0x3F];\n\t\t\t\toutput += lookup[(temp << 2) & 0x3F];\n\t\t\t\toutput += \'=\';\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn output;\n\t}\n\n\tmodule.exports.toByteArray = b64ToByteArray;\n\tmodule.exports.fromByteArray = uint8ToBase64;\n}());\n\n},{}]},{},[])\n;;module.exports=require("buffer-browserify")\n\n},{}],10:[function(require,module,exports){\n(function(Buffer){/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Wentao Shang\n * See COPYING for copyright and distribution information.\n */\n\n// Library namespace\nvar ndn = ndn || {};\n\nvar exports = ndn;\n\n\n// Factory method to create node.js compatible ndnbuf objects\nvar ndnbuf = function ndnbuf(data, format)\n{\n  var obj;\n\n  if (typeof data == \'number\')\n    obj = new Uint8Array(data);\n  else if (typeof data == \'string\') {\n    if (format == null || format == \'utf8\') {\n      var utf8 = ndnbuf.str2rstr_utf8(data);\n      obj = new Uint8Array(utf8.length);\n      for (var i = 0; i < utf8.length; i++)\n        obj[i] = utf8.charCodeAt(i);\n    }\n    else if (format == \'binary\') {\n      obj = new Uint8Array(data.length);\n      for (var i = 0; i < data.length; i++)\n        obj[i] = data.charCodeAt(i);\n    }\n    else if (format == \'hex\') {\n      obj = new Uint8Array(Math.floor(data.length / 2));\n      var i = 0;\n      data.replace(/(..)/g, function(ss) {\n        obj[i++] = parseInt(ss, 16);\n      });\n    }\n    else if (format == \'base64\') {\n      var hex = b64tohex(data);\n      obj = new Uint8Array(Math.floor(hex.length / 2));\n      var i = 0;\n      hex.replace(/(..)/g, function(ss) {\n        obj[i++] = parseInt(ss, 16);\n      });\n    }\n    else\n      throw new Error(\'Buffer: unknown encoding format \' + format);\n  }\n  else if (typeof data == \'object\' && (data instanceof Uint8Array || data instanceof ndnbuf)) {\n    // The second argument is a boolean for "copy", default true.\n    if (format == false)\n      obj = data.subarray(0);\n    else\n      obj = new Uint8Array(data);\n  }\n  else if (typeof data == \'object\' && data instanceof ArrayBuffer)\n    // Copy.\n    obj = new Uint8Array(data);\n  else if (typeof data == \'object\')\n    // Assume component is a byte array.  We can\'t check instanceof Array because\n    //   this doesn\'t work in JavaScript if the array comes from a different module.\n    obj = new Uint8Array(data);\n  else\n    throw new Error(\'Buffer: unknown data type.\');\n\n  try {\n    obj.__proto__ = ndnbuf.prototype;\n  } catch(ex) {\n    throw new Error("Buffer: Set obj.__proto__ exception: " + ex);\n  }\n\n  obj.__proto__.toString = function(encoding) {\n    if (encoding == null) {\n      var ret = "";\n      for (var i = 0; i < this.length; i++)\n        ret += String.fromCharCode(this[i]);\n      return ret;\n    }\n\n    var ret = "";\n    for (var i = 0; i < this.length; i++)\n      ret += (this[i] < 16 ? "0" : "") + this[i].toString(16);\n\n    if (encoding == \'hex\')\n      return ret;\n    else if (encoding == \'base64\')\n      return hex2b64(ret);\n    else\n      throw new Error(\'ndnbuf.toString: unknown encoding format \' + encoding);\n  };\n\n  obj.__proto__.slice = function(begin, end) {\n    if (end !== undefined)\n      return new ndnbuf(this.subarray(begin, end), false);\n    else\n      return new ndnbuf(this.subarray(begin), false);\n  };\n\n  obj.__proto__.copy = function(target, targetStart) {\n    if (targetStart !== undefined)\n      target.set(this, targetStart);\n    else\n      target.set(this);\n  };\n\n  return obj;\n};\n\nndnbuf.prototype = Uint8Array.prototype;\n\nndnbuf.concat = function(arrays)\n{\n  var totalLength = 0;\n  for (var i = 0; i < arrays.length; ++i)\n    totalLength += arrays[i].length;\n\n  var result = new ndnbuf(totalLength);\n  var offset = 0;\n  for (var i = 0; i < arrays.length; ++i) {\n    result.set(arrays[i], offset);\n    offset += arrays[i].length;\n  }\n  return result;\n};\n\nndnbuf.str2rstr_utf8 = function(input)\n{\n  var output = "";\n  var i = -1;\n  var x, y;\n\n  while (++i < input.length)\n  {\n    // Decode utf-16 surrogate pairs\n    x = input.charCodeAt(i);\n    y = i + 1 < input.length ? input.charCodeAt(i + 1) : 0;\n    if (0xD800 <= x && x <= 0xDBFF && 0xDC00 <= y && y <= 0xDFFF)\n    {\n      x = 0x10000 + ((x & 0x03FF) << 10) + (y & 0x03FF);\n      i++;\n    }\n\n    // Encode output as utf-8\n    if (x <= 0x7F)\n      output += String.fromCharCode(x);\n    else if (x <= 0x7FF)\n      output += String.fromCharCode(0xC0 | ((x >>> 6 ) & 0x1F),\n                                    0x80 | ( x         & 0x3F));\n    else if (x <= 0xFFFF)\n      output += String.fromCharCode(0xE0 | ((x >>> 12) & 0x0F),\n                                    0x80 | ((x >>> 6 ) & 0x3F),\n                                    0x80 | ( x         & 0x3F));\n    else if (x <= 0x1FFFFF)\n      output += String.fromCharCode(0xF0 | ((x >>> 18) & 0x07),\n                                    0x80 | ((x >>> 12) & 0x3F),\n                                    0x80 | ((x >>> 6 ) & 0x3F),\n                                    0x80 | ( x         & 0x3F));\n  }\n  return output;\n};\n\nexports.ndnbuf = ndnbuf\n\n// Factory method to create hasher objects\nndn.createHash = function(alg)\n{\n  if (alg != \'sha256\')\n    throw new Error(\'createHash: unsupported algorithm.\');\n\n  var obj = {};\n\n  obj.md = new KJUR.crypto.MessageDigest({alg: "sha256", prov: "cryptojs"});\n\n  obj.update = function(buf) {\n    this.md.updateHex(buf.toString(\'hex\'));\n  };\n\n  obj.digest = function() {\n    return new ndnbuf(this.md.digest(), \'hex\');\n  };\n\n  return obj;\n};\n\n// Factory method to create RSA signer objects\nndn.createSign = function(alg)\n{\n  if (alg != \'RSA-SHA256\')\n    throw new Error(\'createSign: unsupported algorithm.\');\n\n  var obj = {};\n\n  obj.arr = [];\n\n  obj.update = function(buf) {\n    this.arr.push(buf);\n  };\n\n  obj.sign = function(keypem) {\n    var rsa = new RSAKey();\n    rsa.readPrivateKeyFromPEMString(keypem);\n    var signer = new KJUR.crypto.Signature({alg: "SHA256withRSA", prov: "cryptojs/jsrsa"});\n    signer.initSign(rsa);\n    for (var i = 0; i < this.arr.length; ++i)\n      signer.updateHex(this.arr[i].toString(\'hex\'));\n\n    return new ndnbuf(signer.sign(), \'hex\');\n  };\n\n  return obj;\n};\n\n// Factory method to create RSA verifier objects\nndn.createVerify = function(alg)\n{\n  if (alg != \'RSA-SHA256\')\n    throw new Error(\'createSign: unsupported algorithm.\');\n\n  var obj = {};\n\n  obj.arr = [];\n\n  obj.update = function(buf) {\n    this.arr.push(buf);\n  };\n\n  var getSubjectPublicKeyPosFromHex = function(hPub) {\n    var a = ASN1HEX.getPosArrayOfChildren_AtObj(hPub, 0);\n    if (a.length != 2)\n      return -1;\n    var pBitString = a[1];\n    if (hPub.substring(pBitString, pBitString + 2) != \'03\')\n      return -1;\n    var pBitStringV = ASN1HEX.getStartPosOfV_AtObj(hPub, pBitString);\n    if (hPub.substring(pBitStringV, pBitStringV + 2) != \'00\')\n      return -1;\n    return pBitStringV + 2;\n  };\n\n  var readPublicDER = function(pub_der) {\n    var hex = pub_der.toString(\'hex\');\n    var p = getSubjectPublicKeyPosFromHex(hex);\n    var a = ASN1HEX.getPosArrayOfChildren_AtObj(hex, p);\n    if (a.length != 2)\n      return null;\n    var hN = ASN1HEX.getHexOfV_AtObj(hex, a[0]);\n    var hE = ASN1HEX.getHexOfV_AtObj(hex, a[1]);\n    var rsaKey = new RSAKey();\n    rsaKey.setPublic(hN, hE);\n    return rsaKey;\n  };\n\n  obj.verify = function(keypem, sig) {\n    var key = new ndn.Key();\n    key.fromPemString(keypem);\n\n    var rsa = readPublicDER(key.publicToDER());\n    var signer = new KJUR.crypto.Signature({alg: "SHA256withRSA", prov: "cryptojs/jsrsa"});\n    signer.initVerifyByPublicKey(rsa);\n    for (var i = 0; i < this.arr.length; i++)\n      signer.updateHex(this.arr[i].toString(\'hex\'));\n    var hSig = sig.toString(\'hex\');\n    return signer.verify(hSig);\n  };\n\n  return obj;\n};\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\n/**\n * The Log class holds the global static variable LOG.\n */\nvar Log = function Log()\n{\n}\n\nexports.Log = Log;\n\n/**\n * LOG is the level for logging debugging statements.  0 means no log messages.\n * @type Number\n */\nvar LOG = 0;\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class contains all NDNx tags\n */\n\n\nvar NDNProtocolDTags = {\n\n  /**\n   * Note if you add one of these, add it to the reverse string map as well.\n   * Emphasize getting the work done at compile time over trying to make something\n   * flexible and developer error-proof.\n   */\n\n   Any : 13,\n   Name : 14,\n   Component : 15,\n   Certificate : 16,\n   Collection : 17,\n   CompleteName : 18,\n   Content : 19,\n   SignedInfo : 20,\n   ContentDigest : 21,\n   ContentHash : 22,\n   Count : 24,\n   Header : 25,\n   Interest : 26,  /* 20090915 */\n   Key : 27,\n   KeyLocator : 28,\n   KeyName : 29,\n   Length : 30,\n   Link : 31,\n   LinkAuthenticator : 32,\n   NameComponentCount : 33,  /* DeprecatedInInterest */\n   RootDigest : 36,\n   Signature : 37,\n   Start : 38,\n   Timestamp : 39,\n   Type : 40,\n   Nonce : 41,\n   Scope : 42,\n   Exclude : 43,\n   Bloom : 44,\n   BloomSeed : 45,\n   AnswerOriginKind : 47,\n   InterestLifetime : 48,\n   Witness : 53,\n   SignatureBits : 54,\n   DigestAlgorithm : 55,\n   BlockSize : 56,\n   FreshnessSeconds : 58,\n   FinalBlockID : 59,\n   PublisherPublicKeyDigest : 60,\n   PublisherCertificateDigest : 61,\n   PublisherIssuerKeyDigest : 62,\n   PublisherIssuerCertificateDigest : 63,\n   Data : 64,  /* 20090915 */\n   WrappedKey : 65,\n   WrappingKeyIdentifier : 66,\n   WrapAlgorithm : 67,\n   KeyAlgorithm : 68,\n   Label : 69,\n   EncryptedKey : 70,\n   EncryptedNonceKey : 71,\n   WrappingKeyName : 72,\n   Action : 73,\n   FaceID : 74,\n   IPProto : 75,\n   Host : 76,\n   Port : 77,\n   MulticastInterface : 78,\n   ForwardingFlags : 79,\n   FaceInstance : 80,\n   ForwardingEntry : 81,\n   MulticastTTL : 82,\n   MinSuffixComponents : 83,\n   MaxSuffixComponents : 84,\n   ChildSelector : 85,\n   RepositoryInfo : 86,\n   Version : 87,\n   RepositoryVersion : 88,\n   GlobalPrefix : 89,\n   LocalName : 90,\n   Policy : 91,\n   Namespace : 92,\n   GlobalPrefixName : 93,\n   PolicyVersion : 94,\n   KeyValueSet : 95,\n   KeyValuePair : 96,\n   IntegerValue : 97,\n   DecimalValue : 98,\n   StringValue : 99,\n   BinaryValue : 100,\n   NameValue : 101,\n   Entry : 102,\n   ACL : 103,\n   ParameterizedName : 104,\n   Prefix : 105,\n   Suffix : 106,\n   Root : 107,\n   ProfileName : 108,\n   Parameters : 109,\n   InfoString : 110,\n  // 111 unallocated\n   StatusResponse : 112,\n   StatusCode : 113,\n   StatusText : 114,\n\n  // Sync protocol\n   SyncNode : 115,\n   SyncNodeKind : 116,\n   SyncNodeElement : 117,\n   SyncVersion : 118,\n   SyncNodeElements : 119,\n   SyncContentHash : 120,\n   SyncLeafCount : 121,\n   SyncTreeDepth : 122,\n   SyncByteCount : 123,\n   ConfigSlice : 124,\n   ConfigSliceList : 125,\n   ConfigSliceOp : 126,\n\n  // Remember to keep in sync with schema/tagnames.csvsdict\n   NDNProtocolDataUnit : 17702112,\n   NDNPROTOCOL_DATA_UNIT : "NDNProtocolDataUnit"\n};\n\nexports.NDNProtocolDTags = NDNProtocolDTags;\n\nvar NDNProtocolDTagsStrings = [\n  null, null, null, null, null, null, null, null, null, null, null,\n  null, null,\n  "Any", "Name", "Component", "Certificate", "Collection", "CompleteName",\n  "Content", "SignedInfo", "ContentDigest", "ContentHash", null, "Count", "Header",\n  "Interest", "Key", "KeyLocator", "KeyName", "Length", "Link", "LinkAuthenticator",\n  "NameComponentCount", null, null, "RootDigest", "Signature", "Start", "Timestamp", "Type",\n  "Nonce", "Scope", "Exclude", "Bloom", "BloomSeed", null, "AnswerOriginKind",\n  "InterestLifetime", null, null, null, null, "Witness", "SignatureBits", "DigestAlgorithm", "BlockSize",\n  null, "FreshnessSeconds", "FinalBlockID", "PublisherPublicKeyDigest", "PublisherCertificateDigest",\n  "PublisherIssuerKeyDigest", "PublisherIssuerCertificateDigest", "Data",\n  "WrappedKey", "WrappingKeyIdentifier", "WrapAlgorithm", "KeyAlgorithm", "Label",\n  "EncryptedKey", "EncryptedNonceKey", "WrappingKeyName", "Action", "FaceID", "IPProto",\n  "Host", "Port", "MulticastInterface", "ForwardingFlags", "FaceInstance",\n  "ForwardingEntry", "MulticastTTL", "MinSuffixComponents", "MaxSuffixComponents", "ChildSelector",\n  "RepositoryInfo", "Version", "RepositoryVersion", "GlobalPrefix", "LocalName",\n  "Policy", "Namespace", "GlobalPrefixName", "PolicyVersion", "KeyValueSet", "KeyValuePair",\n  "IntegerValue", "DecimalValue", "StringValue", "BinaryValue", "NameValue", "Entry",\n  "ACL", "ParameterizedName", "Prefix", "Suffix", "Root", "ProfileName", "Parameters",\n  "InfoString", null,\n    "StatusResponse", "StatusCode", "StatusText", "SyncNode", "SyncNodeKind", "SyncNodeElement",\n    "SyncVersion", "SyncNodeElements", "SyncContentHash", "SyncLeafCount", "SyncTreeDepth", "SyncByteCount",\n    "ConfigSlice", "ConfigSliceList", "ConfigSliceOp" ];\n\nexports.NDNProtocolDTagsStrings = NDNProtocolDTagsStrings;\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class represents NDNTime Objects\n */\n\n\n/**\n * @constructor\n */\nvar NDNTime = function NDNTime(input)\n{\n  this.NANOS_MAX = 999877929;\n\n  if (typeof input ==\'number\')\n    this.msec = input;\n  else {\n    if (LOG > 1) console.log(\'UNRECOGNIZED TYPE FOR TIME\');\n  }\n};\n\nexports.NDNTime = NDNTime;\n\nNDNTime.prototype.getJavascriptDate = function()\n{\n  var d = new Date();\n  d.setTime(this.msec);\n  return d\n};\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * This is the closure class for use in expressInterest to re express with exponential falloff.\n */\n\n\n/**\n * Create a new ExponentialReExpressClosure where upcall responds to UPCALL_INTEREST_TIMED_OUT\n *   by expressing the interest again with double the interestLifetime. If the interesLifetime goes\n *   over maxInterestLifetime, then call callerClosure.upcall with UPCALL_INTEREST_TIMED_OUT.\n * When upcall is not UPCALL_INTEREST_TIMED_OUT, just call callerClosure.upcall.\n * @constructor\n * @param {Closure} callerClosure\n * @param {Object} settings if not null, an associative array with the following defaults:\n * {\n *   maxInterestLifetime: 16000 // milliseconds\n * }\n */\nvar ExponentialReExpressClosure = function ExponentialReExpressClosure(callerClosure, settings)\n{\n  // Inherit from Closure.\n  Closure.call(this);\n\n  this.callerClosure = callerClosure;\n  settings = (settings || {});\n  this.maxInterestLifetime = (settings.maxInterestLifetime || 16000);\n};\n\nexports.ExponentialReExpressClosure = ExponentialReExpressClosure;\n\n/**\n * Wrap this.callerClosure to responds to UPCALL_INTEREST_TIMED_OUT\n *   by expressing the interest again as described in the constructor.\n */\nExponentialReExpressClosure.prototype.upcall = function(kind, upcallInfo)\n{\n  try {\n    if (kind == Closure.UPCALL_INTEREST_TIMED_OUT) {\n      var interestLifetime = upcallInfo.interest.interestLifetime;\n      if (interestLifetime == null)\n        return this.callerClosure.upcall(Closure.UPCALL_INTEREST_TIMED_OUT, upcallInfo);\n\n      var nextInterestLifetime = interestLifetime * 2;\n      if (nextInterestLifetime > this.maxInterestLifetime)\n        return this.callerClosure.upcall(Closure.UPCALL_INTEREST_TIMED_OUT, upcallInfo);\n\n      var nextInterest = upcallInfo.interest.clone();\n      nextInterest.interestLifetime = nextInterestLifetime;\n      // TODO: Use expressInterest with callbacks, not Closure.\n      upcallInfo.face.expressInterest(nextInterest.name, this, nextInterest);\n      return Closure.RESULT_OK;\n    }\n    else\n      return this.callerClosure.upcall(kind, upcallInfo);\n  } catch (ex) {\n    console.log("ExponentialReExpressClosure.upcall exception: " + ex);\n    return Closure.RESULT_ERR;\n  }\n};\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * Encapsulate a ndnbuf and support dynamic reallocation.\n */\n\n/**\n * Create a DynamicBuffer where this.array is a ndnbuf of size length.\n * The methods will update this.length.\n * To access the array, use this.array or call slice.\n * @constructor\n * @param {number} length the initial length of the array.  If null, use a default.\n */\nvar DynamicBuffer = function DynamicBuffer(length)\n{\n  if (!length)\n    length = 16;\n\n  this.array = new ndnbuf(length);\n  this.length = length;\n};\n\nexports.DynamicBuffer = DynamicBuffer;\n\n/**\n * Ensure that this.array has the length, reallocate and copy if necessary.\n * Update this.length which may be greater than length.\n */\nDynamicBuffer.prototype.ensureLength = function(length)\n{\n  if (this.array.length >= length)\n    return;\n\n  // See if double is enough.\n  var newLength = this.array.length * 2;\n  if (length > newLength)\n    // The needed length is much greater, so use it.\n    newLength = length;\n\n  var newArray = new ndnbuf(newLength);\n  this.array.copy(newArray);\n  this.array = newArray;\n  this.length = newLength;\n};\n\n/**\n * Copy the value to this.array at offset, reallocating if necessary.\n */\nDynamicBuffer.prototype.set = function(value, offset)\n{\n  this.ensureLength(value.length + offset);\n\n  if (typeof value == \'object\' && value instanceof ndnbuf)\n    value.copy(this.array, offset);\n  else\n    // Need to make value a ndnbuf to copy.\n    new ndnbuf(value).copy(this.array, offset);\n};\n\n/**\n * Return this.array.slice(begin, end);\n */\nDynamicBuffer.prototype.slice = function(begin, end)\n{\n  return this.array.slice(begin, end);\n};\n/**\n * This class contains utilities to help parse the data\n *\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Meki Cheraoui\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\n/**\n * A DataUtils has static methods for converting data.\n * @constructor\n */\nvar DataUtils = function DataUtils()\n{\n};\n\nexports.DataUtils = DataUtils;\n\n/*\n * NOTE THIS IS CURRENTLY NOT BEING USED\n *\n */\n\nDataUtils.keyStr = "ABCDEFGHIJKLMNOP" +\n                   "QRSTUVWXYZabcdef" +\n                   "ghijklmnopqrstuv" +\n                   "wxyz0123456789+/" +\n                   "=";\n\n/**\n * Raw String to Base 64\n */\nDataUtils.stringtoBase64 = function stringtoBase64(input)\n{\n   //input = escape(input);\n   var output = "";\n   var chr1, chr2, chr3 = "";\n   var enc1, enc2, enc3, enc4 = "";\n   var i = 0;\n\n   do {\n    chr1 = input.charCodeAt(i++);\n    chr2 = input.charCodeAt(i++);\n    chr3 = input.charCodeAt(i++);\n\n    enc1 = chr1 >> 2;\n    enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\n    enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\n    enc4 = chr3 & 63;\n\n    if (isNaN(chr2))\n       enc3 = enc4 = 64;\n    else if (isNaN(chr3))\n       enc4 = 64;\n\n    output = output +\n       DataUtils.keyStr.charAt(enc1) +\n       DataUtils.keyStr.charAt(enc2) +\n       DataUtils.keyStr.charAt(enc3) +\n       DataUtils.keyStr.charAt(enc4);\n    chr1 = chr2 = chr3 = "";\n    enc1 = enc2 = enc3 = enc4 = "";\n   } while (i < input.length);\n\n   return output;\n};\n\n/**\n * Base 64 to Raw String\n */\nDataUtils.base64toString = function base64toString(input)\n{\n  var output = "";\n  var chr1, chr2, chr3 = "";\n  var enc1, enc2, enc3, enc4 = "";\n  var i = 0;\n\n  // remove all characters that are not A-Z, a-z, 0-9, +, /, or =\n  var base64test = /[^A-Za-z0-9\\+\\/\\=]/g;\n  /* Test for invalid characters. */\n  if (base64test.exec(input)) {\n    alert("There were invalid base64 characters in the input text.\\n" +\n          "Valid base64 characters are A-Z, a-z, 0-9, \'+\', \'/\',and \'=\'\\n" +\n          "Expect errors in decoding.");\n  }\n\n  input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, "");\n\n  do {\n    enc1 = DataUtils.keyStr.indexOf(input.charAt(i++));\n    enc2 = DataUtils.keyStr.indexOf(input.charAt(i++));\n    enc3 = DataUtils.keyStr.indexOf(input.charAt(i++));\n    enc4 = DataUtils.keyStr.indexOf(input.charAt(i++));\n\n    chr1 = (enc1 << 2) | (enc2 >> 4);\n    chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);\n    chr3 = ((enc3 & 3) << 6) | enc4;\n\n    output = output + String.fromCharCode(chr1);\n\n    if (enc3 != 64)\n      output = output + String.fromCharCode(chr2);\n\n    if (enc4 != 64)\n      output = output + String.fromCharCode(chr3);\n\n    chr1 = chr2 = chr3 = "";\n    enc1 = enc2 = enc3 = enc4 = "";\n  } while (i < input.length);\n\n  return output;\n};\n\n/**\n * ndnbuf to Hex String\n */\nDataUtils.toHex = function(ndnbuf)\n{\n  return ndnbuf.toString(\'hex\');\n};\n\n/**\n * Raw string to hex string.\n */\nDataUtils.stringToHex = function(args)\n{\n  var ret = "";\n  for (var i = 0; i < args.length; ++i) {\n    var value = args.charCodeAt(i);\n    ret += (value < 16 ? "0" : "") + value.toString(16);\n  }\n  return ret;\n};\n\n/**\n * ndnbuf to raw string.\n */\nDataUtils.toString = function(ndnbuf)\n{\n  return ndnbuf.toString();\n};\n\n/**\n * Hex String to ndnbuf.\n */\nDataUtils.toNumbers = function(str)\n{\n  return new ndnbuf(str, \'hex\');\n};\n\n/**\n * Hex String to raw string.\n */\nDataUtils.hexToRawString = function(str)\n{\n  if (typeof str ==\'string\') {\n  var ret = "";\n  str.replace(/(..)/g, function(s) {\n    ret += String.fromCharCode(parseInt(s, 16));\n  });\n  return ret;\n  }\n};\n\n/**\n * Raw String to ndnbuf.\n */\nDataUtils.toNumbersFromString = function(str)\n{\n  return new ndnbuf(str, \'binary\');\n};\n\n/**\n * Encode str as utf8 and return as ndnbuf.\n */\nDataUtils.stringToUtf8Array = function(str)\n{\n  return new ndnbuf(str, \'utf8\');\n};\n\n/**\n * arrays is an array of ndnbuf. Return a new ndnbuf which is the concatenation of all.\n */\nDataUtils.concatArrays = function(arrays)\n{\n  return ndnbuf.concat(arrays);\n};\n\n// TODO: Take ndnbuf and use TextDecoder when available.\nDataUtils.decodeUtf8 = function(utftext)\n{\n  var string = "";\n  var i = 0;\n  var c = 0;\n    var c1 = 0;\n    var c2 = 0;\n\n  while (i < utftext.length) {\n    c = utftext.charCodeAt(i);\n\n    if (c < 128) {\n      string += String.fromCharCode(c);\n      i++;\n    }\n    else if (c > 191 && c < 224) {\n      c2 = utftext.charCodeAt(i + 1);\n      string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));\n      i += 2;\n    }\n    else {\n      c2 = utftext.charCodeAt(i+1);\n      var c3 = utftext.charCodeAt(i+2);\n      string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));\n      i += 3;\n    }\n  }\n\n  return string;\n};\n\n/**\n * Return true if a1 and a2 are the same length with equal elements.\n */\nDataUtils.arraysEqual = function(a1, a2)\n{\n  // A simple sanity check that it is an array.\n  if (!a1.slice)\n    throw new Error("DataUtils.arraysEqual: a1 is not an array");\n  if (!a2.slice)\n    throw new Error("DataUtils.arraysEqual: a2 is not an array");\n\n  if (a1.length != a2.length)\n    return false;\n\n  for (var i = 0; i < a1.length; ++i) {\n    if (a1[i] != a2[i])\n      return false;\n  }\n\n  return true;\n};\n\n/**\n * Convert the big endian ndnbuf to an unsigned int.\n * Don\'t check for overflow.\n */\nDataUtils.bigEndianToUnsignedInt = function(bytes)\n{\n  var result = 0;\n  for (var i = 0; i < bytes.length; ++i) {\n    result <<= 8;\n    result += bytes[i];\n  }\n  return result;\n};\n\n/**\n * Convert the int value to a new big endian ndnbuf and return.\n * If value is 0 or negative, return new ndnbuf(0).\n */\nDataUtils.nonNegativeIntToBigEndian = function(value)\n{\n  value = Math.round(value);\n  if (value <= 0)\n    return new ndnbuf(0);\n\n  // Assume value is not over 64 bits.\n  var size = 8;\n  var result = new ndnbuf(size);\n  var i = 0;\n  while (value != 0) {\n    ++i;\n    result[size - i] = value & 0xff;\n    value >>= 8;\n  }\n  return result.slice(size - i, size);\n};\n\n/**\n * Modify array to randomly shuffle the elements.\n */\nDataUtils.shuffle = function(array)\n{\n  for (var i = array.length - 1; i >= 1; --i) {\n    // j is from 0 to i.\n    var j = Math.floor(Math.random() * (i + 1));\n    var temp = array[i];\n    array[i] = array[j];\n    array[j] = temp;\n  }\n};\n/*\n * Date Format 1.2.3\n * (c) 2007-2009 Steven Levithan <stevenlevithan.com>\n * MIT license\n *\n * Includes enhancements by Scott Trenda <scott.trenda.net>\n * and Kris Kowal <cixar.com/~kris.kowal/>\n *\n * Accepts a date, a mask, or a date and a mask.\n * Returns a formatted version of the given date.\n * The date defaults to the current date/time.\n * The mask defaults to dateFormat.masks.default.\n */\n\nvar DateFormat = function()\n{\n  var  token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\\1?|[LloSZ]|"[^"]*"|\'[^\']*\'/g,\n    timezone = /\\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\\d{4})?)\\b/g,\n    timezoneClip = /[^-+\\dA-Z]/g,\n    pad = function(val, len) {\n      val = String(val);\n      len = len || 2;\n      while (val.length < len) val = "0" + val;\n      return val;\n    };\n\n  // Regexes and supporting functions are cached through closure\n  return function(date, mask, utc) {\n    var dF = dateFormat;\n\n    // You can\'t provide utc if you skip other args (use the "UTC:" mask prefix)\n    if (arguments.length == 1 && Object.prototype.toString.call(date) == "[object String]" && !/\\d/.test(date)) {\n      mask = date;\n      date = undefined;\n    }\n\n    // Passing date through Date applies Date.parse, if necessary\n    date = date ? new Date(date) : new Date;\n    if (isNaN(date)) throw SyntaxError("invalid date");\n\n    mask = String(dF.masks[mask] || mask || dF.masks["default"]);\n\n    // Allow setting the utc argument via the mask\n    if (mask.slice(0, 4) == "UTC:") {\n      mask = mask.slice(4);\n      utc = true;\n    }\n\n    var  _ = utc ? "getUTC" : "get",\n      d = date[_ + "Date"](),\n      D = date[_ + "Day"](),\n      m = date[_ + "Month"](),\n      y = date[_ + "FullYear"](),\n      H = date[_ + "Hours"](),\n      M = date[_ + "Minutes"](),\n      s = date[_ + "Seconds"](),\n      L = date[_ + "Milliseconds"](),\n      o = utc ? 0 : date.getTimezoneOffset(),\n      flags = {\n        d:    d,\n        dd:   pad(d),\n        ddd:  dF.i18n.dayNames[D],\n        dddd: dF.i18n.dayNames[D + 7],\n        m:    m + 1,\n        mm:   pad(m + 1),\n        mmm:  dF.i18n.monthNames[m],\n        mmmm: dF.i18n.monthNames[m + 12],\n        yy:   String(y).slice(2),\n        yyyy: y,\n        h:    H % 12 || 12,\n        hh:   pad(H % 12 || 12),\n        H:    H,\n        HH:   pad(H),\n        M:    M,\n        MM:   pad(M),\n        s:    s,\n        ss:   pad(s),\n        l:    pad(L, 3),\n        L:    pad(L > 99 ? Math.round(L / 10) : L),\n        t:    H < 12 ? "a"  : "p",\n        tt:   H < 12 ? "am" : "pm",\n        T:    H < 12 ? "A"  : "P",\n        TT:   H < 12 ? "AM" : "PM",\n        Z:    utc ? "UTC" : (String(date).match(timezone) || [""]).pop().replace(timezoneClip, ""),\n        o:    (o > 0 ? "-" : "+") + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),\n        S:    ["th", "st", "nd", "rd"][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10]\n      };\n\n    return mask.replace(token, function($0) {\n      return $0 in flags ? flags[$0] : $0.slice(1, $0.length - 1);\n    });\n  };\n}();\n\n// Some common format strings\nDateFormat.masks = {\n  "default":      "ddd mmm dd yyyy HH:MM:ss",\n  shortDate:      "m/d/yy",\n  mediumDate:     "mmm d, yyyy",\n  longDate:       "mmmm d, yyyy",\n  fullDate:       "dddd, mmmm d, yyyy",\n  shortTime:      "h:MM TT",\n  mediumTime:     "h:MM:ss TT",\n  longTime:       "h:MM:ss TT Z",\n  isoDate:        "yyyy-mm-dd",\n  isoTime:        "HH:MM:ss",\n  isoDateTime:    "yyyy-mm-dd\'T\'HH:MM:ss",\n  isoUtcDateTime: "UTC:yyyy-mm-dd\'T\'HH:MM:ss\'Z\'"\n};\n\n// Internationalization strings\nDateFormat.i18n = {\n  dayNames: [\n    "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat",\n    "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"\n  ],\n  monthNames: [\n    "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",\n    "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"\n  ]\n};\n\n// For convenience...\nDate.prototype.format = function(mask, utc) {\n  return dateFormat(this, mask, utc);\n};\n/**\n * This class is used to encode ndnb binary elements (blob, type/value pairs).\n *\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n */\n\n\nvar XML_EXT = 0x00;\n\nvar XML_TAG = 0x01;\n\nvar XML_DTAG = 0x02;\n\nvar XML_ATTR = 0x03;\n\nvar XML_DATTR = 0x04;\n\nvar XML_BLOB = 0x05;\n\nvar XML_UDATA = 0x06;\n\nvar XML_CLOSE = 0x0;\n\nvar XML_SUBTYPE_PROCESSING_INSTRUCTIONS = 16;\n\n\nvar XML_TT_BITS = 3;\nvar XML_TT_MASK = ((1 << XML_TT_BITS) - 1);\nvar XML_TT_VAL_BITS = XML_TT_BITS + 1;\nvar XML_TT_VAL_MASK = ((1 << (XML_TT_VAL_BITS)) - 1);\nvar XML_REG_VAL_BITS = 7;\nvar XML_REG_VAL_MASK = ((1 << XML_REG_VAL_BITS) - 1);\nvar XML_TT_NO_MORE = (1 << XML_REG_VAL_BITS); // 0x80\nvar BYTE_MASK = 0xFF;\nvar LONG_BYTES = 8;\nvar LONG_BITS = 64;\n\nvar bits_11 = 0x0000007FF;\nvar bits_18 = 0x00003FFFF;\nvar bits_32 = 0x0FFFFFFFF;\n\n/**\n * @constructor\n */\nvar BinaryXMLEncoder = function BinaryXMLEncoder(initiaLength)\n{\n  if (!initiaLength)\n    initiaLength = 16;\n\n  this.ostream = new DynamicBuffer(initiaLength);\n  this.offset = 0;\n  this.CODEC_NAME = "Binary";\n};\n\nexports.BinaryXMLEncoder = BinaryXMLEncoder;\n\n/**\n * Encode utf8Content as utf8 and write to the output ndnbuf as a UDATA.\n * @param {string} utf8Content The string to convert to utf8.\n */\nBinaryXMLEncoder.prototype.writeUString = function(utf8Content)\n{\n  this.encodeUString(utf8Content, XML_UDATA);\n};\n\nBinaryXMLEncoder.prototype.writeBlob = function(\n    /*Buffer*/ binaryContent)\n{\n  if (LOG >3) console.log(binaryContent);\n\n  this.encodeBlob(binaryContent, binaryContent.length);\n};\n\n/**\n * Write an element start header using DTAG with the tag to the output ndnbuf.\n * @param {number} tag The DTAG tag.\n */\nBinaryXMLEncoder.prototype.writeElementStartDTag = function(tag)\n{\n  this.encodeTypeAndVal(XML_DTAG, tag);\n};\n\n/**\n * @deprecated Use writeElementStartDTag.  Binary XML string tags and attributes are not used by any NDN encodings and\n * support is not maintained in the code base.\n */\nBinaryXMLEncoder.prototype.writeStartElement = function(\n  /*String*/ tag,\n  /*TreeMap<String,String>*/ attributes)\n{\n  /*Long*/ var dictionaryVal = tag; //stringToTag(tag);\n\n  if (null == dictionaryVal)\n    this.encodeUString(tag, XML_TAG);\n  else\n    this.encodeTypeAndVal(XML_DTAG, dictionaryVal);\n\n  if (null != attributes)\n    this.writeAttributes(attributes);\n};\n\n/**\n * Write an element close to the output ndnbuf.\n */\nBinaryXMLEncoder.prototype.writeElementClose = function()\n{\n  this.ostream.ensureLength(this.offset + 1);\n  this.ostream.array[this.offset] = XML_CLOSE;\n  this.offset += 1;\n};\n\n/**\n * @deprecated Use writeElementClose.\n */\nBinaryXMLEncoder.prototype.writeEndElement = function()\n{\n  this.writeElementClose();\n};\n\n/**\n * @deprecated Binary XML string tags and attributes are not used by any NDN encodings and support is not maintained in the code base.\n */\nBinaryXMLEncoder.prototype.writeAttributes = function(/*TreeMap<String,String>*/ attributes)\n{\n  if (null == attributes)\n    return;\n\n  // the keySet of a TreeMap is sorted.\n\n  for (var i = 0; i< attributes.length;i++) {\n    var strAttr = attributes[i].k;\n    var strValue = attributes[i].v;\n\n    var dictionaryAttr = stringToTag(strAttr);\n    if (null == dictionaryAttr)\n      // not in dictionary, encode as attr\n      // compressed format wants length of tag represented as length-1\n      // to save that extra bit, as tag cannot be 0 length.\n      // encodeUString knows to do that.\n      this.encodeUString(strAttr, XML_ATTR);\n    else\n      this.encodeTypeAndVal(XML_DATTR, dictionaryAttr);\n\n    // Write value\n    this.encodeUString(strValue);\n  }\n};\n\n//returns a string\nstringToTag = function(/*long*/ tagVal)\n{\n  if (tagVal >= 0 && tagVal < NDNProtocolDTagsStrings.length)\n    return NDNProtocolDTagsStrings[tagVal];\n  else if (tagVal == NDNProtocolDTags.NDNProtocolDataUnit)\n    return NDNProtocolDTags.NDNPROTOCOL_DATA_UNIT;\n\n  return null;\n};\n\n//returns a Long\ntagToString =  function(/*String*/ tagName)\n{\n  // the slow way, but right now we don\'t care.... want a static lookup for the forward direction\n  for (var i = 0; i < NDNProtocolDTagsStrings.length; ++i) {\n    if (null != NDNProtocolDTagsStrings[i] && NDNProtocolDTagsStrings[i] == tagName)\n      return i;\n  }\n\n  if (NDNProtocolDTags.NDNPROTOCOL_DATA_UNIT == tagName)\n    return NDNProtocolDTags.NDNProtocolDataUnit;\n\n  return null;\n};\n\n/**\n * Write an element start header using DTAG with the tag to the output ndnbuf, then the content as explained below,\n * then an element close.\n * @param {number} tag The DTAG tag.\n * @param {number|string|Buffer} content If contentis a number, convert it to a string and call writeUString.  If content is a string,\n * call writeUString.  Otherwise, call writeBlob.\n */\nBinaryXMLEncoder.prototype.writeDTagElement = function(tag, content)\n{\n  this.writeElementStartDTag(tag);\n\n  if (typeof content === \'number\')\n    this.writeUString(content.toString());\n  else if (typeof content === \'string\')\n    this.writeUString(content);\n  else\n    this.writeBlob(content);\n\n  this.writeElementClose();\n};\n\n/**\n * @deprecated Use writeDTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and\n * support is not maintained in the code base.\n * If Content is a string, then encode as utf8 and write UDATA.\n */\nBinaryXMLEncoder.prototype.writeElement = function(\n    //long\n    tag,\n    //byte[]\n    Content,\n    //TreeMap<String, String>\n    attributes)\n{\n  this.writeStartElement(tag, attributes);\n  // Will omit if 0-length\n\n  if (typeof Content === \'number\') {\n    if (LOG > 4) console.log(\'GOING TO WRITE THE NUMBER .charCodeAt(0) \' + Content.toString().charCodeAt(0));\n    if (LOG > 4) console.log(\'GOING TO WRITE THE NUMBER \' + Content.toString());\n    if (LOG > 4) console.log(\'type of number is \' + typeof Content.toString());\n\n    this.writeUString(Content.toString());\n  }\n  else if (typeof Content === \'string\') {\n    if (LOG > 4) console.log(\'GOING TO WRITE THE STRING  \' + Content);\n    if (LOG > 4) console.log(\'type of STRING is \' + typeof Content);\n\n    this.writeUString(Content);\n  }\n  else {\n    if (LOG > 4) console.log(\'GOING TO WRITE A BLOB  \' + Content);\n\n    this.writeBlob(Content);\n  }\n\n  this.writeElementClose();\n};\n\nvar TypeAndVal = function TypeAndVal(_type,_val)\n{\n  this.type = _type;\n  this.val = _val;\n};\n\nBinaryXMLEncoder.prototype.encodeTypeAndVal = function(\n    //int\n    type,\n    //long\n    val)\n{\n  if (LOG > 4) console.log(\'Encoding type \'+ type+ \' and value \'+ val);\n\n  if (LOG > 4) console.log(\'OFFSET IS \' + this.offset);\n\n  if (type > XML_UDATA || type < 0 || val < 0)\n    throw new Error("Tag and value must be positive, and tag valid.");\n\n  // Encode backwards. Calculate how many bytes we need:\n  var numEncodingBytes = this.numEncodingBytes(val);\n  this.ostream.ensureLength(this.offset + numEncodingBytes);\n\n  // Bottom 4 bits of val go in last byte with tag.\n  this.ostream.array[this.offset + numEncodingBytes - 1] =\n    //(byte)\n      (BYTE_MASK &\n          (((XML_TT_MASK & type) |\n           ((XML_TT_VAL_MASK & val) << XML_TT_BITS))) |\n           XML_TT_NO_MORE); // set top bit for last byte\n  val = val >>> XML_TT_VAL_BITS;\n\n  // Rest of val goes into preceding bytes, 7 bits per byte, top bit\n  // is "more" flag.\n  var i = this.offset + numEncodingBytes - 2;\n  while (0 != val && i >= this.offset) {\n    this.ostream.array[i] = //(byte)\n        (BYTE_MASK & (val & XML_REG_VAL_MASK)); // leave top bit unset\n    val = val >>> XML_REG_VAL_BITS;\n    --i;\n  }\n\n  if (val != 0)\n    throw new Error("This should not happen: miscalculated encoding");\n\n  this.offset+= numEncodingBytes;\n\n  return numEncodingBytes;\n};\n\n/**\n * Encode ustring as utf8.\n */\nBinaryXMLEncoder.prototype.encodeUString = function(\n    //String\n    ustring,\n    //byte\n    type)\n{\n  if (null == ustring)\n    return;\n  if (type == XML_TAG || type == XML_ATTR && ustring.length == 0)\n    return;\n\n  if (LOG > 3) console.log("The string to write is ");\n  if (LOG > 3) console.log(ustring);\n\n  var strBytes = DataUtils.stringToUtf8Array(ustring);\n\n  this.encodeTypeAndVal(type,\n            (((type == XML_TAG) || (type == XML_ATTR)) ?\n                (strBytes.length-1) :\n                strBytes.length));\n\n  if (LOG > 3) console.log("THE string to write is ");\n\n  if (LOG > 3) console.log(strBytes);\n\n  this.writeString(strBytes);\n  this.offset+= strBytes.length;\n};\n\n\nBinaryXMLEncoder.prototype.encodeBlob = function(\n    //Buffer\n    blob,\n    //int\n    length)\n{\n  if (null == blob)\n    return;\n\n  if (LOG > 4) console.log(\'LENGTH OF XML_BLOB IS \'+length);\n\n  this.encodeTypeAndVal(XML_BLOB, length);\n  this.writeBlobArray(blob);\n  this.offset += length;\n};\n\nvar ENCODING_LIMIT_1_BYTE = ((1 << (XML_TT_VAL_BITS)) - 1);\nvar ENCODING_LIMIT_2_BYTES = ((1 << (XML_TT_VAL_BITS + XML_REG_VAL_BITS)) - 1);\nvar ENCODING_LIMIT_3_BYTES = ((1 << (XML_TT_VAL_BITS + 2 * XML_REG_VAL_BITS)) - 1);\n\nBinaryXMLEncoder.prototype.numEncodingBytes = function(\n    //long\n    x)\n{\n  if (x <= ENCODING_LIMIT_1_BYTE) return (1);\n  if (x <= ENCODING_LIMIT_2_BYTES) return (2);\n  if (x <= ENCODING_LIMIT_3_BYTES) return (3);\n\n  var numbytes = 1;\n\n  // Last byte gives you XML_TT_VAL_BITS\n  // Remainder each give you XML_REG_VAL_BITS\n  x = x >>> XML_TT_VAL_BITS;\n  while (x != 0) {\n        numbytes++;\n    x = x >>> XML_REG_VAL_BITS;\n  }\n  return (numbytes);\n};\n\n/**\n * Write an element start header using DTAG with the tag to the output ndnbuf, then the dateTime\n   * as a big endian BLOB converted to 4096 ticks per second, then an element close.\n * @param {number} tag The DTAG tag.\n * @param {NDNTime} dateTime\n */\nBinaryXMLEncoder.prototype.writeDateTimeDTagElement = function(tag, dateTime)\n{\n  //parse to hex\n  var binarydate =  Math.round((dateTime.msec/1000) * 4096).toString(16)  ;\n  if (binarydate.length % 2 == 1)\n    binarydate = \'0\' + binarydate;\n\n  this.writeDTagElement(tag, DataUtils.toNumbers(binarydate));\n};\n\n/**\n * @deprecated Use writeDateTimeDTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and\n * support is not maintained in the code base.\n */\nBinaryXMLEncoder.prototype.writeDateTime = function(\n    //String\n    tag,\n    //NDNTime\n    dateTime)\n{\n  //parse to hex\n  var binarydate =  Math.round((dateTime.msec/1000) * 4096).toString(16)  ;\n  if (binarydate.length % 2 == 1)\n    binarydate = \'0\' + binarydate;\n\n  this.writeElement(tag, DataUtils.toNumbers(binarydate));\n};\n\n// This does not update this.offset.\nBinaryXMLEncoder.prototype.writeString = function(input)\n{\n  if (typeof input === \'string\') {\n    if (LOG > 4) console.log(\'GOING TO WRITE A STRING\');\n    if (LOG > 4) console.log(input);\n\n    this.ostream.ensureLength(this.offset + input.length);\n    for (var i = 0; i < input.length; i++) {\n      if (LOG > 4) console.log(\'input.charCodeAt(i)=\' + input.charCodeAt(i));\n      this.ostream.array[this.offset + i] = (input.charCodeAt(i));\n    }\n  }\n  else\n  {\n    if (LOG > 4) console.log(\'GOING TO WRITE A STRING IN BINARY FORM\');\n    if (LOG > 4) console.log(input);\n\n    this.writeBlobArray(input);\n  }\n};\n\nBinaryXMLEncoder.prototype.writeBlobArray = function(\n    //Buffer\n    blob)\n{\n  if (LOG > 4) console.log(\'GOING TO WRITE A BLOB\');\n\n  this.ostream.set(blob, this.offset);\n};\n\nBinaryXMLEncoder.prototype.getReducedOstream = function()\n{\n  return this.ostream.slice(0, this.offset);\n};\n/**\n * This class is used to decode ndnb binary elements (blob, type/value pairs).\n *\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n */\n\n\nvar XML_EXT = 0x00;\n\nvar XML_TAG = 0x01;\n\nvar XML_DTAG = 0x02;\n\nvar XML_ATTR = 0x03;\n\nvar XML_DATTR = 0x04;\n\nvar XML_BLOB = 0x05;\n\nvar XML_UDATA = 0x06;\n\nvar XML_CLOSE = 0x0;\n\nvar XML_SUBTYPE_PROCESSING_INSTRUCTIONS = 16;\n\n\nvar XML_TT_BITS = 3;\nvar XML_TT_MASK = ((1 << XML_TT_BITS) - 1);\nvar XML_TT_VAL_BITS = XML_TT_BITS + 1;\nvar XML_TT_VAL_MASK = ((1 << (XML_TT_VAL_BITS)) - 1);\nvar XML_REG_VAL_BITS = 7;\nvar XML_REG_VAL_MASK = ((1 << XML_REG_VAL_BITS) - 1);\nvar XML_TT_NO_MORE = (1 << XML_REG_VAL_BITS); // 0x80\nvar BYTE_MASK = 0xFF;\nvar LONG_BYTES = 8;\nvar LONG_BITS = 64;\n\nvar bits_11 = 0x0000007FF;\nvar bits_18 = 0x00003FFFF;\nvar bits_32 = 0x0FFFFFFFF;\n\n\n\n//returns a string\ntagToString = function(/*long*/ tagVal)\n{\n  if (tagVal >= 0 && tagVal < NDNProtocolDTagsStrings.length) {\n    return NDNProtocolDTagsStrings[tagVal];\n  }\n  else if (tagVal == NDNProtocolDTags.NDNProtocolDataUnit) {\n    return NDNProtocolDTags.NDNPROTOCOL_DATA_UNIT;\n  }\n\n  return null;\n};\n\n//returns a Long\nstringToTag =  function(/*String*/ tagName)\n{\n  // the slow way, but right now we don\'t care.... want a static lookup for the forward direction\n  for (var i=0; i < NDNProtocolDTagsStrings.length; ++i) {\n    if (null != NDNProtocolDTagsStrings[i] && NDNProtocolDTagsStrings[i] == tagName)\n      return i;\n  }\n  if (NDNProtocolDTags.NDNPROTOCOL_DATA_UNIT == tagName) {\n    return NDNProtocolDTags.NDNProtocolDataUnit;\n  }\n\n  return null;\n};\n\n/**\n * @constructor\n */\nvar BinaryXMLDecoder = function BinaryXMLDecoder(input)\n{\n  var MARK_LEN=512;\n  var DEBUG_MAX_LEN =  32768;\n\n  this.input = input;\n  this.offset = 0;\n  // peekDTag sets and checks this, and readElementStartDTag uses it to avoid reading again.\n  this.previouslyPeekedDTagStartOffset = -1;\n};\n\nexports.BinaryXMLDecoder = BinaryXMLDecoder;\n\n/**\n * Decode the header from the input starting at its position, expecting the type to be DTAG and the value to be expectedTag.\n   * Update the input\'s offset.\n * @param {number} expectedTag The expected value for DTAG.\n */\nBinaryXMLDecoder.prototype.readElementStartDTag = function(expectedTag)\n{\n  if (this.offset == this.previouslyPeekedDTagStartOffset) {\n    // peekDTag already decoded this DTag.\n    if (this.previouslyPeekedDTag != expectedTag)\n      throw new ContentDecodingException(new Error("Did not get the expected DTAG " + expectedTag + ", got " + this.previouslyPeekedDTag));\n\n    // Fast forward past the header.\n    this.offset = this.previouslyPeekedDTagEndOffset;\n  }\n  else {\n    var typeAndValue = this.decodeTypeAndVal();\n    if (typeAndValue == null || typeAndValue.type() != XML_DTAG)\n      throw new ContentDecodingException(new Error("Header type is not a DTAG"));\n\n    if (typeAndValue.val() != expectedTag)\n      throw new ContentDecodingException(new Error("Expected start element: " + expectedTag + " got: " + typeAndValue.val()));\n  }\n};\n\n/**\n * @deprecated Use readElementStartDTag. Binary XML string tags and attributes are not used by any NDN encodings and\n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.readStartElement = function(\n    //String\n    startTag,\n    //TreeMap<String, String>\n    attributes)\n{\n  //TypeAndVal\n  var tv = this.decodeTypeAndVal();\n\n  if (null == tv)\n    throw new ContentDecodingException(new Error("Expected start element: " + startTag + " got something not a tag."));\n\n  //String\n  var decodedTag = null;\n\n  if (tv.type() == XML_TAG) {\n    // Tag value represents length-1 as tags can never be empty.\n    var valval;\n\n    if (typeof tv.val() == \'string\')\n      valval = (parseInt(tv.val())) + 1;\n    else\n      valval = (tv.val())+ 1;\n\n    decodedTag = this.decodeUString(valval);\n  }\n  else if (tv.type() == XML_DTAG)\n    decodedTag = tv.val();\n\n  if (null ==  decodedTag || decodedTag != startTag) {\n    console.log(\'expecting \'+ startTag + \' but got \'+ decodedTag);\n    throw new ContentDecodingException(new Error("Expected start element: " + startTag + " got: " + decodedTag + "(" + tv.val() + ")"));\n  }\n\n  // DKS: does not read attributes out of stream if caller doesn\'t\n  // ask for them. Should possibly peek and skip over them regardless.\n  // TODO: fix this\n  if (null != attributes)\n    readAttributes(attributes);\n};\n\n/**\n * @deprecated Binary XML string tags and attributes are not used by any NDN encodings and support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.readAttributes = function(\n  // array of [attributeName, attributeValue]\n  attributes)\n{\n  if (null == attributes)\n    return;\n\n  try {\n    // Now need to get attributes.\n    //TypeAndVal\n    var nextTV = this.peekTypeAndVal();\n\n    while (null != nextTV && (XML_ATTR == nextTV.type() || XML_DATTR == nextTV.type())) {\n      // Decode this attribute. First, really read the type and value.\n      //this.TypeAndVal\n      var thisTV = this.decodeTypeAndVal();\n\n      //String\n      var attributeName = null;\n      if (XML_ATTR == thisTV.type()) {\n        // Tag value represents length-1 as attribute names cannot be empty.\n        var valval ;\n        if (typeof thisTV.val() == \'string\')\n          valval = (parseInt(thisTV.val())) + 1;\n        else\n          valval = (thisTV.val())+ 1;\n\n        attributeName = this.decodeUString(valval);\n      }\n      else if (XML_DATTR == thisTV.type()) {\n        // DKS TODO are attributes same or different dictionary?\n        attributeName = tagToString(thisTV.val());\n        if (null == attributeName)\n          throw new ContentDecodingException(new Error("Unknown DATTR value" + thisTV.val()));\n      }\n\n      // Attribute values are always UDATA\n      //String\n      var attributeValue = this.decodeUString();\n\n      attributes.push([attributeName, attributeValue]);\n      nextTV = this.peekTypeAndVal();\n    }\n  }\n  catch (e) {\n    throw new ContentDecodingException(new Error("readStartElement", e));\n  }\n};\n\n/**\n * @deprecated Use peekDTag.  Binary XML string tags and attributes are not used by any NDN encodings and\n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.peekStartElementAsString = function()\n{\n  //String\n  var decodedTag = null;\n  var previousOffset = this.offset;\n  try {\n    // Have to distinguish genuine errors from wrong tags. Could either use\n    // a special exception subtype, or redo the work here.\n    //this.TypeAndVal\n    var tv = this.decodeTypeAndVal();\n\n    if (null != tv) {\n      if (tv.type() == XML_TAG) {\n        // Tag value represents length-1 as tags can never be empty.\n        var valval ;\n        if (typeof tv.val() == \'string\')\n          valval = (parseInt(tv.val())) + 1;\n        else\n          valval = (tv.val())+ 1;\n\n        decodedTag = this.decodeUString(valval);\n      }\n      else if (tv.type() == XML_DTAG)\n        decodedTag = tagToString(tv.val());\n    } // else, not a type and val, probably an end element. rewind and return false.\n  }\n  catch (e) {\n  }\n  finally {\n    try {\n      this.offset = previousOffset;\n    }\n    catch (e) {\n      Log.logStackTrace(Log.FAC_ENCODING, Level.WARNING, e);\n      throw new ContentDecodingException(new Error("Cannot reset stream! " + e.getMessage(), e));\n    }\n  }\n\n  return decodedTag;\n};\n\n/**\n * Decode the header from the input starting at its position, and if it is a DTAG where the value is the expectedTag,\n * then set return true.  Do not update the input\'s offset.\n * @param {number} expectedTag The expected value for DTAG.\n * @returns {boolean} True if the tag is the expected tag, otherwise false.\n */\nBinaryXMLDecoder.prototype.peekDTag = function(expectedTag)\n{\n  if (this.offset == this.previouslyPeekedDTagStartOffset)\n    // We already decoded this DTag.\n    return this.previouslyPeekedDTag == expectedTag;\n  else {\n    // First check if it is an element close (which cannot be the expected tag).\n    if (this.input[this.offset] == XML_CLOSE)\n      return false;\n\n    var saveOffset = this.offset;\n    var typeAndValue = this.decodeTypeAndVal();\n    // readElementStartDTag will use this to fast forward.\n    this.previouslyPeekedDTagEndOffset = this.offset;\n    // Restore the position.\n    this.offset = saveOffset;\n\n    if (typeAndValue != null && typeAndValue.type() == XML_DTAG) {\n      this.previouslyPeekedDTagStartOffset = saveOffset;\n      this.previouslyPeekedDTag = typeAndValue.val();\n\n      return typeAndValue.val() == expectedTag;\n    }\n    else\n      return false;\n  }\n};\n\n/**\n * @deprecated Use peekDTag.  Binary XML string tags and attributes are not used by any NDN encodings and\n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.peekStartElement = function(\n    //String\n    startTag)\n{\n  //String\n  if (typeof startTag == \'string\') {\n    var decodedTag = this.peekStartElementAsString();\n\n    if (null !=  decodedTag && decodedTag == startTag)\n      return true;\n\n    return false;\n  }\n  else if (typeof startTag == \'number\') {\n    var decodedTag = this.peekStartElementAsLong();\n    if (null !=  decodedTag && decodedTag == startTag)\n      return true;\n\n    return false;\n  }\n  else\n    throw new ContentDecodingException(new Error("SHOULD BE STRING OR NUMBER"));\n};\n\n/**\n * @deprecated Use peekDTag.  Binary XML string tags and attributes are not used by any NDN encodings and\n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.peekStartElementAsLong = function()\n{\n  //Long\n  var decodedTag = null;\n  var previousOffset = this.offset;\n\n  try {\n    // Have to distinguish genuine errors from wrong tags. Could either use\n    // a special exception subtype, or redo the work here.\n    //this.TypeAndVal\n    var tv = this.decodeTypeAndVal();\n\n    if (null != tv) {\n      if (tv.type() == XML_TAG) {\n        if (tv.val() + 1 > DEBUG_MAX_LEN)\n          throw new ContentDecodingException(new Error("Decoding error: length " + tv.val()+1 + " longer than expected maximum length!"));\n\n        var valval;\n        if (typeof tv.val() == \'string\')\n          valval = (parseInt(tv.val())) + 1;\n        else\n          valval = (tv.val())+ 1;\n\n        // Tag value represents length-1 as tags can never be empty.\n        //String\n        var strTag = this.decodeUString(valval);\n\n        decodedTag = stringToTag(strTag);\n      }\n      else if (tv.type() == XML_DTAG)\n        decodedTag = tv.val();\n    } // else, not a type and val, probably an end element. rewind and return false.\n\n  }\n  catch (e) {\n  }\n  finally {\n    try {\n      //this.input.reset();\n      this.offset = previousOffset;\n    } catch (e) {\n      Log.logStackTrace(Log.FAC_ENCODING, Level.WARNING, e);\n      throw new Error("Cannot reset stream! " + e.getMessage(), e);\n    }\n  }\n\n  return decodedTag;\n};\n\n/**\n * Decode the header from the input starting its offset, expecting the type to be DTAG and the value to be expectedTag.\n * Then read one item of any type (presumably BLOB, UDATA, TAG or ATTR) and return a\n * ndnbuf. However, if allowNull is true, then the item may be absent.\n * Finally, read the element close.  Update the input\'s offset.\n * @param {number} expectedTag The expected value for DTAG.\n * @param {boolean} allowNull True if the binary item may be missing.\n * @returns {Buffer} A ndnbuf which is a slice on the data inside the input ndnbuf. However,\n * if allowNull is true and the binary data item is absent, then return null.\n */\nBinaryXMLDecoder.prototype.readBinaryDTagElement = function(expectedTag, allowNull)\n{\n  this.readElementStartDTag(expectedTag);\n  return this.readBlob(allowNull);\n};\n\n/**\n * @deprecated Use readBinaryDTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and\n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.readBinaryElement = function(\n    //long\n    startTag,\n    //TreeMap<String, String>\n    attributes,\n    //boolean\n    allowNull)\n{\n  this.readStartElement(startTag, attributes);\n  return this.readBlob(allowNull);\n};\n\n/**\n * Read one byte from the input starting at its offset, expecting it to be the element close.\n * Update the input\'s offset.\n */\nBinaryXMLDecoder.prototype.readElementClose = function()\n{\n  var next = this.input[this.offset++];\n  if (next != XML_CLOSE)\n    throw new ContentDecodingException(new Error("Expected end element, got: " + next));\n};\n\n/**\n * @deprecated Use readElementClose.\n */\nBinaryXMLDecoder.prototype.readEndElement = function()\n{\n  if (LOG > 4) console.log(\'this.offset is \'+this.offset);\n\n  var next = this.input[this.offset];\n\n  this.offset++;\n\n  if (LOG > 4) console.log(\'XML_CLOSE IS \'+XML_CLOSE);\n  if (LOG > 4) console.log(\'next is \'+next);\n\n  if (next != XML_CLOSE) {\n    console.log("Expected end element, got: " + next);\n    throw new ContentDecodingException(new Error("Expected end element, got: " + next));\n  }\n};\n\n//String\nBinaryXMLDecoder.prototype.readUString = function()\n{\n  //String\n  var ustring = this.decodeUString();\n  this.readElementClose();\n  return ustring;\n};\n\n/**\n * Read a blob as well as the end element. Returns a ndnbuf (or null for missing blob).\n * If the blob is missing and allowNull is false (default), throw an exception.  Otherwise,\n *   just read the end element and return null.\n */\nBinaryXMLDecoder.prototype.readBlob = function(allowNull)\n{\n  if (this.input[this.offset] == XML_CLOSE && allowNull) {\n    this.readElementClose();\n    return null;\n  }\n\n  var blob = this.decodeBlob();\n  this.readElementClose();\n  return blob;\n};\n\n/**\n * Decode the header from the input starting at its offset, expecting the type to be\n * DTAG and the value to be expectedTag.  Then read one item, parse it as an unsigned\n * big endian integer in 4096 ticks per second, and convert it to and NDNTime object.\n * Finally, read the element close.  Update the input\'s offset.\n * @param {number} expectedTag The expected value for DTAG.\n * @returns {NDNTime} The dateTime value.\n */\nBinaryXMLDecoder.prototype.readDateTimeDTagElement = function(expectedTag)\n{\n  var byteTimestamp = this.readBinaryDTagElement(expectedTag);\n  byteTimestamp = DataUtils.toHex(byteTimestamp);\n  byteTimestamp = parseInt(byteTimestamp, 16);\n\n  var lontimestamp = (byteTimestamp/ 4096) * 1000;\n\n  var timestamp = new NDNTime(lontimestamp);\n  if (null == timestamp)\n    throw new ContentDecodingException(new Error("Cannot parse timestamp: " + DataUtils.printHexBytes(byteTimestamp)));\n\n  return timestamp;\n};\n\n/**\n * @deprecated Use readDateTimeDTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and\n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.readDateTime = function(\n  //long\n  startTag)\n{\n  var byteTimestamp = this.readBinaryElement(startTag);\n  byteTimestamp = DataUtils.toHex(byteTimestamp);\n  byteTimestamp = parseInt(byteTimestamp, 16);\n\n  var lontimestamp = (byteTimestamp/ 4096) * 1000;\n\n  if (LOG > 4) console.log(\'DECODED DATE WITH VALUE\');\n  if (LOG > 4) console.log(lontimestamp);\n\n  //NDNTime\n  var timestamp = new NDNTime(lontimestamp);\n  if (null == timestamp)\n    throw new ContentDecodingException(new Error("Cannot parse timestamp: " + DataUtils.printHexBytes(byteTimestamp)));\n\n  return timestamp;\n};\n\nBinaryXMLDecoder.prototype.decodeTypeAndVal = function()\n{\n\n  /*int*/ var type = -1;\n  /*long*/ var val = 0;\n  /*boolean*/ var more = true;\n\n  do {\n    var next = this.input[this.offset ];\n    if (next == null)\n      // Quit the loop.\n      return null;\n\n    if (next < 0)\n      return null;\n\n    if (0 == next && 0 == val)\n      return null;\n\n    more = (0 == (next & XML_TT_NO_MORE));\n\n    if  (more) {\n      val = val << XML_REG_VAL_BITS;\n      val |= (next & XML_REG_VAL_MASK);\n    }\n    else {\n      type = next & XML_TT_MASK;\n      val = val << XML_TT_VAL_BITS;\n      val |= ((next >>> XML_TT_BITS) & XML_TT_VAL_MASK);\n    }\n\n    this.offset++;\n  } while (more);\n\n  if (LOG > 4) console.log(\'TYPE is \'+ type + \' VAL is \'+ val);\n\n  return new TypeAndVal(type, val);\n};\n\n//TypeAndVal\nBinaryXMLDecoder.prototype.peekTypeAndVal = function()\n{\n  //TypeAndVal\n  var tv = null;\n  var previousOffset = this.offset;\n\n  try {\n    tv = this.decodeTypeAndVal();\n  }\n  finally {\n    this.offset = previousOffset;\n  }\n\n  return tv;\n};\n\n//Buffer\nBinaryXMLDecoder.prototype.decodeBlob = function(\n    //int\n    blobLength)\n{\n  if (null == blobLength) {\n    //TypeAndVal\n    var tv = this.decodeTypeAndVal();\n\n    var valval ;\n    if (typeof tv.val() == \'string\')\n      valval = (parseInt(tv.val()));\n    else\n      valval = (tv.val());\n\n    return this.decodeBlob(valval);\n  }\n\n  //Buffer\n  var bytes = new ndnbuf(this.input.slice(this.offset, this.offset+ blobLength));\n  this.offset += blobLength;\n\n  return bytes;\n};\n\n//String\nBinaryXMLDecoder.prototype.decodeUString = function(\n    //int\n    byteLength)\n{\n  if (null == byteLength) {\n    var tempStreamPosition = this.offset;\n\n    //TypeAndVal\n    var tv = this.decodeTypeAndVal();\n\n    if (LOG > 4) console.log(\'TV is \'+tv);\n    if (LOG > 4) console.log(tv);\n\n    if (LOG > 4) console.log(\'Type of TV is \'+typeof tv);\n\n    // if we just have closers left, will get back null\n    if (null == tv || XML_UDATA != tv.type()) {\n      this.offset = tempStreamPosition;\n      return "";\n    }\n\n    return this.decodeUString(tv.val());\n  }\n  else {\n    //Buffer\n    var stringBytes = this.decodeBlob(byteLength);\n\n    // TODO: Should this parse as UTF8?\n    return DataUtils.toString(stringBytes);\n  }\n};\n\n//OBject containg a pair of type and value\nvar TypeAndVal = function TypeAndVal(_type,_val)\n{\n  this.t = _type;\n  this.v = _val;\n};\n\nTypeAndVal.prototype.type = function()\n{\n  return this.t;\n};\n\nTypeAndVal.prototype.val = function()\n{\n  return this.v;\n};\n\n/**\n * Decode the header from the input starting its offset, expecting the type to be DTAG and the value to be expectedTag.\n * Then read one UDATA item, parse it as a decimal integer and return the integer. Finally, read the element close.  Update the input\'s offset.\n * @param {number} expectedTag The expected value for DTAG.\n * @returns {number} The parsed integer.\n */\nBinaryXMLDecoder.prototype.readIntegerDTagElement = function(expectedTag)\n{\n  return parseInt(this.readUTF8DTagElement(expectedTag));\n};\n\n/**\n * @deprecated Use readIntegerDTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and\n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.readIntegerElement = function(\n  //String\n  startTag)\n{\n  //String\n  if (LOG > 4) console.log(\'READING INTEGER \'+ startTag);\n  if (LOG > 4) console.log(\'TYPE OF \'+ typeof startTag);\n\n  var strVal = this.readUTF8Element(startTag);\n\n  return parseInt(strVal);\n};\n\n/**\n * Decode the header from the input starting its offset, expecting the type to be DTAG and the value to be expectedTag.\n * Then read one UDATA item and return a string. Finally, read the element close.  Update the input\'s offset.\n * @param {number} expectedTag The expected value for DTAG.\n * @returns {string} The UDATA string.\n */\nBinaryXMLDecoder.prototype.readUTF8DTagElement = function(expectedTag)\n{\n  this.readElementStartDTag(expectedTag);\n  return this.readUString();;\n};\n\n/**\n * @deprecated Use readUTF8DTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and\n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.readUTF8Element = function(\n    //String\n    startTag,\n    //TreeMap<String, String>\n    attributes)\n{\n  //throws Error where name == "ContentDecodingException"\n\n  // can\'t use getElementText, can\'t get attributes\n  this.readStartElement(startTag, attributes);\n  //String\n  var strElementText = this.readUString();\n  return strElementText;\n};\n\n/**\n * Set the offset into the input, used for the next read.\n * @param {number} offset The new offset.\n */\nBinaryXMLDecoder.prototype.seek = function(offset)\n{\n  this.offset = offset;\n};\n\n/*\n * Call with: throw new ContentDecodingException(new Error("message")).\n */\nfunction ContentDecodingException(error)\n{\n  this.message = error.message;\n  // Copy lineNumber, etc. from where new Error was called.\n  for (var prop in error)\n      this[prop] = error[prop];\n}\nContentDecodingException.prototype = new Error();\nContentDecodingException.prototype.name = "ContentDecodingException";\n/**\n * This class uses BinaryXMLDecoder to follow the structure of a ndnb binary element to\n * determine its end.\n *\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\n\nvar XML_EXT = 0x00;\nvar XML_TAG = 0x01;\nvar XML_DTAG = 0x02;\nvar XML_ATTR = 0x03;\nvar XML_DATTR = 0x04;\nvar XML_BLOB = 0x05;\nvar XML_UDATA = 0x06;\nvar XML_CLOSE = 0x0;\n\nvar XML_SUBTYPE_PROCESSING_INSTRUCTIONS = 16;\n\nvar XML_TT_BITS = 3;\nvar XML_TT_MASK = ((1 << XML_TT_BITS) - 1);\nvar XML_TT_VAL_BITS = XML_TT_BITS + 1;\nvar XML_TT_VAL_MASK = ((1 << (XML_TT_VAL_BITS)) - 1);\nvar XML_REG_VAL_BITS = 7;\nvar XML_REG_VAL_MASK = ((1 << XML_REG_VAL_BITS) - 1);\nvar XML_TT_NO_MORE = (1 << XML_REG_VAL_BITS); // 0x80\n\n/**\n * @constructor\n */\nvar BinaryXMLStructureDecoder = function BinaryXMLDecoder()\n{\n  this.gotElementEnd = false;\n  this.offset = 0;\n  this.level = 0;\n  this.state = BinaryXMLStructureDecoder.READ_HEADER_OR_CLOSE;\n  this.headerLength = 0;\n  this.useHeaderBuffer = false;\n  this.headerBuffer = new DynamicBuffer(5);\n  this.nBytesToRead = 0;\n};\n\nexports.BinaryXMLStructureDecoder = BinaryXMLStructureDecoder;\n\nBinaryXMLStructureDecoder.READ_HEADER_OR_CLOSE = 0;\nBinaryXMLStructureDecoder.READ_BYTES = 1;\n\n/**\n * Continue scanning input starting from this.offset.  If found the end of the element\n *   which started at offset 0 then return true, else false.\n * If this returns false, you should read more into input and call again.\n * You have to pass in input each time because the array could be reallocated.\n * This throws an exception for badly formed ndnb.\n */\nBinaryXMLStructureDecoder.prototype.findElementEnd = function(\n  // ndnbuf\n  input)\n{\n  if (this.gotElementEnd)\n    // Someone is calling when we already got the end.\n    return true;\n\n  var decoder = new BinaryXMLDecoder(input);\n\n  while (true) {\n    if (this.offset >= input.length)\n      // All the cases assume we have some input.\n      return false;\n\n    switch (this.state) {\n      case BinaryXMLStructureDecoder.READ_HEADER_OR_CLOSE:\n        // First check for XML_CLOSE.\n        if (this.headerLength == 0 && input[this.offset] == XML_CLOSE) {\n          ++this.offset;\n          // Close the level.\n          --this.level;\n          if (this.level == 0) {\n            // Finished.\n            this.gotElementEnd = true;\n            return true;\n          }\n          if (this.level < 0)\n            throw new Error("BinaryXMLStructureDecoder: Unexpected close tag at offset " + (this.offset - 1));\n\n          // Get ready for the next header.\n          this.startHeader();\n          break;\n        }\n\n        var startingHeaderLength = this.headerLength;\n        while (true) {\n          if (this.offset >= input.length) {\n            // We can\'t get all of the header bytes from this input. Save in headerBuffer.\n            this.useHeaderBuffer = true;\n            var nNewBytes = this.headerLength - startingHeaderLength;\n            this.headerBuffer.set(input.slice(this.offset - nNewBytes, nNewBytes), startingHeaderLength);\n\n            return false;\n          }\n          var headerByte = input[this.offset++];\n          ++this.headerLength;\n          if (headerByte & XML_TT_NO_MORE)\n            // Break and read the header.\n            break;\n        }\n\n        var typeAndVal;\n        if (this.useHeaderBuffer) {\n          // Copy the remaining bytes into headerBuffer.\n          nNewBytes = this.headerLength - startingHeaderLength;\n          this.headerBuffer.set(input.slice(this.offset - nNewBytes, nNewBytes), startingHeaderLength);\n\n          typeAndVal = new BinaryXMLDecoder(this.headerBuffer.array).decodeTypeAndVal();\n        }\n        else {\n          // We didn\'t have to use the headerBuffer.\n          decoder.seek(this.offset - this.headerLength);\n          typeAndVal = decoder.decodeTypeAndVal();\n        }\n\n        if (typeAndVal == null)\n          throw new Error("BinaryXMLStructureDecoder: Can\'t read header starting at offset " +\n                          (this.offset - this.headerLength));\n\n        // Set the next state based on the type.\n        var type = typeAndVal.t;\n        if (type == XML_DATTR)\n          // We already consumed the item. READ_HEADER_OR_CLOSE again.\n          // ndnb has rules about what must follow an attribute, but we are just scanning.\n          this.startHeader();\n        else if (type == XML_DTAG || type == XML_EXT) {\n          // Start a new level and READ_HEADER_OR_CLOSE again.\n          ++this.level;\n          this.startHeader();\n        }\n        else if (type == XML_TAG || type == XML_ATTR) {\n          if (type == XML_TAG)\n            // Start a new level and read the tag.\n            ++this.level;\n          // Minimum tag or attribute length is 1.\n          this.nBytesToRead = typeAndVal.v + 1;\n          this.state = BinaryXMLStructureDecoder.READ_BYTES;\n          // ndnb has rules about what must follow an attribute, but we are just scanning.\n        }\n        else if (type == XML_BLOB || type == XML_UDATA) {\n          this.nBytesToRead = typeAndVal.v;\n          this.state = BinaryXMLStructureDecoder.READ_BYTES;\n        }\n        else\n          throw new Error("BinaryXMLStructureDecoder: Unrecognized header type " + type);\n        break;\n\n      case BinaryXMLStructureDecoder.READ_BYTES:\n        var nRemainingBytes = input.length - this.offset;\n        if (nRemainingBytes < this.nBytesToRead) {\n          // Need more.\n          this.offset += nRemainingBytes;\n          this.nBytesToRead -= nRemainingBytes;\n          return false;\n        }\n        // Got the bytes.  Read a new header or close.\n        this.offset += this.nBytesToRead;\n        this.startHeader();\n        break;\n\n      default:\n        // We don\'t expect this to happen.\n        throw new Error("BinaryXMLStructureDecoder: Unrecognized state " + this.state);\n    }\n  }\n};\n\n/**\n * Set the state to READ_HEADER_OR_CLOSE and set up to start reading the header\n */\nBinaryXMLStructureDecoder.prototype.startHeader = function()\n{\n  this.headerLength = 0;\n  this.useHeaderBuffer = false;\n  this.state = BinaryXMLStructureDecoder.READ_HEADER_OR_CLOSE;\n};\n\n/**\n *  Set the offset into the input, used for the next read.\n */\nBinaryXMLStructureDecoder.prototype.seek = function(offset)\n{\n  this.offset = offset;\n};\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * This class represents Interest Objects\n */\n\n/**\n * Create a WireFormat base class where the encode and decode methods throw an error. You should use a derived class like BinaryXmlWireFormat.\n * @constructor\n */\nvar WireFormat = function WireFormat() {\n};\n\nexports.WireFormat = WireFormat;\n\n/**\n * The override method in the derived class should encode the interest and return a ndnbuf.\n * @param {Interest} interest\n * @returns {Buffer}\n * @throws Error This always throws an "unimplemented" error. The derived class should override.\n */\nWireFormat.prototype.encodeInterest = function(interest)\n{\n  throw new Error("encodeInterest is unimplemented in the base WireFormat class.  You should use a derived class.");\n};\n\n/**\n * The override method in the derived class should decode the input and put the result in interest.\n * @param {Interest} interest\n * @param {Buffer} input\n * @throws Error This always throws an "unimplemented" error. The derived class should override.\n */\nWireFormat.prototype.decodeInterest = function(interest, input)\n{\n  throw new Error("decodeInterest is unimplemented in the base WireFormat class.  You should use a derived class.");\n};\n\n/**\n * The override method in the derived class should encode the data and return a ndnbuf.\n * @param {Data} data\n * @returns {Buffer}\n * @throws Error This always throws an "unimplemented" error. The derived class should override.\n */\nWireFormat.prototype.encodeData = function(data)\n{\n  throw new Error("encodeData is unimplemented in the base WireFormat class.  You should use a derived class.");\n};\n\n/**\n * The override method in the derived class should decode the input and put the result in data.\n * @param {Data} data\n * @param {Buffer} input\n * @throws Error This always throws an "unimplemented" error. The derived class should override.\n */\nWireFormat.prototype.decodeData = function(data, input)\n{\n  throw new Error("decodeData is unimplemented in the base WireFormat class.  You should use a derived class.");\n};\n\n\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\n\n/**\n * A BinaryXmlElementReader lets you call onReceivedData multiple times which uses a\n * BinaryXMLStructureDecoder to detect the end of a binary XML element and calls\n * elementListener.onReceivedElement(element) with the element.\n * This handles the case where a single call to onReceivedData may contain multiple elements.\n * @constructor\n * @param {{onReceivedElement:function}} elementListener\n */\nvar BinaryXmlElementReader = function BinaryXmlElementReader(elementListener)\n{\n  this.elementListener = elementListener;\n  this.dataParts = [];\n  this.structureDecoder = new BinaryXMLStructureDecoder();\n};\n\nexports.BinaryXmlElementReader = BinaryXmlElementReader;\n\nBinaryXmlElementReader.prototype.onReceivedData = function(/* ndnbuf */ data)\n{\n  // Process multiple objects in the data.\n  while (true) {\n    // Scan the input to check if a whole ndnb object has been read.\n    this.structureDecoder.seek(0);\n    if (this.structureDecoder.findElementEnd(data)) {\n      // Got the remainder of an object.  Report to the caller.\n      this.dataParts.push(data.slice(0, this.structureDecoder.offset));\n      var element = DataUtils.concatArrays(this.dataParts);\n      this.dataParts = [];\n      try {\n        this.elementListener.onReceivedElement(element);\n      } catch (ex) {\n          console.log("BinaryXmlElementReader: ignoring exception from onReceivedElement: " + ex);\n      }\n\n      // Need to read a new object.\n      data = data.slice(this.structureDecoder.offset, data.length);\n      this.structureDecoder = new BinaryXMLStructureDecoder();\n      if (data.length == 0)\n        // No more data in the packet.\n        return;\n\n      // else loop back to decode.\n    }\n    else {\n      // Save for a later call to concatArrays so that we only copy data once.\n      this.dataParts.push(data);\n      if (LOG > 3) console.log(\'Incomplete packet received. Length \' + data.length + \'. Wait for more input.\');\n        return;\n    }\n  }\n};\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\n/**\n * Create a context for getting the response from the name enumeration command, as neede by getComponents.\n * (To do name enumeration, call the static method NameEnumeration.getComponents.)\n * @param {Face} face The Face object for using expressInterest.\n * @param {function} onComponents The onComponents callback given to getComponents.\n */\nvar NameEnumeration = function NameEnumeration(face, onComponents)\n{\n  this.face = face;\n  this.onComponents = onComponents;\n  this.contentParts = [];\n\n  var self = this;\n  this.onData = function(interest, data) { self.processData(data); };\n  this.onTimeout = function(interest) { self.processTimeout(); };\n};\n\nexports.NameEnumeration = NameEnumeration;\n\n/**\n * Use the name enumeration protocol to get the child components of the name prefix.\n * @param {Face} face The Face object for using expressInterest.\n * @param {Name} name The name prefix for finding the child components.\n * @param {function} onComponents On getting the response, this calls onComponents(components) where\n * components is an array of ndnbuf name components.  If there is no response, this calls onComponents(null).\n */\nNameEnumeration.getComponents = function(face, prefix, onComponents)\n{\n  var command = new Name(prefix);\n  // Add %C1.E.be\n  command.add([0xc1, 0x2e, 0x45, 0x2e, 0x62, 0x65])\n\n  var enumeration = new NameEnumeration(face, onComponents);\n  face.expressInterest(command, enumeration.onData, enumeration.onTimeout);\n};\n\n\n\n\n\n\n\n\n\n/**\n * Create a closure for getting the response from the name enumeration command.\n * @param {Face} face The Face object for using expressInterest.\n * @param {function} onComponents The onComponents callback given to getComponents.\n */\nNameEnumeration.Closure = function NameEnumerationClosure(face, onComponents)\n{\n  // Inherit from Closure.\n  Closure.call(this);\n\n  this.face = face;\n  this.onComponents = onComponents;\n  this.contentParts = [];\n\n  var enumeration = new NameEnumeration(face, onComponents);\n  face.expressInterest(command, enumeration.onData, enumeration.onTimeout);\n};\n\n/**\n * Parse the response from the name enumeration command and call this.onComponents.\n * @param {Data} data\n */\nNameEnumeration.prototype.processData = function(data)\n{\n  try {\n    if (!NameEnumeration.endsWithSegmentNumber(data.name))\n      // We don\'t expect a name without a segment number.  Treat it as a bad packet.\n      this.onComponents(null);\n    else {\n      var segmentNumber = DataUtils.bigEndianToUnsignedInt\n          (data.name.get(data.name.size() - 1).getValue());\n\n      // Each time we get a segment, we put it in contentParts, so its length follows the segment numbers.\n      var expectedSegmentNumber = this.contentParts.length;\n      if (segmentNumber != expectedSegmentNumber)\n        // Try again to get the expected segment.  This also includes the case where the first segment is not segment 0.\n        this.face.expressInterest\n          (data.name.getPrefix(-1).addSegment(expectedSegmentNumber), this.onData, this.onTimeout);\n      else {\n        // Save the content and check if we are finished.\n        this.contentParts.push(data.content);\n\n        if (data.signedInfo != null && data.signedInfo.finalBlockID != null) {\n          var finalSegmentNumber = DataUtils.bigEndianToUnsignedInt(data.signedInfo.finalBlockID);\n          if (segmentNumber == finalSegmentNumber) {\n            // We are finished.  Parse and return the result.\n            this.onComponents(NameEnumeration.parseComponents(Buffer.concat(this.contentParts)));\n            return;\n          }\n        }\n\n        // Fetch the next segment.\n        this.face.expressInterest\n          (data.name.getPrefix(-1).addSegment(expectedSegmentNumber + 1), this.onData, this.onTimeout);\n      }\n    }\n  } catch (ex) {\n    console.log("NameEnumeration: ignoring exception: " + ex);\n  }\n};\n\n/**\n * Just call onComponents(null).\n */\nNameEnumeration.prototype.processTimeout = function()\n{\n  try {\n    this.onComponents(null);\n  } catch (ex) {\n    console.log("NameEnumeration: ignoring exception: " + ex);\n  }\n};\n\n/**\n * Parse the content as a name enumeration response and return an array of components.  This makes a copy of the component.\n * @param {Uint8Array} content The content to parse.\n * @returns {Array<Buffer>} The array of components.\n */\nNameEnumeration.parseComponents = function(content)\n{\n  var components = [];\n  var decoder = new BinaryXMLDecoder(content);\n\n  decoder.readElementStartDTag(NDNProtocolDTags.Collection);\n\n  while (decoder.peekDTag(NDNProtocolDTags.Link)) {\n    decoder.readElementStartDTag(NDNProtocolDTags.Link);\n    decoder.readElementStartDTag(NDNProtocolDTags.Name);\n\n    components.push(new ndnbuf(decoder.readBinaryDTagElement(NDNProtocolDTags.Component)));\n\n    decoder.readElementClose();\n    decoder.readElementClose();\n  }\n\n  decoder.readElementClose();\n  return components;\n};\n\n/**\n * Check if the last component in the name is a segment number.\n * TODO: Move to Name class.\n * @param {Name} name\n * @returns {Boolean} True if the name ends with a segment number, otherwise false.\n */\nNameEnumeration.endsWithSegmentNumber = function(name) {\n  return name.components != null && name.size() >= 1 &&\n         name.get(name.size() - 1).getValue().length >= 1 &&\n         name.get(name.size() - 1).getValue()[0] == 0;\n};\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Wentao Shang\n * See COPYING for copyright and distribution information.\n */\n\n/**\n * @constructor\n */\nvar WebSocketTransport = function WebSocketTransport()\n{\n  if (!WebSocket)\n    throw new Error("WebSocket support is not available on this platform.");\n\n  this.ws = null;\n  this.connectedHost = null; // Read by Face.\n  this.connectedPort = null; // Read by Face.\n  this.elementReader = null;\n  this.defaultGetHostAndPort = Face.makeShuffledGetHostAndPort\n    (["A.ws.ndn.ucla.edu", "B.ws.ndn.ucla.edu", "C.ws.ndn.ucla.edu", "D.ws.ndn.ucla.edu",\n      "E.ws.ndn.ucla.edu"],\n     9696);\n};\n\nexports.WebSocketTransport = WebSocketTransport;\n\n/**\n * Connect to the host and port in face.  This replaces a previous connection and sets connectedHost\n *   and connectedPort.  Once connected, call onopenCallback().\n * Listen on the port to read an entire binary XML encoded element and call\n *    face.onReceivedElement(element).\n */\nWebSocketTransport.prototype.connect = function(face, onopenCallback)\n{\n  if (this.ws != null)\n    delete this.ws;\n\n  this.ws = new WebSocket(\'ws://\' + face.host + \':\' + face.port);\n  if (LOG > 0) console.log(\'ws connection created.\');\n    this.connectedHost = face.host;\n    this.connectedPort = face.port;\n\n  this.ws.binaryType = "arraybuffer";\n\n  this.elementReader = new BinaryXmlElementReader(face);\n  var self = this;\n  this.ws.onmessage = function(ev) {\n    var result = ev.data;\n    //console.log(\'RecvHandle called.\');\n\n    if (result == null || result == undefined || result == "") {\n      console.log(\'INVALID ANSWER\');\n    }\n    else if (result instanceof ArrayBuffer) {\n      var bytearray = new ndnbuf(result);\n\n      if (LOG > 3) console.log(\'BINARY RESPONSE IS \' + bytearray.toString(\'hex\'));\n\n      try {\n        // Find the end of the binary XML element and call face.onReceivedElement.\n        self.elementReader.onReceivedData(bytearray);\n      } catch (ex) {\n        console.log("NDN.ws.onmessage exception: " + ex);\n        return;\n      }\n    }\n  }\n\n  this.ws.onopen = function(ev) {\n    if (LOG > 3) console.log(ev);\n    if (LOG > 3) console.log(\'ws.onopen: WebSocket connection opened.\');\n    if (LOG > 3) console.log(\'ws.onopen: ReadyState: \' + this.readyState);\n    // Face.registerPrefix will fetch the ndndid when needed.\n\n    onopenCallback();\n  }\n\n  this.ws.onerror = function(ev) {\n    console.log(\'ws.onerror: ReadyState: \' + this.readyState);\n    console.log(ev);\n    console.log(\'ws.onerror: WebSocket error: \' + ev.data);\n  }\n\n  this.ws.onclose = function(ev) {\n    console.log(\'ws.onclose: WebSocket connection closed.\');\n    self.ws = null;\n\n    // Close Face when WebSocket is closed\n    face.readyStatus = Face.CLOSED;\n    face.onclose();\n    //console.log("NDN.onclose event fired.");\n  }\n};\n\n/**\n * Send the Uint8Array data.\n */\nWebSocketTransport.prototype.send = function(data)\n{\n  if (this.ws != null) {\n    // If we directly use data.buffer to feed ws.send(),\n    // WebSocket may end up sending a packet with 10000 bytes of data.\n    // That is, WebSocket will flush the entire ndnbuf\n    // regardless of the offset of the Uint8Array. So we have to create\n    // a new Uint8Array ndnbuf with just the right size and copy the\n    // content from binaryInterest to the new ndnbuf.\n    //    ---Wentao\n    var bytearray = new Uint8Array(data.length);\n    bytearray.set(data);\n    this.ws.send(bytearray.buffer);\n    if (LOG > 3) console.log(\'ws.send() returned.\');\n  }\n  else\n    console.log(\'WebSocket connection is not established.\');\n};\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\n// The Face constructor uses TcpTransport by default which is not available in the browser, so override to WebSocketTransport.\nTcpTransport = WebSocketTransport;\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * Provide the callback closure for the async communication methods in the Face class.\n * This is a port of Closure.py from PyNDN, written by:\n * Derek Kulinski <takeda@takeda.tk>\n * Jeff Burke <jburke@ucla.edu>\n */\n\n/**\n * A subclass of Closure is passed to expressInterest and registerPrefix.\n * @deprecated You should use the forms of expressInterest and registerPrefix which use callbacks instead of Closure.\n * @constructor\n */\nvar Closure = function Closure()\n{\n  // I don\'t think storing Face\'s closure is needed\n  // and it creates a reference loop, as of now both\n  // of those variables are never set -- Derek\n  //\n  // Use instance variables to return data to callback\n  this.ndn_data = null;  // this holds the ndn_closure\n  this.ndn_data_dirty = false;\n};\n\nexports.Closure = Closure;\n\n// Upcall result\nClosure.RESULT_ERR               = -1; // upcall detected an error\nClosure.RESULT_OK                =  0; // normal upcall return\nClosure.RESULT_REEXPRESS         =  1; // reexpress the same interest again\nClosure.RESULT_INTEREST_CONSUMED =  2; // upcall claims to consume interest\nClosure.RESULT_VERIFY            =  3; // force an unverified result to be verified\nClosure.RESULT_FETCHKEY          =  4; // get the key in the key locator and re-call the interest\n                                       //   with the key available in the local storage\n\n// Upcall kind\nClosure.UPCALL_FINAL              = 0; // handler is about to be deregistered\nClosure.UPCALL_INTEREST           = 1; // incoming interest\nClosure.UPCALL_CONSUMED_INTEREST  = 2; // incoming interest, someone has answered\nClosure.UPCALL_CONTENT            = 3; // incoming verified content\nClosure.UPCALL_INTEREST_TIMED_OUT = 4; // interest timed out\nClosure.UPCALL_CONTENT_UNVERIFIED = 5; // content that has not been verified\nClosure.UPCALL_CONTENT_BAD        = 6; // verification failed\n\n/**\n * Override this in your subclass.\n * If you\'re getting strange errors in upcall()\n * check your code whether you\'re returning a value.\n */\nClosure.prototype.upcall = function(kind, upcallInfo)\n{\n  //dump(\'upcall \' + this + " " + kind + " " + upcallInfo + "\\n");\n  return Closure.RESULT_OK;\n};\n\n/**\n * An UpcallInfo is passed to Closure.upcall.\n * @constructor\n */\nvar UpcallInfo = function UpcallInfo(face, interest, matchedComps, data)\n{\n  this.face = face;  // Face object (not used)\n  this.ndn = face;   // deprecated\n  this.interest = interest;  // Interest object\n  this.matchedComps = matchedComps;  // int\n  this.data = data;  // Data\n  this.contentObject = data; // deprecated.  Include for backward compatibility.\n};\n\nUpcallInfo.prototype.toString = function()\n{\n  var ret = "face = " + this.face;\n  ret += "\\nInterest = " + this.interest;\n  ret += "\\nmatchedComps = " + this.matchedComps;\n  ret += "\\nData: " + this.data;\n  return ret;\n};\n\nexports.UpcallInfo = UpcallInfo;\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class represents PublisherPublicKeyDigest Objects\n */\n\n\n/**\n * @constructor\n */\nvar PublisherPublicKeyDigest = function PublisherPublicKeyDigest(pkd)\n{\n this.PUBLISHER_ID_LEN = 512/8;\n this.publisherPublicKeyDigest = pkd;\n};\n\nexports.PublisherPublicKeyDigest = PublisherPublicKeyDigest;\n\nPublisherPublicKeyDigest.prototype.from_ndnb = function(decoder)\n{\n  this.publisherPublicKeyDigest = decoder.readBinaryDTagElement(this.getElementLabel());\n\n  if (LOG > 4) console.log(\'Publisher public key digest is \' + this.publisherPublicKeyDigest);\n\n  if (null == this.publisherPublicKeyDigest)\n    throw new Error("Cannot parse publisher key digest.");\n\n  //TODO check if the length of the PublisherPublicKeyDigest is correct (Security reason)\n\n  if (this.publisherPublicKeyDigest.length != this.PUBLISHER_ID_LEN) {\n    if (LOG > 0)\n      console.log(\'LENGTH OF PUBLISHER ID IS WRONG! Expected \' + this.PUBLISHER_ID_LEN + ", got " + this.publisherPublicKeyDigest.length);\n\n    //this.publisherPublicKeyDigest = new PublisherPublicKeyDigest(this.PublisherPublicKeyDigest).PublisherKeyDigest;\n  }\n};\n\nPublisherPublicKeyDigest.prototype.to_ndnb= function(encoder)\n{\n  //TODO Check that the ByteArray for the key is present\n  if (!this.validate())\n    throw new Error("Cannot encode : field values missing.");\n\n  if (LOG > 3) console.log(\'PUBLISHER KEY DIGEST IS\'+this.publisherPublicKeyDigest);\n  encoder.writeDTagElement(this.getElementLabel(), this.publisherPublicKeyDigest);\n};\n\nPublisherPublicKeyDigest.prototype.getElementLabel = function() { return NDNProtocolDTags.PublisherPublicKeyDigest; };\n\nPublisherPublicKeyDigest.prototype.validate = function()\n{\n    return null != this.publisherPublicKeyDigest;\n};\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class represents Publisher and PublisherType Objects\n */\n\n/**\n * @constructor\n */\nvar PublisherType = function PublisherType(tag)\n{\n  this.KEY = NDNProtocolDTags.PublisherPublicKeyDigest;\n  this.CERTIFICATE = NDNProtocolDTags.PublisherCertificateDigest;\n  this.ISSUER_KEY = NDNProtocolDTags.PublisherIssuerKeyDigest;\n  this.ISSUER_CERTIFICATE = NDNProtocolDTags.PublisherIssuerCertificateDigest;\n\n  this.Tag = tag;\n};\n\n/**\n * @constructor\n */\nvar PublisherID = function PublisherID()\n{\n  this.PUBLISHER_ID_DIGEST_ALGORITHM = "SHA-256";\n  this.PUBLISHER_ID_LEN = 256/8;\n\n  //TODO, implement publisherID creation and key creation\n\n  //TODO implement generatePublicKeyDigest\n  this.publisherID =null;//= generatePublicKeyDigest(key);//ByteArray\n\n  //TODO implement generate key\n  //CryptoUtil.generateKeyID(PUBLISHER_ID_DIGEST_ALGORITHM, key);\n  this.publisherType = null;//isIssuer ? PublisherType.ISSUER_KEY : PublisherType.KEY;//publisher Type\n};\n\nexports.PublisherID = PublisherID;\n\nPublisherID.prototype.from_ndnb = function(decoder)\n{\n  // We have a choice here of one of 4 binary element types.\n  var nextTag = PublisherID.peekAndGetNextDTag(decoder);\n\n  this.publisherType = new PublisherType(nextTag);\n\n  if (nextTag < 0)\n    throw new Error("Invalid publisher ID, got unexpected type");\n\n  this.publisherID = decoder.readBinaryDTagElement(nextTag);\n  if (null == this.publisherID)\n    throw new ContentDecodingException(new Error("Cannot parse publisher ID of type : " + nextTag + "."));\n};\n\nPublisherID.prototype.to_ndnb = function(encoder)\n{\n  if (!this.validate())\n    throw new Error("Cannot encode " + this.getClass().getName() + ": field values missing.");\n\n  encoder.writeDTagElement(this.getElementLabel(), this.publisherID);\n};\n\n/**\n * Peek the next DTag in the decoder and return it if it is a PublisherID DTag.\n * @param {BinaryXMLDecoder} decoder The BinaryXMLDecoder with the input to decode.\n * @returns {number} The PublisherID DTag or -1 if it is not one of them.\n */\nPublisherID.peekAndGetNextDTag = function(decoder)\n{\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherPublicKeyDigest))\n    return             NDNProtocolDTags.PublisherPublicKeyDigest;\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherCertificateDigest))\n    return             NDNProtocolDTags.PublisherCertificateDigest;\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherIssuerKeyDigest))\n    return             NDNProtocolDTags.PublisherIssuerKeyDigest;\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherIssuerCertificateDigest))\n    return             NDNProtocolDTags.PublisherIssuerCertificateDigest;\n\n  return -1;\n};\n\nPublisherID.peek = function(/* XMLDecoder */ decoder)\n{\n  return PublisherID.peekAndGetNextDTag(decoder) >= 0;\n};\n\nPublisherID.prototype.getElementLabel = function()\n{\n  return this.publisherType.Tag;\n};\n\nPublisherID.prototype.validate = function()\n{\n  return null != id() && null != type();\n};\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Meki Cheraoui, Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * This class represents a Name as an array of components where each is a byte array.\n */\n\n/**\n * Create a new Name from components.\n *\n * @constructor\n * @param {string|Name|Array<string|Array<number>|ArrayBuffer|Buffer|Name>} components if a string, parse it as a URI.  If a Name, add a deep copy of its components.\n * Otherwise it is an array of components which are appended according to Name.append, so\n * convert each and store it as an array of ndnbuf.  If a component is a string, encode as utf8.\n */\nvar Name = function Name(components)\n{\n  if (typeof components == \'string\') {\n    if (LOG > 3) console.log(\'Content Name String \' + components);\n    this.components = Name.createNameArray(components);\n  }\n  else if (typeof components === \'object\') {\n    this.components = [];\n    if (components instanceof Name)\n      this.append(components);\n    else {\n      for (var i = 0; i < components.length; ++i)\n        this.append(components[i]);\n    }\n  }\n  else if (components== null)\n    this.components =[];\n  else\n    if (LOG > 1) console.log("NO CONTENT NAME GIVEN");\n};\n\nexports.Name = Name;\n\n/**\n *\n * @constructor\n * Create a new Name.Component with a copy of the given value.\n * @param {Name.Component|String|Array<number>|ArrayBuffer|Buffer} value If the value is a string, encode it as utf8 (but don\'t unescape).\n */\nName.Component = function NameComponent(value)\n{\n  if (typeof value == \'string\')\n    this.value = DataUtils.stringToUtf8Array(value);\n  else if (typeof value == \'object\' && value instanceof Name.Component)\n    this.value = new ndnbuf(value.value);\n  else if (typeof value == \'object\' && value instanceof ndnbuf)\n    this.value = new ndnbuf(value);\n  else if (typeof value == \'object\' && typeof ArrayBuffer != \'undefined\' &&  value instanceof ArrayBuffer) {\n    // Make a copy.  Don\'t use ArrayBuffer.slice since it isn\'t always supported.\n    this.value = new ndnbuf(new ArrayBuffer(value.byteLength));\n    this.value.set(new ndnbuf(value));\n  }\n  else if (typeof value == \'object\')\n    // Assume value is a byte array.  We can\'t check instanceof Array because\n    //   this doesn\'t work in JavaScript if the array comes from a different module.\n    this.value = new ndnbuf(value);\n  else\n    throw new Error("Name.Component constructor: Invalid type");\n}\n\n/**\n * Get the component value.\n * @returns {Buffer} The component value.\n */\nName.Component.prototype.getValue = function()\n{\n  return this.value;\n}\n\n/**\n * Convert this component value to a string by escaping characters according to the NDN URI Scheme.\n * This also adds "..." to a value with zero or more ".".\n * @returns {string} The escaped string.\n */\nName.Component.prototype.toEscapedString = function()\n{\n  return Name.toEscapedString(this.value);\n}\n\n/**\n * @deprecated Use toUri.\n */\nName.prototype.getName = function()\n{\n  return this.toUri();\n};\n\n/** Parse uri as a URI and return an array of ndnbuf components.\n */\nName.createNameArray = function(uri)\n{\n  uri = uri.trim();\n  if (uri.length <= 0)\n    return [];\n\n  var iColon = uri.indexOf(\':\');\n  if (iColon >= 0) {\n    // Make sure the colon came before a \'/\'.\n    var iFirstSlash = uri.indexOf(\'/\');\n    if (iFirstSlash < 0 || iColon < iFirstSlash)\n      // Omit the leading protocol such as ndn:\n      uri = uri.substr(iColon + 1, uri.length - iColon - 1).trim();\n  }\n\n  if (uri[0] == \'/\') {\n    if (uri.length >= 2 && uri[1] == \'/\') {\n      // Strip the authority following "//".\n      var iAfterAuthority = uri.indexOf(\'/\', 2);\n      if (iAfterAuthority < 0)\n        // Unusual case: there was only an authority.\n        return [];\n      else\n        uri = uri.substr(iAfterAuthority + 1, uri.length - iAfterAuthority - 1).trim();\n    }\n    else\n      uri = uri.substr(1, uri.length - 1).trim();\n  }\n\n  var array = uri.split(\'/\');\n\n  // Unescape the components.\n  for (var i = 0; i < array.length; ++i) {\n    var value = Name.fromEscapedString(array[i]);\n\n    if (value == null) {\n      // Ignore the illegal componenent.  This also gets rid of a trailing \'/\'.\n      array.splice(i, 1);\n      --i;\n      continue;\n    }\n    else\n      array[i] = new Name.Component(value);\n  }\n\n  return array;\n};\n\nName.prototype.from_ndnb = function(/*XMLDecoder*/ decoder)\n{\n  decoder.readElementStartDTag(this.getElementLabel());\n\n  this.components = [];\n\n  while (decoder.peekDTag(NDNProtocolDTags.Component))\n    this.append(decoder.readBinaryDTagElement(NDNProtocolDTags.Component));\n\n  decoder.readElementClose();\n};\n\nName.prototype.to_ndnb = function(/*XMLEncoder*/ encoder)\n{\n  if (this.components == null)\n    throw new Error("CANNOT ENCODE EMPTY CONTENT NAME");\n\n  encoder.writeElementStartDTag(this.getElementLabel());\n  var count = this.size();\n  for (var i=0; i < count; i++)\n    encoder.writeDTagElement(NDNProtocolDTags.Component, this.components[i].getValue());\n\n  encoder.writeElementClose();\n};\n\nName.prototype.getElementLabel = function()\n{\n  return NDNProtocolDTags.Name;\n};\n\n/**\n * Convert the component to a ndnbuf and append to this Name.\n * Return this Name object to allow chaining calls to add.\n * @param {Name.Component|String|Array<number>|ArrayBuffer|Buffer|Name} component If a component is a string, encode as utf8 (but don\'t unescape).\n * @returns {Name}\n */\nName.prototype.append = function(component)\n{\n  if (typeof component == \'object\' && component instanceof Name) {\n    var components;\n    if (component == this)\n      // special case, when we need to create a copy\n      components = this.components.slice(0, this.components.length);\n    else\n      components = component.components;\n\n    for (var i = 0; i < components.length; ++i)\n      this.components.push(new Name.Component(components[i]));\n  }\n  else\n    // Just use the Name.Component constructor.\n    this.components.push(new Name.Component(component));\n\n  return this;\n};\n\n/**\n * @deprecated Use append.\n */\nName.prototype.add = function(component)\n{\n  return this.append(component);\n};\n\n/**\n * Return the escaped name string according to "NDNx URI Scheme".\n * @returns {String}\n */\nName.prototype.toUri = function()\n{\n  if (this.size() == 0)\n    return "/";\n\n  var result = "";\n\n  for (var i = 0; i < this.size(); ++i)\n    result += "/"+ Name.toEscapedString(this.components[i].getValue());\n\n  return result;\n};\n\n/**\n * @deprecated Use toUri.\n */\nName.prototype.to_uri = function()\n{\n  return this.toUri();\n};\n\n/**\n * Append a component that represents a segment number\n *\n * This component has a special format handling:\n * - if number is zero, then %00 is added\n * - if number is between 1 and 255, %00%01 .. %00%FF is added\n * - ...\n * @param {number} number the segment number (integer is expected)\n * @returns {Name}\n */\nName.prototype.appendSegment = function(number)\n{\n  var segmentNumberBigEndian = DataUtils.nonNegativeIntToBigEndian(number);\n  // Put a 0 byte in front.\n  var segmentNumberComponent = new ndnbuf(segmentNumberBigEndian.length + 1);\n  segmentNumberComponent[0] = 0;\n  segmentNumberBigEndian.copy(segmentNumberComponent, 1);\n\n  this.components.push(new Name.Component(segmentNumberComponent));\n  return this;\n};\n\n/**\n * @deprecated Use appendSegment.\n */\nName.prototype.addSegment = function(number)\n{\n  return this.appendSegment(number);\n};\n\n/**\n * Get a new name, constructed as a subset of components.\n * @param {number} iStartComponent The index if the first component to get.\n * @param {number} (optional) nComponents The number of components starting at iStartComponent.  If omitted,\n * return components starting at iStartComponent until the end of the name.\n * @returns {Name} A new name.\n */\nName.prototype.getSubName = function(iStartComponent, nComponents)\n{\n  if (nComponents == undefined)\n    nComponents = this.components.length - iStartComponent;\n\n  var result = new Name();\n\n  var iEnd = iStartComponent + nComponents;\n  for (var i = iStartComponent; i < iEnd && i < this.components.length; ++i)\n    result.components.push(this.components[i]);\n\n  return result;\n};\n\n/**\n * Return a new Name with the first nComponents components of this Name.\n * @param {number} nComponents The number of prefix components.  If nComponents is -N then return the prefix up\n * to name.size() - N. For example getPrefix(-1) returns the name without the final component.\n * @returns {Name} A new name.\n */\nName.prototype.getPrefix = function(nComponents)\n{\n  if (nComponents < 0)\n    return this.getSubName(0, this.components.length + nComponents);\n  else\n    return this.getSubName(0, nComponents);\n};\n\n/**\n * @brief Get prefix of the name, containing less minusComponents right components\n * @param minusComponents number of components to cut from the back\n */\nName.prototype.cut = function(minusComponents)\n{\n  return new Name(this.components.slice(0, this.components.length - minusComponents));\n};\n\n/**\n * Return the number of name components.\n * @returns {number}\n */\nName.prototype.size = function()\n{\n  return this.components.length;\n};\n\n/**\n * Return a new Name.Component of the component at the given index.  To get just the component value, use get(i).getValue().\n * @param {Number} i The index of the component, starting from 0.  However, if i is negative, return the component\n * at size() - (-i).\n * @returns {Name.Component}\n */\nName.prototype.get = function(i)\n{\n  if (i >= 0) {\n    if (i >= this.components.length)\n      throw new Error("Name.get: Index is out of bounds");\n\n    return new Name.Component(this.components[i]);\n  }\n  else {\n    // Negative index.\n    if (i < -this.components.length)\n      throw new Error("Name.get: Index is out of bounds");\n\n    return new Name.Component(this.components[this.components.length - (-i)]);\n  }\n};\n\n/**\n * @deprecated Use size().\n */\nName.prototype.getComponentCount = function()\n{\n  return this.components.length;\n};\n\n/**\n * @deprecated To get just the component value, use get(i).getValue().\n */\nName.prototype.getComponent = function(i)\n{\n  return new ndnbuf(this.components[i].getValue());\n};\n\n/**\n * The "file name" in a name is the last component that isn\'t blank and doesn\'t start with one of the\n *   special marker octets (for version, etc.).  Return the index in this.components of\n *   the file name, or -1 if not found.\n */\nName.prototype.indexOfFileName = function()\n{\n  for (var i = this.size() - 1; i >= 0; --i) {\n    var component = this.components[i].getValue();\n    if (component.length <= 0)\n      continue;\n\n    if (component[0] == 0 || component[0] == 0xC0 || component[0] == 0xC1 ||\n        (component[0] >= 0xF5 && component[0] <= 0xFF))\n      continue;\n\n    return i;\n  }\n\n  return -1;\n};\n\n/**\n * Return true if this Name has the same components as name.\n */\nName.prototype.equals = function(name)\n{\n  if (this.components.length != name.components.length)\n    return false;\n\n  // Start from the last component because they are more likely to differ.\n  for (var i = this.components.length - 1; i >= 0; --i) {\n    if (!DataUtils.arraysEqual(this.components[i].getValue(), name.components[i].getValue()))\n      return false;\n  }\n\n  return true;\n};\n\n/**\n * @deprecated Use equals.\n */\nName.prototype.equalsName = function(name)\n{\n  return this.equals(name);\n};\n\n/**\n * Find the last component in name that has a ContentDigest and return the digest value as ndnbuf,\n *   or null if not found.  See Name.getComponentContentDigestValue.\n */\nName.prototype.getContentDigestValue = function()\n{\n  for (var i = this.size() - 1; i >= 0; --i) {\n    var digestValue = Name.getComponentContentDigestValue(this.components[i]);\n    if (digestValue != null)\n      return digestValue;\n  }\n\n  return null;\n};\n\n/**\n * If component is a ContentDigest, return the digest value as a ndnbuf slice (don\'t modify!).\n * If not a ContentDigest, return null.\n * A ContentDigest component is Name.ContentDigestPrefix + 32 bytes + Name.ContentDigestSuffix.\n */\nName.getComponentContentDigestValue = function(component)\n{\n  if (typeof component == \'object\' && component instanceof Name.Component)\n    component = component.getValue();\n\n  var digestComponentLength = Name.ContentDigestPrefix.length + 32 + Name.ContentDigestSuffix.length;\n  // Check for the correct length and equal ContentDigestPrefix and ContentDigestSuffix.\n  if (component.length == digestComponentLength &&\n      DataUtils.arraysEqual(component.slice(0, Name.ContentDigestPrefix.length),\n                            Name.ContentDigestPrefix) &&\n      DataUtils.arraysEqual(component.slice\n         (component.length - Name.ContentDigestSuffix.length, component.length),\n                            Name.ContentDigestSuffix))\n   return component.slice(Name.ContentDigestPrefix.length, Name.ContentDigestPrefix.length + 32);\n else\n   return null;\n};\n\n// Meta GUID "%C1.M.G%C1" + ContentDigest with a 32 byte BLOB.\nName.ContentDigestPrefix = new ndnbuf([0xc1, 0x2e, 0x4d, 0x2e, 0x47, 0xc1, 0x01, 0xaa, 0x02, 0x85]);\nName.ContentDigestSuffix = new ndnbuf([0x00]);\n\n\n/**\n * Return value as an escaped string according to "NDNx URI Scheme".\n * We can\'t use encodeURIComponent because that doesn\'t encode all the characters we want to.\n * @param {Buffer|Name.Component} component The value or Name.Component to escape.\n * @returns {string} The escaped string.\n */\nName.toEscapedString = function(value)\n{\n  if (typeof value == \'object\' && value instanceof Name.Component)\n    value = value.getValue();\n\n  var result = "";\n  var gotNonDot = false;\n  for (var i = 0; i < value.length; ++i) {\n    if (value[i] != 0x2e) {\n      gotNonDot = true;\n      break;\n    }\n  }\n  if (!gotNonDot) {\n    // Special case for component of zero or more periods.  Add 3 periods.\n    result = "...";\n    for (var i = 0; i < value.length; ++i)\n      result += ".";\n  }\n  else {\n    for (var i = 0; i < value.length; ++i) {\n      var x = value[i];\n      // Check for 0-9, A-Z, a-z, (+), (-), (.), (_)\n      if (x >= 0x30 && x <= 0x39 || x >= 0x41 && x <= 0x5a ||\n          x >= 0x61 && x <= 0x7a || x == 0x2b || x == 0x2d ||\n          x == 0x2e || x == 0x5f)\n        result += String.fromCharCode(x);\n      else\n        result += "%" + (x < 16 ? "0" : "") + x.toString(16).toUpperCase();\n    }\n  }\n  return result;\n};\n\n/**\n * Return a ndnbuf byte array by decoding the escapedString according to "NDNx URI Scheme".\n * If escapedString is "", "." or ".." then return null, which means to skip the component in the name.\n * @param {string} escapedString The escaped string to decode.\n * @returns {Buffer} The byte array, or null which means to skip the component in the name.\n */\nName.fromEscapedString = function(escapedString)\n{\n  var value = unescape(escapedString.trim());\n\n  if (value.match(/[^.]/) == null) {\n    // Special case for value of only periods.\n    if (value.length <= 2)\n      // Zero, one or two periods is illegal.  Ignore this componenent to be\n      //   consistent with the C implementation.\n      return null;\n    else\n      // Remove 3 periods.\n      return DataUtils.toNumbersFromString(value.substr(3, value.length - 3));\n  }\n  else\n    return DataUtils.toNumbersFromString(value);\n};\n\n/**\n * Return true if the N components of this name are the same as the first N components of the given name.\n * @param {Name} name The name to check.\n * @returns {Boolean} true if this matches the given name.  This always returns true if this name is empty.\n */\nName.prototype.match = function(name)\n{\n  var i_name = this.components;\n  var o_name = name.components;\n\n  // This name is longer than the name we are checking it against.\n  if (i_name.length > o_name.length)\n    return false;\n\n  // Check if at least one of given components doesn\'t match.\n  for (var i = 0; i < i_name.length; ++i) {\n    if (!DataUtils.arraysEqual(i_name[i].getValue(), o_name[i].getValue()))\n      return false;\n  }\n\n  return true;\n};\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n */\n\n\n/**\n * @constructor\n */\nvar KeyManager = function KeyManager()\n{\n  this.certificate =\n  "MIIBmzCCAQQCCQC32FyQa61S7jANBgkqhkiG9w0BAQUFADASMRAwDgYDVQQDEwd" +\n  "heGVsY2R2MB4XDTEyMDQyODIzNDQzN1oXDTEyMDUyODIzNDQzN1owEjEQMA4GA1" +\n  "UEAxMHYXhlbGNkdjCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA4X0wp9goq" +\n  "xuECxdULcr2IHr9Ih4Iaypg0Wy39URIup8/CLzQmdsh3RYqd55hqonu5VTTpH3i" +\n  "MLx6xZDVJAZ8OJi7pvXcQ2C4Re2kjL2c8SanI0RfDhlS1zJadfr1VhRPmpivcYa" +\n  "wJ4aFuOLAi+qHFxtN7lhcGCgpW1OV60oXd58CAwEAATANBgkqhkiG9w0BAQUFAA" +\n  "OBgQDLOrA1fXzSrpftUB5Ro6DigX1Bjkf7F5Bkd69hSVp+jYeJFBBlsILQAfSxU" +\n  "ZPQtD+2Yc3iCmSYNyxqu9PcufDRJlnvB7PG29+L3y9lR37tetzUV9eTscJ7rdp8" +\n  "Wt6AzpW32IJ/54yKNfP7S6ZIoIG+LP6EIxq6s8K1MXRt8uBJKw==";\n\n  // Public Key\n    this.publicKey =\n  "-----BEGIN PUBLIC KEY-----\\n" +\n  "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDhfTCn2CirG4QLF1QtyvYgev0i\\n" +\n  "HghrKmDRbLf1REi6nz8IvNCZ2yHdFip3nmGqie7lVNOkfeIwvHrFkNUkBnw4mLum\\n" +\n  "9dxDYLhF7aSMvZzxJqcjRF8OGVLXMlp1+vVWFE+amK9xhrAnhoW44sCL6ocXG03u\\n" +\n  "WFwYKClbU5XrShd3nwIDAQAB\\n" +\n  "-----END PUBLIC KEY-----";\n  // Private Key\n    this.privateKey =\n  "-----BEGIN RSA PRIVATE KEY-----\\n" +\n  "MIICXQIBAAKBgQDhfTCn2CirG4QLF1QtyvYgev0iHghrKmDRbLf1REi6nz8IvNCZ\\n" +\n  "2yHdFip3nmGqie7lVNOkfeIwvHrFkNUkBnw4mLum9dxDYLhF7aSMvZzxJqcjRF8O\\n" +\n  "GVLXMlp1+vVWFE+amK9xhrAnhoW44sCL6ocXG03uWFwYKClbU5XrShd3nwIDAQAB\\n" +\n  "AoGAGkv6T6jC3WmhFZYL6CdCWvlc6gysmKrhjarrLTxgavtFY6R5g2ft5BXAsCCV\\n" +\n  "bUkWxkIFSKqxpVNl0gKZCNGEzPDN6mHJOQI/h0rlxNIHAuGfoAbCzALnqmyZivhJ\\n" +\n  "APGijAyKuU9tczsst5+Kpn+bn7ehzHQuj7iwJonS5WbojqECQQD851K8TpW2GrRi\\n" +\n  "zNgG4dx6orZxAaon/Jnl8lS7soXhllQty7qG+oDfzznmdMsiznCqEABzHUUKOVGE\\n" +\n  "9RWPN3aRAkEA5D/w9N55d0ibnChFJlc8cUAoaqH+w+U3oQP2Lb6AZHJpLptN4y4b\\n" +\n  "/uf5d4wYU5/i/gC7SSBH3wFhh9bjRLUDLwJAVOx8vN0Kqt7myfKNbCo19jxjVSlA\\n" +\n  "8TKCn1Oznl/BU1I+rC4oUaEW25DjmX6IpAR8kq7S59ThVSCQPjxqY/A08QJBAIRa\\n" +\n  "F2zGPITQk3r/VumemCvLWiRK/yG0noc9dtibqHOWbCtcXtOm/xDWjq+lis2i3ssO\\n" +\n  "vYrvrv0/HcDY+Dv1An0CQQCLJtMsfSg4kvG/FRY5UMhtMuwo8ovYcMXt4Xv/LWaM\\n" +\n  "hndD67b2UGawQCRqr5ghRTABWdDD/HuuMBjrkPsX0861\\n" +\n  "-----END RSA PRIVATE KEY-----";\n\n  this.key = null;\n};\n\n/**\n * Return a Key object for the keys in this KeyManager.  This creates the Key on the first\n * call and returns a cached copy after that.\n * @returns {Key}\n */\nKeyManager.prototype.getKey = function()\n{\n  if (this.key === null) {\n    this.key = new Key();\n    this.key.fromPemString(this.publicKey, this.privateKey);\n  }\n\n  return this.key;\n}\n\nvar globalKeyManager = globalKeyManager || new KeyManager();\nndn.globalKeyManager = globalKeyManager\nexports.globalKeyManager = globalKeyManager;\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class represents Data Objects\n */\n\n\n/**\n * Create a new Data with the optional values.\n *\n * @constructor\n * @param {Name} name\n * @param {SignedInfo} signedInfo\n * @param {Buffer} content\n */\nvar Data = function Data(name, signedInfo, content)\n{\n  if (typeof name == \'string\')\n    this.name = new Name(name);\n  else\n    //TODO Check the class of name\n    this.name = name;\n\n  this.signedInfo = signedInfo;\n\n  if (typeof content == \'string\')\n    this.content = DataUtils.toNumbersFromString(content);\n  else\n    this.content = content;\n\n  this.signature = new Signature();\n\n  this.startSIG = null;\n  this.endSIG = null;\n\n  this.endContent = null;\n\n  this.rawSignatureData = null;\n};\n\nexports.Data = Data;\n\nData.prototype.sign = function()\n{\n  var n1 = this.encodeObject(this.name);\n  var n2 = this.encodeObject(this.signedInfo);\n  var n3 = this.encodeContent();\n\n  var rsa = ndn.createSign(\'RSA-SHA256\');\n  rsa.update(n1);\n  rsa.update(n2);\n  rsa.update(n3);\n\n  var sig = new ndnbuf(rsa.sign(ndn.globalKeyManager.privateKey));\n\n  this.signature.signature = sig;\n};\n\nData.prototype.verify = function(/*Key*/ key)\n{\n  if (key == null || key.publicKeyPem == null)\n    throw new Error(\'Cannot verify Data without a public key.\');\n\n  var verifier = ndn.createVerify(\'RSA-SHA256\');\n  verifier.update(this.rawSignatureData);\n  return verifier.verify(key.publicKeyPem, this.signature.signature);\n};\n\nData.prototype.encodeObject = function encodeObject(obj)\n{\n  var enc = new BinaryXMLEncoder();\n  obj.to_ndnb(enc);\n  var num = enc.getReducedOstream();\n\n  return num;\n};\n\nData.prototype.encodeContent = function encodeContent()\n{\n  var enc = new BinaryXMLEncoder();\n  enc.writeDTagElement(NDNProtocolDTags.Content, this.content);\n  var num = enc.getReducedOstream();\n\n  return num;\n};\n\nData.prototype.saveRawData = function(bytes)\n{\n  var sigBits = bytes.slice(this.startSIG, this.endSIG);\n  this.rawSignatureData = new ndnbuf(sigBits);\n};\n\nData.prototype.getElementLabel = function() { return NDNProtocolDTags.Data; };\n\n/**\n * Create a new Signature with the optional values.\n * @constructor\n */\nvar Signature = function Signature(witness, signature, digestAlgorithm)\n{\n  this.witness = witness;\n  this.signature = signature;\n  this.digestAlgorithm = digestAlgorithm\n};\n\nexports.Signature = Signature;\n\nSignature.prototype.from_ndnb = function(decoder)\n{\n  decoder.readElementStartDTag(this.getElementLabel());\n\n  if (LOG > 4) console.log(\'STARTED DECODING SIGNATURE\');\n\n  if (decoder.peekDTag(NDNProtocolDTags.DigestAlgorithm)) {\n    if (LOG > 4) console.log(\'DIGIEST ALGORITHM FOUND\');\n    this.digestAlgorithm = decoder.readUTF8DTagElement(NDNProtocolDTags.DigestAlgorithm);\n  }\n  if (decoder.peekDTag(NDNProtocolDTags.Witness)) {\n    if (LOG > 4) console.log(\'WITNESS FOUND\');\n    this.witness = decoder.readBinaryDTagElement(NDNProtocolDTags.Witness);\n  }\n\n  //FORCE TO READ A SIGNATURE\n\n  if (LOG > 4) console.log(\'SIGNATURE FOUND\');\n  this.signature = decoder.readBinaryDTagElement(NDNProtocolDTags.SignatureBits);\n\n  decoder.readElementClose();\n};\n\nSignature.prototype.to_ndnb = function(encoder)\n{\n  if (!this.validate())\n    throw new Error("Cannot encode: field values missing.");\n\n  encoder.writeElementStartDTag(this.getElementLabel());\n\n  if (null != this.digestAlgorithm && !this.digestAlgorithm.equals(NDNDigestHelper.DEFAULT_DIGEST_ALGORITHM))\n    encoder.writeDTagElement(NDNProtocolDTags.DigestAlgorithm, OIDLookup.getDigestOID(this.DigestAlgorithm));\n\n  if (null != this.witness)\n    // needs to handle null witness\n    encoder.writeDTagElement(NDNProtocolDTags.Witness, this.witness);\n\n  encoder.writeDTagElement(NDNProtocolDTags.SignatureBits, this.signature);\n\n  encoder.writeElementClose();\n};\n\nSignature.prototype.getElementLabel = function() { return NDNProtocolDTags.Signature; };\n\nSignature.prototype.validate = function()\n{\n  return null != this.signature;\n};\n\nvar ContentType = {DATA:0, ENCR:1, GONE:2, KEY:3, LINK:4, NACK:5};\nvar ContentTypeValue = {0:0x0C04C0, 1:0x10D091,2:0x18E344,3:0x28463F,4:0x2C834A,5:0x34008A};\nvar ContentTypeValueReverse = {0x0C04C0:0, 0x10D091:1,0x18E344:2,0x28463F:3,0x2C834A:4,0x34008A:5};\n\nexports.ContentType = ContentType;\n\n/**\n * Create a new SignedInfo with the optional values.\n * @constructor\n */\nvar SignedInfo = function SignedInfo(publisher, timestamp, type, locator, freshnessSeconds, finalBlockID)\n{\n  this.publisher = publisher; //publisherPublicKeyDigest\n  this.timestamp=timestamp; // NDN Time\n  this.type=type; // ContentType\n  this.locator =locator;//KeyLocator\n  this.freshnessSeconds =freshnessSeconds; // Integer\n  this.finalBlockID=finalBlockID; //byte array\n\n  this.setFields();\n};\n\nexports.SignedInfo = SignedInfo;\n\nSignedInfo.prototype.setFields = function()\n{\n  var key = ndn.globalKeyManager.getKey();\n  this.publisher = new PublisherPublicKeyDigest(key.getKeyID());\n\n  var d = new Date();\n\n  var time = d.getTime();\n\n  this.timestamp = new NDNTime(time);\n\n  if (LOG > 4) console.log(\'TIME msec is\');\n\n  if (LOG > 4) console.log(this.timestamp.msec);\n\n  //DATA\n  this.type = 0;//0x0C04C0;//ContentTypeValue[ContentType.DATA];\n\n  if (LOG > 4) console.log(\'PUBLIC KEY TO WRITE TO DATA PACKET IS \');\n  if (LOG > 4) console.log(key.publicToDER().toString(\'hex\'));\n\n  this.locator = new KeyLocator(key.publicToDER(), KeyLocatorType.KEY);\n  //this.locator = new KeyLocator(DataUtils.toNumbersFromString(stringCertificate)  ,KeyLocatorType.CERTIFICATE);\n};\n\nSignedInfo.prototype.from_ndnb = function(decoder)\n{\n  decoder.readElementStartDTag(this.getElementLabel());\n\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherPublicKeyDigest)) {\n    if (LOG > 4) console.log(\'DECODING PUBLISHER KEY\');\n    this.publisher = new PublisherPublicKeyDigest();\n    this.publisher.from_ndnb(decoder);\n  }\n\n  if (decoder.peekDTag(NDNProtocolDTags.Timestamp)) {\n    if (LOG > 4) console.log(\'DECODING TIMESTAMP\');\n    this.timestamp = decoder.readDateTimeDTagElement(NDNProtocolDTags.Timestamp);\n  }\n\n  if (decoder.peekDTag(NDNProtocolDTags.Type)) {\n    var binType = decoder.readBinaryDTagElement(NDNProtocolDTags.Type);\n\n    if (LOG > 4) console.log(\'Binary Type of of Signed Info is \'+binType);\n\n    this.type = binType;\n\n    //TODO Implement type of Key Reading\n    if (null == this.type)\n      throw new Error("Cannot parse signedInfo type: bytes.");\n  }\n  else\n    this.type = ContentType.DATA; // default\n\n  if (decoder.peekDTag(NDNProtocolDTags.FreshnessSeconds)) {\n    this.freshnessSeconds = decoder.readIntegerDTagElement(NDNProtocolDTags.FreshnessSeconds);\n    if (LOG > 4) console.log(\'FRESHNESS IN SECONDS IS \'+ this.freshnessSeconds);\n  }\n\n  if (decoder.peekDTag(NDNProtocolDTags.FinalBlockID)) {\n    if (LOG > 4) console.log(\'DECODING FINAL BLOCKID\');\n    this.finalBlockID = decoder.readBinaryDTagElement(NDNProtocolDTags.FinalBlockID);\n  }\n\n  if (decoder.peekDTag(NDNProtocolDTags.KeyLocator)) {\n    if (LOG > 4) console.log(\'DECODING KEY LOCATOR\');\n    this.locator = new KeyLocator();\n    this.locator.from_ndnb(decoder);\n  }\n\n  decoder.readElementClose();\n};\n\nSignedInfo.prototype.to_ndnb = function(encoder)  {\n  if (!this.validate())\n    throw new Error("Cannot encode : field values missing.");\n\n  encoder.writeElementStartDTag(this.getElementLabel());\n\n  if (null != this.publisher) {\n    if (LOG > 3) console.log(\'ENCODING PUBLISHER KEY\' + this.publisher.publisherPublicKeyDigest);\n    this.publisher.to_ndnb(encoder);\n  }\n\n  if (null != this.timestamp)\n    encoder.writeDateTimeDTagElement(NDNProtocolDTags.Timestamp, this.timestamp);\n\n  if (null != this.type && this.type != 0)\n    encoder.writeDTagElement(NDNProtocolDTags.type, this.type);\n\n  if (null != this.freshnessSeconds)\n    encoder.writeDTagElement(NDNProtocolDTags.FreshnessSeconds, this.freshnessSeconds);\n\n  if (null != this.finalBlockID)\n    encoder.writeDTagElement(NDNProtocolDTags.FinalBlockID, this.finalBlockID);\n\n  if (null != this.locator)\n    this.locator.to_ndnb(encoder);\n\n  encoder.writeElementClose();\n};\n\nSignedInfo.prototype.valueToType = function()\n{\n  return null;\n};\n\nSignedInfo.prototype.getElementLabel = function() {\n  return NDNProtocolDTags.SignedInfo;\n};\n\nSignedInfo.prototype.validate = function()\n{\n  // We don\'t do partial matches any more, even though encoder/decoder\n  // is still pretty generous.\n  if (null ==this.publisher || null==this.timestamp ||null== this.locator)\n    return false;\n  return true;\n};\n\n/**\n * @deprecated Use BinaryXmlWireFormat.decodeData.\n */\nData.prototype.from_ndnb = function(/*XMLDecoder*/ decoder)\n{\n  BinaryXmlWireFormat.decodeData(this, decoder);\n};\n\n/**\n * @deprecated Use BinaryXmlWireFormat.encodeData.\n */\nData.prototype.to_ndnb = function(/*XMLEncoder*/ encoder)\n{\n  BinaryXmlWireFormat.encodeData(this, encoder);\n};\n\n/**\n * Encode this Data for a particular wire format.\n * @param {WireFormat} wireFormat if null, use BinaryXmlWireFormat.\n * @returns {Buffer}\n */\nData.prototype.encode = function(wireFormat)\n{\n  wireFormat = (wireFormat || BinaryXmlWireFormat.instance);\n  return wireFormat.encodeData(this);\n};\n\n/**\n * Decode the input using a particular wire format and update this Data.\n * @param {Buffer} input\n * @param {WireFormat} wireFormat if null, use BinaryXmlWireFormat.\n */\nData.prototype.decode = function(input, wireFormat)\n{\n  wireFormat = (wireFormat || BinaryXmlWireFormat.instance);\n  wireFormat.decodeData(this, input);\n};\n\n/**\n * @deprecated Use new Data.\n */\nvar ContentObject = function ContentObject(name, signedInfo, content)\n{\n  // Call the base constructor.\n  Data.call(this, name, signedInfo, content);\n}\n\nContentObject.prototype = new Data();\n\nexports.ContentObject = ContentObject;\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class represents Interest Objects\n */\n\n\n/**\n * Create a new Interest with the optional values.\n *\n * @constructor\n * @param {Name|Interest} nameOrInterest If this is an Interest, copy values from the interest and ignore the\n * other arguments.  Otherwise this is the optional name for the new Interest.\n * @param {number} minSuffixComponents\n * @param {number} maxSuffixComponents\n * @param {Buffer} publisherPublicKeyDigest\n * @param {Exclude} exclude\n * @param {number} childSelector\n * @param {number} answerOriginKind\n * @param {number} scope\n * @param {number} interestLifetimeMilliseconds in milliseconds\n * @param {Buffer} nonce\n */\nvar Interest = function Interest\n   (nameOrInterest, minSuffixComponents, maxSuffixComponents, publisherPublicKeyDigest, exclude,\n    childSelector, answerOriginKind, scope, interestLifetimeMilliseconds, nonce)\n{\n  if (typeof nameOrInterest == \'object\' && nameOrInterest instanceof Interest) {\n    // Special case: this is a copy constructor.  Ignore all but the first argument.\n    var interest = nameOrInterest;\n    if (interest.name)\n      // Copy the name.\n      this.name = new Name(interest.name);\n    this.maxSuffixComponents = interest.maxSuffixComponents;\n    this.minSuffixComponents = interest.minSuffixComponents;\n\n    this.publisherPublicKeyDigest = interest.publisherPublicKeyDigest;\n    this.exclude = interest.exclude;\n    this.childSelector = interest.childSelector;\n    this.answerOriginKind = interest.answerOriginKind;\n    this.scope = interest.scope;\n    this.interestLifetime = interest.interestLifetime;\n    if (interest.nonce)\n      // Copy.\n      this.nonce = new ndnbuf(interest.nonce);\n  }\n  else {\n    this.name = nameOrInterest;\n    this.maxSuffixComponents = maxSuffixComponents;\n    this.minSuffixComponents = minSuffixComponents;\n\n    this.publisherPublicKeyDigest = publisherPublicKeyDigest;\n    this.exclude = exclude;\n    this.childSelector = childSelector;\n    this.answerOriginKind = answerOriginKind;\n    this.scope = scope;\n    this.interestLifetime = interestLifetimeMilliseconds;\n    if (nonce)\n      // Copy and make sure it is a ndnbuf.\n      this.nonce = new ndnbuf(nonce);\n  }\n};\n\nexports.Interest = Interest;\n\nInterest.RECURSIVE_POSTFIX = "*";\n\nInterest.CHILD_SELECTOR_LEFT = 0;\nInterest.CHILD_SELECTOR_RIGHT = 1;\n\nInterest.ANSWER_NO_CONTENT_STORE = 0;\nInterest.ANSWER_CONTENT_STORE = 1;\nInterest.ANSWER_GENERATED = 2;\nInterest.ANSWER_STALE = 4;    // Stale answer OK\nInterest.MARK_STALE = 16;    // Must have scope 0.  Michael calls this a "hack"\n\nInterest.DEFAULT_ANSWER_ORIGIN_KIND = Interest.ANSWER_CONTENT_STORE | Interest.ANSWER_GENERATED;\n\n/**\n * Return true if this.name.match(name) and the name conforms to the interest selectors.\n * @param {Name} name\n * @returns {boolean}\n */\nInterest.prototype.matchesName = function(/*Name*/ name)\n{\n  if (!this.name.match(name))\n    return false;\n\n  if (this.minSuffixComponents != null &&\n      // Add 1 for the implicit digest.\n      !(name.size() + 1 - this.name.size() >= this.minSuffixComponents))\n    return false;\n  if (this.maxSuffixComponents != null &&\n      // Add 1 for the implicit digest.\n      !(name.size() + 1 - this.name.size() <= this.maxSuffixComponents))\n    return false;\n  if (this.exclude != null && name.size() > this.name.size() &&\n      this.exclude.matches(name.components[this.name.size()]))\n    return false;\n\n  return true;\n};\n\n/**\n * @deprecated Use matchesName.\n */\nInterest.prototype.matches_name = function(/*Name*/ name)\n{\n  return this.matchesName(name);\n};\n\n/**\n * Return a new Interest with the same fields as this Interest.\n * Note: This does NOT make a deep clone of the name, exclue or other objects.\n */\nInterest.prototype.clone = function()\n{\n  return new Interest\n     (this.name, this.minSuffixComponents, this.maxSuffixComponents,\n      this.publisherPublicKeyDigest, this.exclude, this.childSelector, this.answerOriginKind,\n      this.scope, this.interestLifetime, this.nonce);\n};\n\nInterest.prototype.setMinSuffixComponents = function(value)\n{\n  this.minSuffixComponents = value;\n}\n\nInterest.prototype.setMaxSuffixComponents = function(value)\n{\n  this.maxSuffixComponents = value;\n}\n\nInterest.prototype.setChildSelector = function(value)\n{\n  this.childSelector = value;\n}\n\nInterest.prototype.setAnswerOriginKind = function(value)\n{\n  this.answerOriginKind = value;\n}\n\nInterest.prototype.setScope = function(value)\n{\n  this.scope = value;\n}\n\nInterest.prototype.setInterestLifetimeMilliseconds = function(value)\n{\n  this.interestLifetime = value;\n}\n\nInterest.prototype.setNonce = function(value)\n{\n  if (value)\n    // Copy and make sure it is a ndnbuf.\n    this.nonce = new ndnbuf(value);\n  else\n    this.nonce = null;\n}\n\n/**\n * Create a new Exclude.\n * @constructor\n * @param {Array<Name.Component|Buffer|Exclude.ANY>} values (optional) An array where each element is either a Name.Component, ndnbuf component or Exclude.ANY.\n */\nvar Exclude = function Exclude(values)\n{\n  this.values = [];\n\n  if (values) {\n    for (var i = 0; i < values.length; ++i) {\n      if (values[i] == Exclude.ANY)\n        this.appendAny();\n      else\n        this.appendComponent(values[i]);\n    }\n  }\n};\n\nexports.Exclude = Exclude;\n\nExclude.ANY = "*";\n\n/**\n * Append an Exclude.ANY element.\n * @returns This Exclude so that you can chain calls to append.\n */\nExclude.prototype.appendAny = function()\n{\n  this.values.push(Exclude.ANY);\n  return this;\n}\n\n/**\n * Append a component entry, copying from component.\n * @param {Name.Component|Buffer} component\n * @returns This Exclude so that you can chain calls to append.\n */\nExclude.prototype.appendComponent = function(component)\n{\n  this.values.push(new Name.Component(component));\n  return this;\n}\n\nExclude.prototype.from_ndnb = function(/*XMLDecoder*/ decoder)\n{\n  decoder.readElementStartDTag(NDNProtocolDTags.Exclude);\n\n  while (true) {\n    if (decoder.peekDTag(NDNProtocolDTags.Component))\n      this.appendComponent(decoder.readBinaryDTagElement(NDNProtocolDTags.Component));\n    else if (decoder.peekDTag(NDNProtocolDTags.Any)) {\n      decoder.readElementStartDTag(NDNProtocolDTags.Any);\n      decoder.readElementClose();\n      this.appendAny();\n    }\n    else if (decoder.peekDTag(NDNProtocolDTags.Bloom)) {\n      // Skip the Bloom and treat it as Any.\n      decoder.readBinaryDTagElement(NDNProtocolDTags.Bloom);\n      this.appendAny();\n    }\n    else\n      break;\n  }\n\n  decoder.readElementClose();\n};\n\nExclude.prototype.to_ndnb = function(/*XMLEncoder*/ encoder)\n{\n  if (this.values == null || this.values.length == 0)\n    return;\n\n  encoder.writeElementStartDTag(NDNProtocolDTags.Exclude);\n\n  // TODO: Do we want to order the components (except for ANY)?\n  for (var i = 0; i < this.values.length; ++i) {\n    if (this.values[i] == Exclude.ANY) {\n      encoder.writeElementStartDTag(NDNProtocolDTags.Any);\n      encoder.writeElementClose();\n    }\n    else\n      encoder.writeDTagElement(NDNProtocolDTags.Component, this.values[i].getValue());\n  }\n\n  encoder.writeElementClose();\n};\n\n/**\n * Return a string with elements separated by "," and Exclude.ANY shown as "*".\n */\nExclude.prototype.toUri = function()\n{\n  if (this.values == null || this.values.length == 0)\n    return "";\n\n  var result = "";\n  for (var i = 0; i < this.values.length; ++i) {\n    if (i > 0)\n      result += ",";\n\n    if (this.values[i] == Exclude.ANY)\n      result += "*";\n    else\n      result += Name.toEscapedString(this.values[i].getValue());\n  }\n  return result;\n};\n\n/**\n * Return true if the component matches any of the exclude criteria.\n */\nExclude.prototype.matches = function(/*Buffer*/ component)\n{\n  if (typeof component == \'object\' && component instanceof Name.Component)\n    component = component.getValue();\n\n  for (var i = 0; i < this.values.length; ++i) {\n    if (this.values[i] == Exclude.ANY) {\n      var lowerBound = null;\n      if (i > 0)\n        lowerBound = this.values[i - 1];\n\n      // Find the upper bound, possibly skipping over multiple ANY in a row.\n      var iUpperBound;\n      var upperBound = null;\n      for (iUpperBound = i + 1; iUpperBound < this.values.length; ++iUpperBound) {\n        if (this.values[iUpperBound] != Exclude.ANY) {\n          upperBound = this.values[iUpperBound];\n          break;\n        }\n      }\n\n      // If lowerBound != null, we already checked component equals lowerBound on the last pass.\n      // If upperBound != null, we will check component equals upperBound on the next pass.\n      if (upperBound != null) {\n        if (lowerBound != null) {\n          if (Exclude.compareComponents(component, lowerBound) > 0 &&\n              Exclude.compareComponents(component, upperBound) < 0)\n            return true;\n        }\n        else {\n          if (Exclude.compareComponents(component, upperBound) < 0)\n            return true;\n        }\n\n        // Make i equal iUpperBound on the next pass.\n        i = iUpperBound - 1;\n      }\n      else {\n        if (lowerBound != null) {\n            if (Exclude.compareComponents(component, lowerBound) > 0)\n              return true;\n        }\n        else\n          // this.values has only ANY.\n          return true;\n      }\n    }\n    else {\n      if (DataUtils.arraysEqual(component, this.values[i].getValue()))\n        return true;\n    }\n  }\n\n  return false;\n};\n\n/**\n * Return -1 if component1 is less than component2, 1 if greater or 0 if equal.\n * A component is less if it is shorter, otherwise if equal length do a byte comparison.\n */\nExclude.compareComponents = function(component1, component2)\n{\n  if (typeof component1 == \'object\' && component1 instanceof Name.Component)\n    component1 = component1.getValue();\n  if (typeof component2 == \'object\' && component2 instanceof Name.Component)\n    component2 = component2.getValue();\n\n  if (component1.length < component2.length)\n    return -1;\n  if (component1.length > component2.length)\n    return 1;\n\n  for (var i = 0; i < component1.length; ++i) {\n    if (component1[i] < component2[i])\n      return -1;\n    if (component1[i] > component2[i])\n      return 1;\n  }\n\n  return 0;\n};\n\n/**\n * @deprecated Use BinaryXmlWireFormat.decodeInterest.\n */\nInterest.prototype.from_ndnb = function(/*XMLDecoder*/ decoder)\n{\n  BinaryXmlWireFormat.decodeInterest(this, decoder);\n};\n\n/**\n * @deprecated Use BinaryXmlWireFormat.encodeInterest.\n */\nInterest.prototype.to_ndnb = function(/*XMLEncoder*/ encoder)\n{\n  BinaryXmlWireFormat.encodeInterest(this, encoder);\n};\n\n/**\n * Encode this Interest for a particular wire format.\n * @param {WireFormat} wireFormat if null, use BinaryXmlWireFormat.\n * @returns {Buffer}\n */\nInterest.prototype.encode = function(wireFormat)\n{\n  wireFormat = (wireFormat || BinaryXmlWireFormat.instance);\n  return wireFormat.encodeInterest(this);\n};\n\n/**\n * Decode the input using a particular wire format and update this Interest.\n * @param {Buffer} input\n * @param {WireFormat} wireFormat if null, use BinaryXmlWireFormat.\n */\nInterest.prototype.decode = function(input, wireFormat)\n{\n  wireFormat = (wireFormat || BinaryXmlWireFormat.instance);\n  wireFormat.decodeInterest(this, input);\n};\n\n/**\n * Encode the name according to the "NDN URI Scheme".  If there are interest selectors, append "?" and\n * added the selectors as a query string.  For example "/test/name?ndn.ChildSelector=1".\n * @returns {string} The URI string.\n */\nInterest.prototype.toUri = function()\n{\n  var selectors = "";\n\n  if (this.minSuffixComponents != null)\n    selectors += "&ndn.MinSuffixComponents=" + this.minSuffixComponents;\n  if (this.maxSuffixComponents != null)\n    selectors += "&ndn.MaxSuffixComponents=" + this.maxSuffixComponents;\n  if (this.childSelector != null)\n    selectors += "&ndn.ChildSelector=" + this.childSelector;\n  if (this.answerOriginKind != null)\n    selectors += "&ndn.AnswerOriginKind=" + this.answerOriginKind;\n  if (this.scope != null)\n    selectors += "&ndn.Scope=" + this.scope;\n  if (this.interestLifetime != null)\n    selectors += "&ndn.InterestLifetime=" + this.interestLifetime;\n  if (this.publisherPublicKeyDigest != null)\n    selectors += "&ndn.PublisherPublicKeyDigest=" + Name.toEscapedString(this.publisherPublicKeyDigest.publisherPublicKeyDigest);\n  if (this.nonce != null)\n    selectors += "&ndn.Nonce=" + Name.toEscapedString(this.nonce);\n  if (this.exclude != null)\n    selectors += "&ndn.Exclude=" + this.exclude.toUri();\n\n  var result = this.name.toUri();\n  if (selectors != "")\n    // Replace the first & with ?.\n    result += "?" + selectors.substr(1);\n\n  return result;\n};\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class represents Key Objects\n */\n\n/**\n * @constructor\n */\n/**\n * Key\n */\nvar Key = function Key()\n{\n  this.publicKeyDer = null;     // ndnbuf\n  this.publicKeyDigest = null;  // ndnbuf\n  this.publicKeyPem = null;     // String\n  this.privateKeyPem = null;    // String\n};\n\nexports.Key = Key;\n\n/**\n * Helper functions to read Key fields\n * TODO: generateRSA()\n */\n\nKey.prototype.publicToDER = function()\n{\n  return this.publicKeyDer;  // ndnbuf\n};\n\nKey.prototype.privateToDER = function()\n{\n  // Remove the \'-----XXX-----\' from the beginning and the end of the key\n  // and also remove any \\n in the key string\n  var lines = this.privateKeyPem.split(\'\\n\');\n  priKey = "";\n  for (var i = 1; i < lines.length - 1; i++)\n    priKey += lines[i];\n\n  return new ndnbuf(priKey, \'base64\');\n};\n\nKey.prototype.publicToPEM = function()\n{\n  return this.publicKeyPem;\n};\n\nKey.prototype.privateToPEM = function()\n{\n  return this.privateKeyPem;\n};\n\nKey.prototype.getKeyID = function()\n{\n  return this.publicKeyDigest;\n};\n\nexports.Key = Key;\n\nKey.prototype.readDerPublicKey = function(/*Buffer*/pub_der)\n{\n  if (LOG > 4) console.log("Encode DER public key:\\n" + pub_der.toString(\'hex\'));\n\n  this.publicKeyDer = pub_der;\n\n  var hash = ndn.createHash(\'sha256\');\n  hash.update(this.publicKeyDer);\n  this.publicKeyDigest = new ndnbuf(hash.digest());\n\n  var keyStr = pub_der.toString(\'base64\');\n  var keyPem = "-----BEGIN PUBLIC KEY-----\\n";\n  for (var i = 0; i < keyStr.length; i += 64)\n  keyPem += (keyStr.substr(i, 64) + "\\n");\n  keyPem += "-----END PUBLIC KEY-----";\n  this.publicKeyPem = keyPem;\n\n  if (LOG > 4) console.log("Convert public key to PEM format:\\n" + this.publicKeyPem);\n};\n\n/**\n * Load RSA key pair from PEM-encoded strings.\n * Will throw an Error if both \'pub\' and \'pri\' are null.\n */\nKey.prototype.fromPemString = function(pub, pri)\n{\n  if (pub == null && pri == null)\n    throw new Error(\'Cannot create Key object if both public and private PEM string is empty.\');\n\n  // Read public key\n  if (pub != null) {\n    this.publicKeyPem = pub;\n    if (LOG > 4) console.log("Key.publicKeyPem: \\n" + this.publicKeyPem);\n\n    // Remove the \'-----XXX-----\' from the beginning and the end of the public key\n    // and also remove any \\n in the public key string\n    var lines = pub.split(\'\\n\');\n    pub = "";\n    for (var i = 1; i < lines.length - 1; i++)\n      pub += lines[i];\n    this.publicKeyDer = new ndnbuf(pub, \'base64\');\n    if (LOG > 4) console.log("Key.publicKeyDer: \\n" + this.publicKeyDer.toString(\'hex\'));\n\n    var hash = ndn.createHash(\'sha256\');\n    hash.update(this.publicKeyDer);\n    this.publicKeyDigest = new ndnbuf(hash.digest());\n    if (LOG > 4) console.log("Key.publicKeyDigest: \\n" + this.publicKeyDigest.toString(\'hex\'));\n  }\n\n  // Read private key\n  if (pri != null) {\n    this.privateKeyPem = pri;\n    if (LOG > 4) console.log("Key.privateKeyPem: \\n" + this.privateKeyPem);\n  }\n};\n\nKey.prototype.fromPem = Key.prototype.fromPemString;\n\n/**\n * Static method that create a Key object.\n * Parameter \'obj\' is a JSON object that has two properties:\n *   pub: the PEM string for the public key\n *   pri: the PEM string for the private key\n * Will throw an Error if both obj.pub and obj.pri are null.\n */\nKey.createFromPEM = function(obj)\n{\n    var key = new Key();\n    key.fromPemString(obj.pub, obj.pri);\n    return key;\n};\n\n/**\n * KeyLocator\n */\nvar KeyLocatorType = {\n  KEY:1,\n  CERTIFICATE:2,\n  KEYNAME:3\n};\n\nexports.KeyLocatorType = KeyLocatorType;\n\n/**\n * @constructor\n */\nvar KeyLocator = function KeyLocator(input,type)\n{\n  this.type = type;\n\n  if (type == KeyLocatorType.KEYNAME) {\n    if (LOG > 3) console.log(\'KeyLocator: SET KEYNAME\');\n    this.keyName = input;\n  }\n  else if (type == KeyLocatorType.KEY) {\n    if (LOG > 3) console.log(\'KeyLocator: SET KEY\');\n    this.publicKey = input;\n  }\n  else if (type == KeyLocatorType.CERTIFICATE) {\n    if (LOG > 3) console.log(\'KeyLocator: SET CERTIFICATE\');\n    this.certificate = input;\n  }\n};\n\nexports.KeyLocator = KeyLocator;\n\nKeyLocator.prototype.from_ndnb = function(decoder) {\n\n  decoder.readElementStartDTag(this.getElementLabel());\n\n  if (decoder.peekDTag(NDNProtocolDTags.Key))\n  {\n    try {\n      var encodedKey = decoder.readBinaryDTagElement(NDNProtocolDTags.Key);\n      // This is a DER-encoded SubjectPublicKeyInfo.\n\n      //TODO FIX THIS, This should create a Key Object instead of keeping bytes\n\n      this.publicKey =   encodedKey;//CryptoUtil.getPublicKey(encodedKey);\n      this.type = KeyLocatorType.KEY;\n\n      if (LOG > 4) console.log(\'PUBLIC KEY FOUND: \'+ this.publicKey);\n    }\n    catch (e) {\n      throw new Error("Cannot parse key: ", e);\n    }\n\n    if (null == this.publicKey)\n      throw new Error("Cannot parse key: ");\n  }\n  else if (decoder.peekDTag(NDNProtocolDTags.Certificate)) {\n    try {\n      var encodedCert = decoder.readBinaryDTagElement(NDNProtocolDTags.Certificate);\n\n      /*\n       * Certificates not yet working\n       */\n\n      this.certificate = encodedCert;\n      this.type = KeyLocatorType.CERTIFICATE;\n\n      if (LOG > 4) console.log(\'CERTIFICATE FOUND: \'+ this.certificate);\n    }\n    catch (e) {\n      throw new Error("Cannot decode certificate: " +  e);\n    }\n    if (null == this.certificate)\n      throw new Error("Cannot parse certificate! ");\n  } else  {\n    this.type = KeyLocatorType.KEYNAME;\n\n    this.keyName = new KeyName();\n    this.keyName.from_ndnb(decoder);\n  }\n  decoder.readElementClose();\n};\n\nKeyLocator.prototype.to_ndnb = function(encoder)\n{\n  if (LOG > 4) console.log(\'type is is \' + this.type);\n  //TODO Check if Name is missing\n  if (!this.validate())\n    throw new Error("Cannot encode " + this.getClass().getName() + ": field values missing.");\n\n  //TODO FIX THIS TOO\n  encoder.writeElementStartDTag(this.getElementLabel());\n\n  if (this.type == KeyLocatorType.KEY) {\n    if (LOG > 5) console.log(\'About to encode a public key\' +this.publicKey);\n    encoder.writeDTagElement(NDNProtocolDTags.Key, this.publicKey);\n  }\n  else if (this.type == KeyLocatorType.CERTIFICATE) {\n    try {\n      encoder.writeDTagElement(NDNProtocolDTags.Certificate, this.certificate);\n    }\n    catch (e) {\n      throw new Error("CertificateEncodingException attempting to write key locator: " + e);\n    }\n  }\n  else if (this.type == KeyLocatorType.KEYNAME)\n    this.keyName.to_ndnb(encoder);\n\n  encoder.writeElementClose();\n};\n\nKeyLocator.prototype.getElementLabel = function()\n{\n  return NDNProtocolDTags.KeyLocator;\n};\n\nKeyLocator.prototype.validate = function()\n{\n  return null != this.keyName || null != this.publicKey || null != this.certificate;\n};\n\n/**\n * KeyName is only used by KeyLocator.\n * @constructor\n */\nvar KeyName = function KeyName()\n{\n  this.contentName = this.contentName;  //contentName\n  this.publisherID = this.publisherID;  //publisherID\n};\n\nexports.KeyName = KeyName;\n\nKeyName.prototype.from_ndnb = function(decoder)\n{\n  decoder.readElementStartDTag(this.getElementLabel());\n\n  this.contentName = new Name();\n  this.contentName.from_ndnb(decoder);\n\n  if (LOG > 4) console.log(\'KEY NAME FOUND: \');\n\n  if (PublisherID.peek(decoder)) {\n    this.publisherID = new PublisherID();\n    this.publisherID.from_ndnb(decoder);\n  }\n\n  decoder.readElementClose();\n};\n\nKeyName.prototype.to_ndnb = function(encoder)\n{\n  if (!this.validate())\n    throw new Error("Cannot encode : field values missing.");\n\n  encoder.writeElementStartDTag(this.getElementLabel());\n\n  this.contentName.to_ndnb(encoder);\n  if (null != this.publisherID)\n    this.publisherID.to_ndnb(encoder);\n\n  encoder.writeElementClose();\n};\n\nKeyName.prototype.getElementLabel = function() { return NDNProtocolDTags.KeyName; };\n\nKeyName.prototype.validate = function()\n{\n    // DKS -- do we do recursive validation?\n    // null signedInfo ok\n    return (null != this.contentName);\n};\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class represents Face Instances\n */\n\n\n/**\n * @constructor\n */\nvar FaceInstance  = function FaceInstance(action, publisherPublicKeyDigest, faceID, ipProto, host, port, multicastInterface,\n    multicastTTL, freshnessSeconds)\n{\n  this.action = action;\n  this.publisherPublicKeyDigest = publisherPublicKeyDigest;\n  this.faceID = faceID;\n  this.ipProto = ipProto;\n  this.host = host;\n  this.Port = port;\n  this.multicastInterface =multicastInterface;\n  this.multicastTTL =multicastTTL;\n  this.freshnessSeconds = freshnessSeconds;\n};\n\nexports.FaceInstance = FaceInstance;\n\nFaceInstance.NetworkProtocol = { TCP:6, UDP:17};\n\n/**\n * Used by NetworkObject to decode the object from a network stream.\n */\nFaceInstance.prototype.from_ndnb = function(\n  //XMLDecoder\n  decoder)\n{\n  decoder.readElementStartDTag(this.getElementLabel());\n\n  if (decoder.peekDTag(NDNProtocolDTags.Action))\n    this.action = decoder.readUTF8DTagElement(NDNProtocolDTags.Action);\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherPublicKeyDigest)) {\n    this.publisherPublicKeyDigest = new PublisherPublicKeyDigest();\n    this.publisherPublicKeyDigest.from_ndnb(decoder);\n  }\n  if (decoder.peekDTag(NDNProtocolDTags.FaceID))\n    this.faceID = decoder.readIntegerDTagElement(NDNProtocolDTags.FaceID);\n  if (decoder.peekDTag(NDNProtocolDTags.IPProto)) {\n    //int\n    var pI = decoder.readIntegerDTagElement(NDNProtocolDTags.IPProto);\n\n    this.ipProto = null;\n\n    if (FaceInstance.NetworkProtocol.TCP == pI)\n      this.ipProto = FaceInstance.NetworkProtocol.TCP;\n    else if (FaceInstance.NetworkProtocol.UDP == pI)\n      this.ipProto = FaceInstance.NetworkProtocol.UDP;\n    else\n      throw new Error("FaceInstance.decoder.  Invalid NDNProtocolDTags.IPProto field: " + pI);\n  }\n\n  if (decoder.peekDTag(NDNProtocolDTags.Host))\n    this.host = decoder.readUTF8DTagElement(NDNProtocolDTags.Host);\n  if (decoder.peekDTag(NDNProtocolDTags.Port))\n    this.Port = decoder.readIntegerDTagElement(NDNProtocolDTags.Port);\n  if (decoder.peekDTag(NDNProtocolDTags.MulticastInterface))\n    this.multicastInterface = decoder.readUTF8DTagElement(NDNProtocolDTags.MulticastInterface);\n  if (decoder.peekDTag(NDNProtocolDTags.MulticastTTL))\n    this.multicastTTL = decoder.readIntegerDTagElement(NDNProtocolDTags.MulticastTTL);\n  if (decoder.peekDTag(NDNProtocolDTags.FreshnessSeconds))\n    this.freshnessSeconds = decoder.readIntegerDTagElement(NDNProtocolDTags.FreshnessSeconds);\n\n  decoder.readElementClose();\n};\n\n/**\n * Used by NetworkObject to encode the object to a network stream.\n */\nFaceInstance.prototype.to_ndnb = function(\n  //XMLEncoder\n  encoder)\n{\n  encoder.writeElementStartDTag(this.getElementLabel());\n\n  if (null != this.action && this.action.length != 0)\n    encoder.writeDTagElement(NDNProtocolDTags.Action, this.action);\n  if (null != this.publisherPublicKeyDigest)\n    this.publisherPublicKeyDigest.to_ndnb(encoder);\n  if (null != this.faceID)\n    encoder.writeDTagElement(NDNProtocolDTags.FaceID, this.faceID);\n  if (null != this.ipProto)\n    encoder.writeDTagElement(NDNProtocolDTags.IPProto, this.ipProto);\n  if (null != this.host && this.host.length != 0)\n    encoder.writeDTagElement(NDNProtocolDTags.Host, this.host);\n  if (null != this.Port)\n    encoder.writeDTagElement(NDNProtocolDTags.Port, this.Port);\n  if (null != this.multicastInterface && this.multicastInterface.length != 0)\n    encoder.writeDTagElement(NDNProtocolDTags.MulticastInterface, this.multicastInterface);\n  if (null !=  this.multicastTTL)\n    encoder.writeDTagElement(NDNProtocolDTags.MulticastTTL, this.multicastTTL);\n  if (null != this.freshnessSeconds)\n    encoder.writeDTagElement(NDNProtocolDTags.FreshnessSeconds, this.freshnessSeconds);\n\n  encoder.writeElementClose();\n};\n\nFaceInstance.prototype.getElementLabel = function()\n{\n  return NDNProtocolDTags.FaceInstance;\n};\n\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class represents Forwarding Entries\n */\n\n\n/**\n * Create a new ForwardingEntry with the optional arguments.\n * @constructor\n * @param {String} action\n * @param {Name} prefixName\n * @param {PublisherPublicKeyDigest} ndndId\n * @param {number} faceID\n * @param {number} flags\n * @param {number} lifetime in seconds\n */\nvar ForwardingEntry = function ForwardingEntry(action, prefixName, ndndId, faceID, flags, lifetime)\n{\n  this.action = action;\n  this.prefixName = prefixName;\n  this.ndndID = ndndId;\n  this.faceID = faceID;\n  this.flags = flags;\n  this.lifetime = lifetime;\n};\n\nexports.ForwardingEntry = ForwardingEntry;\n\nForwardingEntry.ACTIVE         = 1;\nForwardingEntry.CHILD_INHERIT  = 2;\nForwardingEntry.ADVERTISE      = 4;\nForwardingEntry.LAST           = 8;\nForwardingEntry.CAPTURE       = 16;\nForwardingEntry.LOCAL         = 32;\nForwardingEntry.TAP           = 64;\nForwardingEntry.CAPTURE_OK   = 128;\n\nForwardingEntry.prototype.from_ndnb = function(\n  //XMLDecoder\n  decoder)\n  //throws ContentDecodingException\n{\n  decoder.readElementStartDTag(this.getElementLabel());\n  if (decoder.peekDTag(NDNProtocolDTags.Action))\n    this.action = decoder.readUTF8DTagElement(NDNProtocolDTags.Action);\n  if (decoder.peekDTag(NDNProtocolDTags.Name)) {\n    this.prefixName = new Name();\n    this.prefixName.from_ndnb(decoder) ;\n  }\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherPublicKeyDigest)) {\n    this.NdndId = new PublisherPublicKeyDigest();\n    this.NdndId.from_ndnb(decoder);\n  }\n  if (decoder.peekDTag(NDNProtocolDTags.FaceID))\n    this.faceID = decoder.readIntegerDTagElement(NDNProtocolDTags.FaceID);\n  if (decoder.peekDTag(NDNProtocolDTags.ForwardingFlags))\n    this.flags = decoder.readIntegerDTagElement(NDNProtocolDTags.ForwardingFlags);\n  if (decoder.peekDTag(NDNProtocolDTags.FreshnessSeconds))\n    this.lifetime = decoder.readIntegerDTagElement(NDNProtocolDTags.FreshnessSeconds);\n\n  decoder.readElementClose();\n};\n\nForwardingEntry.prototype.to_ndnb = function(\n  //XMLEncoder\n  encoder)\n{\n  encoder.writeElementStartDTag(this.getElementLabel());\n  if (null != this.action && this.action.length != 0)\n    encoder.writeDTagElement(NDNProtocolDTags.Action, this.action);\n  if (null != this.prefixName)\n    this.prefixName.to_ndnb(encoder);\n  if (null != this.NdndId)\n    this.NdndId.to_ndnb(encoder);\n  if (null != this.faceID)\n    encoder.writeDTagElement(NDNProtocolDTags.FaceID, this.faceID);\n  if (null != this.flags)\n    encoder.writeDTagElement(NDNProtocolDTags.ForwardingFlags, this.flags);\n  if (null != this.lifetime)\n    encoder.writeDTagElement(NDNProtocolDTags.FreshnessSeconds, this.lifetime);\n\n  encoder.writeElementClose();\n};\n\nForwardingEntry.prototype.getElementLabel = function() { return NDNProtocolDTags.ForwardingEntry; }\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\n\n/**\n * A ForwardingFlags object holds the flags which specify how the forwarding daemon should forward an interest for\n * a registered prefix.  We use a separate ForwardingFlags object to retain future compatibility if the daemon forwarding\n * bits are changed, amended or deprecated.\n * Create a new ForwardingFlags with "active" and "childInherit" set and all other flags cleared.\n */\nvar ForwardingFlags = function ForwardingFlags()\n{\n  this.active = true;\n  this.childInherit = true;\n  this.advertise = false;\n  this.last = false;\n  this.capture = false;\n  this.local = false;\n  this.tap = false;\n  this.captureOk = false;\n}\n\nexports.ForwardingFlags = ForwardingFlags;\n\n/**\n * Get an integer with the bits set according to the flags as used by the ForwardingEntry message.\n * @returns {number} An integer with the bits set.\n */\nForwardingFlags.prototype.getForwardingEntryFlags = function()\n{\n  var result = 0;\n\n  if (this.active)\n    result |= ForwardingEntry.ACTIVE;\n  if (this.childInherit)\n    result |= ForwardingEntry.CHILD_INHERIT;\n  if (this.advertise)\n    result |= ForwardingEntry.ADVERTISE;\n  if (this.last)\n    result |= ForwardingEntry.LAST;\n  if (this.capture)\n    result |= ForwardingEntry.CAPTURE;\n  if (this.local)\n    result |= ForwardingEntry.LOCAL;\n  if (this.tap)\n    result |= ForwardingEntry.TAP;\n  if (this.captureOk)\n    result |= ForwardingEntry.CAPTURE_OK;\n\n  return result;\n};\n\n/**\n * Set the flags according to the bits in forwardingEntryFlags as used by the ForwardingEntry message.\n * @param {number} forwardingEntryFlags An integer with the bits set.\n */\nForwardingFlags.prototype.setForwardingEntryFlags = function(forwardingEntryFlags)\n{\n  this.active = ((forwardingEntryFlags & ForwardingEntry.ACTIVE) != 0);\n  this.childInherit = ((forwardingEntryFlags & ForwardingEntry.CHILD_INHERIT) != 0);\n  this.advertise = ((forwardingEntryFlags & ForwardingEntry.ADVERTISE) != 0);\n  this.last = ((forwardingEntryFlags & ForwardingEntry.LAST) != 0);\n  this.capture = ((forwardingEntryFlags & ForwardingEntry.CAPTURE) != 0);\n  this.local = ((forwardingEntryFlags & ForwardingEntry.LOCAL) != 0);\n  this.tap = ((forwardingEntryFlags & ForwardingEntry.TAP) != 0);\n  this.captureOk = ((forwardingEntryFlags & ForwardingEntry.CAPTURE_OK) != 0);\n};\n\n/**\n * Get the value of the "active" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getActive = function() { return this.active; };\n\n/**\n * Get the value of the "childInherit" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getChildInherit = function() { return this.childInherit; };\n\n/**\n * Get the value of the "advertise" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getAdvertise = function() { return this.advertise; };\n\n/**\n * Get the value of the "last" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getLast = function() { return this.last; };\n\n/**\n * Get the value of the "capture" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getCapture = function() { return this.capture; };\n\n/**\n * Get the value of the "local" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getLocal = function() { return this.local; };\n\n/**\n * Get the value of the "tap" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getTap = function() { return this.tap; };\n\n/**\n * Get the value of the "captureOk" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getCaptureOk = function() { return this.captureOk; };\n\n/**\n * Set the value of the "active" flag\n * @param {number} value true to set the flag, false to clear it.\n */\nForwardingFlags.prototype.setActive = function(value) { this.active = value; };\n\n/**\n * Set the value of the "childInherit" flag\n * @param {number} value true to set the flag, false to clear it.\n */\nForwardingFlags.prototype.setChildInherit = function(value) { this.childInherit = value; };\n\n/**\n * Set the value of the "advertise" flag\n * @param {number} value true to set the flag, false to clear it.\n */\nForwardingFlags.prototype.setAdvertise = function(value) { this.advertise = value; };\n\n/**\n * Set the value of the "last" flag\n * @param {number} value true to set the flag, false to clear it.\n */\nForwardingFlags.prototype.setLast = function(value) { this.last = value; };\n\n/**\n * Set the value of the "capture" flag\n * @param {number} value true to set the flag, false to clear it.\n */\nForwardingFlags.prototype.setCapture = function(value) { this.capture = value; };\n\n/**\n * Set the value of the "local" flag\n * @param {number} value true to set the flag, false to clear it.\n */\nForwardingFlags.prototype.setLocal = function(value) { this.local = value; };\n\n/**\n * Set the value of the "tap" flag\n * @param {number} value true to set the flag, false to clear it.\n */\nForwardingFlags.prototype.setTap = function(value) { this.tap = value; };\n\n/**\n * Set the value of the "captureOk" flag\n * @param {number} value true to set the flag, false to clear it.\n */\nForwardingFlags.prototype.setCaptureOk = function(value) { this.captureOk = value; };\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\n/**\n * A BinaryXmlWireFormat implements the WireFormat interface for encoding and decoding in binary XML.\n * @constructor\n */\nvar BinaryXmlWireFormat = function BinaryXmlWireFormat()\n{\n  // Inherit from WireFormat.\n  WireFormat.call(this);\n};\n\nexports.BinaryXmlWireFormat = BinaryXmlWireFormat;\n\n// Default object.\nBinaryXmlWireFormat.instance = new BinaryXmlWireFormat();\n\n/**\n * Encode the interest and return a ndnbuf.\n * @param {Interest} interest\n * @returns {Buffer}\n */\nBinaryXmlWireFormat.prototype.encodeInterest = function(interest)\n{\n  var encoder = new BinaryXMLEncoder();\n  BinaryXmlWireFormat.encodeInterest(interest, encoder);\n  return encoder.getReducedOstream();\n};\n\n/**\n * Decode the input and put the result in interest.\n * @param {Interest} interest\n * @param {Buffer} input\n */\nBinaryXmlWireFormat.prototype.decodeInterest = function(interest, input)\n{\n  var decoder = new BinaryXMLDecoder(input);\n  BinaryXmlWireFormat.decodeInterest(interest, decoder);\n};\n\n/**\n * Encode the data and return a ndnbuf.\n * @param {Data} data\n * @returns {Buffer}\n */\nBinaryXmlWireFormat.prototype.encodeData = function(data)\n{\n  var encoder = new BinaryXMLEncoder(1500);\n  BinaryXmlWireFormat.encodeData(data, encoder);\n  return encoder.getReducedOstream();\n};\n\n/**\n * @deprecated Use encodeData(data).\n */\nBinaryXmlWireFormat.prototype.encodeContentObject = function(data)\n{\n  return this.encodeData(data);\n}\n\n/**\n * Decode the input and put the result in data.\n * @param {Data} data\n * @param {Buffer} input\n */\nBinaryXmlWireFormat.prototype.decodeData = function(data, input)\n{\n  var decoder = new BinaryXMLDecoder(input);\n  BinaryXmlWireFormat.decodeData(data, decoder);\n};\n\n/**\n * @deprecated Use decodeData(data, input).\n */\nBinaryXmlWireFormat.prototype.decodeContentObject = function(data, input)\n{\n  this.decodeData(data, input);\n}\n\n/**\n * Encode the interest by calling the operations on the encoder.\n * @param {Interest} interest\n * @param {BinaryXMLEncoder} encoder\n */\nBinaryXmlWireFormat.encodeInterest = function(interest, encoder)\n{\n  encoder.writeElementStartDTag(NDNProtocolDTags.Interest);\n\n  interest.name.to_ndnb(encoder);\n\n  if (null != interest.minSuffixComponents)\n    encoder.writeDTagElement(NDNProtocolDTags.MinSuffixComponents, interest.minSuffixComponents);\n\n  if (null != interest.maxSuffixComponents)\n    encoder.writeDTagElement(NDNProtocolDTags.MaxSuffixComponents, interest.maxSuffixComponents);\n\n  if (null != interest.publisherPublicKeyDigest)\n    interest.publisherPublicKeyDigest.to_ndnb(encoder);\n\n  if (null != interest.exclude)\n    interest.exclude.to_ndnb(encoder);\n\n  if (null != interest.childSelector)\n    encoder.writeDTagElement(NDNProtocolDTags.ChildSelector, interest.childSelector);\n\n  if (interest.DEFAULT_ANSWER_ORIGIN_KIND != interest.answerOriginKind && interest.answerOriginKind!=null)\n    encoder.writeDTagElement(NDNProtocolDTags.AnswerOriginKind, interest.answerOriginKind);\n\n  if (null != interest.scope)\n    encoder.writeDTagElement(NDNProtocolDTags.Scope, interest.scope);\n\n  if (null != interest.interestLifetime)\n    encoder.writeDTagElement(NDNProtocolDTags.InterestLifetime,\n                DataUtils.nonNegativeIntToBigEndian((interest.interestLifetime / 1000.0) * 4096));\n\n  if (null != interest.nonce)\n    encoder.writeDTagElement(NDNProtocolDTags.Nonce, interest.nonce);\n\n  encoder.writeElementClose();\n};\n\n\n/**\n * Use the decoder to place the result in interest.\n * @param {Interest} interest\n * @param {BinaryXMLDecoder} decoder\n */\nBinaryXmlWireFormat.decodeInterest = function(interest, decoder)\n{\n  decoder.readElementStartDTag(NDNProtocolDTags.Interest);\n\n  interest.name = new Name();\n  interest.name.from_ndnb(decoder);\n\n  if (decoder.peekDTag(NDNProtocolDTags.MinSuffixComponents))\n    interest.minSuffixComponents = decoder.readIntegerDTagElement(NDNProtocolDTags.MinSuffixComponents);\n  else\n    interest.minSuffixComponents = null;\n\n  if (decoder.peekDTag(NDNProtocolDTags.MaxSuffixComponents))\n    interest.maxSuffixComponents = decoder.readIntegerDTagElement(NDNProtocolDTags.MaxSuffixComponents);\n  else\n    interest.maxSuffixComponents = null;\n\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherPublicKeyDigest)) {\n    interest.publisherPublicKeyDigest = new PublisherPublicKeyDigest();\n    interest.publisherPublicKeyDigest.from_ndnb(decoder);\n  }\n  else\n    interest.publisherPublicKeyDigest = null;\n\n  if (decoder.peekDTag(NDNProtocolDTags.Exclude)) {\n    interest.exclude = new Exclude();\n    interest.exclude.from_ndnb(decoder);\n  }\n  else\n    interest.exclude = null;\n\n  if (decoder.peekDTag(NDNProtocolDTags.ChildSelector))\n    interest.childSelector = decoder.readIntegerDTagElement(NDNProtocolDTags.ChildSelector);\n  else\n    interest.childSelector = null;\n\n  if (decoder.peekDTag(NDNProtocolDTags.AnswerOriginKind))\n    interest.answerOriginKind = decoder.readIntegerDTagElement(NDNProtocolDTags.AnswerOriginKind);\n  else\n    interest.answerOriginKind = null;\n\n  if (decoder.peekDTag(NDNProtocolDTags.Scope))\n    interest.scope = decoder.readIntegerDTagElement(NDNProtocolDTags.Scope);\n  else\n    interest.scope = null;\n\n  if (decoder.peekDTag(NDNProtocolDTags.InterestLifetime))\n    interest.interestLifetime = 1000.0 * DataUtils.bigEndianToUnsignedInt\n               (decoder.readBinaryDTagElement(NDNProtocolDTags.InterestLifetime)) / 4096;\n  else\n    interest.interestLifetime = null;\n\n  if (decoder.peekDTag(NDNProtocolDTags.Nonce))\n    interest.nonce = decoder.readBinaryDTagElement(NDNProtocolDTags.Nonce);\n  else\n    interest.nonce = null;\n\n  decoder.readElementClose();\n};\n\n/**\n * Encode the data by calling the operations on the encoder.\n * @param {Data} data\n * @param {BinaryXMLEncoder} encoder\n */\nBinaryXmlWireFormat.encodeData = function(data, encoder)\n{\n  //TODO verify name, SignedInfo and Signature is present\n  encoder.writeElementStartDTag(data.getElementLabel());\n\n  if (null != data.signature)\n    data.signature.to_ndnb(encoder);\n\n  data.startSIG = encoder.offset;\n\n  if (null != data.name)\n    data.name.to_ndnb(encoder);\n\n  if (null != data.signedInfo)\n    data.signedInfo.to_ndnb(encoder);\n\n  encoder.writeDTagElement(NDNProtocolDTags.Content, data.content);\n\n  data.endSIG = encoder.offset;\n\n  encoder.writeElementClose();\n\n  data.saveRawData(encoder.ostream);\n};\n\n/**\n * Use the decoder to place the result in data.\n * @param {Data} data\n * @param {BinaryXMLDecoder} decoder\n */\nBinaryXmlWireFormat.decodeData = function(data, decoder)\n{\n  // TODO VALIDATE THAT ALL FIELDS EXCEPT SIGNATURE ARE PRESENT\n  decoder.readElementStartDTag(data.getElementLabel());\n\n  if (decoder.peekDTag(NDNProtocolDTags.Signature)) {\n    data.signature = new Signature();\n    data.signature.from_ndnb(decoder);\n  }\n  else\n    data.signature = null;\n\n  data.startSIG = decoder.offset;\n\n  data.name = new Name();\n  data.name.from_ndnb(decoder);\n\n  if (decoder.peekDTag(NDNProtocolDTags.SignedInfo)) {\n    data.signedInfo = new SignedInfo();\n    data.signedInfo.from_ndnb(decoder);\n  }\n  else\n    data.signedInfo = null;\n\n  data.content = decoder.readBinaryDTagElement(NDNProtocolDTags.Content, true);\n\n  data.endSIG = decoder.offset;\n\n  decoder.readElementClose();\n\n  data.saveRawData(decoder.input);\n};\n/**\n * This file contains utilities to help encode and decode NDN objects.\n * Copyright (C) 2013 Regents of the University of California.\n * author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n */\n\n/**\n * An EncodingUtils has static methods for encoding data.\n * @constructor\n */\nvar EncodingUtils = function EncodingUtils()\n{\n};\n\nexports.EncodingUtils = EncodingUtils;\n\nEncodingUtils.encodeToHexInterest = function(interest)\n{\n  return DataUtils.toHex(interest.encode());\n};\n\nEncodingUtils.encodeToHexData = function(data)\n{\n  return DataUtils.toHex(data.encode());\n};\n\n/**\n * @deprecated Use EncodingUtils.encodeToHexData(data).\n */\nEncodingUtils.encodeToHexContentObject = function(data)\n{\n  return EncodingUtils.encodeToHexData(data);\n}\n\nEncodingUtils.encodeForwardingEntry = function(data)\n{\n  var enc = new BinaryXMLEncoder();\n  data.to_ndnb(enc);\n  var bytes = enc.getReducedOstream();\n\n  return bytes;\n};\n\nEncodingUtils.decodeHexFaceInstance = function(result)\n{\n  var numbers = DataUtils.toNumbers(result);\n  var decoder = new BinaryXMLDecoder(numbers);\n\n  if (LOG > 3) console.log(\'DECODING HEX FACE INSTANCE  \\n\'+numbers);\n\n  var faceInstance = new FaceInstance();\n  faceInstance.from_ndnb(decoder);\n\n  return faceInstance;\n};\n\nEncodingUtils.decodeHexInterest = function(input)\n{\n  var interest = new Interest();\n  interest.decode(DataUtils.toNumbers(input));\n  return interest;\n};\n\nEncodingUtils.decodeHexData = function(input)\n{\n  var data = new Data();\n  data.decode(DataUtils.toNumbers(input));\n  return data;\n};\n\n/**\n * @deprecated Use EncodingUtils.decodeHexData(input).\n */\nEncodingUtils.decodeHexContentObject = function(input)\n{\n  return EncodingUtils.decodeHexData(input);\n}\n\nEncodingUtils.decodeHexForwardingEntry = function(result)\n{\n  var numbers = DataUtils.toNumbers(result);\n  var decoder = new BinaryXMLDecoder(numbers);\n\n  if (LOG > 3) console.log(\'DECODED HEX FORWARDING ENTRY \\n\'+numbers);\n\n  var forwardingEntry = new ForwardingEntry();\n  forwardingEntry.from_ndnb(decoder);\n  return forwardingEntry;\n};\n\n/**\n * Decode the ndnbuf array which holds SubjectPublicKeyInfo and return an RSAKey.\n */\nEncodingUtils.decodeSubjectPublicKeyInfo = function(array)\n{\n  var hex = DataUtils.toHex(array).toLowerCase();\n  var a = _x509_getPublicKeyHexArrayFromCertHex(hex, _x509_getSubjectPublicKeyPosFromCertHex(hex, 0));\n  var rsaKey = new RSAKey();\n  rsaKey.setPublic(a[0], a[1]);\n  return rsaKey;\n}\n\n/**\n * Return a user friendly HTML string with the contents of data.\n * This also outputs to console.log.\n */\nEncodingUtils.dataToHtml = function(/* Data */ data)\n{\n  var output ="";\n\n  if (data == -1)\n    output+= "NO CONTENT FOUND"\n  else if (data == -2)\n    output+= "CONTENT NAME IS EMPTY"\n  else {\n    if (data.name != null && data.name.components != null) {\n      output+= "NAME: " + data.name.toUri();\n\n      output+= "<br />";\n      output+= "<br />";\n    }\n    if (data.content != null) {\n      output += "CONTENT(ASCII): "+ DataUtils.toString(data.content);\n\n      output+= "<br />";\n      output+= "<br />";\n    }\n    if (data.content != null) {\n      output += "CONTENT(hex): "+ DataUtils.toHex(data.content);\n\n      output+= "<br />";\n      output+= "<br />";\n    }\n    if (data.signature != null && data.signature.digestAlgorithm != null) {\n      output += "DigestAlgorithm (hex): "+ DataUtils.toHex(data.signature.digestAlgorithm);\n\n      output+= "<br />";\n      output+= "<br />";\n    }\n    if (data.signature != null && data.signature.witness != null) {\n      output += "Witness (hex): "+ DataUtils.toHex(data.signature.witness);\n\n      output+= "<br />";\n      output+= "<br />";\n    }\n    if (data.signature != null && data.signature.signature != null) {\n      output += "Signature(hex): "+ DataUtils.toHex(data.signature.signature);\n\n      output+= "<br />";\n      output+= "<br />";\n    }\n    if (data.signedInfo != null && data.signedInfo.publisher != null && data.signedInfo.publisher.publisherPublicKeyDigest != null) {\n      output += "Publisher Public Key Digest(hex): "+ DataUtils.toHex(data.signedInfo.publisher.publisherPublicKeyDigest);\n\n      output+= "<br />";\n      output+= "<br />";\n    }\n    if (data.signedInfo != null && data.signedInfo.timestamp != null) {\n      var d = new Date();\n      d.setTime(data.signedInfo.timestamp.msec);\n\n      var bytes = [217, 185, 12, 225, 217, 185, 12, 225];\n\n      output += "TimeStamp: "+d;\n      output+= "<br />";\n      output += "TimeStamp(number): "+ data.signedInfo.timestamp.msec;\n\n      output+= "<br />";\n    }\n    if (data.signedInfo != null && data.signedInfo.finalBlockID != null) {\n      output += "FinalBlockID: "+ DataUtils.toHex(data.signedInfo.finalBlockID);\n      output+= "<br />";\n    }\n    if (data.signedInfo != null && data.signedInfo.locator != null && data.signedInfo.locator.type) {\n      output += "keyLocator: ";\n      if (data.signedInfo.locator.type == KeyLocatorType.KEY)\n        output += "Key: " + DataUtils.toHex(data.signedInfo.locator.publicKey).toLowerCase() + "<br />";\n      else if (data.signedInfo.locator.type == KeyLocatorType.CERTIFICATE)\n        output += "Certificate: " + DataUtils.toHex(data.signedInfo.locator.certificate).toLowerCase() + "<br />";\n      else if (data.signedInfo.locator.type == KeyLocatorType.KEYNAME)\n        output += "KeyName: " + data.signedInfo.locator.keyName.contentName.to_uri() + "<br />";\n      else\n        output += "[unrecognized ndn_KeyLocatorType " + data.signedInfo.locator.type + "]<br />";\n    }\n    if (data.signedInfo!= null && data.signedInfo.locator!= null && data.signedInfo.locator.publicKey!= null) {\n      var publickeyHex = DataUtils.toHex(data.signedInfo.locator.publicKey).toLowerCase();\n      var publickeyString = DataUtils.toString(data.signedInfo.locator.publicKey);\n      var signature = DataUtils.toHex(data.signature.signature).toLowerCase();\n      var input = DataUtils.toString(data.rawSignatureData);\n\n      var witHex = "";\n      if (data.signature.witness != null)\n        witHex = DataUtils.toHex(data.signature.witness);\n\n      // Already showed data.signedInfo.locator.publicKey above.\n      output+= "<br />";\n\n      if (LOG > 2) console.log(" ContentName + SignedInfo + Content = "+input);\n      if (LOG > 2) console.log(" PublicKeyHex = "+publickeyHex);\n      if (LOG > 2) console.log(" PublicKeyString = "+publickeyString);\n\n      if (LOG > 2) console.log(" Signature "+signature);\n      if (LOG > 2) console.log(" Witness "+witHex);\n\n      if (LOG > 2) console.log(" Signature NOW IS");\n\n      if (LOG > 2) console.log(data.signature.signature);\n\n      var rsakey = new Key();\n      rsakey.readDerPublicKey(data.signedInfo.locator.publicKey);\n\n      var result = data.verify(rsakey);\n      if (result)\n      output += \'SIGNATURE VALID\';\n      else\n      output += \'SIGNATURE INVALID\';\n\n      output+= "<br />";\n      output+= "<br />";\n    }\n  }\n\n  return output;\n};\n\n/**\n * @deprecated Use return EncodingUtils.dataToHtml(data).\n */\nEncodingUtils.contentObjectToHtml = function(data)\n{\n  return EncodingUtils.dataToHtml(data);\n}\n\n//\n// Deprecated: For the browser, define these in the global scope.  Applications should access as member of EncodingUtils.\n//\n\nvar encodeToHexInterest = function(interest) { return EncodingUtils.encodeToHexInterest(interest); }\nvar encodeToHexContentObject = function(data) { return EncodingUtils.encodeToHexData(data); }\nvar encodeForwardingEntry = function(data) { return EncodingUtils.encodeForwardingEntry(data); }\nvar decodeHexFaceInstance = function(input) { return EncodingUtils.decodeHexFaceInstance(input); }\nvar decodeHexInterest = function(input) { return EncodingUtils.decodeHexInterest(input); }\nvar decodeHexContentObject = function(input) { return EncodingUtils.decodeHexData(input); }\nvar decodeHexForwardingEntry = function(input) { return EncodingUtils.decodeHexForwardingEntry(input); }\nvar decodeSubjectPublicKeyInfo = function(input) { return EncodingUtils.decodeSubjectPublicKeyInfo(input); }\nvar contentObjectToHtml = function(data) { return EncodingUtils.dataToHtml(data); }\n\n/**\n * @deprecated Use interest.encode().\n */\nfunction encodeToBinaryInterest(interest) { return interest.encode(); }\n/**\n * @deprecated Use data.encode().\n */\nfunction encodeToBinaryContentObject(data) { return data.encode(); }\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Meki Cherkaoui, Jeff Thompson <jefft0@remap.ucla.edu>, Wentao Shang\n * See COPYING for copyright and distribution information.\n * This class represents the top-level object for communicating with an NDN host.\n */\n\n/**\n * Create a new Face with the given settings.\n * This throws an exception if Face.supported is false.\n * @constructor\n * @param {Object} settings if not null, an associative array with the following defaults:\n * {\n *   getTransport: function() { return new WebSocketTransport(); }, // If in the browser.\n *              OR function() { return new TcpTransport(); },       // If in Node.js.\n *   getHostAndPort: transport.defaultGetHostAndPort, // a function, on each call it returns a new { host: host, port: port } or null if there are no more hosts.\n *   host: null, // If null, use getHostAndPort when connecting.\n *   port: 9696, // If in the browser.\n *      OR 6363, // If in Node.js.\n *   onopen: function() { if (LOG > 3) console.log("NDN connection established."); },\n *   onclose: function() { if (LOG > 3) console.log("NDN connection closed."); },\n *   verify: false // If false, don\'t verify and call upcall with Closure.UPCALL_CONTENT_UNVERIFIED.\n * }\n */\nvar Face = function Face(settings)\n{\n  if (!Face.supported)\n    throw new Error("The necessary JavaScript support is not available on this platform.");\n\n  settings = (settings || {});\n  // For the browser, browserify-tcp-transport.js replaces TcpTransport with WebSocketTransport.\n  var getTransport = (settings.getTransport || function() { return new TcpTransport(); });\n  this.transport = getTransport();\n  this.getHostAndPort = (settings.getHostAndPort || this.transport.defaultGetHostAndPort);\n  this.host = (settings.host !== undefined ? settings.host : null);\n  this.port = (settings.port || (typeof WebSocketTransport != \'undefined\' ? 9696 : 6363));\n  this.readyStatus = Face.UNOPEN;\n  this.verify = (settings.verify !== undefined ? settings.verify : false);\n  // Event handler\n  this.onopen = (settings.onopen || function() { if (LOG > 3) console.log("Face connection established."); });\n  this.onclose = (settings.onclose || function() { if (LOG > 3) console.log("Face connection closed."); });\n  this.ndndid = null;\n};\n\nexports.Face = Face;\n\nFace.UNOPEN = 0;  // created but not opened yet\nFace.OPENED = 1;  // connection to ndnd opened\nFace.CLOSED = 2;  // connection to ndnd closed\n\n/**\n * Return true if necessary JavaScript support is available, else log an error and return false.\n */\nFace.getSupported = function()\n{\n  try {\n    var dummy = new ndnbuf(1).slice(0, 1);\n  }\n  catch (ex) {\n    console.log("NDN not available: ndnbuf not supported. " + ex);\n    return false;\n  }\n\n  return true;\n};\n\nFace.supported = Face.getSupported();\n\nFace.ndndIdFetcher = new Name(\'/%C1.M.S.localhost/%C1.M.SRV/ndnd/KEY\');\n\nFace.prototype.createRoute = function(host, port)\n{\n  this.host=host;\n  this.port=port;\n};\n\nFace.KeyStore = new Array();\n\nvar KeyStoreEntry = function KeyStoreEntry(name, rsa, time)\n{\n  this.keyName = name;  // KeyName\n  this.rsaKey = rsa;    // RSA key\n  this.timeStamp = time;  // Time Stamp\n};\n\nFace.addKeyEntry = function(/* KeyStoreEntry */ keyEntry)\n{\n  var result = Face.getKeyByName(keyEntry.keyName);\n  if (result == null)\n    Face.KeyStore.push(keyEntry);\n  else\n    result = keyEntry;\n};\n\nFace.getKeyByName = function(/* KeyName */ name)\n{\n  var result = null;\n\n  for (var i = 0; i < Face.KeyStore.length; i++) {\n    if (Face.KeyStore[i].keyName.contentName.match(name.contentName)) {\n      if (result == null || Face.KeyStore[i].keyName.contentName.components.length > result.keyName.contentName.components.length)\n        result = Face.KeyStore[i];\n    }\n  }\n\n  return result;\n};\n\nFace.prototype.close = function()\n{\n  if (this.readyStatus != Face.OPENED)\n    throw new Error(\'Cannot close because Face connection is not opened.\');\n\n  this.readyStatus = Face.CLOSED;\n  this.transport.close();\n};\n\n// For fetching data\nFace.PITTable = new Array();\n\n/**\n * @constructor\n */\nvar PITEntry = function PITEntry(interest, closure)\n{\n  this.interest = interest;  // Interest\n  this.closure = closure;    // Closure\n  this.timerID = -1;  // Timer ID\n};\n\n/**\n * Return the entry from Face.PITTable where the name conforms to the interest selectors, and\n * the interest name is the longest that matches name.\n */\nFace.getEntryForExpressedInterest = function(/*Name*/ name)\n{\n  var result = null;\n\n  for (var i = 0; i < Face.PITTable.length; i++) {\n    if (Face.PITTable[i].interest.matchesName(name)) {\n      if (result == null || Face.PITTable[i].interest.name.components.length > result.interest.name.components.length)\n        result = Face.PITTable[i];\n    }\n  }\n\n  return result;\n};\n\n// For publishing data\nFace.registeredPrefixTable = new Array();\n\n/**\n * @constructor\n */\nvar RegisteredPrefix = function RegisteredPrefix(prefix, closure)\n{\n  this.prefix = prefix;        // String\n  this.closure = closure;  // Closure\n};\n\n/**\n * Find the first entry from Face.registeredPrefixTable where the entry prefix is the longest that matches name.\n * @param {Name} name The name to find the PrefixEntry for (from the incoming interest packet).\n * @returns {object} The entry from Face.registeredPrefixTable, or 0 if not found.\n */\nfunction getEntryForRegisteredPrefix(name)\n{\n  var iResult = -1;\n\n  for (var i = 0; i < Face.registeredPrefixTable.length; i++) {\n    if (LOG > 3) console.log("Registered prefix " + i + ": checking if " + Face.registeredPrefixTable[i].prefix + " matches " + name);\n    if (Face.registeredPrefixTable[i].prefix.match(name)) {\n      if (iResult < 0 ||\n          Face.registeredPrefixTable[i].prefix.size() > Face.registeredPrefixTable[iResult].prefix.size())\n        // Update to the longer match.\n        iResult = i;\n    }\n  }\n\n  if (iResult >= 0)\n    return Face.registeredPrefixTable[iResult];\n  else\n    return null;\n}\n\n/**\n * Return a function that selects a host at random from hostList and returns { host: host, port: port }.\n * If no more hosts remain, return null.\n */\nFace.makeShuffledGetHostAndPort = function(hostList, port)\n{\n  // Make a copy.\n  hostList = hostList.slice(0, hostList.length);\n  DataUtils.shuffle(hostList);\n\n  return function() {\n    if (hostList.length == 0)\n      return null;\n\n    return { host: hostList.splice(0, 1)[0], port: port };\n  };\n};\n\n/**\n * Send the interest through the transport, read the entire response and call onData.\n * If the interest times out according to interest lifetime, call onTimeout (if not omitted).\n * There are two forms of expressInterest.  The first form takes the exact interest (including lifetime):\n * expressInterest(interest, onData [, onTimeout]).  The second form creates the interest from\n * a name and optional interest template:\n * expressInterest(name [, template], onData [, onTimeout]).\n * This also supports the deprecated form expressInterest(name, closure [, template]), but you should use the other forms.\n * @param {Interest} interest The Interest to send which includes the interest lifetime for the timeout.\n * @param {function} onData When a matching data packet is received, this calls onData(interest, data) where:\n *   interest is the interest given to expressInterest,\n *   data is the received Data object.\n * @param {function} onTimeout (optional) If the interest times out according to the interest lifetime,\n *   this calls onTimeout(interest) where:\n *   interest is the interest given to expressInterest.\n * @param {Name} name The Name for the interest. (only used for the second form of expressInterest).\n * @param {Interest} template (optional) If not omitted, copy the interest selectors from this Interest.\n * If omitted, use a default interest lifetime. (only used for the second form of expressInterest).\n */\nFace.prototype.expressInterest = function(interestOrName, arg2, arg3, arg4)\n{\n  // There are several overloaded versions of expressInterest, each shown inline below.\n\n  // expressInterest(Name name, Closure closure);                      // deprecated\n  // expressInterest(Name name, Closure closure,   Interest template); // deprecated\n  if (arg2 && arg2.upcall && typeof arg2.upcall == \'function\') {\n    // Assume arg2 is the deprecated use with Closure.\n    if (arg3)\n      this.expressInterestWithClosure(interestOrName, arg2, arg3);\n    else\n      this.expressInterestWithClosure(interestOrName, arg2);\n    return;\n  }\n\n  var interest;\n  var onData;\n  var onTimeout;\n  // expressInterest(Interest interest, function onData);\n  // expressInterest(Interest interest, function onData, function onTimeout);\n  if (typeof interestOrName == \'object\' && interestOrName instanceof Interest) {\n    // Just use a copy of the interest.\n    interest = new Interest(interestOrName);\n    onData = arg2;\n    onTimeout = (arg3 ? arg3 : function() {});\n  }\n  else {\n    // The first argument is a name. Make the interest from the name and possible template.\n    interest = new Interest(interestOrName);\n    // expressInterest(Name name, Interest template, function onData);\n    // expressInterest(Name name, Interest template, function onData, function onTimeout);\n    if (arg2 && typeof arg2 == \'object\' && arg2 instanceof Interest) {\n      var template = arg2;\n      interest.minSuffixComponents = template.minSuffixComponents;\n      interest.maxSuffixComponents = template.maxSuffixComponents;\n      interest.publisherPublicKeyDigest = template.publisherPublicKeyDigest;\n      interest.exclude = template.exclude;\n      interest.childSelector = template.childSelector;\n      interest.answerOriginKind = template.answerOriginKind;\n      interest.scope = template.scope;\n      interest.interestLifetime = template.interestLifetime;\n\n      onData = arg3;\n      onTimeout = (arg4 ? arg4 : function() {});\n    }\n    // expressInterest(Name name, function onData);\n    // expressInterest(Name name, function onData,   function onTimeout);\n    else {\n      interest.interestLifetime = 4000;   // default interest timeout value in milliseconds.\n      onData = arg2;\n      onTimeout = (arg3 ? arg3 : function() {});\n    }\n  }\n\n  // Make a Closure from the callbacks so we can use expressInterestWithClosure.\n  // TODO: Convert the PIT to use callbacks, not a closure.\n  this.expressInterestWithClosure(interest, new Face.CallbackClosure(onData, onTimeout), interest);\n}\n\nFace.CallbackClosure = function FaceCallbackClosure(onData, onTimeout, onInterest, prefix, transport) {\n  // Inherit from Closure.\n  Closure.call(this);\n\n  this.onData = onData;\n  this.onTimeout = onTimeout;\n  this.onInterest = onInterest;\n  this.prefix = prefix;\n  this.transport = transport;\n};\n\nFace.CallbackClosure.prototype.upcall = function(kind, upcallInfo) {\n  if (kind == Closure.UPCALL_CONTENT || kind == Closure.UPCALL_CONTENT_UNVERIFIED)\n    this.onData(upcallInfo.interest, upcallInfo.data);\n  else if (kind == Closure.UPCALL_INTEREST_TIMED_OUT)\n    this.onTimeout(upcallInfo.interest);\n  else if (kind == Closure.UPCALL_INTEREST)\n    // Note: We never return INTEREST_CONSUMED because onInterest will send the result to the transport.\n    this.onInterest(this.prefix, upcallInfo.interest, this.transport)\n\n  return Closure.RESULT_OK;\n};\n\n/**\n * A private method to encode name as an Interest and send the it to host:port, read the entire response and call\n * closure.upcall(Closure.UPCALL_CONTENT (or Closure.UPCALL_CONTENT_UNVERIFIED),\n *                 new UpcallInfo(this, interest, 0, data)).\n * @deprecated Use expressInterest with callback functions, not Closure.\n * @param {Name} name Encode name as an Interest using the template (if supplied).\n * @param {Closure} closure\n * @param {Interest} template If not null, use its attributes.\n */\nFace.prototype.expressInterestWithClosure = function(name, closure, template)\n{\n  var interest = new Interest(name);\n  if (template != null) {\n    interest.minSuffixComponents = template.minSuffixComponents;\n    interest.maxSuffixComponents = template.maxSuffixComponents;\n    interest.publisherPublicKeyDigest = template.publisherPublicKeyDigest;\n    interest.exclude = template.exclude;\n    interest.childSelector = template.childSelector;\n    interest.answerOriginKind = template.answerOriginKind;\n    interest.scope = template.scope;\n    interest.interestLifetime = template.interestLifetime;\n  }\n  else\n    interest.interestLifetime = 4000;   // default interest timeout value in milliseconds.\n\n  if (this.host == null || this.port == null) {\n    if (this.getHostAndPort == null)\n      console.log(\'ERROR: host OR port NOT SET\');\n    else {\n      var thisNDN = this;\n      this.connectAndExecute(function() { thisNDN.reconnectAndExpressInterest(interest, closure); });\n    }\n  }\n  else\n    this.reconnectAndExpressInterest(interest, closure);\n};\n\n/**\n * If the host and port are different than the ones in this.transport, then call\n *   this.transport.connect to change the connection (or connect for the first time).\n * Then call expressInterestHelper.\n */\nFace.prototype.reconnectAndExpressInterest = function(interest, closure)\n{\n  if (this.transport.connectedHost != this.host || this.transport.connectedPort != this.port) {\n    var thisNDN = this;\n    this.transport.connect(thisNDN, function() { thisNDN.expressInterestHelper(interest, closure); });\n    this.readyStatus = Face.OPENED;\n  }\n  else\n    this.expressInterestHelper(interest, closure);\n};\n\n/**\n * Do the work of reconnectAndExpressInterest once we know we are connected.  Set the PITTable and call\n *   this.transport.send to send the interest.\n */\nFace.prototype.expressInterestHelper = function(interest, closure)\n{\n  var binaryInterest = interest.encode();\n  var thisNDN = this;\n  //TODO: check local content store first\n  if (closure != null) {\n    var pitEntry = new PITEntry(interest, closure);\n    // TODO: This needs to be a single thread-safe transaction on a global object.\n    Face.PITTable.push(pitEntry);\n    closure.pitEntry = pitEntry;\n\n    // Set interest timer.\n    var timeoutMilliseconds = (interest.interestLifetime || 4000);\n    var timeoutCallback = function() {\n      if (LOG > 1) console.log("Interest time out: " + interest.name.toUri());\n\n      // Remove PIT entry from Face.PITTable, even if we add it again later to re-express\n      //   the interest because we don\'t want to match it in the mean time.\n      // TODO: Make this a thread-safe operation on the global PITTable.\n      var index = Face.PITTable.indexOf(pitEntry);\n      if (index >= 0)\n        Face.PITTable.splice(index, 1);\n\n      // Raise closure callback\n      if (closure.upcall(Closure.UPCALL_INTEREST_TIMED_OUT, new UpcallInfo(thisNDN, interest, 0, null)) == Closure.RESULT_REEXPRESS) {\n        if (LOG > 1) console.log("Re-express interest: " + interest.name.toUri());\n        pitEntry.timerID = setTimeout(timeoutCallback, timeoutMilliseconds);\n        Face.PITTable.push(pitEntry);\n        thisNDN.transport.send(binaryInterest);\n      }\n    };\n\n    pitEntry.timerID = setTimeout(timeoutCallback, timeoutMilliseconds);\n  }\n\n  this.transport.send(binaryInterest);\n};\n\n/**\n * Register prefix with the connected NDN hub and call onInterest when a matching interest is received.\n * This uses the form:\n * registerPrefix(name, onInterest, onRegisterFailed [, flags]).\n * This also supports the deprecated form registerPrefix(name, closure [, intFlags]), but you should use the main form.\n * @param {Name} prefix The Name prefix.\n * @param {function} onInterest When an interest is received which matches the name prefix, this calls\n * onInterest(prefix, interest, transport) where:\n *   prefix is the prefix given to registerPrefix.\n *   interest is the received interest.\n *   transport The Transport with the connection which received the interest. You must encode a signed Data packet and send it using transport.send().\n * @param {function} onRegisterFailed If failed to retrieve the connected hub\'s ID or failed to register the prefix,\n * this calls onRegisterFailed(prefix) where:\n *   prefix is the prefix given to registerPrefix.\n * @param {ForwardingFlags} flags (optional) The flags for finer control of which interests are forward to the application.\n * If omitted, use the default flags defined by the default ForwardingFlags constructor.\n */\nFace.prototype.registerPrefix = function(prefix, arg2, arg3, arg4)\n{\n  // There are several overloaded versions of registerPrefix, each shown inline below.\n\n  // registerPrefix(Name prefix, Closure closure);            // deprecated\n  // registerPrefix(Name prefix, Closure closure, int flags); // deprecated\n  if (arg2 && arg2.upcall && typeof arg2.upcall == \'function\') {\n    // Assume arg2 is the deprecated use with Closure.\n    if (arg3)\n      this.registerPrefixWithClosure(prefix, arg2, arg3);\n    else\n      this.registerPrefixWithClosure(prefix, arg2);\n    return;\n  }\n\n  // registerPrefix(Name prefix, function onInterest, function onRegisterFailed);\n  // registerPrefix(Name prefix, function onInterest, function onRegisterFailed, ForwardingFlags flags);\n  var onInterest = arg2;\n  var onRegisterFailed = (arg3 ? arg3 : function() {});\n  var intFlags = (arg4 ? arg4.getForwardingEntryFlags() : new ForwardingFlags().getForwardingEntryFlags());\n  this.registerPrefixWithClosure(prefix, new Face.CallbackClosure(null, null, onInterest, prefix, this.transport),\n                                 intFlags, onRegisterFailed);\n}\n\n/**\n * A private method to register the prefix with the host, receive the data and call\n * closure.upcall(Closure.UPCALL_INTEREST, new UpcallInfo(this, interest, 0, null)).\n * @deprecated Use registerPrefix with callback functions, not Closure.\n * @param {Name} prefix\n * @param {Closure} closure\n * @param {number} intFlags\n * @param {function} (optional) If called from the non-deprecated registerPrefix, call onRegisterFailed(prefix)\n * if registration fails.\n */\nFace.prototype.registerPrefixWithClosure = function(prefix, closure, intFlags, onRegisterFailed)\n{\n  intFlags = intFlags | 3;\n  var thisNDN = this;\n  var onConnected = function() {\n    if (thisNDN.ndndid == null) {\n      // Fetch ndndid first, then register.\n      var interest = new Interest(Face.ndndIdFetcher);\n      interest.interestLifetime = 4000; // milliseconds\n      if (LOG > 3) console.log(\'Expressing interest for ndndid from ndnd.\');\n      thisNDN.reconnectAndExpressInterest\n        (interest, new Face.FetchNdndidClosure(thisNDN, prefix, closure, intFlags, onRegisterFailed));\n    }\n    else\n      thisNDN.registerPrefixHelper(prefix, closure, intFlags);\n  };\n\n  if (this.host == null || this.port == null) {\n    if (this.getHostAndPort == null)\n      console.log(\'ERROR: host OR port NOT SET\');\n    else\n      this.connectAndExecute(onConnected);\n  }\n  else\n    onConnected();\n};\n\n/**\n * This is a closure to receive the Data for Face.ndndIdFetcher and call\n *   registerPrefixHelper(prefix, callerClosure, flags).\n */\nFace.FetchNdndidClosure = function FetchNdndidClosure(face, prefix, callerClosure, flags, onRegisterFailed)\n{\n  // Inherit from Closure.\n  Closure.call(this);\n\n  this.face = face;\n  this.prefix = prefix;\n  this.callerClosure = callerClosure;\n  this.flags = flags;\n  this.onRegisterFailed = onRegisterFailed;\n};\n\nFace.FetchNdndidClosure.prototype.upcall = function(kind, upcallInfo)\n{\n  if (kind == Closure.UPCALL_INTEREST_TIMED_OUT) {\n    console.log("Timeout while requesting the ndndid.  Cannot registerPrefix for " + this.prefix.toUri() + " .");\n    if (this.onRegisterFailed)\n      this.onRegisterFailed(this.prefix);\n    return Closure.RESULT_OK;\n  }\n  if (!(kind == Closure.UPCALL_CONTENT ||\n        kind == Closure.UPCALL_CONTENT_UNVERIFIED))\n    // The upcall is not for us.  Don\'t expect this to happen.\n    return Closure.RESULT_ERR;\n\n  var data = upcallInfo.data;\n  if (!data.signedInfo || !data.signedInfo.publisher || !data.signedInfo.publisher.publisherPublicKeyDigest) {\n    console.log\n      ("Data doesn\'t have a publisherPublicKeyDigest. Cannot set ndndid and registerPrefix for "\n       + this.prefix.toUri() + " .");\n    if (this.onRegisterFailed)\n      this.onRegisterFailed(this.prefix);\n  }\n  else {\n    if (LOG > 3) console.log(\'Got ndndid from ndnd.\');\n    this.face.ndndid = data.signedInfo.publisher.publisherPublicKeyDigest;\n    if (LOG > 3) console.log(this.face.ndndid);\n    this.face.registerPrefixHelper(this.prefix, this.callerClosure, this.flags);\n  }\n\n  return Closure.RESULT_OK;\n};\n\n/**\n * Do the work of registerPrefix once we know we are connected with a ndndid.\n */\nFace.prototype.registerPrefixHelper = function(prefix, closure, flags)\n{\n  var fe = new ForwardingEntry(\'selfreg\', prefix, null, null, flags, 2147483647);\n\n  var encoder = new BinaryXMLEncoder();\n  fe.to_ndnb(encoder);\n  var bytes = encoder.getReducedOstream();\n\n  var si = new SignedInfo();\n  si.setFields();\n\n  var data = new Data(new Name(), si, bytes);\n  data.sign();\n  var coBinary = data.encode();;\n\n  var nodename = this.ndndid;\n  var interestName = new Name([\'ndnx\', nodename, \'selfreg\', coBinary]);\n\n  var interest = new Interest(interestName);\n  interest.scope = 1;\n  if (LOG > 3) console.log(\'Send Interest registration packet.\');\n\n  Face.registeredPrefixTable.push(new RegisteredPrefix(prefix, closure));\n\n  this.transport.send(interest.encode());\n};\n\n/**\n * This is called when an entire binary XML element is received, such as a Data or Interest.\n * Look up in the PITTable and call the closure callback.\n */\nFace.prototype.onReceivedElement = function(element)\n{\n  if (LOG > 3) console.log(\'Complete element received. Length \' + element.length + \'. Start decoding.\');\n  var decoder = new BinaryXMLDecoder(element);\n  // Dispatch according to packet type\n  if (decoder.peekDTag(NDNProtocolDTags.Interest)) {  // Interest packet\n    if (LOG > 3) console.log(\'Interest packet received.\');\n\n    var interest = new Interest();\n    interest.from_ndnb(decoder);\n    if (LOG > 3) console.log(interest);\n    if (LOG > 3) console.log(interest.name.toUri());\n\n    var entry = getEntryForRegisteredPrefix(interest.name);\n    if (entry != null) {\n      if (LOG > 3) console.log("Found registered prefix for " + interest.name.toUri());\n      var info = new UpcallInfo(this, interest, 0, null);\n      var ret = entry.closure.upcall(Closure.UPCALL_INTEREST, info);\n      if (ret == Closure.RESULT_INTEREST_CONSUMED && info.data != null)\n        this.transport.send(info.data.encode());\n    }\n  }\n  else if (decoder.peekDTag(NDNProtocolDTags.Data)) {  // Content packet\n    if (LOG > 3) console.log(\'Data packet received.\');\n\n    var data = new Data();\n    data.from_ndnb(decoder);\n\n    var pitEntry = Face.getEntryForExpressedInterest(data.name);\n    if (pitEntry != null) {\n      // Cancel interest timer\n      clearTimeout(pitEntry.timerID);\n\n      // Remove PIT entry from Face.PITTable\n      var index = Face.PITTable.indexOf(pitEntry);\n      if (index >= 0)\n        Face.PITTable.splice(index, 1);\n\n      var currentClosure = pitEntry.closure;\n\n      if (this.verify == false) {\n        // Pass content up without verifying the signature\n        currentClosure.upcall(Closure.UPCALL_CONTENT_UNVERIFIED, new UpcallInfo(this, pitEntry.interest, 0, data));\n        return;\n      }\n\n      // Key verification\n\n      // Recursive key fetching & verification closure\n      var KeyFetchClosure = function KeyFetchClosure(content, closure, key, sig, wit) {\n        this.data = content;  // unverified data packet object\n        this.closure = closure;  // closure corresponding to the data\n        this.keyName = key;  // name of current key to be fetched\n\n        Closure.call(this);\n      };\n\n      var thisNDN = this;\n      KeyFetchClosure.prototype.upcall = function(kind, upcallInfo) {\n        if (kind == Closure.UPCALL_INTEREST_TIMED_OUT) {\n          console.log("In KeyFetchClosure.upcall: interest time out.");\n          console.log(this.keyName.contentName.toUri());\n        }\n        else if (kind == Closure.UPCALL_CONTENT) {\n          var rsakey = new Key();\n          rsakey.readDerPublicKey(upcallInfo.data.content);\n          var verified = data.verify(rsakey);\n\n          var flag = (verified == true) ? Closure.UPCALL_CONTENT : Closure.UPCALL_CONTENT_BAD;\n          this.closure.upcall(flag, new UpcallInfo(thisNDN, null, 0, this.data));\n\n          // Store key in cache\n          var keyEntry = new KeyStoreEntry(keylocator.keyName, rsakey, new Date().getTime());\n          Face.addKeyEntry(keyEntry);\n        }\n        else if (kind == Closure.UPCALL_CONTENT_BAD)\n          console.log("In KeyFetchClosure.upcall: signature verification failed");\n      };\n\n      if (data.signedInfo && data.signedInfo.locator && data.signature) {\n        if (LOG > 3) console.log("Key verification...");\n        var sigHex = DataUtils.toHex(data.signature.signature).toLowerCase();\n\n        var wit = null;\n        if (data.signature.witness != null)\n            //SWT: deprecate support for Witness decoding and Merkle hash tree verification\n            currentClosure.upcall(Closure.UPCALL_CONTENT_BAD, new UpcallInfo(this, pitEntry.interest, 0, data));\n\n        var keylocator = data.signedInfo.locator;\n        if (keylocator.type == KeyLocatorType.KEYNAME) {\n          if (LOG > 3) console.log("KeyLocator contains KEYNAME");\n\n          if (keylocator.keyName.contentName.match(data.name)) {\n            if (LOG > 3) console.log("Content is key itself");\n\n            var rsakey = new Key();\n            rsakey.readDerPublicKey(data.content);\n            var verified = data.verify(rsakey);\n            var flag = (verified == true) ? Closure.UPCALL_CONTENT : Closure.UPCALL_CONTENT_BAD;\n\n            currentClosure.upcall(flag, new UpcallInfo(this, pitEntry.interest, 0, data));\n\n            // SWT: We don\'t need to store key here since the same key will be stored again in the closure.\n          }\n          else {\n            // Check local key store\n            var keyEntry = Face.getKeyByName(keylocator.keyName);\n            if (keyEntry) {\n              // Key found, verify now\n              if (LOG > 3) console.log("Local key cache hit");\n              var rsakey = keyEntry.rsaKey;\n              var verified = data.verify(rsakey);\n              var flag = (verified == true) ? Closure.UPCALL_CONTENT : Closure.UPCALL_CONTENT_BAD;\n\n              // Raise callback\n              currentClosure.upcall(flag, new UpcallInfo(this, pitEntry.interest, 0, data));\n            }\n            else {\n              // Not found, fetch now\n              if (LOG > 3) console.log("Fetch key according to keylocator");\n              var nextClosure = new KeyFetchClosure(data, currentClosure, keylocator.keyName, sigHex, wit);\n              // TODO: Use expressInterest with callbacks, not Closure.\n              this.expressInterest(keylocator.keyName.contentName.getPrefix(4), nextClosure);\n            }\n          }\n        }\n        else if (keylocator.type == KeyLocatorType.KEY) {\n          if (LOG > 3) console.log("Keylocator contains KEY");\n\n          var rsakey = new Key();\n          rsakey.readDerPublicKey(keylocator.publicKey);\n          var verified = data.verify(rsakey);\n\n          var flag = (verified == true) ? Closure.UPCALL_CONTENT : Closure.UPCALL_CONTENT_BAD;\n          // Raise callback\n          currentClosure.upcall(Closure.UPCALL_CONTENT, new UpcallInfo(this, pitEntry.interest, 0, data));\n\n          // Since KeyLocator does not contain key name for this key,\n          // we have no way to store it as a key entry in KeyStore.\n        }\n        else {\n          var cert = keylocator.certificate;\n          console.log("KeyLocator contains CERT");\n          console.log(cert);\n          // TODO: verify certificate\n        }\n      }\n    }\n  }\n  else\n    console.log(\'Incoming packet is not Interest or Data. Discard now.\');\n};\n\n/**\n * Assume this.getHostAndPort is not null.  This is called when this.host is null or its host\n *   is not alive.  Get a host and port, connect, then execute onConnected().\n */\nFace.prototype.connectAndExecute = function(onConnected)\n{\n  var hostAndPort = this.getHostAndPort();\n  if (hostAndPort == null) {\n    console.log(\'ERROR: No more hosts from getHostAndPort\');\n    this.host = null;\n    return;\n  }\n\n  if (hostAndPort.host == this.host && hostAndPort.port == this.port) {\n    console.log(\'ERROR: The host returned by getHostAndPort is not alive: \' + this.host + ":" + this.port);\n    return;\n  }\n\n  this.host = hostAndPort.host;\n  this.port = hostAndPort.port;\n  if (LOG>0) console.log("connectAndExecute: trying host from getHostAndPort: " + this.host);\n\n  // Fetch any content.\n  var interest = new Interest(new Name("/"));\n  interest.interestLifetime = 4000; // milliseconds\n\n  var thisNDN = this;\n  var timerID = setTimeout(function() {\n    if (LOG>0) console.log("connectAndExecute: timeout waiting for host " + thisNDN.host);\n      // Try again.\n      thisNDN.connectAndExecute(onConnected);\n  }, 3000);\n\n  this.reconnectAndExpressInterest(interest, new Face.ConnectClosure(this, onConnected, timerID));\n};\n\n/**\n * This is called by the Transport when the connection is closed by the remote host.\n */\nFace.prototype.closeByTransport = function()\n{\n  this.readyStatus = Face.CLOSED;\n  this.onclose();\n};\n\nFace.ConnectClosure = function ConnectClosure(face, onConnected, timerID)\n{\n  // Inherit from Closure.\n  Closure.call(this);\n\n  this.face = face;\n  this.onConnected = onConnected;\n  this.timerID = timerID;\n};\n\nFace.ConnectClosure.prototype.upcall = function(kind, upcallInfo)\n{\n  if (!(kind == Closure.UPCALL_CONTENT ||\n        kind == Closure.UPCALL_CONTENT_UNVERIFIED))\n    // The upcall is not for us.\n    return Closure.RESULT_ERR;\n\n  // The host is alive, so cancel the timeout and continue with onConnected().\n  clearTimeout(this.timerID);\n\n    // Call Face.onopen after success\n  this.face.readyStatus = Face.OPENED;\n  this.face.onopen();\n\n  if (LOG>0) console.log("connectAndExecute: connected to host " + this.face.host);\n  this.onConnected();\n\n  return Closure.RESULT_OK;\n};\n\n/**\n * @deprecated Use new Face.\n */\nvar NDN = function NDN(settings)\n{\n  // Call the base constructor.\n  Face.call(this, settings);\n}\n\n// Use dummy functions so that the Face constructor will not try to set its own defaults.\nNDN.prototype = new Face({ getTransport: function(){}, getHostAndPort: function(){} });\n\nexports.NDN = NDN;\n\nNDN.supported = Face.supported;\nNDN.UNOPEN = Face.UNOPEN;\nNDN.OPENED = Face.OPENED;\nNDN.CLOSED = Face.CLOSED;\n\n\nmodule.exports = exports/*\nCryptoJS v3.1.2\ncode.google.com/p/crypto-js\n(c) 2009-2013 by Jeff Mott. All rights reserved.\ncode.google.com/p/crypto-js/wiki/License\n*/\n/**\n * CryptoJS core components.\n */\nvar CryptoJS = CryptoJS || (function (Math, undefined) {\n    /**\n     * CryptoJS namespace.\n     */\n    var C = {};\n\n    /**\n     * Library namespace.\n     */\n    var C_lib = C.lib = {};\n\n    /**\n     * Base object for prototypal inheritance.\n     */\n    var Base = C_lib.Base = (function () {\n        function F() {}\n\n        return {\n            /**\n             * Creates a new object that inherits from this object.\n             *\n             * @param {Object} overrides Properties to copy into the new object.\n             *\n             * @return {Object} The new object.\n             *\n             * @static\n             *\n             * @example\n             *\n             *     var MyType = CryptoJS.lib.Base.extend({\n             *         field: \'value\',\n             *\n             *         method: function () {\n             *         }\n             *     });\n             */\n            extend: function (overrides) {\n                // Spawn\n                F.prototype = this;\n                var subtype = new F();\n\n                // Augment\n                if (overrides) {\n                    subtype.mixIn(overrides);\n                }\n\n                // Create default initializer\n                if (!subtype.hasOwnProperty(\'init\')) {\n                    subtype.init = function () {\n                        subtype.$super.init.apply(this, arguments);\n                    };\n                }\n\n                // Initializer\'s prototype is the subtype object\n                subtype.init.prototype = subtype;\n\n                // Reference supertype\n                subtype.$super = this;\n\n                return subtype;\n            },\n\n            /**\n             * Extends this object and runs the init method.\n             * Arguments to create() will be passed to init().\n             *\n             * @return {Object} The new object.\n             *\n             * @static\n             *\n             * @example\n             *\n             *     var instance = MyType.create();\n             */\n            create: function () {\n                var instance = this.extend();\n                instance.init.apply(instance, arguments);\n\n                return instance;\n            },\n\n            /**\n             * Initializes a newly created object.\n             * Override this method to add some logic when your objects are created.\n             *\n             * @example\n             *\n             *     var MyType = CryptoJS.lib.Base.extend({\n             *         init: function () {\n             *             // ...\n             *         }\n             *     });\n             */\n            init: function () {\n            },\n\n            /**\n             * Copies properties into this object.\n             *\n             * @param {Object} properties The properties to mix in.\n             *\n             * @example\n             *\n             *     MyType.mixIn({\n             *         field: \'value\'\n             *     });\n             */\n            mixIn: function (properties) {\n                for (var propertyName in properties) {\n                    if (properties.hasOwnProperty(propertyName)) {\n                        this[propertyName] = properties[propertyName];\n                    }\n                }\n\n                // IE won\'t copy toString using the loop above\n                if (properties.hasOwnProperty(\'toString\')) {\n                    this.toString = properties.toString;\n                }\n            },\n\n            /**\n             * Creates a copy of this object.\n             *\n             * @return {Object} The clone.\n             *\n             * @example\n             *\n             *     var clone = instance.clone();\n             */\n            clone: function () {\n                return this.init.prototype.extend(this);\n            }\n        };\n    }());\n\n    /**\n     * An array of 32-bit words.\n     *\n     * @property {Array} words The array of 32-bit words.\n     * @property {number} sigBytes The number of significant bytes in this word array.\n     */\n    var WordArray = C_lib.WordArray = Base.extend({\n        /**\n         * Initializes a newly created word array.\n         *\n         * @param {Array} words (Optional) An array of 32-bit words.\n         * @param {number} sigBytes (Optional) The number of significant bytes in the words.\n         *\n         * @example\n         *\n         *     var wordArray = CryptoJS.lib.WordArray.create();\n         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);\n         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);\n         */\n        init: function (words, sigBytes) {\n            words = this.words = words || [];\n\n            if (sigBytes != undefined) {\n                this.sigBytes = sigBytes;\n            } else {\n                this.sigBytes = words.length * 4;\n            }\n        },\n\n        /**\n         * Converts this word array to a string.\n         *\n         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex\n         *\n         * @return {string} The stringified word array.\n         *\n         * @example\n         *\n         *     var string = wordArray + \'\';\n         *     var string = wordArray.toString();\n         *     var string = wordArray.toString(CryptoJS.enc.Utf8);\n         */\n        toString: function (encoder) {\n            return (encoder || Hex).stringify(this);\n        },\n\n        /**\n         * Concatenates a word array to this word array.\n         *\n         * @param {WordArray} wordArray The word array to append.\n         *\n         * @return {WordArray} This word array.\n         *\n         * @example\n         *\n         *     wordArray1.concat(wordArray2);\n         */\n        concat: function (wordArray) {\n            // Shortcuts\n            var thisWords = this.words;\n            var thatWords = wordArray.words;\n            var thisSigBytes = this.sigBytes;\n            var thatSigBytes = wordArray.sigBytes;\n\n            // Clamp excess bits\n            this.clamp();\n\n            // Concat\n            if (thisSigBytes % 4) {\n                // Copy one byte at a time\n                for (var i = 0; i < thatSigBytes; i++) {\n                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);\n                }\n            } else if (thatWords.length > 0xffff) {\n                // Copy one word at a time\n                for (var i = 0; i < thatSigBytes; i += 4) {\n                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];\n                }\n            } else {\n                // Copy all words at once\n                thisWords.push.apply(thisWords, thatWords);\n            }\n            this.sigBytes += thatSigBytes;\n\n            // Chainable\n            return this;\n        },\n\n        /**\n         * Removes insignificant bits.\n         *\n         * @example\n         *\n         *     wordArray.clamp();\n         */\n        clamp: function () {\n            // Shortcuts\n            var words = this.words;\n            var sigBytes = this.sigBytes;\n\n            // Clamp\n            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);\n            words.length = Math.ceil(sigBytes / 4);\n        },\n\n        /**\n         * Creates a copy of this word array.\n         *\n         * @return {WordArray} The clone.\n         *\n         * @example\n         *\n         *     var clone = wordArray.clone();\n         */\n        clone: function () {\n            var clone = Base.clone.call(this);\n            clone.words = this.words.slice(0);\n\n            return clone;\n        },\n\n        /**\n         * Creates a word array filled with random bytes.\n         *\n         * @param {number} nBytes The number of random bytes to generate.\n         *\n         * @return {WordArray} The random word array.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var wordArray = CryptoJS.lib.WordArray.random(16);\n         */\n        random: function (nBytes) {\n            var words = [];\n            for (var i = 0; i < nBytes; i += 4) {\n                words.push((Math.random() * 0x100000000) | 0);\n            }\n\n            return new WordArray.init(words, nBytes);\n        }\n    });\n\n    /**\n     * Encoder namespace.\n     */\n    var C_enc = C.enc = {};\n\n    /**\n     * Hex encoding strategy.\n     */\n    var Hex = C_enc.Hex = {\n        /**\n         * Converts a word array to a hex string.\n         *\n         * @param {WordArray} wordArray The word array.\n         *\n         * @return {string} The hex string.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);\n         */\n        stringify: function (wordArray) {\n            // Shortcuts\n            var words = wordArray.words;\n            var sigBytes = wordArray.sigBytes;\n\n            // Convert\n            var hexChars = [];\n            for (var i = 0; i < sigBytes; i++) {\n                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n                hexChars.push((bite >>> 4).toString(16));\n                hexChars.push((bite & 0x0f).toString(16));\n            }\n\n            return hexChars.join(\'\');\n        },\n\n        /**\n         * Converts a hex string to a word array.\n         *\n         * @param {string} hexStr The hex string.\n         *\n         * @return {WordArray} The word array.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);\n         */\n        parse: function (hexStr) {\n            // Shortcut\n            var hexStrLength = hexStr.length;\n\n            // Convert\n            var words = [];\n            for (var i = 0; i < hexStrLength; i += 2) {\n                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);\n            }\n\n            return new WordArray.init(words, hexStrLength / 2);\n        }\n    };\n\n    /**\n     * Latin1 encoding strategy.\n     */\n    var Latin1 = C_enc.Latin1 = {\n        /**\n         * Converts a word array to a Latin1 string.\n         *\n         * @param {WordArray} wordArray The word array.\n         *\n         * @return {string} The Latin1 string.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);\n         */\n        stringify: function (wordArray) {\n            // Shortcuts\n            var words = wordArray.words;\n            var sigBytes = wordArray.sigBytes;\n\n            // Convert\n            var latin1Chars = [];\n            for (var i = 0; i < sigBytes; i++) {\n                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n                latin1Chars.push(String.fromCharCode(bite));\n            }\n\n            return latin1Chars.join(\'\');\n        },\n\n        /**\n         * Converts a Latin1 string to a word array.\n         *\n         * @param {string} latin1Str The Latin1 string.\n         *\n         * @return {WordArray} The word array.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);\n         */\n        parse: function (latin1Str) {\n            // Shortcut\n            var latin1StrLength = latin1Str.length;\n\n            // Convert\n            var words = [];\n            for (var i = 0; i < latin1StrLength; i++) {\n                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);\n            }\n\n            return new WordArray.init(words, latin1StrLength);\n        }\n    };\n\n    /**\n     * UTF-8 encoding strategy.\n     */\n    var Utf8 = C_enc.Utf8 = {\n        /**\n         * Converts a word array to a UTF-8 string.\n         *\n         * @param {WordArray} wordArray The word array.\n         *\n         * @return {string} The UTF-8 string.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);\n         */\n        stringify: function (wordArray) {\n            try {\n                return decodeURIComponent(escape(Latin1.stringify(wordArray)));\n            } catch (e) {\n                throw new Error(\'Malformed UTF-8 data\');\n            }\n        },\n\n        /**\n         * Converts a UTF-8 string to a word array.\n         *\n         * @param {string} utf8Str The UTF-8 string.\n         *\n         * @return {WordArray} The word array.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);\n         */\n        parse: function (utf8Str) {\n            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\n        }\n    };\n\n    /**\n     * Abstract buffered block algorithm template.\n     *\n     * The property blockSize must be implemented in a concrete subtype.\n     *\n     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0\n     */\n    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({\n        /**\n         * Resets this block algorithm\'s data buffer to its initial state.\n         *\n         * @example\n         *\n         *     bufferedBlockAlgorithm.reset();\n         */\n        reset: function () {\n            // Initial values\n            this._data = new WordArray.init();\n            this._nDataBytes = 0;\n        },\n\n        /**\n         * Adds new data to this block algorithm\'s buffer.\n         *\n         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.\n         *\n         * @example\n         *\n         *     bufferedBlockAlgorithm._append(\'data\');\n         *     bufferedBlockAlgorithm._append(wordArray);\n         */\n        _append: function (data) {\n            // Convert string to WordArray, else assume WordArray already\n            if (typeof data == \'string\') {\n                data = Utf8.parse(data);\n            }\n\n            // Append\n            this._data.concat(data);\n            this._nDataBytes += data.sigBytes;\n        },\n\n        /**\n         * Processes available data blocks.\n         *\n         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.\n         *\n         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.\n         *\n         * @return {WordArray} The processed data.\n         *\n         * @example\n         *\n         *     var processedData = bufferedBlockAlgorithm._process();\n         *     var processedData = bufferedBlockAlgorithm._process(!!\'flush\');\n         */\n        _process: function (doFlush) {\n            // Shortcuts\n            var data = this._data;\n            var dataWords = data.words;\n            var dataSigBytes = data.sigBytes;\n            var blockSize = this.blockSize;\n            var blockSizeBytes = blockSize * 4;\n\n            // Count blocks ready\n            var nBlocksReady = dataSigBytes / blockSizeBytes;\n            if (doFlush) {\n                // Round up to include partial blocks\n                nBlocksReady = Math.ceil(nBlocksReady);\n            } else {\n                // Round down to include only full blocks,\n                // less the number of blocks that must remain in the buffer\n                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n            }\n\n            // Count words ready\n            var nWordsReady = nBlocksReady * blockSize;\n\n            // Count bytes ready\n            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);\n\n            // Process blocks\n            if (nWordsReady) {\n                for (var offset = 0; offset < nWordsReady; offset += blockSize) {\n                    // Perform concrete-algorithm logic\n                    this._doProcessBlock(dataWords, offset);\n                }\n\n                // Remove processed words\n                var processedWords = dataWords.splice(0, nWordsReady);\n                data.sigBytes -= nBytesReady;\n            }\n\n            // Return processed words\n            return new WordArray.init(processedWords, nBytesReady);\n        },\n\n        /**\n         * Creates a copy of this object.\n         *\n         * @return {Object} The clone.\n         *\n         * @example\n         *\n         *     var clone = bufferedBlockAlgorithm.clone();\n         */\n        clone: function () {\n            var clone = Base.clone.call(this);\n            clone._data = this._data.clone();\n\n            return clone;\n        },\n\n        _minBufferSize: 0\n    });\n\n    /**\n     * Abstract hasher template.\n     *\n     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)\n     */\n    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({\n        /**\n         * Configuration options.\n         */\n        cfg: Base.extend(),\n\n        /**\n         * Initializes a newly created hasher.\n         *\n         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.\n         *\n         * @example\n         *\n         *     var hasher = CryptoJS.algo.SHA256.create();\n         */\n        init: function (cfg) {\n            // Apply config defaults\n            this.cfg = this.cfg.extend(cfg);\n\n            // Set initial values\n            this.reset();\n        },\n\n        /**\n         * Resets this hasher to its initial state.\n         *\n         * @example\n         *\n         *     hasher.reset();\n         */\n        reset: function () {\n            // Reset data buffer\n            BufferedBlockAlgorithm.reset.call(this);\n\n            // Perform concrete-hasher logic\n            this._doReset();\n        },\n\n        /**\n         * Updates this hasher with a message.\n         *\n         * @param {WordArray|string} messageUpdate The message to append.\n         *\n         * @return {Hasher} This hasher.\n         *\n         * @example\n         *\n         *     hasher.update(\'message\');\n         *     hasher.update(wordArray);\n         */\n        update: function (messageUpdate) {\n            // Append\n            this._append(messageUpdate);\n\n            // Update the hash\n            this._process();\n\n            // Chainable\n            return this;\n        },\n\n        /**\n         * Finalizes the hash computation.\n         * Note that the finalize operation is effectively a destructive, read-once operation.\n         *\n         * @param {WordArray|string} messageUpdate (Optional) A final message update.\n         *\n         * @return {WordArray} The hash.\n         *\n         * @example\n         *\n         *     var hash = hasher.finalize();\n         *     var hash = hasher.finalize(\'message\');\n         *     var hash = hasher.finalize(wordArray);\n         */\n        finalize: function (messageUpdate) {\n            // Final message update\n            if (messageUpdate) {\n                this._append(messageUpdate);\n            }\n\n            // Perform concrete-hasher logic\n            var hash = this._doFinalize();\n\n            return hash;\n        },\n\n        blockSize: 512/32,\n\n        /**\n         * Creates a shortcut function to a hasher\'s object interface.\n         *\n         * @param {Hasher} hasher The hasher to create a helper for.\n         *\n         * @return {Function} The shortcut function.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);\n         */\n        _createHelper: function (hasher) {\n            return function (message, cfg) {\n                return new hasher.init(cfg).finalize(message);\n            };\n        },\n\n        /**\n         * Creates a shortcut function to the HMAC\'s object interface.\n         *\n         * @param {Hasher} hasher The hasher to use in this HMAC helper.\n         *\n         * @return {Function} The shortcut function.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);\n         */\n        _createHmacHelper: function (hasher) {\n            return function (message, key) {\n                return new C_algo.HMAC.init(hasher, key).finalize(message);\n            };\n        }\n    });\n\n    /**\n     * Algorithm namespace.\n     */\n    var C_algo = C.algo = {};\n\n    return C;\n}(Math));\n/*\nCryptoJS v3.1.2\ncode.google.com/p/crypto-js\n(c) 2009-2013 by Jeff Mott. All rights reserved.\ncode.google.com/p/crypto-js/wiki/License\n*/\n(function (Math) {\n    // Shortcuts\n    var C = CryptoJS;\n    var C_lib = C.lib;\n    var WordArray = C_lib.WordArray;\n    var Hasher = C_lib.Hasher;\n    var C_algo = C.algo;\n\n    // Initialization and round constants tables\n    var H = [];\n    var K = [];\n\n    // Compute constants\n    (function () {\n        function isPrime(n) {\n            var sqrtN = Math.sqrt(n);\n            for (var factor = 2; factor <= sqrtN; factor++) {\n                if (!(n % factor)) {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        function getFractionalBits(n) {\n            return ((n - (n | 0)) * 0x100000000) | 0;\n        }\n\n        var n = 2;\n        var nPrime = 0;\n        while (nPrime < 64) {\n            if (isPrime(n)) {\n                if (nPrime < 8) {\n                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));\n                }\n                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));\n\n                nPrime++;\n            }\n\n            n++;\n        }\n    }());\n\n    // Reusable object\n    var W = [];\n\n    /**\n     * SHA-256 hash algorithm.\n     */\n    var SHA256 = C_algo.SHA256 = Hasher.extend({\n        _doReset: function () {\n            this._hash = new WordArray.init(H.slice(0));\n        },\n\n        _doProcessBlock: function (M, offset) {\n            // Shortcut\n            var H = this._hash.words;\n\n            // Working variables\n            var a = H[0];\n            var b = H[1];\n            var c = H[2];\n            var d = H[3];\n            var e = H[4];\n            var f = H[5];\n            var g = H[6];\n            var h = H[7];\n\n            // Computation\n            for (var i = 0; i < 64; i++) {\n                if (i < 16) {\n                    W[i] = M[offset + i] | 0;\n                } else {\n                    var gamma0x = W[i - 15];\n                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^\n                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^\n                                   (gamma0x >>> 3);\n\n                    var gamma1x = W[i - 2];\n                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^\n                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^\n                                   (gamma1x >>> 10);\n\n                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];\n                }\n\n                var ch  = (e & f) ^ (~e & g);\n                var maj = (a & b) ^ (a & c) ^ (b & c);\n\n                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));\n                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));\n\n                var t1 = h + sigma1 + ch + K[i] + W[i];\n                var t2 = sigma0 + maj;\n\n                h = g;\n                g = f;\n                f = e;\n                e = (d + t1) | 0;\n                d = c;\n                c = b;\n                b = a;\n                a = (t1 + t2) | 0;\n            }\n\n            // Intermediate hash value\n            H[0] = (H[0] + a) | 0;\n            H[1] = (H[1] + b) | 0;\n            H[2] = (H[2] + c) | 0;\n            H[3] = (H[3] + d) | 0;\n            H[4] = (H[4] + e) | 0;\n            H[5] = (H[5] + f) | 0;\n            H[6] = (H[6] + g) | 0;\n            H[7] = (H[7] + h) | 0;\n        },\n\n        _doFinalize: function () {\n            // Shortcuts\n            var data = this._data;\n            var dataWords = data.words;\n\n            var nBitsTotal = this._nDataBytes * 8;\n            var nBitsLeft = data.sigBytes * 8;\n\n            // Add padding\n            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);\n            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;\n            data.sigBytes = dataWords.length * 4;\n\n            // Hash final blocks\n            this._process();\n\n            // Return final computed hash\n            return this._hash;\n        },\n\n        clone: function () {\n            var clone = Hasher.clone.call(this);\n            clone._hash = this._hash.clone();\n\n            return clone;\n        }\n    });\n\n    /**\n     * Shortcut function to the hasher\'s object interface.\n     *\n     * @param {WordArray|string} message The message to hash.\n     *\n     * @return {WordArray} The hash.\n     *\n     * @static\n     *\n     * @example\n     *\n     *     var hash = CryptoJS.SHA256(\'message\');\n     *     var hash = CryptoJS.SHA256(wordArray);\n     */\n    C.SHA256 = Hasher._createHelper(SHA256);\n\n    /**\n     * Shortcut function to the HMAC\'s object interface.\n     *\n     * @param {WordArray|string} message The message to hash.\n     * @param {WordArray|string} key The secret key.\n     *\n     * @return {WordArray} The HMAC.\n     *\n     * @static\n     *\n     * @example\n     *\n     *     var hmac = CryptoJS.HmacSHA256(message, key);\n     */\n    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);\n}(Math));\nvar b64map="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";\nvar b64pad="=";\n\nfunction hex2b64(h) {\n  var i;\n  var c;\n  var ret = "";\n  for(i = 0; i+3 <= h.length; i+=3) {\n    c = parseInt(h.substring(i,i+3),16);\n    ret += b64map.charAt(c >> 6) + b64map.charAt(c & 63);\n  }\n  if(i+1 == h.length) {\n    c = parseInt(h.substring(i,i+1),16);\n    ret += b64map.charAt(c << 2);\n  }\n  else if(i+2 == h.length) {\n    c = parseInt(h.substring(i,i+2),16);\n    ret += b64map.charAt(c >> 2) + b64map.charAt((c & 3) << 4);\n  }\n  if (b64pad) while((ret.length & 3) > 0) ret += b64pad;\n  return ret;\n}\n\n// convert a base64 string to hex\nfunction b64tohex(s) {\n  var ret = ""\n  var i;\n  var k = 0; // b64 state, 0-3\n  var slop;\n  for(i = 0; i < s.length; ++i) {\n    if(s.charAt(i) == b64pad) break;\n    v = b64map.indexOf(s.charAt(i));\n    if(v < 0) continue;\n    if(k == 0) {\n      ret += int2char(v >> 2);\n      slop = v & 3;\n      k = 1;\n    }\n    else if(k == 1) {\n      ret += int2char((slop << 2) | (v >> 4));\n      slop = v & 0xf;\n      k = 2;\n    }\n    else if(k == 2) {\n      ret += int2char(slop);\n      ret += int2char(v >> 2);\n      slop = v & 3;\n      k = 3;\n    }\n    else {\n      ret += int2char((slop << 2) | (v >> 4));\n      ret += int2char(v & 0xf);\n      k = 0;\n    }\n  }\n  if(k == 1)\n    ret += int2char(slop << 2);\n  return ret;\n}\n\n// convert a base64 string to a byte/number array\nfunction b64toBA(s) {\n  //piggyback on b64tohex for now, optimize later\n  var h = b64tohex(s);\n  var i;\n  var a = new Array();\n  for(i = 0; 2*i < h.length; ++i) {\n    a[i] = parseInt(h.substring(2*i,2*i+2),16);\n  }\n  return a;\n}\n// Depends on jsbn.js and rng.js\n\n// Version 1.1: support utf-8 encoding in pkcs1pad2\n\n// convert a (hex) string to a bignum object\nfunction parseBigInt(str,r) {\n  return new BigInteger(str,r);\n}\n\nfunction linebrk(s,n) {\n  var ret = "";\n  var i = 0;\n  while(i + n < s.length) {\n    ret += s.substring(i,i+n) + "\\n";\n    i += n;\n  }\n  return ret + s.substring(i,s.length);\n}\n\nfunction byte2Hex(b) {\n  if(b < 0x10)\n    return "0" + b.toString(16);\n  else\n    return b.toString(16);\n}\n\n// PKCS#1 (type 2, random) pad input string s to n bytes, and return a bigint\nfunction pkcs1pad2(s,n) {\n  if(n < s.length + 11) { // TODO: fix for utf-8\n    alert("Message too long for RSA");\n    return null;\n  }\n  var ba = new Array();\n  var i = s.length - 1;\n  while(i >= 0 && n > 0) {\n    var c = s.charCodeAt(i--);\n    if(c < 128) { // encode using utf-8\n      ba[--n] = c;\n    }\n    else if((c > 127) && (c < 2048)) {\n      ba[--n] = (c & 63) | 128;\n      ba[--n] = (c >> 6) | 192;\n    }\n    else {\n      ba[--n] = (c & 63) | 128;\n      ba[--n] = ((c >> 6) & 63) | 128;\n      ba[--n] = (c >> 12) | 224;\n    }\n  }\n  ba[--n] = 0;\n  var rng = new SecureRandom();\n  var x = new Array();\n  while(n > 2) { // random non-zero pad\n    x[0] = 0;\n    while(x[0] == 0) rng.nextBytes(x);\n    ba[--n] = x[0];\n  }\n  ba[--n] = 2;\n  ba[--n] = 0;\n  return new BigInteger(ba);\n}\n\n// PKCS#1 (OAEP) mask generation function\nfunction oaep_mgf1_arr(seed, len, hash)\n{\n    var mask = \'\', i = 0;\n\n    while (mask.length < len)\n    {\n        mask += hash(String.fromCharCode.apply(String, seed.concat([\n                (i & 0xff000000) >> 24,\n                (i & 0x00ff0000) >> 16,\n                (i & 0x0000ff00) >> 8,\n                i & 0x000000ff])));\n        i += 1;\n    }\n\n    return mask;\n}\n\nvar SHA1_SIZE = 20;\n\n// PKCS#1 (OAEP) pad input string s to n bytes, and return a bigint\nfunction oaep_pad(s, n, hash)\n{\n    if (s.length + 2 * SHA1_SIZE + 2 > n)\n    {\n        throw "Message too long for RSA";\n    }\n\n    var PS = \'\', i;\n\n    for (i = 0; i < n - s.length - 2 * SHA1_SIZE - 2; i += 1)\n    {\n        PS += \'\\x00\';\n    }\n\n    var DB = rstr_sha1(\'\') + PS + \'\\x01\' + s;\n    var seed = new Array(SHA1_SIZE);\n    new SecureRandom().nextBytes(seed);\n\n    var dbMask = oaep_mgf1_arr(seed, DB.length, hash || rstr_sha1);\n    var maskedDB = [];\n\n    for (i = 0; i < DB.length; i += 1)\n    {\n        maskedDB[i] = DB.charCodeAt(i) ^ dbMask.charCodeAt(i);\n    }\n\n    var seedMask = oaep_mgf1_arr(maskedDB, seed.length, rstr_sha1);\n    var maskedSeed = [0];\n\n    for (i = 0; i < seed.length; i += 1)\n    {\n        maskedSeed[i + 1] = seed[i] ^ seedMask.charCodeAt(i);\n    }\n\n    return new BigInteger(maskedSeed.concat(maskedDB));\n}\n\n// "empty" RSA key constructor\nfunction RSAKey() {\n  this.n = null;\n  this.e = 0;\n  this.d = null;\n  this.p = null;\n  this.q = null;\n  this.dmp1 = null;\n  this.dmq1 = null;\n  this.coeff = null;\n}\n\n// Set the public key fields N and e from hex strings\nfunction RSASetPublic(N,E) {\n  if (typeof N !== "string")\n  {\n    this.n = N;\n    this.e = E;\n  }\n  else if(N != null && E != null && N.length > 0 && E.length > 0) {\n    this.n = parseBigInt(N,16);\n    this.e = parseInt(E,16);\n  }\n  else\n    alert("Invalid RSA public key");\n}\n\n// Perform raw public operation on "x": return x^e (mod n)\nfunction RSADoPublic(x) {\n  return x.modPowInt(this.e, this.n);\n}\n\n// Return the PKCS#1 RSA encryption of "text" as an even-length hex string\nfunction RSAEncrypt(text) {\n  var m = pkcs1pad2(text,(this.n.bitLength()+7)>>3);\n  if(m == null) return null;\n  var c = this.doPublic(m);\n  if(c == null) return null;\n  var h = c.toString(16);\n  if((h.length & 1) == 0) return h; else return "0" + h;\n}\n\n// Return the PKCS#1 OAEP RSA encryption of "text" as an even-length hex string\nfunction RSAEncryptOAEP(text, hash) {\n  var m = oaep_pad(text, (this.n.bitLength()+7)>>3, hash);\n  if(m == null) return null;\n  var c = this.doPublic(m);\n  if(c == null) return null;\n  var h = c.toString(16);\n  if((h.length & 1) == 0) return h; else return "0" + h;\n}\n\n// Return the PKCS#1 RSA encryption of "text" as a Base64-encoded string\n//function RSAEncryptB64(text) {\n//  var h = this.encrypt(text);\n//  if(h) return hex2b64(h); else return null;\n//}\n\n// protected\nRSAKey.prototype.doPublic = RSADoPublic;\n\n// public\nRSAKey.prototype.setPublic = RSASetPublic;\nRSAKey.prototype.encrypt = RSAEncrypt;\nRSAKey.prototype.encryptOAEP = RSAEncryptOAEP;\n//RSAKey.prototype.encrypt_b64 = RSAEncryptB64;\n// Depends on rsa.js and jsbn2.js\n\n// Version 1.1: support utf-8 decoding in pkcs1unpad2\n\n// Undo PKCS#1 (type 2, random) padding and, if valid, return the plaintext\nfunction pkcs1unpad2(d,n) {\n  var b = d.toByteArray();\n  var i = 0;\n  while(i < b.length && b[i] == 0) ++i;\n  if(b.length-i != n-1 || b[i] != 2)\n    return null;\n  ++i;\n  while(b[i] != 0)\n    if(++i >= b.length) return null;\n  var ret = "";\n  while(++i < b.length) {\n    var c = b[i] & 255;\n    if(c < 128) { // utf-8 decode\n      ret += String.fromCharCode(c);\n    }\n    else if((c > 191) && (c < 224)) {\n      ret += String.fromCharCode(((c & 31) << 6) | (b[i+1] & 63));\n      ++i;\n    }\n    else {\n      ret += String.fromCharCode(((c & 15) << 12) | ((b[i+1] & 63) << 6) | (b[i+2] & 63));\n      i += 2;\n    }\n  }\n  return ret;\n}\n\n// PKCS#1 (OAEP) mask generation function\nfunction oaep_mgf1_str(seed, len, hash)\n{\n    var mask = \'\', i = 0;\n\n    while (mask.length < len)\n    {\n        mask += hash(seed + String.fromCharCode.apply(String, [\n                (i & 0xff000000) >> 24,\n                (i & 0x00ff0000) >> 16,\n                (i & 0x0000ff00) >> 8,\n                i & 0x000000ff]));\n        i += 1;\n    }\n\n    return mask;\n}\n\nvar SHA1_SIZE = 20;\n\n// Undo PKCS#1 (OAEP) padding and, if valid, return the plaintext\nfunction oaep_unpad(d, n, hash)\n{\n    d = d.toByteArray();\n\n    var i;\n\n    for (i = 0; i < d.length; i += 1)\n    {\n        d[i] &= 0xff;\n    }\n\n    while (d.length < n)\n    {\n        d.unshift(0);\n    }\n\n    d = String.fromCharCode.apply(String, d);\n\n    if (d.length < 2 * SHA1_SIZE + 2)\n    {\n        throw "Cipher too short";\n    }\n\n    var maskedSeed = d.substr(1, SHA1_SIZE)\n    var maskedDB = d.substr(SHA1_SIZE + 1);\n\n    var seedMask = oaep_mgf1_str(maskedDB, SHA1_SIZE, hash || rstr_sha1);\n    var seed = [], i;\n\n    for (i = 0; i < maskedSeed.length; i += 1)\n    {\n        seed[i] = maskedSeed.charCodeAt(i) ^ seedMask.charCodeAt(i);\n    }\n\n    var dbMask = oaep_mgf1_str(String.fromCharCode.apply(String, seed),\n                           d.length - SHA1_SIZE, rstr_sha1);\n\n    var DB = [];\n\n    for (i = 0; i < maskedDB.length; i += 1)\n    {\n        DB[i] = maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i);\n    }\n\n    DB = String.fromCharCode.apply(String, DB);\n\n    if (DB.substr(0, SHA1_SIZE) !== rstr_sha1(\'\'))\n    {\n        throw "Hash mismatch";\n    }\n\n    DB = DB.substr(SHA1_SIZE);\n\n    var first_one = DB.indexOf(\'\\x01\');\n    var last_zero = (first_one != -1) ? DB.substr(0, first_one).lastIndexOf(\'\\x00\') : -1;\n\n    if (last_zero + 1 != first_one)\n    {\n        throw "Malformed data";\n    }\n\n    return DB.substr(first_one + 1);\n}\n\n// Set the private key fields N, e, and d from hex strings\nfunction RSASetPrivate(N,E,D) {\n  if (typeof N !== "string")\n  {\n    this.n = N;\n    this.e = E;\n    this.d = D;\n  }\n  else if(N != null && E != null && N.length > 0 && E.length > 0) {\n    this.n = parseBigInt(N,16);\n    this.e = parseInt(E,16);\n    this.d = parseBigInt(D,16);\n  }\n  else\n    alert("Invalid RSA private key");\n}\n\n// Set the private key fields N, e, d and CRT params from hex strings\nfunction RSASetPrivateEx(N,E,D,P,Q,DP,DQ,C) {\n  //alert("RSASetPrivateEx called");\n  if (N == null) throw "RSASetPrivateEx N == null";\n  if (E == null) throw "RSASetPrivateEx E == null";\n  if (N.length == 0) throw "RSASetPrivateEx N.length == 0";\n  if (E.length == 0) throw "RSASetPrivateEx E.length == 0";\n\n  if (N != null && E != null && N.length > 0 && E.length > 0) {\n    this.n = parseBigInt(N,16);\n    this.e = parseInt(E,16);\n    this.d = parseBigInt(D,16);\n    this.p = parseBigInt(P,16);\n    this.q = parseBigInt(Q,16);\n    this.dmp1 = parseBigInt(DP,16);\n    this.dmq1 = parseBigInt(DQ,16);\n    this.coeff = parseBigInt(C,16);\n  } else {\n    alert("Invalid RSA private key in RSASetPrivateEx");\n  }\n}\n\n// Generate a new random private key B bits long, using public expt E\nfunction RSAGenerate(B,E) {\n  var rng = new SecureRandom();\n  var qs = B>>1;\n  this.e = parseInt(E,16);\n  var ee = new BigInteger(E,16);\n  for(;;) {\n    for(;;) {\n      this.p = new BigInteger(B-qs,1,rng);\n      if(this.p.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) == 0 && this.p.isProbablePrime(10)) break;\n    }\n    for(;;) {\n      this.q = new BigInteger(qs,1,rng);\n      if(this.q.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) == 0 && this.q.isProbablePrime(10)) break;\n    }\n    if(this.p.compareTo(this.q) <= 0) {\n      var t = this.p;\n      this.p = this.q;\n      this.q = t;\n    }\n    var p1 = this.p.subtract(BigInteger.ONE);\t// p1 = p - 1\n    var q1 = this.q.subtract(BigInteger.ONE);\t// q1 = q - 1\n    var phi = p1.multiply(q1);\n    if(phi.gcd(ee).compareTo(BigInteger.ONE) == 0) {\n      this.n = this.p.multiply(this.q);\t// this.n = p * q\n      this.d = ee.modInverse(phi);\t// this.d =\n      this.dmp1 = this.d.mod(p1);\t// this.dmp1 = d mod (p - 1)\n      this.dmq1 = this.d.mod(q1);\t// this.dmq1 = d mod (q - 1)\n      this.coeff = this.q.modInverse(this.p);\t// this.coeff = (q ^ -1) mod p\n      break;\n    }\n  }\n}\n\n// Perform raw private operation on "x": return x^d (mod n)\nfunction RSADoPrivate(x) {\n  if(this.p == null || this.q == null)\n    return x.modPow(this.d, this.n);\n\n  // TODO: re-calculate any missing CRT params\n  var xp = x.mod(this.p).modPow(this.dmp1, this.p); // xp=cp?\n  var xq = x.mod(this.q).modPow(this.dmq1, this.q); // xq=cq?\n\n  while(xp.compareTo(xq) < 0)\n    xp = xp.add(this.p);\n  // NOTE:\n  // xp.subtract(xq) => cp -cq\n  // xp.subtract(xq).multiply(this.coeff).mod(this.p) => (cp - cq) * u mod p = h\n  // xp.subtract(xq).multiply(this.coeff).mod(this.p).multiply(this.q).add(xq) => cq + (h * q) = M\n  return xp.subtract(xq).multiply(this.coeff).mod(this.p).multiply(this.q).add(xq);\n}\n\n// Return the PKCS#1 RSA decryption of "ctext".\n// "ctext" is an even-length hex string and the output is a plain string.\nfunction RSADecrypt(ctext) {\n  var c = parseBigInt(ctext, 16);\n  var m = this.doPrivate(c);\n  if(m == null) return null;\n  return pkcs1unpad2(m, (this.n.bitLength()+7)>>3);\n}\n\n// Return the PKCS#1 OAEP RSA decryption of "ctext".\n// "ctext" is an even-length hex string and the output is a plain string.\nfunction RSADecryptOAEP(ctext, hash) {\n  var c = parseBigInt(ctext, 16);\n  var m = this.doPrivate(c);\n  if(m == null) return null;\n  return oaep_unpad(m, (this.n.bitLength()+7)>>3, hash);\n}\n\n// Return the PKCS#1 RSA decryption of "ctext".\n// "ctext" is a Base64-encoded string and the output is a plain string.\n//function RSAB64Decrypt(ctext) {\n//  var h = b64tohex(ctext);\n//  if(h) return this.decrypt(h); else return null;\n//}\n\n// protected\nRSAKey.prototype.doPrivate = RSADoPrivate;\n\n// public\nRSAKey.prototype.setPrivate = RSASetPrivate;\nRSAKey.prototype.setPrivateEx = RSASetPrivateEx;\nRSAKey.prototype.generate = RSAGenerate;\nRSAKey.prototype.decrypt = RSADecrypt;\nRSAKey.prototype.decryptOAEP = RSADecryptOAEP;\n//RSAKey.prototype.b64_decrypt = RSAB64Decrypt;\n/*! crypto-1.0.4.js (c) 2013 Kenji Urushima | kjur.github.com/jsrsasign/license\n */\n/*\n * crypto.js - Cryptographic Algorithm Provider class\n *\n * Copyright (c) 2013 Kenji Urushima (kenji.urushima@gmail.com)\n *\n * This software is licensed under the terms of the MIT License.\n * http://kjur.github.com/jsrsasign/license\n *\n * The above copyright and license notice shall be\n * included in all copies or substantial portions of the Software.\n */\n\n/**\n * @fileOverview\n * @name crypto-1.0.js\n * @author Kenji Urushima kenji.urushima@gmail.com\n * @version 1.0.4 (2013-Mar-28)\n * @since 2.2\n * @license <a href="http://kjur.github.io/jsrsasign/license/">MIT License</a>\n */\n\n/**\n * kjur\'s class library name space\n * @name KJUR\n * @namespace kjur\'s class library name space\n */\nif (typeof KJUR == "undefined" || !KJUR) KJUR = {};\n/**\n * kjur\'s cryptographic algorithm provider library name space\n * <p>\n * This namespace privides following crytpgrahic classes.\n * <ul>\n * <li>{@link KJUR.crypto.MessageDigest} - Java JCE(cryptograhic extension) style MessageDigest class</li>\n * <li>{@link KJUR.crypto.Signature} - Java JCE(cryptograhic extension) style Signature class</li>\n * <li>{@link KJUR.crypto.Util} - cryptographic utility functions and properties</li>\n * </ul>\n * NOTE: Please ignore method summary and document of this namespace. This caused by a bug of jsdoc2.\n * </p>\n * @name KJUR.crypto\n * @namespace\n */\nif (typeof KJUR.crypto == "undefined" || !KJUR.crypto) KJUR.crypto = {};\n\n/**\n * static object for cryptographic function utilities\n * @name KJUR.crypto.Util\n * @class static object for cryptographic function utilities\n * @property {Array} DIGESTINFOHEAD PKCS#1 DigestInfo heading hexadecimal bytes for each hash algorithms\n * @description\n */\nKJUR.crypto.Util = new function() {\n    this.DIGESTINFOHEAD = {\n\t\'sha1\':      "3021300906052b0e03021a05000414",\n        \'sha224\':    "302d300d06096086480165030402040500041c",\n\t\'sha256\':    "3031300d060960864801650304020105000420",\n\t\'sha384\':    "3041300d060960864801650304020205000430",\n\t\'sha512\':    "3051300d060960864801650304020305000440",\n\t\'md2\':       "3020300c06082a864886f70d020205000410",\n\t\'md5\':       "3020300c06082a864886f70d020505000410",\n\t\'ripemd160\': "3021300906052b2403020105000414"\n    };\n\n    /**\n     * get hexadecimal DigestInfo\n     * @name getDigestInfoHex\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} hHash hexadecimal hash value\n     * @param {String} alg hash algorithm name (ex. \'sha1\')\n     * @return {String} hexadecimal string DigestInfo ASN.1 structure\n     */\n    this.getDigestInfoHex = function(hHash, alg) {\n\tif (typeof this.DIGESTINFOHEAD[alg] == "undefined")\n\t    throw "alg not supported in Util.DIGESTINFOHEAD: " + alg;\n\treturn this.DIGESTINFOHEAD[alg] + hHash;\n    };\n\n    /**\n     * get PKCS#1 padded hexadecimal DigestInfo\n     * @name getPaddedDigestInfoHex\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} hHash hexadecimal hash value\n     * @param {String} alg hash algorithm name (ex. \'sha1\')\n     * @param {Integer} keySize key bit length (ex. 1024)\n     * @return {String} hexadecimal string of PKCS#1 padded DigestInfo\n     */\n    this.getPaddedDigestInfoHex = function(hHash, alg, keySize) {\n\tvar hDigestInfo = this.getDigestInfoHex(hHash, alg);\n\tvar pmStrLen = keySize / 4; // minimum PM length\n\n\tif (hDigestInfo.length + 22 > pmStrLen) // len(0001+ff(*8)+00+hDigestInfo)=22\n\t    throw "key is too short for SigAlg: keylen=" + keySize + "," + alg;\n\n\tvar hHead = "0001";\n\tvar hTail = "00" + hDigestInfo;\n\tvar hMid = "";\n\tvar fLen = pmStrLen - hHead.length - hTail.length;\n\tfor (var i = 0; i < fLen; i += 2) {\n\t    hMid += "ff";\n\t}\n\tvar hPaddedMessage = hHead + hMid + hTail;\n\treturn hPaddedMessage;\n    };\n\n    /**\n     * get hexadecimal SHA1 hash of string\n     * @name sha1\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} s input string to be hashed\n     * @return {String} hexadecimal string of hash value\n     * @since 1.0.3\n     */\n    this.sha1 = function(s) {\n        var md = new KJUR.crypto.MessageDigest({\'alg\':\'sha1\', \'prov\':\'cryptojs\'});\n        return md.digestString(s);\n    };\n\n    /**\n     * get hexadecimal SHA256 hash of string\n     * @name sha256\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} s input string to be hashed\n     * @return {String} hexadecimal string of hash value\n     * @since 1.0.3\n     */\n    this.sha256 = function(s) {\n        var md = new KJUR.crypto.MessageDigest({\'alg\':\'sha256\', \'prov\':\'cryptojs\'});\n        return md.digestString(s);\n    };\n\n    /**\n     * get hexadecimal SHA512 hash of string\n     * @name sha512\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} s input string to be hashed\n     * @return {String} hexadecimal string of hash value\n     * @since 1.0.3\n     */\n    this.sha512 = function(s) {\n        var md = new KJUR.crypto.MessageDigest({\'alg\':\'sha512\', \'prov\':\'cryptojs\'});\n        return md.digestString(s);\n    };\n\n    /**\n     * get hexadecimal MD5 hash of string\n     * @name md5\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} s input string to be hashed\n     * @return {String} hexadecimal string of hash value\n     * @since 1.0.3\n     */\n    this.md5 = function(s) {\n        var md = new KJUR.crypto.MessageDigest({\'alg\':\'md5\', \'prov\':\'cryptojs\'});\n        return md.digestString(s);\n    };\n\n    /**\n     * get hexadecimal RIPEMD160 hash of string\n     * @name ripemd160\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} s input string to be hashed\n     * @return {String} hexadecimal string of hash value\n     * @since 1.0.3\n     */\n    this.ripemd160 = function(s) {\n        var md = new KJUR.crypto.MessageDigest({\'alg\':\'ripemd160\', \'prov\':\'cryptojs\'});\n        return md.digestString(s);\n    };\n};\n\n/**\n * MessageDigest class which is very similar to java.security.MessageDigest class\n * @name KJUR.crypto.MessageDigest\n * @class MessageDigest class which is very similar to java.security.MessageDigest class\n * @param {Array} params parameters for constructor\n * @description\n * <br/>\n * Currently this supports following algorithm and providers combination:\n * <ul>\n * <li>md5 - cryptojs</li>\n * <li>sha1 - cryptojs</li>\n * <li>sha224 - cryptojs</li>\n * <li>sha256 - cryptojs</li>\n * <li>sha384 - cryptojs</li>\n * <li>sha512 - cryptojs</li>\n * <li>ripemd160 - cryptojs</li>\n * <li>sha256 - sjcl (NEW from crypto.js 1.0.4)</li>\n * </ul>\n * @example\n * // CryptoJS provider sample\n * &lt;script src="http://crypto-js.googlecode.com/svn/tags/3.1.2/build/components/core.js"&gt;&lt;/script&gt;\n * &lt;script src="http://crypto-js.googlecode.com/svn/tags/3.1.2/build/components/sha1.js"&gt;&lt;/script&gt;\n * &lt;script src="crypto-1.0.js"&gt;&lt;/script&gt;\n * var md = new KJUR.crypto.MessageDigest({alg: "sha1", prov: "cryptojs"});\n * md.updateString(\'aaa\')\n * var mdHex = md.digest()\n *\n * // SJCL(Stanford JavaScript Crypto Library) provider sample\n * &lt;script src="http://bitwiseshiftleft.github.io/sjcl/sjcl.js"&gt;&lt;/script&gt;\n * &lt;script src="crypto-1.0.js"&gt;&lt;/script&gt;\n * var md = new KJUR.crypto.MessageDigest({alg: "sha256", prov: "sjcl"}); // sjcl supports sha256 only\n * md.updateString(\'aaa\')\n * var mdHex = md.digest()\n */\nKJUR.crypto.MessageDigest = function(params) {\n    var md = null;\n    var algName = null;\n    var provName = null;\n    var _CryptoJSMdName = {\n\t\'md5\': \'CryptoJS.algo.MD5\',\n\t\'sha1\': \'CryptoJS.algo.SHA1\',\n\t\'sha224\': \'CryptoJS.algo.SHA224\',\n\t\'sha256\': \'CryptoJS.algo.SHA256\',\n\t\'sha384\': \'CryptoJS.algo.SHA384\',\n\t\'sha512\': \'CryptoJS.algo.SHA512\',\n\t\'ripemd160\': \'CryptoJS.algo.RIPEMD160\'\n    };\n\n    /**\n     * set hash algorithm and provider\n     * @name setAlgAndProvider\n     * @memberOf KJUR.crypto.MessageDigest\n     * @function\n     * @param {String} alg hash algorithm name\n     * @param {String} prov provider name\n     * @description\n     * @example\n     * // for SHA1\n     * md.setAlgAndProvider(\'sha1\', \'cryptojs\');\n     * // for RIPEMD160\n     * md.setAlgAndProvider(\'ripemd160\', \'cryptojs\');\n     */\n    this.setAlgAndProvider = function(alg, prov) {\n\tif (\':md5:sha1:sha224:sha256:sha384:sha512:ripemd160:\'.indexOf(alg) != -1 &&\n\t    prov == \'cryptojs\') {\n\t    try {\n\t\tthis.md = eval(_CryptoJSMdName[alg]).create();\n\t    } catch (ex) {\n\t\tthrow "setAlgAndProvider hash alg set fail alg=" + alg + "/" + ex;\n\t    }\n\t    this.updateString = function(str) {\n\t\tthis.md.update(str);\n\t    };\n\t    this.updateHex = function(hex) {\n\t\tvar wHex = CryptoJS.enc.Hex.parse(hex);\n\t\tthis.md.update(wHex);\n\t    };\n\t    this.digest = function() {\n\t\tvar hash = this.md.finalize();\n\t\treturn hash.toString(CryptoJS.enc.Hex);\n\t    };\n\t    this.digestString = function(str) {\n\t\tthis.updateString(str);\n\t\treturn this.digest();\n\t    };\n\t    this.digestHex = function(hex) {\n\t\tthis.updateHex(hex);\n\t\treturn this.digest();\n\t    };\n\t}\n\tif (\':sha256:\'.indexOf(alg) != -1 &&\n\t    prov == \'sjcl\') {\n\t    try {\n\t\tthis.md = new sjcl.hash.sha256();\n\t    } catch (ex) {\n\t\tthrow "setAlgAndProvider hash alg set fail alg=" + alg + "/" + ex;\n\t    }\n\t    this.updateString = function(str) {\n\t\tthis.md.update(str);\n\t    };\n\t    this.updateHex = function(hex) {\n\t\tvar baHex = sjcl.codec.hex.toBits(hex);\n\t\tthis.md.update(baHex);\n\t    };\n\t    this.digest = function() {\n\t\tvar hash = this.md.finalize();\n\t\treturn sjcl.codec.hex.fromBits(hash);\n\t    };\n\t    this.digestString = function(str) {\n\t\tthis.updateString(str);\n\t\treturn this.digest();\n\t    };\n\t    this.digestHex = function(hex) {\n\t\tthis.updateHex(hex);\n\t\treturn this.digest();\n\t    };\n\t}\n    };\n\n    /**\n     * update digest by specified string\n     * @name updateString\n     * @memberOf KJUR.crypto.MessageDigest\n     * @function\n     * @param {String} str string to update\n     * @description\n     * @example\n     * md.updateString(\'New York\');\n     */\n    this.updateString = function(str) {\n\tthrow "updateString(str) not supported for this alg/prov: " + this.algName + "/" + this.provName;\n    };\n\n    /**\n     * update digest by specified hexadecimal string\n     * @name updateHex\n     * @memberOf KJUR.crypto.MessageDigest\n     * @function\n     * @param {String} hex hexadecimal string to update\n     * @description\n     * @example\n     * md.updateHex(\'0afe36\');\n     */\n    this.updateHex = function(hex) {\n\tthrow "updateHex(hex) not supported for this alg/prov: " + this.algName + "/" + this.provName;\n    };\n\n    /**\n     * completes hash calculation and returns hash result\n     * @name digest\n     * @memberOf KJUR.crypto.MessageDigest\n     * @function\n     * @description\n     * @example\n     * md.digest()\n     */\n    this.digest = function() {\n\tthrow "digest() not supported for this alg/prov: " + this.algName + "/" + this.provName;\n    };\n\n    /**\n     * performs final update on the digest using string, then completes the digest computation\n     * @name digestString\n     * @memberOf KJUR.crypto.MessageDigest\n     * @function\n     * @param {String} str string to final update\n     * @description\n     * @example\n     * md.digestString(\'aaa\')\n     */\n    this.digestString = function(str) {\n\tthrow "digestString(str) not supported for this alg/prov: " + this.algName + "/" + this.provName;\n    };\n\n    /**\n     * performs final update on the digest using hexadecimal string, then completes the digest computation\n     * @name digestHex\n     * @memberOf KJUR.crypto.MessageDigest\n     * @function\n     * @param {String} hex hexadecimal string to final update\n     * @description\n     * @example\n     * md.digestHex(\'0f2abd\')\n     */\n    this.digestHex = function(hex) {\n\tthrow "digestHex(hex) not supported for this alg/prov: " + this.algName + "/" + this.provName;\n    };\n\n    if (typeof params != "undefined") {\n\tif (typeof params[\'alg\'] != "undefined") {\n\t    this.algName = params[\'alg\'];\n\t    this.provName = params[\'prov\'];\n\t    this.setAlgAndProvider(params[\'alg\'], params[\'prov\']);\n\t}\n    }\n};\n\n\n/**\n * Signature class which is very similar to java.security.Signature class\n * @name KJUR.crypto.Signature\n * @class Signature class which is very similar to java.security.Signature class\n * @param {Array} params parameters for constructor\n * @property {String} state Current state of this signature object whether \'SIGN\', \'VERIFY\' or null\n * @description\n * <br/>\n * As for params of constructor\'s argument, it can be specify following attributes:\n * <ul>\n * <li>alg - signature algorithm name (ex. {MD5,SHA1,SHA224,SHA256,SHA384,SHA512,RIPEMD160}withRSA)</li>\n * <li>provider - currently \'cryptojs/jsrsa\' only</li>\n * <li>prvkeypem - PEM string of signer\'s private key. If this specified, no need to call initSign(prvKey).</li>\n * </ul>\n * <h4>SUPPORTED ALGORITHMS AND PROVIDERS</h4>\n * Signature class supports {MD5,SHA1,SHA224,SHA256,SHA384,SHA512,RIPEMD160}\n * withRSA algorithm in \'cryptojs/jsrsa\' provider.\n * <h4>EXAMPLES</h4>\n * @example\n * // signature generation\n * var sig = new KJUR.crypto.Signature({"alg": "SHA1withRSA", "prov": "cryptojs/jsrsa"});\n * sig.initSign(prvKey);\n * sig.updateString(\'aaa\');\n * var hSigVal = sig.sign();\n *\n * // signature validation\n * var sig2 = new KJUR.crypto.Signature({"alg": "SHA1withRSA", "prov": "cryptojs/jsrsa"});\n * sig2.initVerifyByCertificatePEM(cert)\n * sig.updateString(\'aaa\');\n * var isValid = sig2.verify(hSigVal);\n */\nKJUR.crypto.Signature = function(params) {\n    var prvKey = null; // RSAKey for signing\n    var pubKey = null; // RSAKey for verifying\n\n    var md = null; // KJUR.crypto.MessageDigest object\n    var sig = null;\n    var algName = null;\n    var provName = null;\n    var algProvName = null;\n    var mdAlgName = null;\n    var pubkeyAlgName = null;\n    var state = null;\n\n    var sHashHex = null; // hex hash value for hex\n    var hDigestInfo = null;\n    var hPaddedDigestInfo = null;\n    var hSign = null;\n\n    this._setAlgNames = function() {\n\tif (this.algName.match(/^(.+)with(.+)$/)) {\n\t    this.mdAlgName = RegExp.$1.toLowerCase();\n\t    this.pubkeyAlgName = RegExp.$2.toLowerCase();\n\t}\n    };\n\n    this._zeroPaddingOfSignature = function(hex, bitLength) {\n\tvar s = "";\n\tvar nZero = bitLength / 4 - hex.length;\n\tfor (var i = 0; i < nZero; i++) {\n\t    s = s + "0";\n\t}\n\treturn s + hex;\n    };\n\n    /**\n     * set signature algorithm and provider\n     * @name setAlgAndProvider\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {String} alg signature algorithm name\n     * @param {String} prov provider name\n     * @description\n     * @example\n     * md.setAlgAndProvider(\'SHA1withRSA\', \'cryptojs/jsrsa\');\n     */\n    this.setAlgAndProvider = function(alg, prov) {\n\tthis._setAlgNames();\n\tif (prov != \'cryptojs/jsrsa\')\n\t    throw "provider not supported: " + prov;\n\n\tif (\':md5:sha1:sha224:sha256:sha384:sha512:ripemd160:\'.indexOf(this.mdAlgName) != -1) {\n\t    try {\n\t\tthis.md = new KJUR.crypto.MessageDigest({\'alg\':this.mdAlgName,\'prov\':\'cryptojs\'});\n\t    } catch (ex) {\n\t\tthrow "setAlgAndProvider hash alg set fail alg=" + this.mdAlgName + "/" + ex;\n\t    }\n\n\t    this.initSign = function(prvKey) {\n\t\tthis.prvKey = prvKey;\n\t\tthis.state = "SIGN";\n\t    };\n\n\t    this.initVerifyByPublicKey = function(rsaPubKey) {\n\t\tthis.pubKey = rsaPubKey;\n\t\tthis.state = "VERIFY";\n\t    };\n\n\t    this.initVerifyByCertificatePEM = function(certPEM) {\n\t\tvar x509 = new X509();\n\t\tx509.readCertPEM(certPEM);\n\t\tthis.pubKey = x509.subjectPublicKeyRSA;\n\t\tthis.state = "VERIFY";\n\t    };\n\n\t    this.updateString = function(str) {\n\t\tthis.md.updateString(str);\n\t    };\n\t    this.updateHex = function(hex) {\n\t\tthis.md.updateHex(hex);\n\t    };\n\t    this.sign = function() {\n                var util = KJUR.crypto.Util;\n\t\tvar keyLen = this.prvKey.n.bitLength();\n\t\tthis.sHashHex = this.md.digest();\n\t\tthis.hDigestInfo = util.getDigestInfoHex(this.sHashHex, this.mdAlgName);\n\t\tthis.hPaddedDigestInfo =\n                    util.getPaddedDigestInfoHex(this.sHashHex, this.mdAlgName, keyLen);\n\n\t\tvar biPaddedDigestInfo = parseBigInt(this.hPaddedDigestInfo, 16);\n\t\tthis.hoge = biPaddedDigestInfo.toString(16);\n\n\t\tvar biSign = this.prvKey.doPrivate(biPaddedDigestInfo);\n\t\tthis.hSign = this._zeroPaddingOfSignature(biSign.toString(16), keyLen);\n\t\treturn this.hSign;\n\t    };\n\t    this.signString = function(str) {\n\t\tthis.updateString(str);\n\t\tthis.sign();\n\t    };\n\t    this.signHex = function(hex) {\n\t\tthis.updateHex(hex);\n\t\tthis.sign();\n\t    };\n\t    this.verify = function(hSigVal) {\n                var util = KJUR.crypto.Util;\n\t\tvar keyLen = this.pubKey.n.bitLength();\n\t\tthis.sHashHex = this.md.digest();\n\n\t\tvar biSigVal = parseBigInt(hSigVal, 16);\n\t\tvar biPaddedDigestInfo = this.pubKey.doPublic(biSigVal);\n\t\tthis.hPaddedDigestInfo = biPaddedDigestInfo.toString(16);\n                var s = this.hPaddedDigestInfo;\n                s = s.replace(/^1ff+00/, \'\');\n\n\t\tvar hDIHEAD = KJUR.crypto.Util.DIGESTINFOHEAD[this.mdAlgName];\n                if (s.indexOf(hDIHEAD) != 0) {\n\t\t    return false;\n\t\t}\n\t\tvar hHashFromDI = s.substr(hDIHEAD.length);\n\t\t//alert(hHashFromDI + "\\n" + this.sHashHex);\n\t\treturn (hHashFromDI == this.sHashHex);\n\t    };\n\t}\n    };\n\n    /**\n     * Initialize this object for verifying with a public key\n     * @name initVerifyByPublicKey\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {RSAKey} rsaPubKey RSAKey object of public key\n     * @since 1.0.2\n     * @description\n     * @example\n     * sig.initVerifyByPublicKey(prvKey)\n     */\n    this.initVerifyByPublicKey = function(rsaPubKey) {\n\tthrow "initVerifyByPublicKey(rsaPubKeyy) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * Initialize this object for verifying with a certficate\n     * @name initVerifyByCertificatePEM\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {String} certPEM PEM formatted string of certificate\n     * @since 1.0.2\n     * @description\n     * @example\n     * sig.initVerifyByCertificatePEM(certPEM)\n     */\n    this.initVerifyByCertificatePEM = function(certPEM) {\n\tthrow "initVerifyByCertificatePEM(certPEM) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * Initialize this object for signing\n     * @name initSign\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {RSAKey} prvKey RSAKey object of private key\n     * @description\n     * @example\n     * sig.initSign(prvKey)\n     */\n    this.initSign = function(prvKey) {\n\tthrow "initSign(prvKey) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * Updates the data to be signed or verified by a string\n     * @name updateString\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {String} str string to use for the update\n     * @description\n     * @example\n     * sig.updateString(\'aaa\')\n     */\n    this.updateString = function(str) {\n\tthrow "updateString(str) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * Updates the data to be signed or verified by a hexadecimal string\n     * @name updateHex\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {String} hex hexadecimal string to use for the update\n     * @description\n     * @example\n     * sig.updateHex(\'1f2f3f\')\n     */\n    this.updateHex = function(hex) {\n\tthrow "updateHex(hex) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * Returns the signature bytes of all data updates as a hexadecimal string\n     * @name sign\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @return the signature bytes as a hexadecimal string\n     * @description\n     * @example\n     * var hSigValue = sig.sign()\n     */\n    this.sign = function() {\n\tthrow "sign() not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * performs final update on the sign using string, then returns the signature bytes of all data updates as a hexadecimal string\n     * @name signString\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {String} str string to final update\n     * @return the signature bytes of a hexadecimal string\n     * @description\n     * @example\n     * var hSigValue = sig.signString(\'aaa\')\n     */\n    this.signString = function(str) {\n\tthrow "digestString(str) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * performs final update on the sign using hexadecimal string, then returns the signature bytes of all data updates as a hexadecimal string\n     * @name signHex\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {String} hex hexadecimal string to final update\n     * @return the signature bytes of a hexadecimal string\n     * @description\n     * @example\n     * var hSigValue = sig.signHex(\'1fdc33\')\n     */\n    this.signHex = function(hex) {\n\tthrow "digestHex(hex) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * verifies the passed-in signature.\n     * @name verify\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {String} str string to final update\n     * @return {Boolean} true if the signature was verified, otherwise false\n     * @description\n     * @example\n     * var isValid = sig.verify(\'1fbcefdca4823a7(snip)\')\n     */\n    this.verify = function(hSigVal) {\n\tthrow "verify(hSigVal) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    if (typeof params != "undefined") {\n\tif (typeof params[\'alg\'] != "undefined") {\n\t    this.algName = params[\'alg\'];\n\t    this.provName = params[\'prov\'];\n\t    this.algProvName = params[\'alg\'] + ":" + params[\'prov\'];\n\t    this.setAlgAndProvider(params[\'alg\'], params[\'prov\']);\n\t    this._setAlgNames();\n\t}\n\tif (typeof params[\'prvkeypem\'] != "undefined") {\n\t    if (typeof params[\'prvkeypas\'] != "undefined") {\n\t\tthrow "both prvkeypem and prvkeypas parameters not supported";\n\t    } else {\n\t\ttry {\n\t\t    var prvKey = new RSAKey();\n\t\t    prvKey.readPrivateKeyFromPEMString(params[\'prvkeypem\']);\n\t\t    this.initSign(prvKey);\n\t\t} catch (ex) {\n\t\t    throw "fatal error to load pem private key: " + ex;\n\t\t}\n\t    }\n\t}\n    }\n};\n\n/*! rsapem-1.1.js (c) 2012 Kenji Urushima | kjur.github.com/jsrsasign/license\n */\n//\n// rsa-pem.js - adding function for reading/writing PKCS#1 PEM private key\n//              to RSAKey class.\n//\n// version: 1.1.1 (2013-Apr-12)\n//\n// Copyright (c) 2010-2013 Kenji Urushima (kenji.urushima@gmail.com)\n//\n// This software is licensed under the terms of the MIT License.\n// http://kjur.github.com/jsrsasign/license/\n//\n// The above copyright and license notice shall be\n// included in all copies or substantial portions of the Software.\n//\n//\n// Depends on:\n//\n//\n//\n// _RSApem_pemToBase64(sPEM)\n//\n//   removing PEM header, PEM footer and space characters including\n//   new lines from PEM formatted RSA private key string.\n//\n\n/**\n * @fileOverview\n * @name rsapem-1.1.js\n * @author Kenji Urushima kenji.urushima@gmail.com\n * @version 1.1\n * @license <a href="http://kjur.github.io/jsrsasign/license/">MIT License</a>\n */\nfunction _rsapem_pemToBase64(sPEMPrivateKey) {\n  var s = sPEMPrivateKey;\n  s = s.replace("-----BEGIN RSA PRIVATE KEY-----", "");\n  s = s.replace("-----END RSA PRIVATE KEY-----", "");\n  s = s.replace(/[ \\n]+/g, "");\n  return s;\n}\n\nfunction _rsapem_getPosArrayOfChildrenFromHex(hPrivateKey) {\n  var a = new Array();\n  var v1 = ASN1HEX.getStartPosOfV_AtObj(hPrivateKey, 0);\n  var n1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, v1);\n  var e1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, n1);\n  var d1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, e1);\n  var p1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, d1);\n  var q1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, p1);\n  var dp1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, q1);\n  var dq1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, dp1);\n  var co1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, dq1);\n  a.push(v1, n1, e1, d1, p1, q1, dp1, dq1, co1);\n  return a;\n}\n\nfunction _rsapem_getHexValueArrayOfChildrenFromHex(hPrivateKey) {\n  var posArray = _rsapem_getPosArrayOfChildrenFromHex(hPrivateKey);\n  var v =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[0]);\n  var n =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[1]);\n  var e =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[2]);\n  var d =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[3]);\n  var p =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[4]);\n  var q =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[5]);\n  var dp = ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[6]);\n  var dq = ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[7]);\n  var co = ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[8]);\n  var a = new Array();\n  a.push(v, n, e, d, p, q, dp, dq, co);\n  return a;\n}\n\n/**\n * read RSA private key from a ASN.1 hexadecimal string\n * @name readPrivateKeyFromASN1HexString\n * @memberOf RSAKey#\n * @function\n * @param {String} keyHex ASN.1 hexadecimal string of PKCS#1 private key.\n * @since 1.1.1\n */\nfunction _rsapem_readPrivateKeyFromASN1HexString(keyHex) {\n  var a = _rsapem_getHexValueArrayOfChildrenFromHex(keyHex);\n  this.setPrivateEx(a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);\n}\n\n/**\n * read PKCS#1 private key from a string\n * @name readPrivateKeyFromPEMString\n * @memberOf RSAKey#\n * @function\n * @param {String} keyPEM string of PKCS#1 private key.\n */\nfunction _rsapem_readPrivateKeyFromPEMString(keyPEM) {\n  var keyB64 = _rsapem_pemToBase64(keyPEM);\n  var keyHex = b64tohex(keyB64) // depends base64.js\n  var a = _rsapem_getHexValueArrayOfChildrenFromHex(keyHex);\n  this.setPrivateEx(a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);\n}\n\nRSAKey.prototype.readPrivateKeyFromPEMString = _rsapem_readPrivateKeyFromPEMString;\nRSAKey.prototype.readPrivateKeyFromASN1HexString = _rsapem_readPrivateKeyFromASN1HexString;\n/*! rsasign-1.2.2.js (c) 2012 Kenji Urushima | kjur.github.com/jsrsasign/license\n */\n//\n// rsa-sign.js - adding signing functions to RSAKey class.\n//\n//\n// version: 1.2.2 (13 May 2013)\n//\n// Copyright (c) 2010-2013 Kenji Urushima (kenji.urushima@gmail.com)\n//\n// This software is licensed under the terms of the MIT License.\n// http://kjur.github.com/jsrsasign/license/\n//\n// The above copyright and license notice shall be\n// included in all copies or substantial portions of the Software.\n\n//\n// Depends on:\n//   function sha1.hex(s) of sha1.js\n//   jsbn.js\n//   jsbn2.js\n//   rsa.js\n//   rsa2.js\n//\n\n// keysize / pmstrlen\n//  512 /  128\n// 1024 /  256\n// 2048 /  512\n// 4096 / 1024\n\n/**\n * @fileOverview\n * @name rsasign-1.2.js\n * @author Kenji Urushima kenji.urushima@gmail.com\n * @version 1.2.2\n * @license <a href="http://kjur.github.io/jsrsasign/license/">MIT License</a>\n */\n\n/**\n * @property {Dictionary} _RSASIGN_DIHEAD\n * @description Array of head part of hexadecimal DigestInfo value for hash algorithms.\n * You can add any DigestInfo hash algorith for signing.\n * See PKCS#1 v2.1 spec (p38).\n */\nvar _RSASIGN_DIHEAD = [];\n_RSASIGN_DIHEAD[\'sha1\'] =      "3021300906052b0e03021a05000414";\n_RSASIGN_DIHEAD[\'sha256\'] =    "3031300d060960864801650304020105000420";\n_RSASIGN_DIHEAD[\'sha384\'] =    "3041300d060960864801650304020205000430";\n_RSASIGN_DIHEAD[\'sha512\'] =    "3051300d060960864801650304020305000440";\n_RSASIGN_DIHEAD[\'md2\'] =       "3020300c06082a864886f70d020205000410";\n_RSASIGN_DIHEAD[\'md5\'] =       "3020300c06082a864886f70d020505000410";\n_RSASIGN_DIHEAD[\'ripemd160\'] = "3021300906052b2403020105000414";\n\n/**\n * @property {Dictionary} _RSASIGN_HASHHEXFUNC\n * @description Array of functions which calculate hash and returns it as hexadecimal.\n * You can add any hash algorithm implementations.\n */\nvar _RSASIGN_HASHHEXFUNC = [];\n_RSASIGN_HASHHEXFUNC[\'sha1\'] =      function(s){return KJUR.crypto.Util.sha1(s);};\n_RSASIGN_HASHHEXFUNC[\'sha256\'] =    function(s){return KJUR.crypto.Util.sha256(s);}\n_RSASIGN_HASHHEXFUNC[\'sha512\'] =    function(s){return KJUR.crypto.Util.sha512(s);}\n_RSASIGN_HASHHEXFUNC[\'md5\'] =       function(s){return KJUR.crypto.Util.md5(s);};\n_RSASIGN_HASHHEXFUNC[\'ripemd160\'] = function(s){return KJUR.crypto.Util.ripemd160(s);};\n\n//_RSASIGN_HASHHEXFUNC[\'sha1\'] =   function(s){return sha1.hex(s);}   // http://user1.matsumoto.ne.jp/~goma/js/hash.html\n//_RSASIGN_HASHHEXFUNC[\'sha256\'] = function(s){return sha256.hex;}    // http://user1.matsumoto.ne.jp/~goma/js/hash.html\n\nvar _RE_HEXDECONLY = new RegExp("");\n_RE_HEXDECONLY.compile("[^0-9a-f]", "gi");\n\n// ========================================================================\n// Signature Generation\n// ========================================================================\n\nfunction _rsasign_getHexPaddedDigestInfoForString(s, keySize, hashAlg) {\n    var pmStrLen = keySize / 4;\n    var hashFunc = _RSASIGN_HASHHEXFUNC[hashAlg];\n    var sHashHex = hashFunc(s);\n\n    var sHead = "0001";\n    var sTail = "00" + _RSASIGN_DIHEAD[hashAlg] + sHashHex;\n    var sMid = "";\n    var fLen = pmStrLen - sHead.length - sTail.length;\n    for (var i = 0; i < fLen; i += 2) {\n\tsMid += "ff";\n    }\n    sPaddedMessageHex = sHead + sMid + sTail;\n    return sPaddedMessageHex;\n}\n\nfunction _zeroPaddingOfSignature(hex, bitLength) {\n    var s = "";\n    var nZero = bitLength / 4 - hex.length;\n    for (var i = 0; i < nZero; i++) {\n\ts = s + "0";\n    }\n    return s + hex;\n}\n\n/**\n * sign for a message string with RSA private key.<br/>\n * @name signString\n * @memberOf RSAKey#\n * @function\n * @param {String} s message string to be signed.\n * @param {String} hashAlg hash algorithm name for signing.<br/>\n * @return returns hexadecimal string of signature value.\n */\nfunction _rsasign_signString(s, hashAlg) {\n    //alert("this.n.bitLength() = " + this.n.bitLength());\n    var hPM = _rsasign_getHexPaddedDigestInfoForString(s, this.n.bitLength(), hashAlg);\n    var biPaddedMessage = parseBigInt(hPM, 16);\n    var biSign = this.doPrivate(biPaddedMessage);\n    var hexSign = biSign.toString(16);\n    return _zeroPaddingOfSignature(hexSign, this.n.bitLength());\n}\n\nfunction _rsasign_signStringWithSHA1(s) {\n    return _rsasign_signString.call(this, s, \'sha1\');\n}\n\nfunction _rsasign_signStringWithSHA256(s) {\n    return _rsasign_signString.call(this, s, \'sha256\');\n}\n\n// PKCS#1 (PSS) mask generation function\nfunction pss_mgf1_str(seed, len, hash) {\n    var mask = \'\', i = 0;\n\n    while (mask.length < len) {\n        mask += hash(seed + String.fromCharCode.apply(String, [\n                (i & 0xff000000) >> 24,\n                (i & 0x00ff0000) >> 16,\n                (i & 0x0000ff00) >> 8,\n                i & 0x000000ff]));\n        i += 1;\n    }\n\n    return mask;\n}\n\n/**\n * sign for a message string with RSA private key by PKCS#1 PSS signing.<br/>\n * @name signStringPSS\n * @memberOf RSAKey#\n * @function\n * @param {String} s message string to be signed.\n * @param {String} hashAlg hash algorithm name for signing.<br/>\n * @return returns hexadecimal string of signature value.\n */\nfunction _rsasign_signStringPSS(s, hashAlg, sLen) {\n    var hashFunc = _RSASIGN_HASHRAWFUNC[hashAlg];\n    var mHash = hashFunc(s);\n    var hLen = mHash.length;\n    var emBits = this.n.bitLength() - 1;\n    var emLen = Math.ceil(emBits / 8);\n    var i;\n\n    if (sLen === -1) {\n        sLen = hLen; // same has hash length\n    } else if ((sLen === -2) || (sLen === undefined)) {\n        sLen = emLen - hLen - 2; // maximum\n    } else if (sLen < -2) {\n        throw "invalid salt length";\n    }\n\n    if (emLen < (hLen + sLen + 2)) {\n        throw "data too long";\n    }\n\n    var salt = \'\';\n\n    if (sLen > 0) {\n        salt = new Array(sLen);\n        new SecureRandom().nextBytes(salt);\n        salt = String.fromCharCode.apply(String, salt);\n    }\n\n    var H = hashFunc(\'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\' + mHash + salt);\n    var PS = [];\n\n    for (i = 0; i < emLen - sLen - hLen - 2; i += 1) {\n        PS[i] = 0x00;\n    }\n\n    var DB = String.fromCharCode.apply(String, PS) + \'\\x01\' + salt;\n    var dbMask = pss_mgf1_str(H, DB.length, hashFunc);\n    var maskedDB = [];\n\n    for (i = 0; i < DB.length; i += 1) {\n        maskedDB[i] = DB.charCodeAt(i) ^ dbMask.charCodeAt(i);\n    }\n\n    var mask = (0xff00 >> (8 * emLen - emBits)) & 0xff;\n    maskedDB[0] &= ~mask;\n\n    for (i = 0; i < hLen; i++) {\n        maskedDB.push(H.charCodeAt(i));\n    }\n\n    maskedDB.push(0xbc);\n\n    return _zeroPaddingOfSignature(\n            this.doPrivate(new BigInteger(maskedDB)).toString(16),\n            this.n.bitLength());\n}\n\n// ========================================================================\n// Signature Verification\n// ========================================================================\n\nfunction _rsasign_getDecryptSignatureBI(biSig, hN, hE) {\n    var rsa = new RSAKey();\n    rsa.setPublic(hN, hE);\n    var biDecryptedSig = rsa.doPublic(biSig);\n    return biDecryptedSig;\n}\n\nfunction _rsasign_getHexDigestInfoFromSig(biSig, hN, hE) {\n    var biDecryptedSig = _rsasign_getDecryptSignatureBI(biSig, hN, hE);\n    var hDigestInfo = biDecryptedSig.toString(16).replace(/^1f+00/, \'\');\n    return hDigestInfo;\n}\n\nfunction _rsasign_getAlgNameAndHashFromHexDisgestInfo(hDigestInfo) {\n    for (var algName in _RSASIGN_DIHEAD) {\n\tvar head = _RSASIGN_DIHEAD[algName];\n\tvar len = head.length;\n\tif (hDigestInfo.substring(0, len) == head) {\n\t    var a = [algName, hDigestInfo.substring(len)];\n\t    return a;\n\t}\n    }\n    return [];\n}\n\nfunction _rsasign_verifySignatureWithArgs(sMsg, biSig, hN, hE) {\n    var hDigestInfo = _rsasign_getHexDigestInfoFromSig(biSig, hN, hE);\n    var digestInfoAry = _rsasign_getAlgNameAndHashFromHexDisgestInfo(hDigestInfo);\n    if (digestInfoAry.length == 0) return false;\n    var algName = digestInfoAry[0];\n    var diHashValue = digestInfoAry[1];\n    var ff = _RSASIGN_HASHHEXFUNC[algName];\n    var msgHashValue = ff(sMsg);\n    return (diHashValue == msgHashValue);\n}\n\nfunction _rsasign_verifyHexSignatureForMessage(hSig, sMsg) {\n    var biSig = parseBigInt(hSig, 16);\n    var result = _rsasign_verifySignatureWithArgs(sMsg, biSig,\n\t\t\t\t\t\t  this.n.toString(16),\n\t\t\t\t\t\t  this.e.toString(16));\n    return result;\n}\n\n/**\n * verifies a sigature for a message string with RSA public key.<br/>\n * @name verifyString\n * @memberOf RSAKey#\n * @function\n * @param {String} sMsg message string to be verified.\n * @param {String} hSig hexadecimal string of siganture.<br/>\n *                 non-hexadecimal charactors including new lines will be ignored.\n * @return returns 1 if valid, otherwise 0\n */\nfunction _rsasign_verifyString(sMsg, hSig) {\n    hSig = hSig.replace(_RE_HEXDECONLY, \'\');\n    if (hSig.length != this.n.bitLength() / 4) return 0;\n    hSig = hSig.replace(/[ \\n]+/g, "");\n    var biSig = parseBigInt(hSig, 16);\n    var biDecryptedSig = this.doPublic(biSig);\n    var hDigestInfo = biDecryptedSig.toString(16).replace(/^1f+00/, \'\');\n    var digestInfoAry = _rsasign_getAlgNameAndHashFromHexDisgestInfo(hDigestInfo);\n\n    if (digestInfoAry.length == 0) return false;\n    var algName = digestInfoAry[0];\n    var diHashValue = digestInfoAry[1];\n    var ff = _RSASIGN_HASHHEXFUNC[algName];\n    var msgHashValue = ff(sMsg);\n    return (diHashValue == msgHashValue);\n}\n\n/**\n * verifies a sigature for a message string with RSA public key by PKCS#1 PSS sign.<br/>\n * @name verifyStringPSS\n * @memberOf RSAKey#\n * @function\n * @param {String} sMsg message string to be verified.\n * @param {String} hSig hexadecimal string of siganture.<br/>\n *                 non-hexadecimal charactors including new lines will be ignored.\n * @return returns 1 if valid, otherwise 0\n */\nfunction _rsasign_verifyStringPSS(sMsg, hSig, hashAlg, sLen) {\n    if (hSig.length !== this.n.bitLength() / 4) {\n        return false;\n    }\n\n    var hashFunc = _RSASIGN_HASHRAWFUNC[hashAlg];\n    var mHash = hashFunc(sMsg);\n    var hLen = mHash.length;\n    var emBits = this.n.bitLength() - 1;\n    var emLen = Math.ceil(emBits / 8);\n    var i;\n\n    if (sLen === -1) {\n        sLen = hLen; // same has hash length\n    } else if ((sLen === -2) || (sLen === undefined)) {\n        sLen = emLen - hLen - 2; // maximum\n    } else if (sLen < -2) {\n        throw "invalid salt length";\n    }\n\n    if (emLen < (hLen + sLen + 2)) {\n        throw "data too long";\n    }\n\n    var em = this.doPublic(parseBigInt(hSig, 16)).toByteArray();\n\n    for (i = 0; i < em.length; i += 1) {\n        em[i] &= 0xff;\n    }\n\n    while (em.length < emLen) {\n        em.unshift(0);\n    }\n\n    if (em[emLen -1] !== 0xbc) {\n        throw "encoded message does not end in 0xbc";\n    }\n\n    em = String.fromCharCode.apply(String, em);\n\n    var maskedDB = em.substr(0, emLen - hLen - 1);\n    var H = em.substr(maskedDB.length, hLen);\n\n    var mask = (0xff00 >> (8 * emLen - emBits)) & 0xff;\n\n    if ((maskedDB.charCodeAt(0) & mask) !== 0) {\n        throw "bits beyond keysize not zero";\n    }\n\n    var dbMask = pss_mgf1_str(H, maskedDB.length, hashFunc);\n    var DB = [];\n\n    for (i = 0; i < maskedDB.length; i += 1) {\n        DB[i] = maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i);\n    }\n\n    DB[0] &= ~mask;\n\n    var checkLen = emLen - hLen - sLen - 2;\n\n    for (i = 0; i < checkLen; i += 1) {\n        if (DB[i] !== 0x00) {\n            throw "leftmost octets not zero";\n        }\n    }\n\n    if (DB[checkLen] !== 0x01) {\n        throw "0x01 marker not found";\n    }\n\n    return H === hashFunc(\'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\' + mHash +\n                          String.fromCharCode.apply(String, DB.slice(-sLen)));\n}\n\nRSAKey.prototype.signString = _rsasign_signString;\nRSAKey.prototype.signStringWithSHA1 = _rsasign_signStringWithSHA1;\nRSAKey.prototype.signStringWithSHA256 = _rsasign_signStringWithSHA256;\nRSAKey.prototype.sign = _rsasign_signString;\nRSAKey.prototype.signWithSHA1 = _rsasign_signStringWithSHA1;\nRSAKey.prototype.signWithSHA256 = _rsasign_signStringWithSHA256;\nRSAKey.prototype.signStringPSS = _rsasign_signStringPSS;\nRSAKey.prototype.signPSS = _rsasign_signStringPSS;\nRSAKey.SALT_LEN_HLEN = -1;\nRSAKey.SALT_LEN_MAX = -2;\n\nRSAKey.prototype.verifyString = _rsasign_verifyString;\nRSAKey.prototype.verifyHexSignatureForMessage = _rsasign_verifyHexSignatureForMessage;\nRSAKey.prototype.verify = _rsasign_verifyString;\nRSAKey.prototype.verifyHexSignatureForByteArrayMessage = _rsasign_verifyHexSignatureForMessage;\nRSAKey.prototype.verifyStringPSS = _rsasign_verifyStringPSS;\nRSAKey.prototype.verifyPSS = _rsasign_verifyStringPSS;\nRSAKey.SALT_LEN_RECOVER = -2;\n\n/**\n * @name RSAKey\n * @class key of RSA public key algorithm\n * @description Tom Wu\'s RSA Key class and extension\n */\n/*! asn1hex-1.1.js (c) 2012 Kenji Urushima | kjur.github.com/jsrsasign/license\n */\n//\n// asn1hex.js - Hexadecimal represented ASN.1 string library\n//\n// version: 1.1 (09-May-2012)\n//\n// Copyright (c) 2010-2012 Kenji Urushima (kenji.urushima@gmail.com)\n//\n// This software is licensed under the terms of the MIT License.\n// http://kjur.github.com/jsrsasign/license/\n//\n// The above copyright and license notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// Depends on:\n//\n\n// MEMO:\n//   f(\'3082025b02...\', 2) ... 82025b ... 3bytes\n//   f(\'020100\', 2) ... 01 ... 1byte\n//   f(\'0203001...\', 2) ... 03 ... 1byte\n//   f(\'02818003...\', 2) ... 8180 ... 2bytes\n//   f(\'3080....0000\', 2) ... 80 ... -1\n//\n//   Requirements:\n//   - ASN.1 type octet length MUST be 1.\n//     (i.e. ASN.1 primitives like SET, SEQUENCE, INTEGER, OCTETSTRING ...)\n//   -\n\n/**\n * @fileOverview\n * @name asn1hex-1.1.js\n * @author Kenji Urushima kenji.urushima@gmail.com\n * @version 1.1\n * @license <a href="http://kjur.github.io/jsrsasign/license/">MIT License</a>\n */\n\n/**\n * get byte length for ASN.1 L(length) bytes\n * @name getByteLengthOfL_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} pos string index\n * @return byte length for ASN.1 L(length) bytes\n */\nfunction _asnhex_getByteLengthOfL_AtObj(s, pos) {\n  if (s.substring(pos + 2, pos + 3) != \'8\') return 1;\n  var i = parseInt(s.substring(pos + 3, pos + 4));\n  if (i == 0) return -1; \t\t// length octet \'80\' indefinite length\n  if (0 < i && i < 10) return i + 1;\t// including \'8?\' octet;\n  return -2;\t\t\t\t// malformed format\n}\n\n\n/**\n * get hexadecimal string for ASN.1 L(length) bytes\n * @name getHexOfL_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} pos string index\n * @return {String} hexadecimal string for ASN.1 L(length) bytes\n */\nfunction _asnhex_getHexOfL_AtObj(s, pos) {\n  var len = _asnhex_getByteLengthOfL_AtObj(s, pos);\n  if (len < 1) return \'\';\n  return s.substring(pos + 2, pos + 2 + len * 2);\n}\n\n//\n//   getting ASN.1 length value at the position \'idx\' of\n//   hexa decimal string \'s\'.\n//\n//   f(\'3082025b02...\', 0) ... 82025b ... ???\n//   f(\'020100\', 0) ... 01 ... 1\n//   f(\'0203001...\', 0) ... 03 ... 3\n//   f(\'02818003...\', 0) ... 8180 ... 128\n/**\n * get integer value of ASN.1 length for ASN.1 data\n * @name getIntOfL_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} pos string index\n * @return ASN.1 L(length) integer value\n */\nfunction _asnhex_getIntOfL_AtObj(s, pos) {\n  var hLength = _asnhex_getHexOfL_AtObj(s, pos);\n  if (hLength == \'\') return -1;\n  var bi;\n  if (parseInt(hLength.substring(0, 1)) < 8) {\n     bi = parseBigInt(hLength, 16);\n  } else {\n     bi = parseBigInt(hLength.substring(2), 16);\n  }\n  return bi.intValue();\n}\n\n/**\n * get ASN.1 value starting string position for ASN.1 object refered by index \'idx\'.\n * @name getStartPosOfV_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} pos string index\n */\nfunction _asnhex_getStartPosOfV_AtObj(s, pos) {\n  var l_len = _asnhex_getByteLengthOfL_AtObj(s, pos);\n  if (l_len < 0) return l_len;\n  return pos + (l_len + 1) * 2;\n}\n\n/**\n * get hexadecimal string of ASN.1 V(value)\n * @name getHexOfV_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} pos string index\n * @return {String} hexadecimal string of ASN.1 value.\n */\nfunction _asnhex_getHexOfV_AtObj(s, pos) {\n  var pos1 = _asnhex_getStartPosOfV_AtObj(s, pos);\n  var len = _asnhex_getIntOfL_AtObj(s, pos);\n  return s.substring(pos1, pos1 + len * 2);\n}\n\n/**\n * get hexadecimal string of ASN.1 TLV at\n * @name getHexOfTLV_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} pos string index\n * @return {String} hexadecimal string of ASN.1 TLV.\n * @since 1.1\n */\nfunction _asnhex_getHexOfTLV_AtObj(s, pos) {\n  var hT = s.substr(pos, 2);\n  var hL = _asnhex_getHexOfL_AtObj(s, pos);\n  var hV = _asnhex_getHexOfV_AtObj(s, pos);\n  return hT + hL + hV;\n}\n\n/**\n * get next sibling starting index for ASN.1 object string\n * @name getPosOfNextSibling_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} pos string index\n * @return next sibling starting index for ASN.1 object string\n */\nfunction _asnhex_getPosOfNextSibling_AtObj(s, pos) {\n  var pos1 = _asnhex_getStartPosOfV_AtObj(s, pos);\n  var len = _asnhex_getIntOfL_AtObj(s, pos);\n  return pos1 + len * 2;\n}\n\n/**\n * get array of indexes of child ASN.1 objects\n * @name getPosArrayOfChildren_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} start string index of ASN.1 object\n * @return {Array of Number} array of indexes for childen of ASN.1 objects\n */\nfunction _asnhex_getPosArrayOfChildren_AtObj(h, pos) {\n  var a = new Array();\n  var p0 = _asnhex_getStartPosOfV_AtObj(h, pos);\n  a.push(p0);\n\n  var len = _asnhex_getIntOfL_AtObj(h, pos);\n  var p = p0;\n  var k = 0;\n  while (1) {\n    var pNext = _asnhex_getPosOfNextSibling_AtObj(h, p);\n    if (pNext == null || (pNext - p0  >= (len * 2))) break;\n    if (k >= 200) break;\n\n    a.push(pNext);\n    p = pNext;\n\n    k++;\n  }\n\n  return a;\n}\n\n/**\n * get string index of nth child object of ASN.1 object refered by h, idx\n * @name getNthChildIndex_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} h hexadecimal string of ASN.1 DER encoded data\n * @param {Number} idx start string index of ASN.1 object\n * @param {Number} nth for child\n * @return {Number} string index of nth child.\n * @since 1.1\n */\nfunction _asnhex_getNthChildIndex_AtObj(h, idx, nth) {\n  var a = _asnhex_getPosArrayOfChildren_AtObj(h, idx);\n  return a[nth];\n}\n\n// ========== decendant methods ==============================\n\n/**\n * get string index of nth child object of ASN.1 object refered by h, idx\n * @name getDecendantIndexByNthList\n * @memberOf ASN1HEX\n * @function\n * @param {String} h hexadecimal string of ASN.1 DER encoded data\n * @param {Number} currentIndex start string index of ASN.1 object\n * @param {Array of Number} nthList array list of nth\n * @return {Number} string index refered by nthList\n * @since 1.1\n */\nfunction _asnhex_getDecendantIndexByNthList(h, currentIndex, nthList) {\n  if (nthList.length == 0) {\n    return currentIndex;\n  }\n  var firstNth = nthList.shift();\n  var a = _asnhex_getPosArrayOfChildren_AtObj(h, currentIndex);\n  return _asnhex_getDecendantIndexByNthList(h, a[firstNth], nthList);\n}\n\n/**\n * get hexadecimal string of ASN.1 TLV refered by current index and nth index list.\n * @name getDecendantHexTLVByNthList\n * @memberOf ASN1HEX\n * @function\n * @param {String} h hexadecimal string of ASN.1 DER encoded data\n * @param {Number} currentIndex start string index of ASN.1 object\n * @param {Array of Number} nthList array list of nth\n * @return {Number} hexadecimal string of ASN.1 TLV refered by nthList\n * @since 1.1\n */\nfunction _asnhex_getDecendantHexTLVByNthList(h, currentIndex, nthList) {\n  var idx = _asnhex_getDecendantIndexByNthList(h, currentIndex, nthList);\n  return _asnhex_getHexOfTLV_AtObj(h, idx);\n}\n\n/**\n * get hexadecimal string of ASN.1 V refered by current index and nth index list.\n * @name getDecendantHexVByNthList\n * @memberOf ASN1HEX\n * @function\n * @param {String} h hexadecimal string of ASN.1 DER encoded data\n * @param {Number} currentIndex start string index of ASN.1 object\n * @param {Array of Number} nthList array list of nth\n * @return {Number} hexadecimal string of ASN.1 V refered by nthList\n * @since 1.1\n */\nfunction _asnhex_getDecendantHexVByNthList(h, currentIndex, nthList) {\n  var idx = _asnhex_getDecendantIndexByNthList(h, currentIndex, nthList);\n  return _asnhex_getHexOfV_AtObj(h, idx);\n}\n\n// ========== class definition ==============================\n\n/**\n * ASN.1 DER encoded hexadecimal string utility class\n * @class ASN.1 DER encoded hexadecimal string utility class\n * @author Kenji Urushima\n * @version 1.1 (09 May 2012)\n * @see <a href="http://kjur.github.com/jsrsasigns/">\'jwrsasign\'(RSA Sign JavaScript Library) home page http://kjur.github.com/jsrsasign/</a>\n * @since 1.1\n */\nfunction ASN1HEX() {\n  return ASN1HEX;\n}\n\nASN1HEX.getByteLengthOfL_AtObj = _asnhex_getByteLengthOfL_AtObj;\nASN1HEX.getHexOfL_AtObj = _asnhex_getHexOfL_AtObj;\nASN1HEX.getIntOfL_AtObj = _asnhex_getIntOfL_AtObj;\nASN1HEX.getStartPosOfV_AtObj = _asnhex_getStartPosOfV_AtObj;\nASN1HEX.getHexOfV_AtObj = _asnhex_getHexOfV_AtObj;\nASN1HEX.getHexOfTLV_AtObj = _asnhex_getHexOfTLV_AtObj;\nASN1HEX.getPosOfNextSibling_AtObj = _asnhex_getPosOfNextSibling_AtObj;\nASN1HEX.getPosArrayOfChildren_AtObj = _asnhex_getPosArrayOfChildren_AtObj;\nASN1HEX.getNthChildIndex_AtObj = _asnhex_getNthChildIndex_AtObj;\nASN1HEX.getDecendantIndexByNthList = _asnhex_getDecendantIndexByNthList;\nASN1HEX.getDecendantHexVByNthList = _asnhex_getDecendantHexVByNthList;\nASN1HEX.getDecendantHexTLVByNthList = _asnhex_getDecendantHexTLVByNthList;\n/*! x509-1.1.js (c) 2012 Kenji Urushima | kjur.github.com/jsrsasign/license\n */\n//\n// x509.js - X509 class to read subject public key from certificate.\n//\n// version: 1.1 (10-May-2012)\n//\n// Copyright (c) 2010-2012 Kenji Urushima (kenji.urushima@gmail.com)\n//\n// This software is licensed under the terms of the MIT License.\n// http://kjur.github.com/jsrsasign/license\n//\n// The above copyright and license notice shall be\n// included in all copies or substantial portions of the Software.\n//\n\n// Depends:\n//   base64.js\n//   rsa.js\n//   asn1hex.js\n\n/**\n * @fileOverview\n * @name x509-1.1.js\n * @author Kenji Urushima kenji.urushima@gmail.com\n * @version 1.1\n * @license <a href="http://kjur.github.io/jsrsasign/license/">MIT License</a>\n */\n\nfunction _x509_pemToBase64(sCertPEM) {\n  var s = sCertPEM;\n  s = s.replace("-----BEGIN CERTIFICATE-----", "");\n  s = s.replace("-----END CERTIFICATE-----", "");\n  s = s.replace(/[ \\n]+/g, "");\n  return s;\n}\n\nfunction _x509_pemToHex(sCertPEM) {\n  var b64Cert = _x509_pemToBase64(sCertPEM);\n  var hCert = b64tohex(b64Cert);\n  return hCert;\n}\n\nfunction _x509_getHexTbsCertificateFromCert(hCert) {\n  var pTbsCert = ASN1HEX.getStartPosOfV_AtObj(hCert, 0);\n  return pTbsCert;\n}\n\n// NOTE: privateKeyUsagePeriod field of X509v2 not supported.\n// NOTE: v1 and v3 supported\nfunction _x509_getSubjectPublicKeyInfoPosFromCertHex(hCert) {\n  var pTbsCert = ASN1HEX.getStartPosOfV_AtObj(hCert, 0);\n  var a = ASN1HEX.getPosArrayOfChildren_AtObj(hCert, pTbsCert);\n  if (a.length < 1) return -1;\n  if (hCert.substring(a[0], a[0] + 10) == "a003020102") { // v3\n    if (a.length < 6) return -1;\n    return a[6];\n  } else {\n    if (a.length < 5) return -1;\n    return a[5];\n  }\n}\n\n// NOTE: Without BITSTRING encapsulation.\nfunction _x509_getSubjectPublicKeyPosFromCertHex(hCert) {\n  var pInfo = _x509_getSubjectPublicKeyInfoPosFromCertHex(hCert);\n  if (pInfo == -1) return -1;\n  var a = ASN1HEX.getPosArrayOfChildren_AtObj(hCert, pInfo);\n  if (a.length != 2) return -1;\n  var pBitString = a[1];\n  if (hCert.substring(pBitString, pBitString + 2) != \'03\') return -1;\n  var pBitStringV = ASN1HEX.getStartPosOfV_AtObj(hCert, pBitString);\n\n  if (hCert.substring(pBitStringV, pBitStringV + 2) != \'00\') return -1;\n  return pBitStringV + 2;\n}\n\nfunction _x509_getPublicKeyHexArrayFromCertHex(hCert) {\n  var p = _x509_getSubjectPublicKeyPosFromCertHex(hCert);\n  var a = ASN1HEX.getPosArrayOfChildren_AtObj(hCert, p);\n  if (a.length != 2) return [];\n  var hN = ASN1HEX.getHexOfV_AtObj(hCert, a[0]);\n  var hE = ASN1HEX.getHexOfV_AtObj(hCert, a[1]);\n  if (hN != null && hE != null) {\n    return [hN, hE];\n  } else {\n    return [];\n  }\n}\n\nfunction _x509_getPublicKeyHexArrayFromCertPEM(sCertPEM) {\n  var hCert = _x509_pemToHex(sCertPEM);\n  var a = _x509_getPublicKeyHexArrayFromCertHex(hCert);\n  return a;\n}\n\n// ===== get basic fields from hex =====================================\n/**\n * get hexadecimal string of serialNumber field of certificate.<br/>\n * @name getSerialNumberHex\n * @memberOf X509#\n * @function\n */\nfunction _x509_getSerialNumberHex() {\n  return ASN1HEX.getDecendantHexVByNthList(this.hex, 0, [0, 1]);\n}\n\n/**\n * get hexadecimal string of issuer field of certificate.<br/>\n * @name getIssuerHex\n * @memberOf X509#\n * @function\n */\nfunction _x509_getIssuerHex() {\n  return ASN1HEX.getDecendantHexTLVByNthList(this.hex, 0, [0, 3]);\n}\n\n/**\n * get string of issuer field of certificate.<br/>\n * @name getIssuerString\n * @memberOf X509#\n * @function\n */\nfunction _x509_getIssuerString() {\n  return _x509_hex2dn(ASN1HEX.getDecendantHexTLVByNthList(this.hex, 0, [0, 3]));\n}\n\n/**\n * get hexadecimal string of subject field of certificate.<br/>\n * @name getSubjectHex\n * @memberOf X509#\n * @function\n */\nfunction _x509_getSubjectHex() {\n  return ASN1HEX.getDecendantHexTLVByNthList(this.hex, 0, [0, 5]);\n}\n\n/**\n * get string of subject field of certificate.<br/>\n * @name getSubjectString\n * @memberOf X509#\n * @function\n */\nfunction _x509_getSubjectString() {\n  return _x509_hex2dn(ASN1HEX.getDecendantHexTLVByNthList(this.hex, 0, [0, 5]));\n}\n\n/**\n * get notBefore field string of certificate.<br/>\n * @name getNotBefore\n * @memberOf X509#\n * @function\n */\nfunction _x509_getNotBefore() {\n  var s = ASN1HEX.getDecendantHexVByNthList(this.hex, 0, [0, 4, 0]);\n  s = s.replace(/(..)/g, "%$1");\n  s = decodeURIComponent(s);\n  return s;\n}\n\n/**\n * get notAfter field string of certificate.<br/>\n * @name getNotAfter\n * @memberOf X509#\n * @function\n */\nfunction _x509_getNotAfter() {\n  var s = ASN1HEX.getDecendantHexVByNthList(this.hex, 0, [0, 4, 1]);\n  s = s.replace(/(..)/g, "%$1");\n  s = decodeURIComponent(s);\n  return s;\n}\n\n// ===== read certificate =====================================\n\n_x509_DN_ATTRHEX = {\n    "0603550406": "C",\n    "060355040a": "O",\n    "060355040b": "OU",\n    "0603550403": "CN",\n    "0603550405": "SN",\n    "0603550408": "ST",\n    "0603550407": "L" };\n\nfunction _x509_hex2dn(hDN) {\n  var s = "";\n  var a = ASN1HEX.getPosArrayOfChildren_AtObj(hDN, 0);\n  for (var i = 0; i < a.length; i++) {\n    var hRDN = ASN1HEX.getHexOfTLV_AtObj(hDN, a[i]);\n    s = s + "/" + _x509_hex2rdn(hRDN);\n  }\n  return s;\n}\n\nfunction _x509_hex2rdn(hRDN) {\n    var hType = ASN1HEX.getDecendantHexTLVByNthList(hRDN, 0, [0, 0]);\n    var hValue = ASN1HEX.getDecendantHexVByNthList(hRDN, 0, [0, 1]);\n    var type = "";\n    try { type = _x509_DN_ATTRHEX[hType]; } catch (ex) { type = hType; }\n    hValue = hValue.replace(/(..)/g, "%$1");\n    var value = decodeURIComponent(hValue);\n    return type + "=" + value;\n}\n\n// ===== read certificate =====================================\n\n\n/**\n * read PEM formatted X.509 certificate from string.<br/>\n * @name readCertPEM\n * @memberOf X509#\n * @function\n * @param {String} sCertPEM string for PEM formatted X.509 certificate\n */\nfunction _x509_readCertPEM(sCertPEM) {\n  var hCert = _x509_pemToHex(sCertPEM);\n  var a = _x509_getPublicKeyHexArrayFromCertHex(hCert);\n  var rsa = new RSAKey();\n  rsa.setPublic(a[0], a[1]);\n  this.subjectPublicKeyRSA = rsa;\n  this.subjectPublicKeyRSA_hN = a[0];\n  this.subjectPublicKeyRSA_hE = a[1];\n  this.hex = hCert;\n}\n\nfunction _x509_readCertPEMWithoutRSAInit(sCertPEM) {\n  var hCert = _x509_pemToHex(sCertPEM);\n  var a = _x509_getPublicKeyHexArrayFromCertHex(hCert);\n  this.subjectPublicKeyRSA.setPublic(a[0], a[1]);\n  this.subjectPublicKeyRSA_hN = a[0];\n  this.subjectPublicKeyRSA_hE = a[1];\n  this.hex = hCert;\n}\n\n/**\n * X.509 certificate class.<br/>\n * @class X.509 certificate class\n * @property {RSAKey} subjectPublicKeyRSA Tom Wu\'s RSAKey object\n * @property {String} subjectPublicKeyRSA_hN hexadecimal string for modulus of RSA public key\n * @property {String} subjectPublicKeyRSA_hE hexadecimal string for public exponent of RSA public key\n * @property {String} hex hexacedimal string for X.509 certificate.\n * @author Kenji Urushima\n * @version 1.0.1 (08 May 2012)\n * @see <a href="http://kjur.github.com/jsrsasigns/">\'jwrsasign\'(RSA Sign JavaScript Library) home page http://kjur.github.com/jsrsasign/</a>\n */\nfunction X509() {\n  this.subjectPublicKeyRSA = null;\n  this.subjectPublicKeyRSA_hN = null;\n  this.subjectPublicKeyRSA_hE = null;\n  this.hex = null;\n}\n\nX509.prototype.readCertPEM = _x509_readCertPEM;\nX509.prototype.readCertPEMWithoutRSAInit = _x509_readCertPEMWithoutRSAInit;\nX509.prototype.getSerialNumberHex = _x509_getSerialNumberHex;\nX509.prototype.getIssuerHex = _x509_getIssuerHex;\nX509.prototype.getSubjectHex = _x509_getSubjectHex;\nX509.prototype.getIssuerString = _x509_getIssuerString;\nX509.prototype.getSubjectString = _x509_getSubjectString;\nX509.prototype.getNotBefore = _x509_getNotBefore;\nX509.prototype.getNotAfter = _x509_getNotAfter;\n\n// Copyright (c) 2005  Tom Wu\n// All Rights Reserved.\n// See "LICENSE" for details.\n\n// Basic JavaScript BN library - subset useful for RSA encryption.\n\n// Bits per digit\nvar dbits;\n\n// JavaScript engine analysis\nvar canary = 0xdeadbeefcafe;\nvar j_lm = ((canary&0xffffff)==0xefcafe);\n\n// (public) Constructor\nfunction BigInteger(a,b,c) {\n  if(a != null)\n    if("number" == typeof a) this.fromNumber(a,b,c);\n    else if(b == null && "string" != typeof a) this.fromString(a,256);\n    else this.fromString(a,b);\n}\n\n// return new, unset BigInteger\nfunction nbi() { return new BigInteger(null); }\n\n// am: Compute w_j += (x*this_i), propagate carries,\n// c is initial carry, returns final carry.\n// c < 3*dvalue, x < 2*dvalue, this_i < dvalue\n// We need to select the fastest one that works in this environment.\n\n// am1: use a single mult and divide to get the high bits,\n// max digit bits should be 26 because\n// max internal value = 2*dvalue^2-2*dvalue (< 2^53)\nfunction am1(i,x,w,j,c,n) {\n  while(--n >= 0) {\n    var v = x*this[i++]+w[j]+c;\n    c = Math.floor(v/0x4000000);\n    w[j++] = v&0x3ffffff;\n  }\n  return c;\n}\n// am2 avoids a big mult-and-extract completely.\n// Max digit bits should be <= 30 because we do bitwise ops\n// on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)\nfunction am2(i,x,w,j,c,n) {\n  var xl = x&0x7fff, xh = x>>15;\n  while(--n >= 0) {\n    var l = this[i]&0x7fff;\n    var h = this[i++]>>15;\n    var m = xh*l+h*xl;\n    l = xl*l+((m&0x7fff)<<15)+w[j]+(c&0x3fffffff);\n    c = (l>>>30)+(m>>>15)+xh*h+(c>>>30);\n    w[j++] = l&0x3fffffff;\n  }\n  return c;\n}\n// Alternately, set max digit bits to 28 since some\n// browsers slow down when dealing with 32-bit numbers.\nfunction am3(i,x,w,j,c,n) {\n  var xl = x&0x3fff, xh = x>>14;\n  while(--n >= 0) {\n    var l = this[i]&0x3fff;\n    var h = this[i++]>>14;\n    var m = xh*l+h*xl;\n    l = xl*l+((m&0x3fff)<<14)+w[j]+c;\n    c = (l>>28)+(m>>14)+xh*h;\n    w[j++] = l&0xfffffff;\n  }\n  return c;\n}\nif(j_lm && (navigator.appName == "Microsoft Internet Explorer")) {\n  BigInteger.prototype.am = am2;\n  dbits = 30;\n}\nelse if(j_lm && (navigator.appName != "Netscape")) {\n  BigInteger.prototype.am = am1;\n  dbits = 26;\n}\nelse { // Mozilla/Netscape seems to prefer am3\n  BigInteger.prototype.am = am3;\n  dbits = 28;\n}\n\nBigInteger.prototype.DB = dbits;\nBigInteger.prototype.DM = ((1<<dbits)-1);\nBigInteger.prototype.DV = (1<<dbits);\n\nvar BI_FP = 52;\nBigInteger.prototype.FV = Math.pow(2,BI_FP);\nBigInteger.prototype.F1 = BI_FP-dbits;\nBigInteger.prototype.F2 = 2*dbits-BI_FP;\n\n// Digit conversions\nvar BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";\nvar BI_RC = new Array();\nvar rr,vv;\nrr = "0".charCodeAt(0);\nfor(vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;\nrr = "a".charCodeAt(0);\nfor(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\nrr = "A".charCodeAt(0);\nfor(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n\nfunction int2char(n) { return BI_RM.charAt(n); }\nfunction intAt(s,i) {\n  var c = BI_RC[s.charCodeAt(i)];\n  return (c==null)?-1:c;\n}\n\n// (protected) copy this to r\nfunction bnpCopyTo(r) {\n  for(var i = this.t-1; i >= 0; --i) r[i] = this[i];\n  r.t = this.t;\n  r.s = this.s;\n}\n\n// (protected) set from integer value x, -DV <= x < DV\nfunction bnpFromInt(x) {\n  this.t = 1;\n  this.s = (x<0)?-1:0;\n  if(x > 0) this[0] = x;\n  else if(x < -1) this[0] = x+DV;\n  else this.t = 0;\n}\n\n// return bigint initialized to value\nfunction nbv(i) { var r = nbi(); r.fromInt(i); return r; }\n\n// (protected) set from string and radix\nfunction bnpFromString(s,b) {\n  var k;\n  if(b == 16) k = 4;\n  else if(b == 8) k = 3;\n  else if(b == 256) k = 8; // byte array\n  else if(b == 2) k = 1;\n  else if(b == 32) k = 5;\n  else if(b == 4) k = 2;\n  else { this.fromRadix(s,b); return; }\n  this.t = 0;\n  this.s = 0;\n  var i = s.length, mi = false, sh = 0;\n  while(--i >= 0) {\n    var x = (k==8)?s[i]&0xff:intAt(s,i);\n    if(x < 0) {\n      if(s.charAt(i) == "-") mi = true;\n      continue;\n    }\n    mi = false;\n    if(sh == 0)\n      this[this.t++] = x;\n    else if(sh+k > this.DB) {\n      this[this.t-1] |= (x&((1<<(this.DB-sh))-1))<<sh;\n      this[this.t++] = (x>>(this.DB-sh));\n    }\n    else\n      this[this.t-1] |= x<<sh;\n    sh += k;\n    if(sh >= this.DB) sh -= this.DB;\n  }\n  if(k == 8 && (s[0]&0x80) != 0) {\n    this.s = -1;\n    if(sh > 0) this[this.t-1] |= ((1<<(this.DB-sh))-1)<<sh;\n  }\n  this.clamp();\n  if(mi) BigInteger.ZERO.subTo(this,this);\n}\n\n// (protected) clamp off excess high words\nfunction bnpClamp() {\n  var c = this.s&this.DM;\n  while(this.t > 0 && this[this.t-1] == c) --this.t;\n}\n\n// (public) return string representation in given radix\nfunction bnToString(b) {\n  if(this.s < 0) return "-"+this.negate().toString(b);\n  var k;\n  if(b == 16) k = 4;\n  else if(b == 8) k = 3;\n  else if(b == 2) k = 1;\n  else if(b == 32) k = 5;\n  else if(b == 4) k = 2;\n  else return this.toRadix(b);\n  var km = (1<<k)-1, d, m = false, r = "", i = this.t;\n  var p = this.DB-(i*this.DB)%k;\n  if(i-- > 0) {\n    if(p < this.DB && (d = this[i]>>p) > 0) { m = true; r = int2char(d); }\n    while(i >= 0) {\n      if(p < k) {\n        d = (this[i]&((1<<p)-1))<<(k-p);\n        d |= this[--i]>>(p+=this.DB-k);\n      }\n      else {\n        d = (this[i]>>(p-=k))&km;\n        if(p <= 0) { p += this.DB; --i; }\n      }\n      if(d > 0) m = true;\n      if(m) r += int2char(d);\n    }\n  }\n  return m?r:"0";\n}\n\n// (public) -this\nfunction bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; }\n\n// (public) |this|\nfunction bnAbs() { return (this.s<0)?this.negate():this; }\n\n// (public) return + if this > a, - if this < a, 0 if equal\nfunction bnCompareTo(a) {\n  var r = this.s-a.s;\n  if(r != 0) return r;\n  var i = this.t;\n  r = i-a.t;\n  if(r != 0) return (this.s<0)?-r:r;\n  while(--i >= 0) if((r=this[i]-a[i]) != 0) return r;\n  return 0;\n}\n\n// returns bit length of the integer x\nfunction nbits(x) {\n  var r = 1, t;\n  if((t=x>>>16) != 0) { x = t; r += 16; }\n  if((t=x>>8) != 0) { x = t; r += 8; }\n  if((t=x>>4) != 0) { x = t; r += 4; }\n  if((t=x>>2) != 0) { x = t; r += 2; }\n  if((t=x>>1) != 0) { x = t; r += 1; }\n  return r;\n}\n\n// (public) return the number of bits in "this"\nfunction bnBitLength() {\n  if(this.t <= 0) return 0;\n  return this.DB*(this.t-1)+nbits(this[this.t-1]^(this.s&this.DM));\n}\n\n// (protected) r = this << n*DB\nfunction bnpDLShiftTo(n,r) {\n  var i;\n  for(i = this.t-1; i >= 0; --i) r[i+n] = this[i];\n  for(i = n-1; i >= 0; --i) r[i] = 0;\n  r.t = this.t+n;\n  r.s = this.s;\n}\n\n// (protected) r = this >> n*DB\nfunction bnpDRShiftTo(n,r) {\n  for(var i = n; i < this.t; ++i) r[i-n] = this[i];\n  r.t = Math.max(this.t-n,0);\n  r.s = this.s;\n}\n\n// (protected) r = this << n\nfunction bnpLShiftTo(n,r) {\n  var bs = n%this.DB;\n  var cbs = this.DB-bs;\n  var bm = (1<<cbs)-1;\n  var ds = Math.floor(n/this.DB), c = (this.s<<bs)&this.DM, i;\n  for(i = this.t-1; i >= 0; --i) {\n    r[i+ds+1] = (this[i]>>cbs)|c;\n    c = (this[i]&bm)<<bs;\n  }\n  for(i = ds-1; i >= 0; --i) r[i] = 0;\n  r[ds] = c;\n  r.t = this.t+ds+1;\n  r.s = this.s;\n  r.clamp();\n}\n\n// (protected) r = this >> n\nfunction bnpRShiftTo(n,r) {\n  r.s = this.s;\n  var ds = Math.floor(n/this.DB);\n  if(ds >= this.t) { r.t = 0; return; }\n  var bs = n%this.DB;\n  var cbs = this.DB-bs;\n  var bm = (1<<bs)-1;\n  r[0] = this[ds]>>bs;\n  for(var i = ds+1; i < this.t; ++i) {\n    r[i-ds-1] |= (this[i]&bm)<<cbs;\n    r[i-ds] = this[i]>>bs;\n  }\n  if(bs > 0) r[this.t-ds-1] |= (this.s&bm)<<cbs;\n  r.t = this.t-ds;\n  r.clamp();\n}\n\n// (protected) r = this - a\nfunction bnpSubTo(a,r) {\n  var i = 0, c = 0, m = Math.min(a.t,this.t);\n  while(i < m) {\n    c += this[i]-a[i];\n    r[i++] = c&this.DM;\n    c >>= this.DB;\n  }\n  if(a.t < this.t) {\n    c -= a.s;\n    while(i < this.t) {\n      c += this[i];\n      r[i++] = c&this.DM;\n      c >>= this.DB;\n    }\n    c += this.s;\n  }\n  else {\n    c += this.s;\n    while(i < a.t) {\n      c -= a[i];\n      r[i++] = c&this.DM;\n      c >>= this.DB;\n    }\n    c -= a.s;\n  }\n  r.s = (c<0)?-1:0;\n  if(c < -1) r[i++] = this.DV+c;\n  else if(c > 0) r[i++] = c;\n  r.t = i;\n  r.clamp();\n}\n\n// (protected) r = this * a, r != this,a (HAC 14.12)\n// "this" should be the larger one if appropriate.\nfunction bnpMultiplyTo(a,r) {\n  var x = this.abs(), y = a.abs();\n  var i = x.t;\n  r.t = i+y.t;\n  while(--i >= 0) r[i] = 0;\n  for(i = 0; i < y.t; ++i) r[i+x.t] = x.am(0,y[i],r,i,0,x.t);\n  r.s = 0;\n  r.clamp();\n  if(this.s != a.s) BigInteger.ZERO.subTo(r,r);\n}\n\n// (protected) r = this^2, r != this (HAC 14.16)\nfunction bnpSquareTo(r) {\n  var x = this.abs();\n  var i = r.t = 2*x.t;\n  while(--i >= 0) r[i] = 0;\n  for(i = 0; i < x.t-1; ++i) {\n    var c = x.am(i,x[i],r,2*i,0,1);\n    if((r[i+x.t]+=x.am(i+1,2*x[i],r,2*i+1,c,x.t-i-1)) >= x.DV) {\n      r[i+x.t] -= x.DV;\n      r[i+x.t+1] = 1;\n    }\n  }\n  if(r.t > 0) r[r.t-1] += x.am(i,x[i],r,2*i,0,1);\n  r.s = 0;\n  r.clamp();\n}\n\n// (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)\n// r != q, this != m.  q or r may be null.\nfunction bnpDivRemTo(m,q,r) {\n  var pm = m.abs();\n  if(pm.t <= 0) return;\n  var pt = this.abs();\n  if(pt.t < pm.t) {\n    if(q != null) q.fromInt(0);\n    if(r != null) this.copyTo(r);\n    return;\n  }\n  if(r == null) r = nbi();\n  var y = nbi(), ts = this.s, ms = m.s;\n  var nsh = this.DB-nbits(pm[pm.t-1]);\t// normalize modulus\n  if(nsh > 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); }\n  else { pm.copyTo(y); pt.copyTo(r); }\n  var ys = y.t;\n  var y0 = y[ys-1];\n  if(y0 == 0) return;\n  var yt = y0*(1<<this.F1)+((ys>1)?y[ys-2]>>this.F2:0);\n  var d1 = this.FV/yt, d2 = (1<<this.F1)/yt, e = 1<<this.F2;\n  var i = r.t, j = i-ys, t = (q==null)?nbi():q;\n  y.dlShiftTo(j,t);\n  if(r.compareTo(t) >= 0) {\n    r[r.t++] = 1;\n    r.subTo(t,r);\n  }\n  BigInteger.ONE.dlShiftTo(ys,t);\n  t.subTo(y,y);\t// "negative" y so we can replace sub with am later\n  while(y.t < ys) y[y.t++] = 0;\n  while(--j >= 0) {\n    // Estimate quotient digit\n    var qd = (r[--i]==y0)?this.DM:Math.floor(r[i]*d1+(r[i-1]+e)*d2);\n    if((r[i]+=y.am(0,qd,r,j,0,ys)) < qd) {\t// Try it out\n      y.dlShiftTo(j,t);\n      r.subTo(t,r);\n      while(r[i] < --qd) r.subTo(t,r);\n    }\n  }\n  if(q != null) {\n    r.drShiftTo(ys,q);\n    if(ts != ms) BigInteger.ZERO.subTo(q,q);\n  }\n  r.t = ys;\n  r.clamp();\n  if(nsh > 0) r.rShiftTo(nsh,r);\t// Denormalize remainder\n  if(ts < 0) BigInteger.ZERO.subTo(r,r);\n}\n\n// (public) this mod a\nfunction bnMod(a) {\n  var r = nbi();\n  this.abs().divRemTo(a,null,r);\n  if(this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r,r);\n  return r;\n}\n\n// Modular reduction using "classic" algorithm\nfunction Classic(m) { this.m = m; }\nfunction cConvert(x) {\n  if(x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);\n  else return x;\n}\nfunction cRevert(x) { return x; }\nfunction cReduce(x) { x.divRemTo(this.m,null,x); }\nfunction cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\nfunction cSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\nClassic.prototype.convert = cConvert;\nClassic.prototype.revert = cRevert;\nClassic.prototype.reduce = cReduce;\nClassic.prototype.mulTo = cMulTo;\nClassic.prototype.sqrTo = cSqrTo;\n\n// (protected) return "-1/this % 2^DB"; useful for Mont. reduction\n// justification:\n//         xy == 1 (mod m)\n//         xy =  1+km\n//   xy(2-xy) = (1+km)(1-km)\n// x[y(2-xy)] = 1-k^2m^2\n// x[y(2-xy)] == 1 (mod m^2)\n// if y is 1/x mod m, then y(2-xy) is 1/x mod m^2\n// should reduce x and y(2-xy) by m^2 at each step to keep size bounded.\n// JS multiply "overflows" differently from C/C++, so care is needed here.\nfunction bnpInvDigit() {\n  if(this.t < 1) return 0;\n  var x = this[0];\n  if((x&1) == 0) return 0;\n  var y = x&3;\t\t// y == 1/x mod 2^2\n  y = (y*(2-(x&0xf)*y))&0xf;\t// y == 1/x mod 2^4\n  y = (y*(2-(x&0xff)*y))&0xff;\t// y == 1/x mod 2^8\n  y = (y*(2-(((x&0xffff)*y)&0xffff)))&0xffff;\t// y == 1/x mod 2^16\n  // last step - calculate inverse mod DV directly;\n  // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints\n  y = (y*(2-x*y%this.DV))%this.DV;\t\t// y == 1/x mod 2^dbits\n  // we really want the negative inverse, and -DV < y < DV\n  return (y>0)?this.DV-y:-y;\n}\n\n// Montgomery reduction\nfunction Montgomery(m) {\n  this.m = m;\n  this.mp = m.invDigit();\n  this.mpl = this.mp&0x7fff;\n  this.mph = this.mp>>15;\n  this.um = (1<<(m.DB-15))-1;\n  this.mt2 = 2*m.t;\n}\n\n// xR mod m\nfunction montConvert(x) {\n  var r = nbi();\n  x.abs().dlShiftTo(this.m.t,r);\n  r.divRemTo(this.m,null,r);\n  if(x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r,r);\n  return r;\n}\n\n// x/R mod m\nfunction montRevert(x) {\n  var r = nbi();\n  x.copyTo(r);\n  this.reduce(r);\n  return r;\n}\n\n// x = x/R mod m (HAC 14.32)\nfunction montReduce(x) {\n  while(x.t <= this.mt2)\t// pad x so am has enough room later\n    x[x.t++] = 0;\n  for(var i = 0; i < this.m.t; ++i) {\n    // faster way of calculating u0 = x[i]*mp mod DV\n    var j = x[i]&0x7fff;\n    var u0 = (j*this.mpl+(((j*this.mph+(x[i]>>15)*this.mpl)&this.um)<<15))&x.DM;\n    // use am to combine the multiply-shift-add into one call\n    j = i+this.m.t;\n    x[j] += this.m.am(0,u0,x,i,0,this.m.t);\n    // propagate carry\n    while(x[j] >= x.DV) { x[j] -= x.DV; x[++j]++; }\n  }\n  x.clamp();\n  x.drShiftTo(this.m.t,x);\n  if(x.compareTo(this.m) >= 0) x.subTo(this.m,x);\n}\n\n// r = "x^2/R mod m"; x != r\nfunction montSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\n// r = "xy/R mod m"; x,y != r\nfunction montMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\n\nMontgomery.prototype.convert = montConvert;\nMontgomery.prototype.revert = montRevert;\nMontgomery.prototype.reduce = montReduce;\nMontgomery.prototype.mulTo = montMulTo;\nMontgomery.prototype.sqrTo = montSqrTo;\n\n// (protected) true iff this is even\nfunction bnpIsEven() { return ((this.t>0)?(this[0]&1):this.s) == 0; }\n\n// (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)\nfunction bnpExp(e,z) {\n  if(e > 0xffffffff || e < 1) return BigInteger.ONE;\n  var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e)-1;\n  g.copyTo(r);\n  while(--i >= 0) {\n    z.sqrTo(r,r2);\n    if((e&(1<<i)) > 0) z.mulTo(r2,g,r);\n    else { var t = r; r = r2; r2 = t; }\n  }\n  return z.revert(r);\n}\n\n// (public) this^e % m, 0 <= e < 2^32\nfunction bnModPowInt(e,m) {\n  var z;\n  if(e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);\n  return this.exp(e,z);\n}\n\n// protected\nBigInteger.prototype.copyTo = bnpCopyTo;\nBigInteger.prototype.fromInt = bnpFromInt;\nBigInteger.prototype.fromString = bnpFromString;\nBigInteger.prototype.clamp = bnpClamp;\nBigInteger.prototype.dlShiftTo = bnpDLShiftTo;\nBigInteger.prototype.drShiftTo = bnpDRShiftTo;\nBigInteger.prototype.lShiftTo = bnpLShiftTo;\nBigInteger.prototype.rShiftTo = bnpRShiftTo;\nBigInteger.prototype.subTo = bnpSubTo;\nBigInteger.prototype.multiplyTo = bnpMultiplyTo;\nBigInteger.prototype.squareTo = bnpSquareTo;\nBigInteger.prototype.divRemTo = bnpDivRemTo;\nBigInteger.prototype.invDigit = bnpInvDigit;\nBigInteger.prototype.isEven = bnpIsEven;\nBigInteger.prototype.exp = bnpExp;\n\n// public\nBigInteger.prototype.toString = bnToString;\nBigInteger.prototype.negate = bnNegate;\nBigInteger.prototype.abs = bnAbs;\nBigInteger.prototype.compareTo = bnCompareTo;\nBigInteger.prototype.bitLength = bnBitLength;\nBigInteger.prototype.mod = bnMod;\nBigInteger.prototype.modPowInt = bnModPowInt;\n\n// "constants"\nBigInteger.ZERO = nbv(0);\nBigInteger.ONE = nbv(1);\n// Copyright (c) 2005-2009  Tom Wu\n// All Rights Reserved.\n// See "LICENSE" for details.\n\n// Extended JavaScript BN functions, required for RSA private ops.\n\n// Version 1.1: new BigInteger("0", 10) returns "proper" zero\n// Version 1.2: square() API, isProbablePrime fix\n\n// (public)\nfunction bnClone() { var r = nbi(); this.copyTo(r); return r; }\n\n// (public) return value as integer\nfunction bnIntValue() {\n  if(this.s < 0) {\n    if(this.t == 1) return this[0]-this.DV;\n    else if(this.t == 0) return -1;\n  }\n  else if(this.t == 1) return this[0];\n  else if(this.t == 0) return 0;\n  // assumes 16 < DB < 32\n  return ((this[1]&((1<<(32-this.DB))-1))<<this.DB)|this[0];\n}\n\n// (public) return value as byte\nfunction bnByteValue() { return (this.t==0)?this.s:(this[0]<<24)>>24; }\n\n// (public) return value as short (assumes DB>=16)\nfunction bnShortValue() { return (this.t==0)?this.s:(this[0]<<16)>>16; }\n\n// (protected) return x s.t. r^x < DV\nfunction bnpChunkSize(r) { return Math.floor(Math.LN2*this.DB/Math.log(r)); }\n\n// (public) 0 if this == 0, 1 if this > 0\nfunction bnSigNum() {\n  if(this.s < 0) return -1;\n  else if(this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;\n  else return 1;\n}\n\n// (protected) convert to radix string\nfunction bnpToRadix(b) {\n  if(b == null) b = 10;\n  if(this.signum() == 0 || b < 2 || b > 36) return "0";\n  var cs = this.chunkSize(b);\n  var a = Math.pow(b,cs);\n  var d = nbv(a), y = nbi(), z = nbi(), r = "";\n  this.divRemTo(d,y,z);\n  while(y.signum() > 0) {\n    r = (a+z.intValue()).toString(b).substr(1) + r;\n    y.divRemTo(d,y,z);\n  }\n  return z.intValue().toString(b) + r;\n}\n\n// (protected) convert from radix string\nfunction bnpFromRadix(s,b) {\n  this.fromInt(0);\n  if(b == null) b = 10;\n  var cs = this.chunkSize(b);\n  var d = Math.pow(b,cs), mi = false, j = 0, w = 0;\n  for(var i = 0; i < s.length; ++i) {\n    var x = intAt(s,i);\n    if(x < 0) {\n      if(s.charAt(i) == "-" && this.signum() == 0) mi = true;\n      continue;\n    }\n    w = b*w+x;\n    if(++j >= cs) {\n      this.dMultiply(d);\n      this.dAddOffset(w,0);\n      j = 0;\n      w = 0;\n    }\n  }\n  if(j > 0) {\n    this.dMultiply(Math.pow(b,j));\n    this.dAddOffset(w,0);\n  }\n  if(mi) BigInteger.ZERO.subTo(this,this);\n}\n\n// (protected) alternate constructor\nfunction bnpFromNumber(a,b,c) {\n  if("number" == typeof b) {\n    // new BigInteger(int,int,RNG)\n    if(a < 2) this.fromInt(1);\n    else {\n      this.fromNumber(a,c);\n      if(!this.testBit(a-1))\t// force MSB set\n        this.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,this);\n      if(this.isEven()) this.dAddOffset(1,0); // force odd\n      while(!this.isProbablePrime(b)) {\n        this.dAddOffset(2,0);\n        if(this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a-1),this);\n      }\n    }\n  }\n  else {\n    // new BigInteger(int,RNG)\n    var x = new Array(), t = a&7;\n    x.length = (a>>3)+1;\n    b.nextBytes(x);\n    if(t > 0) x[0] &= ((1<<t)-1); else x[0] = 0;\n    this.fromString(x,256);\n  }\n}\n\n// (public) convert to bigendian byte array\nfunction bnToByteArray() {\n  var i = this.t, r = new Array();\n  r[0] = this.s;\n  var p = this.DB-(i*this.DB)%8, d, k = 0;\n  if(i-- > 0) {\n    if(p < this.DB && (d = this[i]>>p) != (this.s&this.DM)>>p)\n      r[k++] = d|(this.s<<(this.DB-p));\n    while(i >= 0) {\n      if(p < 8) {\n        d = (this[i]&((1<<p)-1))<<(8-p);\n        d |= this[--i]>>(p+=this.DB-8);\n      }\n      else {\n        d = (this[i]>>(p-=8))&0xff;\n        if(p <= 0) { p += this.DB; --i; }\n      }\n      if((d&0x80) != 0) d |= -256;\n      if(k == 0 && (this.s&0x80) != (d&0x80)) ++k;\n      if(k > 0 || d != this.s) r[k++] = d;\n    }\n  }\n  return r;\n}\n\nfunction bnEquals(a) { return(this.compareTo(a)==0); }\nfunction bnMin(a) { return(this.compareTo(a)<0)?this:a; }\nfunction bnMax(a) { return(this.compareTo(a)>0)?this:a; }\n\n// (protected) r = this op a (bitwise)\nfunction bnpBitwiseTo(a,op,r) {\n  var i, f, m = Math.min(a.t,this.t);\n  for(i = 0; i < m; ++i) r[i] = op(this[i],a[i]);\n  if(a.t < this.t) {\n    f = a.s&this.DM;\n    for(i = m; i < this.t; ++i) r[i] = op(this[i],f);\n    r.t = this.t;\n  }\n  else {\n    f = this.s&this.DM;\n    for(i = m; i < a.t; ++i) r[i] = op(f,a[i]);\n    r.t = a.t;\n  }\n  r.s = op(this.s,a.s);\n  r.clamp();\n}\n\n// (public) this & a\nfunction op_and(x,y) { return x&y; }\nfunction bnAnd(a) { var r = nbi(); this.bitwiseTo(a,op_and,r); return r; }\n\n// (public) this | a\nfunction op_or(x,y) { return x|y; }\nfunction bnOr(a) { var r = nbi(); this.bitwiseTo(a,op_or,r); return r; }\n\n// (public) this ^ a\nfunction op_xor(x,y) { return x^y; }\nfunction bnXor(a) { var r = nbi(); this.bitwiseTo(a,op_xor,r); return r; }\n\n// (public) this & ~a\nfunction op_andnot(x,y) { return x&~y; }\nfunction bnAndNot(a) { var r = nbi(); this.bitwiseTo(a,op_andnot,r); return r; }\n\n// (public) ~this\nfunction bnNot() {\n  var r = nbi();\n  for(var i = 0; i < this.t; ++i) r[i] = this.DM&~this[i];\n  r.t = this.t;\n  r.s = ~this.s;\n  return r;\n}\n\n// (public) this << n\nfunction bnShiftLeft(n) {\n  var r = nbi();\n  if(n < 0) this.rShiftTo(-n,r); else this.lShiftTo(n,r);\n  return r;\n}\n\n// (public) this >> n\nfunction bnShiftRight(n) {\n  var r = nbi();\n  if(n < 0) this.lShiftTo(-n,r); else this.rShiftTo(n,r);\n  return r;\n}\n\n// return index of lowest 1-bit in x, x < 2^31\nfunction lbit(x) {\n  if(x == 0) return -1;\n  var r = 0;\n  if((x&0xffff) == 0) { x >>= 16; r += 16; }\n  if((x&0xff) == 0) { x >>= 8; r += 8; }\n  if((x&0xf) == 0) { x >>= 4; r += 4; }\n  if((x&3) == 0) { x >>= 2; r += 2; }\n  if((x&1) == 0) ++r;\n  return r;\n}\n\n// (public) returns index of lowest 1-bit (or -1 if none)\nfunction bnGetLowestSetBit() {\n  for(var i = 0; i < this.t; ++i)\n    if(this[i] != 0) return i*this.DB+lbit(this[i]);\n  if(this.s < 0) return this.t*this.DB;\n  return -1;\n}\n\n// return number of 1 bits in x\nfunction cbit(x) {\n  var r = 0;\n  while(x != 0) { x &= x-1; ++r; }\n  return r;\n}\n\n// (public) return number of set bits\nfunction bnBitCount() {\n  var r = 0, x = this.s&this.DM;\n  for(var i = 0; i < this.t; ++i) r += cbit(this[i]^x);\n  return r;\n}\n\n// (public) true iff nth bit is set\nfunction bnTestBit(n) {\n  var j = Math.floor(n/this.DB);\n  if(j >= this.t) return(this.s!=0);\n  return((this[j]&(1<<(n%this.DB)))!=0);\n}\n\n// (protected) this op (1<<n)\nfunction bnpChangeBit(n,op) {\n  var r = BigInteger.ONE.shiftLeft(n);\n  this.bitwiseTo(r,op,r);\n  return r;\n}\n\n// (public) this | (1<<n)\nfunction bnSetBit(n) { return this.changeBit(n,op_or); }\n\n// (public) this & ~(1<<n)\nfunction bnClearBit(n) { return this.changeBit(n,op_andnot); }\n\n// (public) this ^ (1<<n)\nfunction bnFlipBit(n) { return this.changeBit(n,op_xor); }\n\n// (protected) r = this + a\nfunction bnpAddTo(a,r) {\n  var i = 0, c = 0, m = Math.min(a.t,this.t);\n  while(i < m) {\n    c += this[i]+a[i];\n    r[i++] = c&this.DM;\n    c >>= this.DB;\n  }\n  if(a.t < this.t) {\n    c += a.s;\n    while(i < this.t) {\n      c += this[i];\n      r[i++] = c&this.DM;\n      c >>= this.DB;\n    }\n    c += this.s;\n  }\n  else {\n    c += this.s;\n    while(i < a.t) {\n      c += a[i];\n      r[i++] = c&this.DM;\n      c >>= this.DB;\n    }\n    c += a.s;\n  }\n  r.s = (c<0)?-1:0;\n  if(c > 0) r[i++] = c;\n  else if(c < -1) r[i++] = this.DV+c;\n  r.t = i;\n  r.clamp();\n}\n\n// (public) this + a\nfunction bnAdd(a) { var r = nbi(); this.addTo(a,r); return r; }\n\n// (public) this - a\nfunction bnSubtract(a) { var r = nbi(); this.subTo(a,r); return r; }\n\n// (public) this * a\nfunction bnMultiply(a) { var r = nbi(); this.multiplyTo(a,r); return r; }\n\n// (public) this^2\nfunction bnSquare() { var r = nbi(); this.squareTo(r); return r; }\n\n// (public) this / a\nfunction bnDivide(a) { var r = nbi(); this.divRemTo(a,r,null); return r; }\n\n// (public) this % a\nfunction bnRemainder(a) { var r = nbi(); this.divRemTo(a,null,r); return r; }\n\n// (public) [this/a,this%a]\nfunction bnDivideAndRemainder(a) {\n  var q = nbi(), r = nbi();\n  this.divRemTo(a,q,r);\n  return new Array(q,r);\n}\n\n// (protected) this *= n, this >= 0, 1 < n < DV\nfunction bnpDMultiply(n) {\n  this[this.t] = this.am(0,n-1,this,0,0,this.t);\n  ++this.t;\n  this.clamp();\n}\n\n// (protected) this += n << w words, this >= 0\nfunction bnpDAddOffset(n,w) {\n  if(n == 0) return;\n  while(this.t <= w) this[this.t++] = 0;\n  this[w] += n;\n  while(this[w] >= this.DV) {\n    this[w] -= this.DV;\n    if(++w >= this.t) this[this.t++] = 0;\n    ++this[w];\n  }\n}\n\n// A "null" reducer\nfunction NullExp() {}\nfunction nNop(x) { return x; }\nfunction nMulTo(x,y,r) { x.multiplyTo(y,r); }\nfunction nSqrTo(x,r) { x.squareTo(r); }\n\nNullExp.prototype.convert = nNop;\nNullExp.prototype.revert = nNop;\nNullExp.prototype.mulTo = nMulTo;\nNullExp.prototype.sqrTo = nSqrTo;\n\n// (public) this^e\nfunction bnPow(e) { return this.exp(e,new NullExp()); }\n\n// (protected) r = lower n words of "this * a", a.t <= n\n// "this" should be the larger one if appropriate.\nfunction bnpMultiplyLowerTo(a,n,r) {\n  var i = Math.min(this.t+a.t,n);\n  r.s = 0; // assumes a,this >= 0\n  r.t = i;\n  while(i > 0) r[--i] = 0;\n  var j;\n  for(j = r.t-this.t; i < j; ++i) r[i+this.t] = this.am(0,a[i],r,i,0,this.t);\n  for(j = Math.min(a.t,n); i < j; ++i) this.am(0,a[i],r,i,0,n-i);\n  r.clamp();\n}\n\n// (protected) r = "this * a" without lower n words, n > 0\n// "this" should be the larger one if appropriate.\nfunction bnpMultiplyUpperTo(a,n,r) {\n  --n;\n  var i = r.t = this.t+a.t-n;\n  r.s = 0; // assumes a,this >= 0\n  while(--i >= 0) r[i] = 0;\n  for(i = Math.max(n-this.t,0); i < a.t; ++i)\n    r[this.t+i-n] = this.am(n-i,a[i],r,0,0,this.t+i-n);\n  r.clamp();\n  r.drShiftTo(1,r);\n}\n\n// Barrett modular reduction\nfunction Barrett(m) {\n  // setup Barrett\n  this.r2 = nbi();\n  this.q3 = nbi();\n  BigInteger.ONE.dlShiftTo(2*m.t,this.r2);\n  this.mu = this.r2.divide(m);\n  this.m = m;\n}\n\nfunction barrettConvert(x) {\n  if(x.s < 0 || x.t > 2*this.m.t) return x.mod(this.m);\n  else if(x.compareTo(this.m) < 0) return x;\n  else { var r = nbi(); x.copyTo(r); this.reduce(r); return r; }\n}\n\nfunction barrettRevert(x) { return x; }\n\n// x = x mod m (HAC 14.42)\nfunction barrettReduce(x) {\n  x.drShiftTo(this.m.t-1,this.r2);\n  if(x.t > this.m.t+1) { x.t = this.m.t+1; x.clamp(); }\n  this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);\n  this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);\n  while(x.compareTo(this.r2) < 0) x.dAddOffset(1,this.m.t+1);\n  x.subTo(this.r2,x);\n  while(x.compareTo(this.m) >= 0) x.subTo(this.m,x);\n}\n\n// r = x^2 mod m; x != r\nfunction barrettSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\n// r = x*y mod m; x,y != r\nfunction barrettMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\n\nBarrett.prototype.convert = barrettConvert;\nBarrett.prototype.revert = barrettRevert;\nBarrett.prototype.reduce = barrettReduce;\nBarrett.prototype.mulTo = barrettMulTo;\nBarrett.prototype.sqrTo = barrettSqrTo;\n\n// (public) this^e % m (HAC 14.85)\nfunction bnModPow(e,m) {\n  var i = e.bitLength(), k, r = nbv(1), z;\n  if(i <= 0) return r;\n  else if(i < 18) k = 1;\n  else if(i < 48) k = 3;\n  else if(i < 144) k = 4;\n  else if(i < 768) k = 5;\n  else k = 6;\n  if(i < 8)\n    z = new Classic(m);\n  else if(m.isEven())\n    z = new Barrett(m);\n  else\n    z = new Montgomery(m);\n\n  // precomputation\n  var g = new Array(), n = 3, k1 = k-1, km = (1<<k)-1;\n  g[1] = z.convert(this);\n  if(k > 1) {\n    var g2 = nbi();\n    z.sqrTo(g[1],g2);\n    while(n <= km) {\n      g[n] = nbi();\n      z.mulTo(g2,g[n-2],g[n]);\n      n += 2;\n    }\n  }\n\n  var j = e.t-1, w, is1 = true, r2 = nbi(), t;\n  i = nbits(e[j])-1;\n  while(j >= 0) {\n    if(i >= k1) w = (e[j]>>(i-k1))&km;\n    else {\n      w = (e[j]&((1<<(i+1))-1))<<(k1-i);\n      if(j > 0) w |= e[j-1]>>(this.DB+i-k1);\n    }\n\n    n = k;\n    while((w&1) == 0) { w >>= 1; --n; }\n    if((i -= n) < 0) { i += this.DB; --j; }\n    if(is1) {\t// ret == 1, don\'t bother squaring or multiplying it\n      g[w].copyTo(r);\n      is1 = false;\n    }\n    else {\n      while(n > 1) { z.sqrTo(r,r2); z.sqrTo(r2,r); n -= 2; }\n      if(n > 0) z.sqrTo(r,r2); else { t = r; r = r2; r2 = t; }\n      z.mulTo(r2,g[w],r);\n    }\n\n    while(j >= 0 && (e[j]&(1<<i)) == 0) {\n      z.sqrTo(r,r2); t = r; r = r2; r2 = t;\n      if(--i < 0) { i = this.DB-1; --j; }\n    }\n  }\n  return z.revert(r);\n}\n\n// (public) gcd(this,a) (HAC 14.54)\nfunction bnGCD(a) {\n  var x = (this.s<0)?this.negate():this.clone();\n  var y = (a.s<0)?a.negate():a.clone();\n  if(x.compareTo(y) < 0) { var t = x; x = y; y = t; }\n  var i = x.getLowestSetBit(), g = y.getLowestSetBit();\n  if(g < 0) return x;\n  if(i < g) g = i;\n  if(g > 0) {\n    x.rShiftTo(g,x);\n    y.rShiftTo(g,y);\n  }\n  while(x.signum() > 0) {\n    if((i = x.getLowestSetBit()) > 0) x.rShiftTo(i,x);\n    if((i = y.getLowestSetBit()) > 0) y.rShiftTo(i,y);\n    if(x.compareTo(y) >= 0) {\n      x.subTo(y,x);\n      x.rShiftTo(1,x);\n    }\n    else {\n      y.subTo(x,y);\n      y.rShiftTo(1,y);\n    }\n  }\n  if(g > 0) y.lShiftTo(g,y);\n  return y;\n}\n\n// (protected) this % n, n < 2^26\nfunction bnpModInt(n) {\n  if(n <= 0) return 0;\n  var d = this.DV%n, r = (this.s<0)?n-1:0;\n  if(this.t > 0)\n    if(d == 0) r = this[0]%n;\n    else for(var i = this.t-1; i >= 0; --i) r = (d*r+this[i])%n;\n  return r;\n}\n\n// (public) 1/this % m (HAC 14.61)\nfunction bnModInverse(m) {\n  var ac = m.isEven();\n  if((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;\n  var u = m.clone(), v = this.clone();\n  var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);\n  while(u.signum() != 0) {\n    while(u.isEven()) {\n      u.rShiftTo(1,u);\n      if(ac) {\n        if(!a.isEven() || !b.isEven()) { a.addTo(this,a); b.subTo(m,b); }\n        a.rShiftTo(1,a);\n      }\n      else if(!b.isEven()) b.subTo(m,b);\n      b.rShiftTo(1,b);\n    }\n    while(v.isEven()) {\n      v.rShiftTo(1,v);\n      if(ac) {\n        if(!c.isEven() || !d.isEven()) { c.addTo(this,c); d.subTo(m,d); }\n        c.rShiftTo(1,c);\n      }\n      else if(!d.isEven()) d.subTo(m,d);\n      d.rShiftTo(1,d);\n    }\n    if(u.compareTo(v) >= 0) {\n      u.subTo(v,u);\n      if(ac) a.subTo(c,a);\n      b.subTo(d,b);\n    }\n    else {\n      v.subTo(u,v);\n      if(ac) c.subTo(a,c);\n      d.subTo(b,d);\n    }\n  }\n  if(v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;\n  if(d.compareTo(m) >= 0) return d.subtract(m);\n  if(d.signum() < 0) d.addTo(m,d); else return d;\n  if(d.signum() < 0) return d.add(m); else return d;\n}\n\nvar lowprimes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997];\nvar lplim = (1<<26)/lowprimes[lowprimes.length-1];\n\n// (public) test primality with certainty >= 1-.5^t\nfunction bnIsProbablePrime(t) {\n  var i, x = this.abs();\n  if(x.t == 1 && x[0] <= lowprimes[lowprimes.length-1]) {\n    for(i = 0; i < lowprimes.length; ++i)\n      if(x[0] == lowprimes[i]) return true;\n    return false;\n  }\n  if(x.isEven()) return false;\n  i = 1;\n  while(i < lowprimes.length) {\n    var m = lowprimes[i], j = i+1;\n    while(j < lowprimes.length && m < lplim) m *= lowprimes[j++];\n    m = x.modInt(m);\n    while(i < j) if(m%lowprimes[i++] == 0) return false;\n  }\n  return x.millerRabin(t);\n}\n\n// (protected) true if probably prime (HAC 4.24, Miller-Rabin)\nfunction bnpMillerRabin(t) {\n  var n1 = this.subtract(BigInteger.ONE);\n  var k = n1.getLowestSetBit();\n  if(k <= 0) return false;\n  var r = n1.shiftRight(k);\n  t = (t+1)>>1;\n  if(t > lowprimes.length) t = lowprimes.length;\n  var a = nbi();\n  for(var i = 0; i < t; ++i) {\n    //Pick bases at random, instead of starting at 2\n    a.fromInt(lowprimes[Math.floor(Math.random()*lowprimes.length)]);\n    var y = a.modPow(r,this);\n    if(y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {\n      var j = 1;\n      while(j++ < k && y.compareTo(n1) != 0) {\n        y = y.modPowInt(2,this);\n        if(y.compareTo(BigInteger.ONE) == 0) return false;\n      }\n      if(y.compareTo(n1) != 0) return false;\n    }\n  }\n  return true;\n}\n\n// protected\nBigInteger.prototype.chunkSize = bnpChunkSize;\nBigInteger.prototype.toRadix = bnpToRadix;\nBigInteger.prototype.fromRadix = bnpFromRadix;\nBigInteger.prototype.fromNumber = bnpFromNumber;\nBigInteger.prototype.bitwiseTo = bnpBitwiseTo;\nBigInteger.prototype.changeBit = bnpChangeBit;\nBigInteger.prototype.addTo = bnpAddTo;\nBigInteger.prototype.dMultiply = bnpDMultiply;\nBigInteger.prototype.dAddOffset = bnpDAddOffset;\nBigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;\nBigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;\nBigInteger.prototype.modInt = bnpModInt;\nBigInteger.prototype.millerRabin = bnpMillerRabin;\n\n// public\nBigInteger.prototype.clone = bnClone;\nBigInteger.prototype.intValue = bnIntValue;\nBigInteger.prototype.byteValue = bnByteValue;\nBigInteger.prototype.shortValue = bnShortValue;\nBigInteger.prototype.signum = bnSigNum;\nBigInteger.prototype.toByteArray = bnToByteArray;\nBigInteger.prototype.equals = bnEquals;\nBigInteger.prototype.min = bnMin;\nBigInteger.prototype.max = bnMax;\nBigInteger.prototype.and = bnAnd;\nBigInteger.prototype.or = bnOr;\nBigInteger.prototype.xor = bnXor;\nBigInteger.prototype.andNot = bnAndNot;\nBigInteger.prototype.not = bnNot;\nBigInteger.prototype.shiftLeft = bnShiftLeft;\nBigInteger.prototype.shiftRight = bnShiftRight;\nBigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;\nBigInteger.prototype.bitCount = bnBitCount;\nBigInteger.prototype.testBit = bnTestBit;\nBigInteger.prototype.setBit = bnSetBit;\nBigInteger.prototype.clearBit = bnClearBit;\nBigInteger.prototype.flipBit = bnFlipBit;\nBigInteger.prototype.add = bnAdd;\nBigInteger.prototype.subtract = bnSubtract;\nBigInteger.prototype.multiply = bnMultiply;\nBigInteger.prototype.divide = bnDivide;\nBigInteger.prototype.remainder = bnRemainder;\nBigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;\nBigInteger.prototype.modPow = bnModPow;\nBigInteger.prototype.modInverse = bnModInverse;\nBigInteger.prototype.pow = bnPow;\nBigInteger.prototype.gcd = bnGCD;\nBigInteger.prototype.isProbablePrime = bnIsProbablePrime;\n\n// JSBN-specific extension\nBigInteger.prototype.square = bnSquare;\n\n// BigInteger interfaces not implemented in jsbn:\n\n// BigInteger(int signum, byte[] magnitude)\n// double doubleValue()\n// float floatValue()\n// int hashCode()\n// long longValue()\n// static BigInteger valueOf(long val)\n\n})(require("__browserify_buffer").Buffer)\n},{"__browserify_buffer":12}],13:[function(require,module,exports){\n// shim for using process in browser\n\nvar process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== \'undefined\'\n    && window.setImmediate;\n    var canPost = typeof window !== \'undefined\'\n    && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    if (canPost) {\n        var queue = [];\n        window.addEventListener(\'message\', function (ev) {\n            var source = ev.source;\n            if ((source === window || source === null) && ev.data === \'process-tick\') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage(\'process-tick\', \'*\');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = \'browser\';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nprocess.binding = function (name) {\n    throw new Error(\'process.binding is not supported\');\n}\n\n// TODO(shtylman)\nprocess.cwd = function () { return \'/\' };\nprocess.chdir = function (dir) {\n    throw new Error(\'process.chdir is not supported\');\n};\n\n},{}],4:[function(require,module,exports){\n(function(process){var ndn = require(\'ndn-browser-shim\');\nvar utils = require(\'./utils.js\')\nndn.FIB = require("./ndn-FIB.js")\nndn.PIT = require("./ndn-PIT.js")\nvar Cache = require(\'./ndn-cache.js\')\nvar BinaryXMLDecoder = ndn.BinaryXMLDecoder;\nvar NDNProtocolDTags = ndn.NDNProtocolDTags;\nvar Interest = ndn.Interest;\nvar Data = ndn.Data;\nvar ndnbuf = ndn.ndnbuf;\nvar Face = ndn.Face;\nvar Closure = ndn.Closure;\nvar UpcallInfo = ndn.UpcallInfo;\nvar Name = ndn.Name;\nvar LOG = require(\'./LOG.js\')\nvar strategy = require(\'./ndn-strategy.js\')\n\n\nprocess.nextTick = require(\'./worker-process.js\').nextTick\n\nvar PitEntry = function PitEntry(interest, face)\n{\n  this.interest = interest;\n  this.face = face;\n}\n\nvar ForwarderFace = function ForwarderFace(opts)\n{\n  var face = new ndn.Face(opts);\n\n  face.forwardingInterestHandler = function (element, interest, transport){\n    if (LOG > 3) console.log("Interest packet received: " + interest.name.toUri() + "\\n");\n\n      if (LOG > 3) console.log(\'Interest packet received.\');\n\n\n      //window.interest = interest\n      //console.log(interest)\n      // Add to the PIT.\n      /*for (var i = 0; i < ndn.PIT.length; i++) {\n        //console.log(PIT[i].interest.nonce)\n        if (ndn.PIT[i].interest.nonce.toString() == interest.nonce.toString()) {\n          return;\n        };\n      };*/\n      function onCacheHit(element, transport){\n        console.log(\'cache hit\')\n        transport.send(element)\n      }\n\n      function onCacheMiss(element, interest){\n        ndn.PIT.put(thisFace, interest, element, strategy.forwardInterest);\n      }\n      Cache.check(interest, element, transport, onCacheHit, onCacheMiss)\n\n\n  }\n  face.onReceivedElement = function(element)\n  {\n    console.log("got element in forwarderFace ", this)\n    var decoder = new BinaryXMLDecoder(element);\n    // Dispatch according to packet type\n    if (decoder.peekDTag(NDNProtocolDTags.Interest)) {\n      var interest = new Interest();\n      interest.decode(element);\n      this.forwardingInterestHandler(element, interest, this.transport)\n\n\n    }\n    else if (decoder.peekDTag(NDNProtocolDTags.Data)) {\n\n      if (LOG > 3) console.log(\'Data packet received.\');\n      var data = new Data();\n      data.from_ndnb(decoder);\n      // Send the data packet to the face for each matching PIT entry.\n      // Iterate backwards so we can remove the entry and keep iterating.\n\n\n\n      var pitEntry = Face.getEntryForExpressedInterest(data.name);\n      //window.data = data\n      //console.log(data)\n      if (pitEntry != null) {\n        // Cancel interest timer\n        clearTimeout(pitEntry.timerID);\n\n        // Remove PIT entry from Face.PITTable\n        var index = Face.PITTable.indexOf(pitEntry);\n        if (index >= 0)\n          Face.PITTable.splice(index, 1);\n\n        var currentClosure = pitEntry.closure;\n\n        if (this.verify == false) {\n          // Pass content up without verifying the signature\n          currentClosure.upcall(Closure.UPCALL_CONTENT_UNVERIFIED, new UpcallInfo(this, pitEntry.interest, 0, data));\n          return;\n        }\n\n        // Key verification\n\n        // Recursive key fetching & verification closure\n        var KeyFetchClosure = function KeyFetchClosure(content, closure, key, sig, wit) {\n          this.data = content;  // unverified data packet object\n          this.closure = closure;  // closure corresponding to the data\n          this.keyName = key;  // name of current key to be fetched\n\n          Closure.call(this);\n        };\n\n        var thisNDN = this;\n        KeyFetchClosure.prototype.upcall = function(kind, upcallInfo) {\n          if (kind == Closure.UPCALL_INTEREST_TIMED_OUT) {\n            //console.log("In KeyFetchClosure.upcall: interest time out.");\n            //console.log(this.keyName.contentName.toUri());\n          }\n          else if (kind == Closure.UPCALL_CONTENT) {\n            var rsakey = new Key();\n            rsakey.readDerPublicKey(upcallInfo.data.content);\n            var verified = data.verify(rsakey);\n\n            var flag = (verified == true) ? Closure.UPCALL_CONTENT : Closure.UPCALL_CONTENT_BAD;\n            this.closure.upcall(flag, new UpcallInfo(thisNDN, null, 0, this.data));\n\n            // Store key in cache\n            var keyEntry = new KeyStoreEntry(keylocator.keyName, rsakey, new Date().getTime());\n            Face.addKeyEntry(keyEntry);\n          }\n          else if (kind == Closure.UPCALL_CONTENT_BAD)\n            console.log("In KeyFetchClosure.upcall: signature verification failed");\n        };\n\n        if (data.signedInfo && data.signedInfo.locator && data.signature) {\n          if (LOG > 3) console.log("Key verification...");\n          var sigHex = DataUtils.toHex(data.signature.signature).toLowerCase();\n\n          var wit = null;\n          if (data.signature.witness != null)\n              //SWT: deprecate support for Witness decoding and Merkle hash tree verification\n              currentClosure.upcall(Closure.UPCALL_CONTENT_BAD, new UpcallInfo(this, pitEntry.interest, 0, data));\n\n          var keylocator = data.signedInfo.locator;\n          if (keylocator.type == KeyLocatorType.KEYNAME) {\n            if (LOG > 3) console.log("KeyLocator contains KEYNAME");\n\n            if (keylocator.keyName.contentName.match(data.name)) {\n              if (LOG > 3) console.log("Content is key itself");\n\n              var rsakey = new Key();\n              rsakey.readDerPublicKey(data.content);\n              var verified = data.verify(rsakey);\n              var flag = (verified == true) ? Closure.UPCALL_CONTENT : Closure.UPCALL_CONTENT_BAD;\n\n              currentClosure.upcall(flag, new UpcallInfo(this, pitEntry.interest, 0, data));\n\n              // SWT: We don\'t need to store key here since the same key will be stored again in the closure.\n            }\n            else {\n              // Check local key store\n              var keyEntry = Face.getKeyByName(keylocator.keyName);\n              if (keyEntry) {\n                // Key found, verify now\n                if (LOG > 3) console.log("Local key cache hit");\n                var rsakey = keyEntry.rsaKey;\n                var verified = data.verify(rsakey);\n                var flag = (verified == true) ? Closure.UPCALL_CONTENT : Closure.UPCALL_CONTENT_BAD;\n\n                // Raise callback\n                currentClosure.upcall(flag, new UpcallInfo(this, pitEntry.interest, 0, data));\n              }\n              else {\n                // Not found, fetch now\n                if (LOG > 3) console.log("Fetch key according to keylocator");\n                var nextClosure = new KeyFetchClosure(data, currentClosure, keylocator.keyName, sigHex, wit);\n                // TODO: Use expressInterest with callbacks, not Closure.\n                this.expressInterest(keylocator.keyName.contentName.getPrefix(4), nextClosure);\n              }\n            }\n          }\n          else if (keylocator.type == KeyLocatorType.KEY) {\n            if (LOG > 3) console.log("Keylocator contains KEY");\n\n            var rsakey = new Key();\n            rsakey.readDerPublicKey(keylocator.publicKey);\n            var verified = data.verify(rsakey);\n\n            var flag = (verified == true) ? Closure.UPCALL_CONTENT : Closure.UPCALL_CONTENT_BAD;\n            // Raise callback\n            currentClosure.upcall(Closure.UPCALL_CONTENT, new UpcallInfo(this, pitEntry.interest, 0, data));\n\n            // Since KeyLocator does not contain key name for this key,\n            // we have no way to store it as a key entry in KeyStore.\n          }\n          else {\n            var cert = keylocator.certificate;\n            //console.log("KeyLocator contains CERT");\n            //console.log(cert);\n            // TODO: verify certificate\n          }\n        }\n      }\n      function onAck(data) {\n        console.log(\'found matching pit entrys\')\n        Cache.data(data, element)\n      }\n      ndn.PIT.lookupData(data, element, onAck)\n    }\n\n  };\n\n\n  face.selfReg = function (prefix) {\n    if (this.registeredPrefixes == undefined) {\n      this.registeredPrefixes = [];\n    };\n    if (prefix instanceof ndn.Name) {\n      this.registeredPrefixes.push(prefix)\n    } else if (typeof prefix == "string") {\n      this.registeredPrefixes.push(new ndn.Name(prefix))\n    }\n\n  };\n  var thisFace = face\n  return face;\n};\n\n\nmodule.exports = ForwarderFace\n\n})(require("__browserify_process"))\n},{"./LOG.js":1,"./ndn-FIB.js":6,"./ndn-PIT.js":14,"./ndn-cache.js":15,"./ndn-strategy.js":9,"./utils.js":8,"./worker-process.js":11,"__browserify_process":13,"ndn-browser-shim":10}],5:[function(require,module,exports){\nvar ndn = require(\'ndn-browser-shim\');\nvar BinaryXmlElementReader = ndn.BinaryXmlElementReader;\nvar ndnbuf = ndn.ndnbuf;\nvar Name = ndn.Name\nvar Data = ndn.Data\nvar LOG = require(\'./LOG.js\')\nvar local = {}\n\nlocal.transport = function (port) {\n  this.port = port\n};\n\n\n/**\n * Connect to the host and port in face.  This replaces a previous connection and sets connectedHost\n *   and connectedPort.  Once connected, call onopenCallback().\n * Listen on the port to read an entire binary XML encoded element and call\n *    face.onReceivedElement(element).\n */\nlocal.transport.prototype.connect = function(face, onopenCallback)\n{\n  this.elementReader = new BinaryXmlElementReader(face);\n  var self = this;\n  this.port.onmessage = function(ev) {\n    //console.log(\'RecvHandle called on local face\', result);\n\n    if (ev.data == null || ev.data == undefined || ev.data == "") {\n      console.log(\'INVALID ANSWER\');\n    }\n    else if (ev.data instanceof ArrayBuffer) {\n      var bytearray = new ndnbuf(ev.data);\n\n      if (LOG > 3) console.log(\'BINARY RESPONSE IS \' + bytearray.toString(\'hex\'));\n\n      try {\n        // Find the end of the binary XML element and call face.onReceivedElement.\n        self.elementReader.onReceivedData(bytearray);\n      } catch (ex) {\n        console.log("NDN.ws.onmessage exception: " + ex);\n        return;\n      }\n      // garbage collect arraybuffer\n      //var ms = new MessageChannel()\n      //ms.port1.postMessage(ev.data, [ev.data])\n    }\n  };\n\n  onopenCallback();\n\n};\n\n/**\n * Send the Uint8Array data.\n */\nlocal.transport.prototype.send = function(data)\n{\n  if (true) {\n        // If we directly use data.buffer to feed ws.send(),\n        // WebSocket may end up sending a packet with 10000 bytes of data.\n        // That is, WebSocket will flush the entire buffer\n        // regardless of the offset of the Uint8Array. So we have to create\n        // a new Uint8Array buffer with just the right size and copy the\n        // content from binaryInterest to the new buffer.\n        //    ---Wentao\n        var bytearray = new Uint8Array(data.length);\n        bytearray.set(data);\n        this.port.postMessage(bytearray.buffer);\n\n        //garbage collect\n        //var ms = new MessageChannel();\n        //ms.port1.postMessage(bytearray.buffer, [bytearray.buffer])\n        //ms.port1.postMessage(data.buffer, [data.buffer])\n    console.log(\'local.send() returned.\');\n  }\n  else\n    console.log(\'local connection is not established.\');\n};\n\nmodule.exports = local;\n\n},{"./LOG.js":1,"ndn-browser-shim":10}],6:[function(require,module,exports){\nvar ndn = require(\'ndn-browser-shim\');\nndn.Faces = require(\'./ndn-Faces.js\')\nvar strategy = require(\'./ndn-strategy.js\');\n\nvar idb = require(\'idb-wrapper\');\n\n\nvar FIB = {};\n\nvar fib = new idb({\n  storeName: "FIB",\n  dbVersion: 1,\n  indexes: [\n    {name: "faceID"},\n    {name: "faceHash"},\n    {name: "prefixURI"}\n  ]\n})\n\nFIB.put = function(forwardingEntry) {\n  console.log(forwardingEntry, ndn.Faces.list)\n  if ((forwardingEntry.faceID == null) || (ndn.Faces.list[forwardingEntry.faceID].ndndid.toString() != forwardingEntry.ndndID.toString())) {\n    for(i = 0; i < ndn.Faces.list.length; i++ ){\n      if ((ndn.Faces.list[i].ndndid.toString() == forwardingEntry.ndndID.toString())) {\n        forwardingEntry.faceID == i;\n        var cromulent = true\n        continue\n      }\n    }\n  } else {\n    var cromulent = true\n  }\n\n  if (cromulent) {\n\n    var FIBEntry = {\n      faceID: forwardingEntry.faceID,\n      faceHash: forwardingEntry.ndndID.toString(\'hex\'),\n      prefixURI: forwardingEntry.prefixName.toUri()\n    }\n    fib.put(FIBEntry, function onSuccess(id){\n      console.log(\'put FIBEntry at id: \', id)\n    }, function onError(err){\n      console.log(\'error inserting FIBEntry : \', FIBEntry, err)\n    })\n  }\n}\n\nFIB.lookupByName = function(name, onMatches) {\n  var prefixes = [];\n\n  function getAllPrefixes(name){\n    var prefix = name.getPrefix(-1)\n    prefixes.push(prefix.toUri())\n    if (prefix.components.length > 0) {\n      getAllPrefixes(prefix)\n    }\n  }\n\n  var keyRanges = [];\n\n  getAllPrefixes(name)\n\n  for (var i = 0; i < prefixes.length; i++ ){\n    var r = fib.makeKeyRange({\n      only: prefixes[i]\n    })\n    keyRanges.push(r)\n  }\n\n  var allMatches = []\n\n  function getMatchingEntries (keyRanges) {\n    var range = keyRanges.pop()\n    fib.query(function onSuccess(matches){\n      allMatches = allMatches.concat(matches)\n      if (keyRanges.length > 0){\n        getMatchingEntries(keyRanges)\n      } else {\n        onMatches(allMatches)\n      }\n    },{\n      index: "prefixURI",\n      keyRange: range\n    })\n  }\n\n  getMatchingEntries(keyRanges)\n}\n\n\nmodule.exports = FIB\n\n},{"./ndn-Faces.js":7,"./ndn-strategy.js":9,"idb-wrapper":16,"ndn-browser-shim":10}],7:[function(require,module,exports){\n\nvar ndn = require(\'ndn-browser-shim\');\nndn.globalKeyManager = require(\'./ndn-keyManager.js\');\n\nvar Faces = {};\n\nFaces.list = []\n\nFaces.add = function(face){\n  if (face.ndndid == undefined){\n    face.ndndid = ndn.globalKeyManager.getKey().publicKeyDigest\n  }\n  Faces.list.push(face)\n  face.id = Faces.list.length - 1\n  return face.id\n}\n\n\nmodule.exports = Faces;\n\n},{"./ndn-keyManager.js":3,"ndn-browser-shim":10}],8:[function(require,module,exports){\nvar utils = {}\nvar Data = require(\'ndn-browser-shim\').Data\nvar Name = require(\'ndn-browser-shim\').Name\nvar SignedInfo = require(\'ndn-browser-shim\').SignedInfo\nvar ndnbuf = require(\'ndn-browser-shim\').ndnbuf\nvar DataUtils = require(\'ndn-browser-shim\').DataUtils\n\nutils.chunkArbitraryData = function(opts) {\n  var ndnArray = [];\n  //console.log(name)\n  if (opts.type == \'object\') {\n    var string = JSON.stringify(opts.thing);\n  } else if (typeof opts.data == \'string\') {\n    var string = data;\n  } else if (typeof opts.data == \'file\') {\n    //console.log(\'no handlers yet for datatype: \', typeof data);\n    return;\n  };\n  var name = new ndn.Name(opts.uri)\n  if (opts.version != false) {\n    utils.appendVersion(name, opts.version)\n  }\n  var stringArray = string.match(/.{1,4000}/g);\n  var segmentNames = [];\n  for (i = 0; i < stringArray.length; i++) {\n    segmentNames[i] = new Name(name).appendSegment(i)\n    var co = new Data(segmentNames[i], new SignedInfo(), new ndnbuf(stringArray[i]));\n    co.signedInfo.setFields()\n    co.signedInfo.finalBlockID = utils.initSegment(stringArray.length - 1)\n    console.log(co.signedInfo.finalBlockID)\n    if (opts.freshness != undefined) {\n      co.signedInfo.freshnessSeconds = fresh\n    }\n    co.sign()\n    ndnArray[i] = co.encode()\n  };\n\n  return {array:ndnArray, name: name};\n\n};\n\nutils.initSegment = function(seg) {\n    if (seg == null || seg == 0)\n\t  return (new ndnbuf(\'00\', \'hex\'));\n\n    var segStr = seg.toString(16);\n\n    if (segStr.length % 2 == 1)\n\tsegStr = \'0\' + segStr;\n\n    segStr = \'00\' + segStr;\n    return (new ndnbuf(segStr, \'hex\'));\n};\n\nutils.getAllPrefixes = function(name) {\n  var uriArray = [];\n  for (i = 0 ; i < name.components.length + 1 ; i++) {\n    var uri = name.getPrefix(i).toUri()\n    uriArray.push(uri);\n  };\n  return uriArray;\n};\n\nutils.isFirstSegment = function(name) {\n    return name.components != null && name.components.length >= 1 &&\n        name.components[name.components.length - 1].value.length == 1 &&\n        name.components[name.components.length - 1].value[0] == 0;\n};\n\nutils.isLastSegment = function(name, co) {\n\n    return DataUtils.arraysEqual(name.components[name.components.length - 1].value, co.signedInfo.finalBlockID);\n}\n\nutils.normalizeUri = function(name) {\n  //console.log(name)\n  if (!endsWithSegmentNumber(name)) {\n    normalizedName = name;\n    requestedSegment = 0\n  } else if (!isFirstSegment(name)) {\n    normalizedName = name.getPrefix(name.components.length - 1);\n    requestedSegment = DataUtils.bigEndianToUnsignedInt(name.components[name.components.length - 1].value);\n  } else {\n    normalizedName = name.getPrefix(name.components.length - 1) ;\n    requestedSegment = 0;\n  };\n  var returns = [normalizedName, requestedSegment];\n  return returns;\n};\n\nutils.getSegmentInteger = function(name) {\n  if (name.components != null && name.components.length >= 1 &&\n  name.components[name.components.length - 1].value.length >= 1 &&\n  name.components[name.components.length - 1].value[0] == 0) {\n    return DataUtils.bigEndianToUnsignedInt(name.components[name.components.length - 1].value)\n  } else {\n    return 0;\n  }\n};\n\nutils.normalizeNameToObjectStore = function(name) {\n  var throwaway = utils.getNameWithoutCommandMarker(name);\n\n  if (!utils.endsWithSegmentNumber(throwaway)) {\n    return throwaway.appendSegment(0).toUri();\n  } else if (!utils.isFirstSegment(throwaway)) {\n    return throwaway.getPrefix(name.components.length - 1).appendSegment(0).toUri();\n  } else {\n    return throwaway.toUri();\n  };\n};\n\nutils.endsWithSegmentNumber = function(name) {\n    return name.components != null && name.components.length >= 1 &&\n        name.components[name.components.length - 1].value.length >= 1 &&\n        name.components[name.components.length - 1].value[0] == 0;\n}\n\nutils.nameHasCommandMarker = function(name) {\n  for (var i = name.size() - 1; i >= 0; --i) {\n    var component = name.components[i].getValue();\n    if (component.length <= 0)\n      continue;\n\n    if (component[0] == 0xC1) {\n      return true\n    };\n  }\n\n  return false;\n};\n\nutils.getCommandMarker = function(name) {\n  //console.log(name)\n  for (var i = name.size() - 1; i >= 0; --i) {\n    var component = name.components[i].getValue();\n    if (component.length <= 0)\n      continue;\n\n    if (component[0] == 0xC1 && component[2] != 0x4E) {\n      return name.components[i].toEscapedString()\n    };\n  }\n};\n\nutils.getNameWithoutCommandMarker = function(name) {\n  var strippedName = new Name(\'\');\n\n  for (var i = 0 ; i < name.size(); i++) {\n    var component = name.components[i].getValue();\n    if (component.length <= 0)\n      continue;\n\n    if (component[0] != 0xC1) {\n      strippedName.append(name.components[i]);\n    };\n  };\n  return strippedName;\n};\n\n\nutils.getSuffix = function(name, p) {\n    return new Name(name.components.slice(p));\n};\n\nutils.appendVersion = function(name, date) {\n    console.log(date)\n    if (date) {\n      if (date instanceof Date) {\n        var d = date.getTime()\n\n      } else if (typeof date == "number")\n        var d = new Date().setTime(date)\n    } else {\n      var d = new Date().getTime();\n    };\n\n    var time = d.toString(16);\n    if (time.length % 2 == 1) {\n\t    time = \'0\' + time;\n    };\n    time = \'fd\' + time;\n    var binTime = new ndnbuf(time, \'hex\');\n    //console.log(binTime)\n    return name.append(binTime);\n};\n\nutils.timeToVersion = function(date) {\n  if (date instanceof Date) {\n    var d = date.getTime\n  } else {\n    var d = date;\n  };\n  var time = d.toString(16);\n  if (time.length % 2 == 1) {\n    time = \'0\' + time;\n  };\n  time = \'fd\' + time;\n  var binTime = new ndnbuf(time, \'hex\');\n  return (new Name.Component(binTime).toEscapedString())\n\n};\n\nutils.versionToTime = function(version) {\n  time = 0\n  array = DataUtils.toNumbers(DataUtils.toHex(version))\n  //console.log(array)\n  for (i = 1; i < array.length ; i++) {\n    time = time + (array[i] * Math.pow(2, (7 - i)));\n    //console.log(time)\n  };\n  return time\n};\n\n\n\nutils.setNonce = function(interest) {\n  var bytes = [0xc1, 0x2e, 0x4e, 0x00];\n  for (var n = 8; n > 0; n--) {\n\t  bytes.push(Math.floor(Math.random() * 256));\n\t  //console.log(bytes)\n  }\n  var buf = new ndnbuf(bytes);\n  interest.nonce = buf;\n}\n\nmodule.exports = utils;\n\n},{"ndn-browser-shim":10}],9:[function(require,module,exports){\nvar ndn = require(\'ndn-browser-shim\'),\n    utils = require(\'./utils.js\'),\n    FIB = require(\'./ndn-FIB.js\'),\n    strategy = {};\n\nndn.PIT = require(\'./ndn-PIT.js\');\n\n\nstrategy.forwardInterest = function(thisFace, element, interest) {\n\n  console.log(\'interest got cache miss in forwarding face\')\n  // Send the interest to the matching faces in the FIB.\n  var isLocalInterest = false;\n  if (utils.nameHasCommandMarker(interest.name)) {\n    if (utils.getCommandMarker(interest.name) == \'%C1.M.S.localhost\') {\n      //console.log("interest has localhost commandMarker")\n      isLocalInterest = true;\n    }\n  }\n  //console.log(ndn.FIB)\n\n  function forward(FIBEntrys) {\n    console.log("found FIBEntrys ", FIBEntrys)\n    var sent = []\n    for (var i = 0; i < FIBEntrys.length; i++){\n      var entry = FIBEntrys[i]\n      var faceID = entry.faceID\n      if (sent[faceID] == undefined) {\n        ndn.Faces.list[faceID].transport.send(element)\n        sent[faceID] = true\n      }\n    }\n  }\n\n  ndn.FIB.lookupByName(interest.name, forward)\n}\n\nstrategy.forwardData = function(element) {}\n\nstrategy.onNewFace = function(face) {\n  function express (results){\n    for(var i = 0; i < results.length; i++) {\n      var element = results[i].encodedInterest\n      face.transport.send(element)\n    }\n  }\n  if (face.registeredPrefixes!= null){\n    for (var j = 0; j < face.registeredPrefixes.length; j++) {\n      console.log(ndn.PIT)\n      ndn.PIT.lookupName(face.registeredPrefixes[j], express )\n    }\n  }\n\n  var faceID = ndn.Faces.add(face)\n}\n\nstrategy.onPrefixRegistered = function(forwardingEntry) {\n\n}\n\nstrategy.caughtDataSends = function(caught) {\n  console.log(caught)\n}\n\nmodule.exports = strategy\n\n},{"./ndn-FIB.js":6,"./ndn-PIT.js":14,"./utils.js":8,"ndn-browser-shim":10}],3:[function(require,module,exports){\n\nself.ndn = require(\'ndn-browser-shim\');\n\nvar yManager = function() {\n\n  this.certificate = null\n  this.publicKey = null\n  this.privateKey = null\n\n  this.key = null;\n};\nyManager.prototype.getKey = function()\n{\n  if (this.key === null) {\n    this.key = new ndn.Key();\n    this.key.fromPemString(this.publicKey, this.privateKey);\n  }\n\n  return this.key;\n}\n\nmodule.exports = new yManager()\n\n},{"ndn-browser-shim":10}],16:[function(require,module,exports){\n(function(){/*global window:false, self:false, define:false, module:false */\n\n/**\n * @license IDBWrapper - A cross-browser wrapper for IndexedDB\n * Copyright (c) 2011 - 2013 Jens Arps\n * http://jensarps.de/\n *\n * Licensed under the MIT (X11) license\n */\n\n(function (name, definition, global) {\n  if (typeof define === \'function\') {\n    define(definition);\n  } else if (typeof module !== \'undefined\' && module.exports) {\n    module.exports = definition();\n  } else {\n    global[name] = definition();\n  }\n})(\'IDBStore\', function () {\n\n  \'use strict\';\n\n  var defaultErrorHandler = function (error) {\n    throw error;\n  };\n\n  var defaults = {\n    storeName: \'Store\',\n    storePrefix: \'IDBWrapper-\',\n    dbVersion: 1,\n    keyPath: \'id\',\n    autoIncrement: true,\n    onStoreReady: function () {\n    },\n    onError: defaultErrorHandler,\n    indexes: []\n  };\n\n  /**\n   *\n   * The IDBStore constructor\n   *\n   * @constructor\n   * @name IDBStore\n   * @version 1.4.1\n   *\n   * @param {Object} [kwArgs] An options object used to configure the store and\n   *  set callbacks\n   * @param {String} [kwArgs.storeName=\'Store\'] The name of the store\n   * @param {String} [kwArgs.storePrefix=\'IDBWrapper-\'] A prefix that is\n   *  internally used to construct the name of the database, which will be\n   *  kwArgs.storePrefix + kwArgs.storeName\n   * @param {Number} [kwArgs.dbVersion=1] The version of the store\n   * @param {String} [kwArgs.keyPath=\'id\'] The key path to use. If you want to\n   *  setup IDBWrapper to work with out-of-line keys, you need to set this to\n   *  `null`\n   * @param {Boolean} [kwArgs.autoIncrement=true] If set to true, IDBStore will\n   *  automatically make sure a unique keyPath value is present on each object\n   *  that is stored.\n   * @param {Function} [kwArgs.onStoreReady] A callback to be called when the\n   *  store is ready to be used.\n   * @param {Function} [kwArgs.onError=throw] A callback to be called when an\n   *  error occurred during instantiation of the store.\n   * @param {Array} [kwArgs.indexes=[]] An array of indexData objects\n   *  defining the indexes to use with the store. For every index to be used\n   *  one indexData object needs to be passed in the array.\n   *  An indexData object is defined as follows:\n   * @param {Object} [kwArgs.indexes.indexData] An object defining the index to\n   *  use\n   * @param {String} kwArgs.indexes.indexData.name The name of the index\n   * @param {String} [kwArgs.indexes.indexData.keyPath] The key path of the index\n   * @param {Boolean} [kwArgs.indexes.indexData.unique] Whether the index is unique\n   * @param {Boolean} [kwArgs.indexes.indexData.multiEntry] Whether the index is multi entry\n   * @param {Function} [onStoreReady] A callback to be called when the store\n   * is ready to be used.\n   * @example\n      // create a store for customers with an additional index over the\n      // `lastname` property.\n      var myCustomerStore = new IDBStore({\n        dbVersion: 1,\n        storeName: \'customer-index\',\n        keyPath: \'customerid\',\n        autoIncrement: true,\n        onStoreReady: populateTable,\n        indexes: [\n          { name: \'lastname\', keyPath: \'lastname\', unique: false, multiEntry: false }\n        ]\n      });\n   * @example\n      // create a generic store\n      var myCustomerStore = new IDBStore({\n        storeName: \'my-data-store\',\n        onStoreReady: function(){\n          // start working with the store.\n        }\n      });\n   */\n  var IDBStore = function (kwArgs, onStoreReady) {\n\n    if (typeof onStoreReady == \'undefined\' && typeof kwArgs == \'function\') {\n      onStoreReady = kwArgs;\n    }\n    if (Object.prototype.toString.call(kwArgs) != \'[object Object]\') {\n      kwArgs = {};\n    }\n\n    for (var key in defaults) {\n      this[key] = typeof kwArgs[key] != \'undefined\' ? kwArgs[key] : defaults[key];\n    }\n\n    this.dbName = this.storePrefix + this.storeName;\n    this.dbVersion = parseInt(this.dbVersion, 10) || 1;\n\n    onStoreReady && (this.onStoreReady = onStoreReady);\n\n    var env = typeof window == \'object\' ? window : self;\n    this.idb = env.indexedDB || env.webkitIndexedDB || env.mozIndexedDB;\n    this.keyRange = env.IDBKeyRange || env.webkitIDBKeyRange || env.mozIDBKeyRange;\n\n    this.features = {\n      hasAutoIncrement: !env.mozIndexedDB\n    };\n\n    this.consts = {\n      \'READ_ONLY\':         \'readonly\',\n      \'READ_WRITE\':        \'readwrite\',\n      \'VERSION_CHANGE\':    \'versionchange\',\n      \'NEXT\':              \'next\',\n      \'NEXT_NO_DUPLICATE\': \'nextunique\',\n      \'PREV\':              \'prev\',\n      \'PREV_NO_DUPLICATE\': \'prevunique\'\n    };\n\n    this.openDB();\n  };\n\n  IDBStore.prototype = /** @lends IDBStore */ {\n\n    /**\n     * A pointer to the IDBStore ctor\n     *\n     * @type IDBStore\n     */\n    constructor: IDBStore,\n\n    /**\n     * The version of IDBStore\n     *\n     * @type String\n     */\n    version: \'1.4.1\',\n\n    /**\n     * A reference to the IndexedDB object\n     *\n     * @type Object\n     */\n    db: null,\n\n    /**\n     * The full name of the IndexedDB used by IDBStore, composed of\n     * this.storePrefix + this.storeName\n     *\n     * @type String\n     */\n    dbName: null,\n\n    /**\n     * The version of the IndexedDB used by IDBStore\n     *\n     * @type Number\n     */\n    dbVersion: null,\n\n    /**\n     * A reference to the objectStore used by IDBStore\n     *\n     * @type Object\n     */\n    store: null,\n\n    /**\n     * The store name\n     *\n     * @type String\n     */\n    storeName: null,\n\n    /**\n     * The key path\n     *\n     * @type String\n     */\n    keyPath: null,\n\n    /**\n     * Whether IDBStore uses autoIncrement\n     *\n     * @type Boolean\n     */\n    autoIncrement: null,\n\n    /**\n     * The indexes used by IDBStore\n     *\n     * @type Array\n     */\n    indexes: null,\n\n    /**\n     * A hashmap of features of the used IDB implementation\n     *\n     * @type Object\n     * @proprty {Boolean} autoIncrement If the implementation supports\n     *  native auto increment\n     */\n    features: null,\n\n    /**\n     * The callback to be called when the store is ready to be used\n     *\n     * @type Function\n     */\n    onStoreReady: null,\n\n    /**\n     * The callback to be called if an error occurred during instantiation\n     * of the store\n     *\n     * @type Function\n     */\n    onError: null,\n\n    /**\n     * The internal insertID counter\n     *\n     * @type Number\n     * @private\n     */\n    _insertIdCount: 0,\n\n    /**\n     * Opens an IndexedDB; called by the constructor.\n     *\n     * Will check if versions match and compare provided index configuration\n     * with existing ones, and update indexes if necessary.\n     *\n     * Will call this.onStoreReady() if everything went well and the store\n     * is ready to use, and this.onError() is something went wrong.\n     *\n     * @private\n     *\n     */\n    openDB: function () {\n\n      var openRequest = this.idb.open(this.dbName, this.dbVersion);\n      var preventSuccessCallback = false;\n\n      openRequest.onerror = function (error) {\n\n        var gotVersionErr = false;\n        if (\'error\' in error.target) {\n          gotVersionErr = error.target.error.name == \'VersionError\';\n        } else if (\'errorCode\' in error.target) {\n          gotVersionErr = error.target.errorCode == 12;\n        }\n\n        if (gotVersionErr) {\n          this.onError(new Error(\'The version number provided is lower than the existing one.\'));\n        } else {\n          this.onError(error);\n        }\n      }.bind(this);\n\n      openRequest.onsuccess = function (event) {\n\n        if (preventSuccessCallback) {\n          return;\n        }\n\n        if(this.db){\n          this.onStoreReady();\n          return;\n        }\n\n        this.db = event.target.result;\n\n        if(typeof this.db.version == \'string\'){\n          this.onError(new Error(\'The IndexedDB implementation in this browser is outdated. Please upgrade your browser.\'));\n          return;\n        }\n\n        if(!this.db.objectStoreNames.contains(this.storeName)){\n          // We should never ever get here.\n          // Lets notify the user anyway.\n          this.onError(new Error(\'Something is wrong with the IndexedDB implementation in this browser. Please upgrade your browser.\'));\n          return;\n        }\n\n        var emptyTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n        this.store = emptyTransaction.objectStore(this.storeName);\n\n        // check indexes\n        var existingIndexes = Array.prototype.slice.call(this.getIndexList());\n        this.indexes.forEach(function(indexData){\n          var indexName = indexData.name;\n\n          if(!indexName){\n            preventSuccessCallback = true;\n            this.onError(new Error(\'Cannot create index: No index name given.\'));\n            return;\n          }\n\n          this.normalizeIndexData(indexData);\n\n          if(this.hasIndex(indexName)){\n            // check if it complies\n            var actualIndex = this.store.index(indexName);\n            var complies = this.indexComplies(actualIndex, indexData);\n            if(!complies){\n              preventSuccessCallback = true;\n              this.onError(new Error(\'Cannot modify index "\' + indexName + \'" for current version. Please bump version number to \' + ( this.dbVersion + 1 ) + \'.\'));\n            }\n\n            existingIndexes.splice(existingIndexes.indexOf(indexName), 1);\n          } else {\n            preventSuccessCallback = true;\n            this.onError(new Error(\'Cannot create new index "\' + indexName + \'" for current version. Please bump version number to \' + ( this.dbVersion + 1 ) + \'.\'));\n          }\n\n        }, this);\n\n        if (existingIndexes.length) {\n          preventSuccessCallback = true;\n          this.onError(new Error(\'Cannot delete index(es) "\' + existingIndexes.toString() + \'" for current version. Please bump version number to \' + ( this.dbVersion + 1 ) + \'.\'));\n        }\n\n        preventSuccessCallback || this.onStoreReady();\n      }.bind(this);\n\n      openRequest.onupgradeneeded = function(/* IDBVersionChangeEvent */ event){\n\n        this.db = event.target.result;\n\n        if(this.db.objectStoreNames.contains(this.storeName)){\n          this.store = event.target.transaction.objectStore(this.storeName);\n        } else {\n          var optionalParameters = { autoIncrement: this.autoIncrement };\n          if (this.keyPath !== null) {\n            optionalParameters.keyPath = this.keyPath;\n          }\n          this.store = this.db.createObjectStore(this.storeName, optionalParameters);\n        }\n\n        var existingIndexes = Array.prototype.slice.call(this.getIndexList());\n        this.indexes.forEach(function(indexData){\n          var indexName = indexData.name;\n\n          if(!indexName){\n            preventSuccessCallback = true;\n            this.onError(new Error(\'Cannot create index: No index name given.\'));\n          }\n\n          this.normalizeIndexData(indexData);\n\n          if(this.hasIndex(indexName)){\n            // check if it complies\n            var actualIndex = this.store.index(indexName);\n            var complies = this.indexComplies(actualIndex, indexData);\n            if(!complies){\n              // index differs, need to delete and re-create\n              this.store.deleteIndex(indexName);\n              this.store.createIndex(indexName, indexData.keyPath, { unique: indexData.unique, multiEntry: indexData.multiEntry });\n            }\n\n            existingIndexes.splice(existingIndexes.indexOf(indexName), 1);\n          } else {\n            this.store.createIndex(indexName, indexData.keyPath, { unique: indexData.unique, multiEntry: indexData.multiEntry });\n          }\n\n        }, this);\n\n        if (existingIndexes.length) {\n          existingIndexes.forEach(function(_indexName){\n            this.store.deleteIndex(_indexName);\n          }, this);\n        }\n\n      }.bind(this);\n    },\n\n    /**\n     * Deletes the database used for this store if the IDB implementations\n     * provides that functionality.\n     */\n    deleteDatabase: function () {\n      if (this.idb.deleteDatabase) {\n        this.idb.deleteDatabase(this.dbName);\n      }\n    },\n\n    /*********************\n     * data manipulation *\n     *********************/\n\n    /**\n     * Puts an object into the store. If an entry with the given id exists,\n     * it will be overwritten. This method has a different signature for inline\n     * keys and out-of-line keys; please see the examples below.\n     *\n     * @param {*} [key] The key to store. This is only needed if IDBWrapper\n     *  is set to use out-of-line keys. For inline keys - the default scenario -\n     *  this can be omitted.\n     * @param {Object} value The data object to store.\n     * @param {Function} [onSuccess] A callback that is called if insertion\n     *  was successful.\n     * @param {Function} [onError] A callback that is called if insertion\n     *  failed.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     * @example\n        // Storing an object, using inline keys (the default scenario):\n        var myCustomer = {\n          customerid: 2346223,\n          lastname: \'Doe\',\n          firstname: \'John\'\n        };\n        myCustomerStore.put(myCustomer, mySuccessHandler, myErrorHandler);\n        // Note that passing success- and error-handlers is optional.\n     * @example\n        // Storing an object, using out-of-line keys:\n       var myCustomer = {\n         lastname: \'Doe\',\n         firstname: \'John\'\n       };\n       myCustomerStore.put(2346223, myCustomer, mySuccessHandler, myErrorHandler);\n      // Note that passing success- and error-handlers is optional.\n     */\n    put: function (key, value, onSuccess, onError) {\n      if (this.keyPath !== null) {\n        onError = onSuccess;\n        onSuccess = value;\n        value = key;\n      }\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = noop);\n\n      var hasSuccess = false,\n          result = null,\n          putRequest;\n\n      var putTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);\n      putTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n      putTransaction.onabort = onError;\n      putTransaction.onerror = onError;\n\n      if (this.keyPath !== null) { // in-line keys\n        this._addIdPropertyIfNeeded(value);\n        putRequest = putTransaction.objectStore(this.storeName).put(value);\n      } else { // out-of-line keys\n        putRequest = putTransaction.objectStore(this.storeName).put(value, key);\n      }\n      putRequest.onsuccess = function (event) {\n        hasSuccess = true;\n        result = event.target.result;\n      };\n      putRequest.onerror = onError;\n\n      return putTransaction;\n    },\n\n    /**\n     * Retrieves an object from the store. If no entry exists with the given id,\n     * the success handler will be called with null as first and only argument.\n     *\n     * @param {*} key The id of the object to fetch.\n     * @param {Function} [onSuccess] A callback that is called if fetching\n     *  was successful. Will receive the object as only argument.\n     * @param {Function} [onError] A callback that will be called if an error\n     *  occurred during the operation.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    get: function (key, onSuccess, onError) {\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = noop);\n\n      var hasSuccess = false,\n          result = null;\n      \n      var getTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n      getTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n      getTransaction.onabort = onError;\n      getTransaction.onerror = onError;\n      var getRequest = getTransaction.objectStore(this.storeName).get(key);\n      getRequest.onsuccess = function (event) {\n        hasSuccess = true;\n        result = event.target.result;\n      };\n      getRequest.onerror = onError;\n\n      return getTransaction;\n    },\n\n    /**\n     * Removes an object from the store.\n     *\n     * @param {*} key The id of the object to remove.\n     * @param {Function} [onSuccess] A callback that is called if the removal\n     *  was successful.\n     * @param {Function} [onError] A callback that will be called if an error\n     *  occurred during the operation.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    remove: function (key, onSuccess, onError) {\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = noop);\n\n      var hasSuccess = false,\n          result = null;\n\n      var removeTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);\n      removeTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n      removeTransaction.onabort = onError;\n      removeTransaction.onerror = onError;\n\n      var deleteRequest = removeTransaction.objectStore(this.storeName)[\'delete\'](key);\n      deleteRequest.onsuccess = function (event) {\n        hasSuccess = true;\n        result = event.target.result;\n      };\n      deleteRequest.onerror = onError;\n\n      return removeTransaction;\n    },\n\n    /**\n     * Runs a batch of put and/or remove operations on the store.\n     *\n     * @param {Array} dataArray An array of objects containing the operation to run\n     *  and the data object (for put operations).\n     * @param {Function} [onSuccess] A callback that is called if all operations\n     *  were successful.\n     * @param {Function} [onError] A callback that is called if an error\n     *  occurred during one of the operations.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    batch: function (dataArray, onSuccess, onError) {\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = noop);\n\n      if(Object.prototype.toString.call(dataArray) != \'[object Array]\'){\n        onError(new Error(\'dataArray argument must be of type Array.\'));\n      }\n      var batchTransaction = this.db.transaction([this.storeName] , this.consts.READ_WRITE);\n      batchTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(hasSuccess);\n      };\n      batchTransaction.onabort = onError;\n      batchTransaction.onerror = onError;\n      \n      var count = dataArray.length;\n      var called = false;\n      var hasSuccess = false;\n\n      var onItemSuccess = function () {\n        count--;\n        if (count === 0 && !called) {\n          called = true;\n          hasSuccess = true;\n        }\n      };\n\n      dataArray.forEach(function (operation) {\n        var type = operation.type;\n        var key = operation.key;\n        var value = operation.value;\n\n        var onItemError = function (err) {\n          batchTransaction.abort();\n          if (!called) {\n            called = true;\n            onError(err, type, key);\n          }\n        };\n\n        if (type == \'remove\') {\n          var deleteRequest = batchTransaction.objectStore(this.storeName)[\'delete\'](key);\n          deleteRequest.onsuccess = onItemSuccess;\n          deleteRequest.onerror = onItemError;\n        } else if (type == \'put\') {\n          var putRequest;\n          if (this.keyPath !== null) { // in-line keys\n            this._addIdPropertyIfNeeded(value);\n            putRequest = batchTransaction.objectStore(this.storeName).put(value);\n          } else { // out-of-line keys\n            putRequest = batchTransaction.objectStore(this.storeName).put(value, key);\n          }\n          putRequest.onsuccess = onItemSuccess;\n          putRequest.onerror = onItemError;\n        }\n      }, this);\n\n      return batchTransaction;\n    },\n\n    /**\n     * Takes an array of objects and stores them in a single transaction.\n     *\n     * @param {Array} dataArray An array of objects to store\n     * @param {Function} [onSuccess] A callback that is called if all operations\n     *  were successful.\n     * @param {Function} [onError] A callback that is called if an error\n     *  occurred during one of the operations.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    putBatch: function (dataArray, onSuccess, onError) {\n      var batchData = dataArray.map(function(item){\n        return { type: \'put\', value: item };\n      });\n\n      return this.batch(batchData, onSuccess, onError);\n    },\n\n    /**\n     * Takes an array of keys and removes matching objects in a single\n     * transaction.\n     *\n     * @param {Array} keyArray An array of keys to remove\n     * @param {Function} [onSuccess] A callback that is called if all operations\n     *  were successful.\n     * @param {Function} [onError] A callback that is called if an error\n     *  occurred during one of the operations.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    removeBatch: function (keyArray, onSuccess, onError) {\n      var batchData = keyArray.map(function(key){\n        return { type: \'remove\', key: key };\n      });\n\n      return this.batch(batchData, onSuccess, onError);\n    },\n\n    /**\n     * Takes an array of keys and fetches matching objects\n     *\n     * @param {Array} keyArray An array of keys identifying the objects to fetch\n     * @param {Function} [onSuccess] A callback that is called if all operations\n     *  were successful.\n     * @param {Function} [onError] A callback that is called if an error\n     *  occurred during one of the operations.\n     * @param {String} [arrayType=\'sparse\'] The type of array to pass to the\n     *  success handler. May be one of \'sparse\', \'dense\' or \'skip\'. Defaults to\n     *  \'sparse\'. This parameter specifies how to handle the situation if a get\n     *  operation did not throw an error, but there was no matching object in\n     *  the database. In most cases, \'sparse\' provides the most desired\n     *  behavior. See the examples for details.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     * @example\n     // given that there are two objects in the database with the keypath\n     // values 1 and 2, and the call looks like this:\n     myStore.getBatch([1, 5, 2], onError, function (data) { \u2026 }, arrayType);\n\n     // this is what the `data` array will be like:\n\n     // arrayType == \'sparse\':\n     // data is a sparse array containing two entries and having a length of 3:\n       [Object, 2: Object]\n         0: Object\n         2: Object\n         length: 3\n         __proto__: Array[0]\n     // calling forEach on data will result in the callback being called two\n     // times, with the index parameter matching the index of the key in the\n     // keyArray.\n\n     // arrayType == \'dense\':\n     // data is a dense array containing three entries and having a length of 3,\n     // where data[1] is of type undefined:\n       [Object, undefined, Object]\n         0: Object\n         1: undefined\n         2: Object\n         length: 3\n         __proto__: Array[0]\n     // calling forEach on data will result in the callback being called three\n     // times, with the index parameter matching the index of the key in the\n     // keyArray, but the second call will have undefined as first argument.\n\n     // arrayType == \'skip\':\n     // data is a dense array containing two entries and having a length of 2:\n       [Object, Object]\n         0: Object\n         1: Object\n         length: 2\n         __proto__: Array[0]\n     // calling forEach on data will result in the callback being called two\n     // times, with the index parameter not matching the index of the key in the\n     // keyArray.\n     */\n    getBatch: function (keyArray, onSuccess, onError, arrayType) {\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = noop);\n      arrayType || (arrayType = \'sparse\');\n\n      if(Object.prototype.toString.call(keyArray) != \'[object Array]\'){\n        onError(new Error(\'keyArray argument must be of type Array.\'));\n      }\n      var batchTransaction = this.db.transaction([this.storeName] , this.consts.READ_ONLY);\n      batchTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n      batchTransaction.onabort = onError;\n      batchTransaction.onerror = onError;\n\n      var data = [];\n      var count = keyArray.length;\n      var called = false;\n      var hasSuccess = false;\n      var result = null;\n\n      var onItemSuccess = function (event) {\n        if (event.target.result || arrayType == \'dense\') {\n          data.push(event.target.result);\n        } else if (arrayType == \'sparse\') {\n          data.length++;\n        }\n        count--;\n        if (count === 0) {\n          called = true;\n          hasSuccess = true;\n          result = data;\n        }\n      };\n\n      keyArray.forEach(function (key) {\n\n        var onItemError = function (err) {\n          called = true;\n          result = err;\n          onError(err);\n          batchTransaction.abort();\n        };\n\n        var getRequest = batchTransaction.objectStore(this.storeName).get(key);\n        getRequest.onsuccess = onItemSuccess;\n        getRequest.onerror = onItemError;\n\n      }, this);\n\n      return batchTransaction;\n    },\n\n    /**\n     * Fetches all entries in the store.\n     *\n     * @param {Function} [onSuccess] A callback that is called if the operation\n     *  was successful. Will receive an array of objects.\n     * @param {Function} [onError] A callback that will be called if an error\n     *  occurred during the operation.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    getAll: function (onSuccess, onError) {\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = noop);\n      var getAllTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n      var store = getAllTransaction.objectStore(this.storeName);\n      if (store.getAll) {\n        this._getAllNative(getAllTransaction, store, onSuccess, onError);\n      } else {\n        this._getAllCursor(getAllTransaction, store, onSuccess, onError);\n      }\n\n      return getAllTransaction;\n    },\n\n    /**\n     * Implements getAll for IDB implementations that have a non-standard\n     * getAll() method.\n     *\n     * @param {Object} getAllTransaction An open READ transaction.\n     * @param {Object} store A reference to the store.\n     * @param {Function} onSuccess A callback that will be called if the\n     *  operation was successful.\n     * @param {Function} onError A callback that will be called if an\n     *  error occurred during the operation.\n     * @private\n     */\n    _getAllNative: function (getAllTransaction, store, onSuccess, onError) {\n      var hasSuccess = false,\n          result = null;\n\n      getAllTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n      getAllTransaction.onabort = onError;\n      getAllTransaction.onerror = onError;\n\n      var getAllRequest = store.getAll();\n      getAllRequest.onsuccess = function (event) {\n        hasSuccess = true;\n        result = event.target.result;\n      };\n      getAllRequest.onerror = onError;\n    },\n\n    /**\n     * Implements getAll for IDB implementations that do not have a getAll()\n     * method.\n     *\n     * @param {Object} getAllTransaction An open READ transaction.\n     * @param {Object} store A reference to the store.\n     * @param {Function} onSuccess A callback that will be called if the\n     *  operation was successful.\n     * @param {Function} onError A callback that will be called if an\n     *  error occurred during the operation.\n     * @private\n     */\n    _getAllCursor: function (getAllTransaction, store, onSuccess, onError) {\n      var all = [],\n          hasSuccess = false,\n          result = null;\n\n      getAllTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n      getAllTransaction.onabort = onError;\n      getAllTransaction.onerror = onError;\n\n      var cursorRequest = store.openCursor();\n      cursorRequest.onsuccess = function (event) {\n        var cursor = event.target.result;\n        if (cursor) {\n          all.push(cursor.value);\n          cursor[\'continue\']();\n        }\n        else {\n          hasSuccess = true;\n          result = all;\n        }\n      };\n      cursorRequest.onError = onError;\n    },\n\n    /**\n     * Clears the store, i.e. deletes all entries in the store.\n     *\n     * @param {Function} [onSuccess] A callback that will be called if the\n     *  operation was successful.\n     * @param {Function} [onError] A callback that will be called if an\n     *  error occurred during the operation.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    clear: function (onSuccess, onError) {\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = noop);\n\n      var hasSuccess = false,\n          result = null;\n\n      var clearTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);\n      clearTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n      clearTransaction.onabort = onError;\n      clearTransaction.onerror = onError;\n\n      var clearRequest = clearTransaction.objectStore(this.storeName).clear();\n      clearRequest.onsuccess = function (event) {\n        hasSuccess = true;\n        result = event.target.result;\n      };\n      clearRequest.onerror = onError;\n\n      return clearTransaction;\n    },\n\n    /**\n     * Checks if an id property needs to present on a object and adds one if\n     * necessary.\n     *\n     * @param {Object} dataObj The data object that is about to be stored\n     * @private\n     */\n    _addIdPropertyIfNeeded: function (dataObj) {\n      if (!this.features.hasAutoIncrement && typeof dataObj[this.keyPath] == \'undefined\') {\n        dataObj[this.keyPath] = this._insertIdCount++ + Date.now();\n      }\n    },\n\n    /************\n     * indexing *\n     ************/\n\n    /**\n     * Returns a DOMStringList of index names of the store.\n     *\n     * @return {DOMStringList} The list of index names\n     */\n    getIndexList: function () {\n      return this.store.indexNames;\n    },\n\n    /**\n     * Checks if an index with the given name exists in the store.\n     *\n     * @param {String} indexName The name of the index to look for\n     * @return {Boolean} Whether the store contains an index with the given name\n     */\n    hasIndex: function (indexName) {\n      return this.store.indexNames.contains(indexName);\n    },\n\n    /**\n     * Normalizes an object containing index data and assures that all\n     * properties are set.\n     *\n     * @param {Object} indexData The index data object to normalize\n     * @param {String} indexData.name The name of the index\n     * @param {String} [indexData.keyPath] The key path of the index\n     * @param {Boolean} [indexData.unique] Whether the index is unique\n     * @param {Boolean} [indexData.multiEntry] Whether the index is multi entry\n     */\n    normalizeIndexData: function (indexData) {\n      indexData.keyPath = indexData.keyPath || indexData.name;\n      indexData.unique = !!indexData.unique;\n      indexData.multiEntry = !!indexData.multiEntry;\n    },\n\n    /**\n     * Checks if an actual index complies with an expected index.\n     *\n     * @param {Object} actual The actual index found in the store\n     * @param {Object} expected An Object describing an expected index\n     * @return {Boolean} Whether both index definitions are identical\n     */\n    indexComplies: function (actual, expected) {\n      var complies = [\'keyPath\', \'unique\', \'multiEntry\'].every(function (key) {\n        // IE10 returns undefined for no multiEntry\n        if (key == \'multiEntry\' && actual[key] === undefined && expected[key] === false) {\n          return true;\n        }\n        // Compound keys\n        if (key == \'keyPath\' && Object.prototype.toString.call(expected[key]) == \'[object Array]\') {\n          var exp = expected.keyPath;\n          var act = actual.keyPath;\n\n          // IE10 can\'t handle keyPath sequences and stores them as a string.\n          // The index will be unusable there, but let\'s still return true if\n          // the keyPath sequence matches.\n          if (typeof act == \'string\') {\n            return exp.toString() == act;\n          }\n\n          // Chrome/Opera stores keyPath squences as DOMStringList, Firefox\n          // as Array\n          if ( ! (typeof act.contains == \'function\' || typeof act.indexOf == \'function\') ) {\n            return false;\n          }\n\n          if (act.length !== exp.length) {\n            return false;\n          }\n\n          for (var i = 0, m = exp.length; i<m; i++) {\n            if ( ! ( (act.contains && act.contains(exp[i])) || act.indexOf(exp[i] !== -1) )) {\n              return false;\n            }\n          }\n          return true;\n        }\n        return expected[key] == actual[key];\n      });\n      return complies;\n    },\n\n    /**********\n     * cursor *\n     **********/\n\n    /**\n     * Iterates over the store using the given options and calling onItem\n     * for each entry matching the options.\n     *\n     * @param {Function} onItem A callback to be called for each match\n     * @param {Object} [options] An object defining specific options\n     * @param {Object} [options.index=null] An IDBIndex to operate on\n     * @param {String} [options.order=ASC] The order in which to provide the\n     *  results, can be \'DESC\' or \'ASC\'\n     * @param {Boolean} [options.autoContinue=true] Whether to automatically\n     *  iterate the cursor to the next result\n     * @param {Boolean} [options.filterDuplicates=false] Whether to exclude\n     *  duplicate matches\n     * @param {Object} [options.keyRange=null] An IDBKeyRange to use\n     * @param {Boolean} [options.writeAccess=false] Whether grant write access\n     *  to the store in the onItem callback\n     * @param {Function} [options.onEnd=null] A callback to be called after\n     *  iteration has ended\n     * @param {Function} [options.onError=throw] A callback to be called\n     *  if an error occurred during the operation.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    iterate: function (onItem, options) {\n      options = mixin({\n        index: null,\n        order: \'ASC\',\n        autoContinue: true,\n        filterDuplicates: false,\n        keyRange: null,\n        writeAccess: false,\n        onEnd: null,\n        onError: defaultErrorHandler\n      }, options || {});\n\n      var directionType = options.order.toLowerCase() == \'desc\' ? \'PREV\' : \'NEXT\';\n      if (options.filterDuplicates) {\n        directionType += \'_NO_DUPLICATE\';\n      }\n\n      var hasSuccess = false;\n      var cursorTransaction = this.db.transaction([this.storeName], this.consts[options.writeAccess ? \'READ_WRITE\' : \'READ_ONLY\']);\n      var cursorTarget = cursorTransaction.objectStore(this.storeName);\n      if (options.index) {\n        cursorTarget = cursorTarget.index(options.index);\n      }\n\n      cursorTransaction.oncomplete = function () {\n        if (!hasSuccess) {\n          options.onError(null);\n          return;\n        }\n        if (options.onEnd) {\n          options.onEnd();\n        } else {\n          onItem(null);\n        }\n      };\n      cursorTransaction.onabort = options.onError;\n      cursorTransaction.onerror = options.onError;\n\n      var cursorRequest = cursorTarget.openCursor(options.keyRange, this.consts[directionType]);\n      cursorRequest.onerror = options.onError;\n      cursorRequest.onsuccess = function (event) {\n        var cursor = event.target.result;\n        if (cursor) {\n          onItem(cursor.value, cursor, cursorTransaction);\n          if (options.autoContinue) {\n            cursor[\'continue\']();\n          }\n        } else {\n          hasSuccess = true;\n        }\n      };\n\n      return cursorTransaction;\n    },\n\n    /**\n     * Runs a query against the store and passes an array containing matched\n     * objects to the success handler.\n     *\n     * @param {Function} onSuccess A callback to be called when the operation\n     *  was successful.\n     * @param {Object} [options] An object defining specific query options\n     * @param {Object} [options.index=null] An IDBIndex to operate on\n     * @param {String} [options.order=ASC] The order in which to provide the\n     *  results, can be \'DESC\' or \'ASC\'\n     * @param {Boolean} [options.filterDuplicates=false] Whether to exclude\n     *  duplicate matches\n     * @param {Object} [options.keyRange=null] An IDBKeyRange to use\n     * @param {Function} [options.onError=throw] A callback to be called if an error\n     *  occurred during the operation.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    query: function (onSuccess, options) {\n      var result = [];\n      options = options || {};\n      options.onEnd = function () {\n        onSuccess(result);\n      };\n      return this.iterate(function (item) {\n        result.push(item);\n      }, options);\n    },\n\n    /**\n     *\n     * Runs a query against the store, but only returns the number of matches\n     * instead of the matches itself.\n     *\n     * @param {Function} onSuccess A callback to be called if the opration\n     *  was successful.\n     * @param {Object} [options] An object defining specific options\n     * @param {Object} [options.index=null] An IDBIndex to operate on\n     * @param {Object} [options.keyRange=null] An IDBKeyRange to use\n     * @param {Function} [options.onError=throw] A callback to be called if an error\n     *  occurred during the operation.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    count: function (onSuccess, options) {\n\n      options = mixin({\n        index: null,\n        keyRange: null\n      }, options || {});\n\n      var onError = options.onError || defaultErrorHandler;\n\n      var hasSuccess = false,\n          result = null;\n\n      var cursorTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n      cursorTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n      cursorTransaction.onabort = onError;\n      cursorTransaction.onerror = onError;\n\n      var cursorTarget = cursorTransaction.objectStore(this.storeName);\n      if (options.index) {\n        cursorTarget = cursorTarget.index(options.index);\n      }\n      var countRequest = cursorTarget.count(options.keyRange);\n      countRequest.onsuccess = function (evt) {\n        hasSuccess = true;\n        result = evt.target.result;\n      };\n      countRequest.onError = onError;\n\n      return cursorTransaction;\n    },\n\n    /**************/\n    /* key ranges */\n    /**************/\n\n    /**\n     * Creates a key range using specified options. This key range can be\n     * handed over to the count() and iterate() methods.\n     *\n     * Note: You must provide at least one or both of "lower" or "upper" value.\n     *\n     * @param {Object} options The options for the key range to create\n     * @param {*} [options.lower] The lower bound\n     * @param {Boolean} [options.excludeLower] Whether to exclude the lower\n     *  bound passed in options.lower from the key range\n     * @param {*} [options.upper] The upper bound\n     * @param {Boolean} [options.excludeUpper] Whether to exclude the upper\n     *  bound passed in options.upper from the key range\n     * @param {*} [options.only] A single key value. Use this if you need a key\n     *  range that only includes one value for a key. Providing this\n     *  property invalidates all other properties.\n     * @return {Object} The IDBKeyRange representing the specified options\n     */\n    makeKeyRange: function(options){\n      /*jshint onecase:true */\n      var keyRange,\n          hasLower = typeof options.lower != \'undefined\',\n          hasUpper = typeof options.upper != \'undefined\',\n          isOnly = typeof options.only != \'undefined\';\n\n      switch(true){\n        case isOnly:\n          keyRange = this.keyRange.only(options.only);\n          break;\n        case hasLower && hasUpper:\n          keyRange = this.keyRange.bound(options.lower, options.upper, options.excludeLower, options.excludeUpper);\n          break;\n        case hasLower:\n          keyRange = this.keyRange.lowerBound(options.lower, options.excludeLower);\n          break;\n        case hasUpper:\n          keyRange = this.keyRange.upperBound(options.upper, options.excludeUpper);\n          break;\n        default:\n          throw new Error(\'Cannot create KeyRange. Provide one or both of "lower" or "upper" value, or an "only" value.\');\n      }\n\n      return keyRange;\n\n    }\n\n  };\n\n  /** helpers **/\n\n  var noop = function () {\n  };\n  var empty = {};\n  var mixin = function (target, source) {\n    var name, s;\n    for (name in source) {\n      s = source[name];\n      if (s !== empty[name] && s !== target[name]) {\n        target[name] = s;\n      }\n    }\n    return target;\n  };\n\n  IDBStore.version = IDBStore.prototype.version;\n\n  return IDBStore;\n\n}, this);\n\n})()\n},{}],14:[function(require,module,exports){\nvar ndn = require(\'ndn-browser-shim\');\nndn.Faces = require(\'./ndn-Faces.js\')\nvar strategy = require(\'./ndn-strategy.js\');\n\nvar idb = require(\'idb-wrapper\');\n\nvar pit = new idb({\n  storeName: "PITable",\n  dbVersion: 1,\n  keyPath: \'nonce\',\n  autoIncrement: false,\n  indexes: [\n    {name: "faceID"},\n    {name: "uri"},\n    {name: "prefixURIs", multiEntry: true},\n    {name: "publisherPublicKeyDigest"},\n    {name: "facePubKeyDigest"},\n    {name: "expirationAbsoluteMsec"}\n  ]\n}, function(){\n  console.log(\'PITable Ready, clearing out Interests that expired while we were gone...\');\n  var keyRange = pit.makeKeyRange({\n    upper: Date.now(),\n    lower: 0\n  })\n\n  pit.query(function onSuccess(matchArray){\n    var toRemove = []\n    for (var i = 0; i < matchArray.length; i++){\n      toRemove.push(matchArray[i].nonce)\n    }\n    pit.removeBatch(toRemove, function onSuccess(){\n      console.log(\'successfully garbage collected old PITEntrys\')\n    }, function onError(err){\n      console.log(\'something went wrong removing old PITEntrys \', err)\n    })\n  }, {\n    index: "expirationAbsoluteMsec",\n    keyRange: keyRange,\n    onError: function(err){\n      console.log(err)\n    }\n  } )\n\n  var setTimeoutKeyRange = pit.makeKeyRange({\n    lower: Date.now()\n  })\n\n  pit.query(function onSuccess(matchArray){\n    function clearEntry (nonce){\n      pit.remove(nonce, function onSuccess(bool){\n        console.log(\'remove Timeout PITEntry: \', bool)\n      }, function onError(err){\n        console.log(\'error removing timed out Pitentry, \', err)\n      })\n    }\n    for (var i = 0; i < matchArray.length; i++){\n      var time = matchArray[i].expirationAbsoluteMsec - Date.now()\n      setTimeout(clearEntry, time, matchArray[i].nonce)\n    }\n  },{\n    index: "expirationAbsoluteMsec",\n    keyRange: setTimeoutKeyRange,\n    onError: function(err){\n      console.log(err)\n    }\n  })\n})\n\nvar PIT = {};\n\nPIT.put = function(face, interestObj, interestBytes, forward){\n\n  var prefixes = [];\n\n  function getAllPrefixes(name){\n    var prefix = name.getPrefix(-1)\n    prefixes.push(prefix.toUri())\n    if (prefix.components.length > 0) {\n      getAllPrefixes(prefix)\n    }\n  }\n  getAllPrefixes(interestObj.name)\n  if (interestObj.publisherPublicKeyDigest) {\n    var pubKeyDig = interestObj.publisherPublicKeyDigest.toString(\'hex\')\n  }\n  var PITEntry = {\n    nonce: interestObj.nonce.toString(),\n    faceID: face.id,\n    faceHash: face.ndndid.toString(\'hex\'),\n    publisherPublicKeyDigest: pubKeyDig || \'any\',\n    expirationAbsoluteMsec: (Date.now() + interestObj.interestLifetime),\n    prefixURIs: prefixes,\n    uri: interestObj.name.toUri(),\n    encodedInterest: interestBytes\n  }\n\n  pit.put(PITEntry, function onSuccess(nonce){\n    forward(face, interestBytes, interestObj)\n    console.log(interestObj.interestLifetime, nonce, PITEntry, interestObj)\n    function clearEntry (){\n      pit.remove(nonce, function onSuccess(bool){\n        console.log(\'remove Timeout PITEntry: \', bool)\n      }, function onError(err){\n        console.log(\'error removing timed out Pitentry, \', err)\n      })\n    }\n    setTimeout(clearEntry, interestObj.interestLifetime)\n  }, function onError(err){\n    console.log(\'error inserting PITEntry\', PITEntry, err)\n  })\n\n\n\n}\n\nPIT.lookupData = function(data, bytes, onAck) {\n  console.log(\'got data, looking up in PIT\')\n  function evaluatePitEntrys(PITEntrys){\n    if (PITEntrys.length > 0) {\n      onAck(data)\n    }\n    var sent = []\n    for (var i = 0; i < PITEntrys.length; i++){\n      var entry = PITEntrys[i]\n      var faceID = entry.faceID\n      var faceHash = entry.faceHash\n      var inst = new ndn.Interest()\n      inst.decode(PITEntrys[i].encodedInterest)\n      try {\n        console.log(inst.matchesName(data.name) , (sent[faceID] == undefined) , (ndn.Faces.list[faceID].ndndid.toString(\'hex\') == faceHash))\n        if (inst.matchesName(data.name) && (sent[faceID] == undefined) && (ndn.Faces.list[faceID].ndndid.toString(\'hex\') == faceHash)) {\n          ndn.Faces.list[faceID].transport.send(bytes)\n          sent[faceID] == true\n          pit.remove(entry.nonce)\n        }\n      } catch (err) {\n        // this is where we would do some voodoo for long standing, delay tolerant stuff\n        console.log(err)\n      }\n    }\n  }\n\n\n  var pubKeyRange = pit.makeKeyRange({\n    only: data.signedInfo.publisher.publisherPublicKeyDigest.toString(\'hex\')\n  })\n\n  pit.query(function onSuccess(matchPubKey){\n    var anyPublisherKeyRange = pit.makeKeyRange({\n      only: "any"\n    })\n    pit.query(function onSuccess(matchAny){\n      var possiblePitEntrys = matchPubKey.concat(matchAny)\n      evaluatePitEntrys(possiblePitEntrys);\n    },{\n      index: "publisherPublicKeyDigest",\n      keyRange: anyPublisherKeyRange\n    })\n  }, {\n    index: "publisherPublicKeyDigest",\n    keyRange: pubKeyRange\n  })\n}\n\nPIT.lookupName = function(name, callback){\n  var keyRange = pit.makeKeyRange({\n    only: name.toUri()\n  })\n  console.log(\'looking up name\', name.toUri())\n\n  pit.query(function onSuccess(matches){\n    console.log(\'found matches, \', matches)\n    callback(matches)\n  }, {\n    index: "prefixURIs",\n    keyRange: keyRange\n  })\n}\n\n\n\nmodule.exports = PIT;\n\n},{"./ndn-Faces.js":7,"./ndn-strategy.js":9,"idb-wrapper":16,"ndn-browser-shim":10}],15:[function(require,module,exports){\nvar utils = require(\'./utils.js\')\nvar ndn = require(\'ndn-browser-shim\');\n\nvar level = require(\'levelup\');\nvar memdown = require(\'memdown\')\nvar sublevel = require(\'level-sublevel\');\nvar superlevel = require(\'level-superlevel\');\nvar ttl = require(\'level-ttl\');\nvar db = sublevel(superlevel(ttl(level(\'cache\',{db: memdown}))));\n\n\n\nvar cache = {}\ncache.db = db\n\ncache.check = function(interest,element, transport, onhit, onmiss) {\n  var uri = interest.name.toUri(),\n      contentKey = utils.initSegment(0),\n      reverse;\n      if ((interest.childSelector == 0) || (interest.childSelector == undefined)) {\n        reverse = false;\n      } else {\n        reverse = true;\n      };\n\n  if (utils.endsWithSegmentNumber(interest.name)) {\n    // A specific segment of a data object is being requested, so don\'t bother querying for loose matches, just return or drop\n    var level = interest.name.getPrefix(-1).append(contentKey).toUri(),\n        segmentNumber = utils.getSegmentInteger(interest.name);\n\n    if (db.sublevels[level] != undefined) {\n      db.sublevels[level].get(segmentNumber, function(err, data) {\n        if (err == undefined) {\n          onhit(data, transport)\n        } else {\n          onmiss(element, interest )\n        }\n      })\n    } else {\n      onmiss(element,interest)\n    }\n  } else {\n    // A general interest. Interpret according to selectors and return the first segment of the best matching dataset\n    var suffixIndex = 0;\n    var hit = false\n    function crawl(q, lastfail) {\n      var cursor, start, end;\n      //console.log(q)\n      if (db.sublevels[q] != undefined) {\n        cursor = db.sublevels[q]\n        if (lastfail && (reverse == true)) {\n          var tmp = lastfail[lastfail.length - 1]\n          lastfail[lastfail.length - 1] = tmp - 1\n          end = lastfail\n        } else if (lastfail) {\n          var tmp = lastfail[lastfail.length - 1]\n          lastfail[lastfail.length - 1] = tmp + 1\n          start = lastfail\n        }\n        var read = false\n        cursor.createReadStream({start: start, end: end, reverse: reverse, limit: 1}).on(\'data\', function(data) {\n          read = true\n          if ((interest.exclude == null) || (!interest.exclude.matches(new ndn.Name.Component(data.key)))) {\n            console.log(\'Suffix is not excluded\');\n            if (data.key == contentKey) {\n              console.log(\'got to data\');\n              if ((interest.minSuffixComponents == null) || (suffixIndex >= interest.minSuffixComponents )) {\n                console.log(\'more than minimum suffix components\');\n                db.sublevels[data.value].get(0, function(err, data){\n                  if (interest.publisherPublicKeyDigest != undefined) {\n                    var d = new ndn.Data()\n                    d.decode(data)\n                    if (ndn.DataUtils.arraysEqual(d.signedInfo.publisher.publisherPublicKeyDigest, interest.publisherPublicKeyDigest.publisherPublicKeyDigest)) {\n                      onhit(data, transport)\n                    } else {\n                      crawl(q, contentKey)\n                    }\n                  } else {\n                    onhit(data, transport)\n                  }\n                })\n              } else {\n                console.log(\'not enough suffix\')\n                crawl(q, contentKey)\n              }\n            } else {\n              console.log(\'keep crawling\')\n\n              if ((interest.maxSuffixComponents == null) || (suffixIndex  < interest.maxSuffixComponents)) {\n                suffixIndex++\n                crawl(data.value)\n              } else {\n                console.log(\'reached max suffix\');\n                crawl(q,  data.key)\n              }\n            }\n\n          } else {\n            console.log(\'name component is excluded in interest,\')\n            crawl(q, data.key)\n          }\n        }).on(\'end\', function(err,data){\n          if ((read == false) && ((interest.minSuffixComponents == null) || (suffixIndex > interest.minSuffixComponents ))) {\n            //we\'ve exhasted this depth, need to go up a level, and we have the leeway from minSuffix to allow\n            var comps = q.split(\'/\')\n            var fail = comps.pop()\n            var newQ = \'/\' + comps.join(\'/\')\n            crawl(newQ, new ndn.Name.Component(fail).value)\n          }\n\n        })\n      } else {\n        onmiss(element,interest)\n      }\n    }\n  crawl(uri)\n  }\n}\n\n\ncache.data = function(data, element) {\n  var segmentNumber = utils.getSegmentInteger(data.name),\n      contentKey = utils.initSegment(0),\n      levelName = data.name.getPrefix(-1).append(contentKey),\n      level = levelName.toUri(),\n      ttl;\n  if (data.signedInfo.freshnessSeconds != undefined || 0) {\n      ttl = data.signedInfo.freshnessSeconds * 1000\n  }\n  //console.log(level, segmentNumber, \'put in cache\')\n  db.sublevel(level).put(segmentNumber, element)\n  var comps = level.split(\'/\')\n  //construct tree\n  for (var i = comps.length - 1; i > 0; i-- ) {\n    console.log(comps)\n    var value = comps.join(\'/\')\n    var keyComp = comps.pop()\n    if (keyComp == \'%00\') {\n      var key = contentKey\n    } else {\n      var key = new ndn.Name.Component(keyComp).value\n    }\n\n    var slevel = comps.join(\'/\') || \'/\'\n    db.sublevel(slevel).put(key, value)\n\n  }\n}\n\n\nmodule.exports = cache;\n\n},{"./utils.js":8,"level-sublevel":21,"level-superlevel":19,"level-ttl":20,"levelup":17,"memdown":18,"ndn-browser-shim":10}],22:[function(require,module,exports){\nvar events = require(\'events\');\n\nexports.isArray = isArray;\nexports.isDate = function(obj){return Object.prototype.toString.call(obj) === \'[object Date]\'};\nexports.isRegExp = function(obj){return Object.prototype.toString.call(obj) === \'[object RegExp]\'};\n\n\nexports.print = function () {};\nexports.puts = function () {};\nexports.debug = function() {};\n\nexports.inspect = function(obj, showHidden, depth, colors) {\n  var seen = [];\n\n  var stylize = function(str, styleType) {\n    // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\n    var styles =\n        { \'bold\' : [1, 22],\n          \'italic\' : [3, 23],\n          \'underline\' : [4, 24],\n          \'inverse\' : [7, 27],\n          \'white\' : [37, 39],\n          \'grey\' : [90, 39],\n          \'black\' : [30, 39],\n          \'blue\' : [34, 39],\n          \'cyan\' : [36, 39],\n          \'green\' : [32, 39],\n          \'magenta\' : [35, 39],\n          \'red\' : [31, 39],\n          \'yellow\' : [33, 39] };\n\n    var style =\n        { \'special\': \'cyan\',\n          \'number\': \'blue\',\n          \'boolean\': \'yellow\',\n          \'undefined\': \'grey\',\n          \'null\': \'bold\',\n          \'string\': \'green\',\n          \'date\': \'magenta\',\n          // "name": intentionally not styling\n          \'regexp\': \'red\' }[styleType];\n\n    if (style) {\n      return \'\\u001b[\' + styles[style][0] + \'m\' + str +\n             \'\\u001b[\' + styles[style][1] + \'m\';\n    } else {\n      return str;\n    }\n  };\n  if (! colors) {\n    stylize = function(str, styleType) { return str; };\n  }\n\n  function format(value, recurseTimes) {\n    // Provide a hook for user-specified inspect functions.\n    // Check that value is an object with an inspect function on it\n    if (value && typeof value.inspect === \'function\' &&\n        // Filter out the util module, it\'s inspect function is special\n        value !== exports &&\n        // Also filter out any prototype objects using the circular check.\n        !(value.constructor && value.constructor.prototype === value)) {\n      return value.inspect(recurseTimes);\n    }\n\n    // Primitive types cannot have properties\n    switch (typeof value) {\n      case \'undefined\':\n        return stylize(\'undefined\', \'undefined\');\n\n      case \'string\':\n        var simple = \'\\\'\' + JSON.stringify(value).replace(/^"|"$/g, \'\')\n                                                 .replace(/\'/g, "\\\\\'")\n                                                 .replace(/\\\\"/g, \'"\') + \'\\\'\';\n        return stylize(simple, \'string\');\n\n      case \'number\':\n        return stylize(\'\' + value, \'number\');\n\n      case \'boolean\':\n        return stylize(\'\' + value, \'boolean\');\n    }\n    // For some reason typeof null is "object", so special case here.\n    if (value === null) {\n      return stylize(\'null\', \'null\');\n    }\n\n    // Look up the keys of the object.\n    var visible_keys = Object_keys(value);\n    var keys = showHidden ? Object_getOwnPropertyNames(value) : visible_keys;\n\n    // Functions without properties can be shortcutted.\n    if (typeof value === \'function\' && keys.length === 0) {\n      if (isRegExp(value)) {\n        return stylize(\'\' + value, \'regexp\');\n      } else {\n        var name = value.name ? \': \' + value.name : \'\';\n        return stylize(\'[Function\' + name + \']\', \'special\');\n      }\n    }\n\n    // Dates without properties can be shortcutted\n    if (isDate(value) && keys.length === 0) {\n      return stylize(value.toUTCString(), \'date\');\n    }\n\n    var base, type, braces;\n    // Determine the object type\n    if (isArray(value)) {\n      type = \'Array\';\n      braces = [\'[\', \']\'];\n    } else {\n      type = \'Object\';\n      braces = [\'{\', \'}\'];\n    }\n\n    // Make functions say that they are functions\n    if (typeof value === \'function\') {\n      var n = value.name ? \': \' + value.name : \'\';\n      base = (isRegExp(value)) ? \' \' + value : \' [Function\' + n + \']\';\n    } else {\n      base = \'\';\n    }\n\n    // Make dates with properties first say the date\n    if (isDate(value)) {\n      base = \' \' + value.toUTCString();\n    }\n\n    if (keys.length === 0) {\n      return braces[0] + base + braces[1];\n    }\n\n    if (recurseTimes < 0) {\n      if (isRegExp(value)) {\n        return stylize(\'\' + value, \'regexp\');\n      } else {\n        return stylize(\'[Object]\', \'special\');\n      }\n    }\n\n    seen.push(value);\n\n    var output = keys.map(function(key) {\n      var name, str;\n      if (value.__lookupGetter__) {\n        if (value.__lookupGetter__(key)) {\n          if (value.__lookupSetter__(key)) {\n            str = stylize(\'[Getter/Setter]\', \'special\');\n          } else {\n            str = stylize(\'[Getter]\', \'special\');\n          }\n        } else {\n          if (value.__lookupSetter__(key)) {\n            str = stylize(\'[Setter]\', \'special\');\n          }\n        }\n      }\n      if (visible_keys.indexOf(key) < 0) {\n        name = \'[\' + key + \']\';\n      }\n      if (!str) {\n        if (seen.indexOf(value[key]) < 0) {\n          if (recurseTimes === null) {\n            str = format(value[key]);\n          } else {\n            str = format(value[key], recurseTimes - 1);\n          }\n          if (str.indexOf(\'\\n\') > -1) {\n            if (isArray(value)) {\n              str = str.split(\'\\n\').map(function(line) {\n                return \'  \' + line;\n              }).join(\'\\n\').substr(2);\n            } else {\n              str = \'\\n\' + str.split(\'\\n\').map(function(line) {\n                return \'   \' + line;\n              }).join(\'\\n\');\n            }\n          }\n        } else {\n          str = stylize(\'[Circular]\', \'special\');\n        }\n      }\n      if (typeof name === \'undefined\') {\n        if (type === \'Array\' && key.match(/^\\d+$/)) {\n          return str;\n        }\n        name = JSON.stringify(\'\' + key);\n        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {\n          name = name.substr(1, name.length - 2);\n          name = stylize(name, \'name\');\n        } else {\n          name = name.replace(/\'/g, "\\\\\'")\n                     .replace(/\\\\"/g, \'"\')\n                     .replace(/(^"|"$)/g, "\'");\n          name = stylize(name, \'string\');\n        }\n      }\n\n      return name + \': \' + str;\n    });\n\n    seen.pop();\n\n    var numLinesEst = 0;\n    var length = output.reduce(function(prev, cur) {\n      numLinesEst++;\n      if (cur.indexOf(\'\\n\') >= 0) numLinesEst++;\n      return prev + cur.length + 1;\n    }, 0);\n\n    if (length > 50) {\n      output = braces[0] +\n               (base === \'\' ? \'\' : base + \'\\n \') +\n               \' \' +\n               output.join(\',\\n  \') +\n               \' \' +\n               braces[1];\n\n    } else {\n      output = braces[0] + base + \' \' + output.join(\', \') + \' \' + braces[1];\n    }\n\n    return output;\n  }\n  return format(obj, (typeof depth === \'undefined\' ? 2 : depth));\n};\n\n\nfunction isArray(ar) {\n  return Array.isArray(ar) ||\n         (typeof ar === \'object\' && Object.prototype.toString.call(ar) === \'[object Array]\');\n}\n\n\nfunction isRegExp(re) {\n  typeof re === \'object\' && Object.prototype.toString.call(re) === \'[object RegExp]\';\n}\n\n\nfunction isDate(d) {\n  return typeof d === \'object\' && Object.prototype.toString.call(d) === \'[object Date]\';\n}\n\nfunction pad(n) {\n  return n < 10 ? \'0\' + n.toString(10) : n.toString(10);\n}\n\nvar months = [\'Jan\', \'Feb\', \'Mar\', \'Apr\', \'May\', \'Jun\', \'Jul\', \'Aug\', \'Sep\',\n              \'Oct\', \'Nov\', \'Dec\'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(\':\');\n  return [d.getDate(), months[d.getMonth()], time].join(\' \');\n}\n\nexports.log = function (msg) {};\n\nexports.pump = null;\n\nvar Object_keys = Object.keys || function (obj) {\n    var res = [];\n    for (var key in obj) res.push(key);\n    return res;\n};\n\nvar Object_getOwnPropertyNames = Object.getOwnPropertyNames || function (obj) {\n    var res = [];\n    for (var key in obj) {\n        if (Object.hasOwnProperty.call(obj, key)) res.push(key);\n    }\n    return res;\n};\n\nvar Object_create = Object.create || function (prototype, properties) {\n    // from es5-shim\n    var object;\n    if (prototype === null) {\n        object = { \'__proto__\' : null };\n    }\n    else {\n        if (typeof prototype !== \'object\') {\n            throw new TypeError(\n                \'typeof prototype[\' + (typeof prototype) + \'] != \\\'object\\\'\'\n            );\n        }\n        var Type = function () {};\n        Type.prototype = prototype;\n        object = new Type();\n        object.__proto__ = prototype;\n    }\n    if (typeof properties !== \'undefined\' && Object.defineProperties) {\n        Object.defineProperties(object, properties);\n    }\n    return object;\n};\n\nexports.inherits = function(ctor, superCtor) {\n  ctor.super_ = superCtor;\n  ctor.prototype = Object_create(superCtor.prototype, {\n    constructor: {\n      value: ctor,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n};\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (typeof f !== \'string\') {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(exports.inspect(arguments[i]));\n    }\n    return objects.join(\' \');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === \'%%\') return \'%\';\n    if (i >= len) return x;\n    switch (x) {\n      case \'%s\': return String(args[i++]);\n      case \'%d\': return Number(args[i++]);\n      case \'%j\': return JSON.stringify(args[i++]);\n      default:\n        return x;\n    }\n  });\n  for(var x = args[i]; i < len; x = args[++i]){\n    if (x === null || typeof x !== \'object\') {\n      str += \' \' + x;\n    } else {\n      str += \' \' + exports.inspect(x);\n    }\n  }\n  return str;\n};\n\n},{"events":23}],23:[function(require,module,exports){\n(function(process){if (!process.EventEmitter) process.EventEmitter = function () {};\n\nvar EventEmitter = exports.EventEmitter = process.EventEmitter;\nvar isArray = typeof Array.isArray === \'function\'\n    ? Array.isArray\n    : function (xs) {\n        return Object.prototype.toString.call(xs) === \'[object Array]\'\n    }\n;\nfunction indexOf (xs, x) {\n    if (xs.indexOf) return xs.indexOf(x);\n    for (var i = 0; i < xs.length; i++) {\n        if (x === xs[i]) return i;\n    }\n    return -1;\n}\n\n// By default EventEmitters will print a warning if more than\n// 10 listeners are added to it. This is a useful default which\n// helps finding memory leaks.\n//\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nvar defaultMaxListeners = 10;\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!this._events) this._events = {};\n  this._events.maxListeners = n;\n};\n\n\nEventEmitter.prototype.emit = function(type) {\n  // If there is no \'error\' event listener then throw.\n  if (type === \'error\') {\n    if (!this._events || !this._events.error ||\n        (isArray(this._events.error) && !this._events.error.length))\n    {\n      if (arguments[1] instanceof Error) {\n        throw arguments[1]; // Unhandled \'error\' event\n      } else {\n        throw new Error("Uncaught, unspecified \'error\' event.");\n      }\n      return false;\n    }\n  }\n\n  if (!this._events) return false;\n  var handler = this._events[type];\n  if (!handler) return false;\n\n  if (typeof handler == \'function\') {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        var args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n    return true;\n\n  } else if (isArray(handler)) {\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    var listeners = handler.slice();\n    for (var i = 0, l = listeners.length; i < l; i++) {\n      listeners[i].apply(this, args);\n    }\n    return true;\n\n  } else {\n    return false;\n  }\n};\n\n// EventEmitter is defined in src/node_events.cc\n// EventEmitter.prototype.emit() is also defined there.\nEventEmitter.prototype.addListener = function(type, listener) {\n  if (\'function\' !== typeof listener) {\n    throw new Error(\'addListener only takes instances of Function\');\n  }\n\n  if (!this._events) this._events = {};\n\n  // To avoid recursion in the case that type == "newListeners"! Before\n  // adding it to the listeners, first emit "newListeners".\n  this.emit(\'newListener\', type, listener);\n\n  if (!this._events[type]) {\n    // Optimize the case of one listener. Don\'t need the extra array object.\n    this._events[type] = listener;\n  } else if (isArray(this._events[type])) {\n\n    // Check for listener leak\n    if (!this._events[type].warned) {\n      var m;\n      if (this._events.maxListeners !== undefined) {\n        m = this._events.maxListeners;\n      } else {\n        m = defaultMaxListeners;\n      }\n\n      if (m && m > 0 && this._events[type].length > m) {\n        this._events[type].warned = true;\n        console.error(\'(node) warning: possible EventEmitter memory \' +\n                      \'leak detected. %d listeners added. \' +\n                      \'Use emitter.setMaxListeners() to increase limit.\',\n                      this._events[type].length);\n        console.trace();\n      }\n    }\n\n    // If we\'ve already got an array, just append.\n    this._events[type].push(listener);\n  } else {\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  var self = this;\n  self.on(type, function g() {\n    self.removeListener(type, g);\n    listener.apply(this, arguments);\n  });\n\n  return this;\n};\n\nEventEmitter.prototype.removeListener = function(type, listener) {\n  if (\'function\' !== typeof listener) {\n    throw new Error(\'removeListener only takes instances of Function\');\n  }\n\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (!this._events || !this._events[type]) return this;\n\n  var list = this._events[type];\n\n  if (isArray(list)) {\n    var i = indexOf(list, listener);\n    if (i < 0) return this;\n    list.splice(i, 1);\n    if (list.length == 0)\n      delete this._events[type];\n  } else if (this._events[type] === listener) {\n    delete this._events[type];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  if (arguments.length === 0) {\n    this._events = {};\n    return this;\n  }\n\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (type && this._events && this._events[type]) this._events[type] = null;\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  if (!this._events) this._events = {};\n  if (!this._events[type]) this._events[type] = [];\n  if (!isArray(this._events[type])) {\n    this._events[type] = [this._events[type]];\n  }\n  return this._events[type];\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  var ret;\n  if (!emitter._events || !emitter._events[type])\n    ret = 0;\n  else if (typeof emitter._events[type] === \'function\')\n    ret = 1;\n  else\n    ret = emitter._events[type].length;\n  return ret;\n};\n\n})(require("__browserify_process"))\n},{"__browserify_process":13}],19:[function(require,module,exports){\n\n/*\n * superlevel\n * https://github.com/randymized/level-superlevel\n *\n * Copyright (c) 2013 Randy McLaughlin\n * Licensed under the MIT license.\n */\n\n\'use strict\';\n\nvar superlevel = require( \'./lib/level-superlevel.js\' );\n\nmodule.exports = superlevel;\n\n},{"./lib/level-superlevel.js":24}],24:[function(require,module,exports){\n\n/*\n * level-superlevel\n * https://github.com/randymized/level-superlevel\n *\n * Copyright (c) 2013 Randy McLaughlin\n * Licensed under the MIT license.\n */\n\n\'use strict\';\n\nvar crypto= require(\'crypto\');\nvar superlevel;\n\nmodule.exports = superlevel = function(db,options) {\n  function Superlevel() {}\n  Superlevel.prototype.createReadStream = function(options) {\n    return db.createReadStream(options);\n  };\n  Superlevel.prototype.createKeyStream = function(options) {\n    return db.createKeyStream(options);\n  };\n  Superlevel.prototype.createValueStream = function(options) {\n    return db.createValueStream(options);\n  };\n  Superlevel.prototype.get = function(key,options,cb) {\n    return db.get(key,options,cb);\n  };\n  if (options && options.writable) {\n    Superlevel.prototype.createWriteStream = function(options) {\n      return db.createWriteStream(options);\n    };\n    Superlevel.prototype.put = function(key,value,options,cb) {\n      return db.put(key,value,options,cb);\n    };\n    Superlevel.prototype.del = function(key,options,cb) {\n      return db.del(key,options,cb);\n    };\n    Superlevel.prototype.batch = function(array,options,cb) {\n      return db.batch(array,options,cb);\n    };\n  }\n  db.superlevel= new Superlevel();\n  return db;\n};\n\n},{"crypto":25}],26:[function(require,module,exports){\nfunction addOperation (type, key, value, options) {\n  var operation = {\n    type: type,\n    key: key,\n    value: value,\n    options: options\n  }\n\n  if (options && options.prefix) {\n    operation.prefix = options.prefix\n    delete options.prefix\n  }\n\n  this._operations.push(operation)\n\n  return this\n}\n\nfunction Batch(sdb) {\n  this._operations = []\n  this._sdb = sdb\n\n  this.put = addOperation.bind(this, \'put\')\n  this.del = addOperation.bind(this, \'del\')\n}\n\nvar B = Batch.prototype\n\n\nB.clear = function () {\n  this._operations = []\n}\n\nB.write = function (cb) {\n  this._sdb.batch(this._operations, cb)\n}\n\nmodule.exports = Batch\n\n},{}],18:[function(require,module,exports){\n(function(process){var util              = require(\'util\')\n  , bops              = require(\'bops\')\n  , AbstractLevelDOWN = require(\'abstract-leveldown\').AbstractLevelDOWN\n  , AbstractIterator  = require(\'abstract-leveldown\').AbstractIterator\n  , noop              = function () {}\n  , setImmediate      = process.nextTick\n\nfunction toKey (key) {\n  return typeof key == \'string\' ? \'$\' + key : JSON.stringify(key)\n}\n\nfunction sortedIndexOf (arr, item) {\n  var low = 0, high = arr.length, mid\n  while (low < high) {\n    mid = (low + high) >>> 1\n    arr[mid] < item ? low = mid + 1 : high = mid\n  }\n  return low\n}\n\nfunction MemIterator (db, options) {\n  AbstractIterator.call(this, db)\n  this._reverse = options.reverse\n  this._limit   = options.limit\n  this._count   = 0\n  this._end     = options.end\n  this._start   = options.start\n  this._gt      = options.gt\n  this._gte     = options.gte\n  this._lt      = options.lt\n  this._lte     = options.lte\n\n  var i\n\n  if (this._start) {\n    for (i = 0; i < this.db._keys.length; i++) {\n      if (this.db._keys[i] >= this._start) {\n        this._pos = i\n        if (this.db._keys[i] != this._start) {\n          if (this._reverse) {\n            // going backwards and key doesn\'t match, jump back one\n            --this._pos\n          }\n        } else {\n          if (options.exclusiveStart) {\n            // key matches but it\'s a gt or lt\n            this._pos += (this._reverse ? -1 : 1)\n          }\n        }\n        break\n      }\n    }\n\n    if (this._pos == null && !this._reverse) // no matching keys, non starter\n      this._pos = -1\n  }\n\n  if (!options.start || !this._pos)\n    this._pos = this._reverse ? this.db._keys.length - 1 : 0\n}\n\nutil.inherits(MemIterator, AbstractIterator)\n\nMemIterator.prototype._next = function (callback) {\n  var self  = this\n    , key   = self.db._keys[self._pos]\n    , value\n\n  if (self._pos >= self.db._keys.length || self._pos < 0)\n    return setImmediate(callback)\n\n  if (!!self._end && (self._reverse ? key < self._end : key > self._end))\n    return setImmediate(callback)\n\n\n  if (!!self._limit && self._limit > 0 && self._count++ >= self._limit)\n    return setImmediate(callback)\n\n  if (  (this._lt  && key >= this._lt)\n     || (this._lte && key > this._lte)\n     || (this._gt  && key <= this._gt)\n     || (this._gte && key < this._gte))\n    return setImmediate(callback)\n\n  value = self.db._store[toKey(key)]\n  self._pos += self._reverse ? -1 : 1\n\n  setImmediate(function () { callback(null, key, value) })\n}\n\nfunction MemDOWN (location) {\n  if (!(this instanceof MemDOWN))\n    return new MemDOWN(location)\n\n  AbstractLevelDOWN.call(this, typeof location == \'string\' ? location : \'\')\n  this._store = {}\n  this._keys  = []\n}\n\nutil.inherits(MemDOWN, AbstractLevelDOWN)\n\nMemDOWN.prototype._open = function (options, callback) {\n  var self = this\n  setImmediate(function () { callback(null, self) })\n}\n\nMemDOWN.prototype._put = function (key, value, options, callback) {\n  var ix = sortedIndexOf(this._keys, key)\n  if (this._keys[ix] != key)\n    this._keys.splice(ix, 0, key)\n  key = toKey(key) // safety, to avoid key=\'__proto__\'-type skullduggery \n  this._store[key] = value\n  setImmediate(callback)\n}\n\nMemDOWN.prototype._get = function (key, options, callback) {\n  var value = this._store[toKey(key)]\n  if (value === undefined) {\n    // \'NotFound\' error, consistent with LevelDOWN API\n    return setImmediate(function () { callback(new Error(\'NotFound\')) })\n  }\n  if (options.asBuffer !== false && !bops.is(value))\n    value = bops.from(String(value))\n  setImmediate(function () {\n    callback(null, value)\n  })\n}\n\nMemDOWN.prototype._del = function (key, options, callback) {\n  var ix = sortedIndexOf(this._keys, key)\n  if (this._keys[ix] == key)\n    this._keys.splice(ix, 1)\n  delete this._store[toKey(key)]\n  setImmediate(callback)\n}\n\nMemDOWN.prototype._batch = function (array, options, callback) {\n  var err\n    , i = 0\n    , key\n    , value\n\n  if (Array.isArray(array)) {\n    for (; i < array.length; i++) {\n      if (array[i]) {\n        key = bops.is(array[i].key) ? array[i].key : String(array[i].key)\n        err = this._checkKeyValue(key, \'key\')\n        if (err) return setImmediate(function () { callback(err) })\n        if (array[i].type === \'del\') {\n          this._del(array[i].key, options, noop)\n        } else if (array[i].type === \'put\') {\n          value = bops.is(array[i].value) ? array[i].value : String(array[i].value)\n          err = this._checkKeyValue(value, \'value\')\n          if (err) return setImmediate(function () { callback(err) })\n          this._put(key, value, options, noop)\n        }\n      }\n    }\n  }\n  setImmediate(callback)\n}\n\nMemDOWN.prototype._iterator = function (options) {\n  return new MemIterator(this, options)\n}\n\nMemDOWN.prototype._isBuffer = function (obj) {\n  return bops.is(obj)\n}\n\nmodule.exports = MemDOWN\n\n})(require("__browserify_process"))\n},{"__browserify_process":13,"abstract-leveldown":28,"bops":27,"util":22}],21:[function(require,module,exports){\n(function(process){var EventEmitter = require(\'events\').EventEmitter\nvar next         = process.nextTick\nvar SubDb        = require(\'./sub\')\nvar Batch        = require(\'./batch\')\nvar fixRange     = require(\'level-fix-range\')\n\nvar Hooks   = require(\'level-hooks\')\n\nmodule.exports   = function (_db, options) {\n  function DB () {}\n  DB.prototype = _db\n  var db = new DB()\n\n  if (db.sublevel) return db\n\n  options = options || {}\n\n  //use \\xff (255) as the seperator,\n  //so that sections of the database will sort after the regular keys\n  var sep = options.sep = options.sep || \'\\xff\'\n  db._options = options\n\n  Hooks(db)\n\n  db.sublevels = {}\n\n  db.sublevel = function (prefix, options) {\n    if(db.sublevels[prefix])\n      return db.sublevels[prefix]\n    return new SubDb(db, prefix, options || this._options)\n  }\n\n  db.methods = {}\n\n  db.prefix = function (key) {\n    return \'\' + (key || \'\')\n  }\n\n  db.pre = function (range, hook) {\n    if(!hook)\n      hook = range, range = {\n        max  : sep\n      }\n    return db.hooks.pre(range, hook)\n  }\n\n  db.post = function (range, hook) {\n    if(!hook)\n      hook = range, range = {\n        max : sep\n      }\n    return db.hooks.post(range, hook)\n  }\n\n  function safeRange(fun) {\n    return function (opts) {\n      opts = opts || {}\n      opts = fixRange(opts)\n\n      if(opts.reverse) opts.start = opts.start || sep\n      else             opts.end   = opts.end || sep\n\n      return fun.call(db, opts)\n    }\n  }\n\n  db.readStream =\n  db.createReadStream  = safeRange(db.createReadStream)\n  db.keyStream =\n  db.createKeyStream   = safeRange(db.createKeyStream)\n  db.valuesStream =\n  db.createValueStream = safeRange(db.createValueStream)\n\n  var batch = db.batch\n  db.batch = function (changes, opts, cb) {\n    if(!Array.isArray(changes))\n      return new Batch(db)\n    changes.forEach(function (e) {\n      if(e.prefix) {\n        if(\'function\' === typeof e.prefix.prefix)\n          e.key = e.prefix.prefix(e.key)\n        else if(\'string\'  === typeof e.prefix)\n          e.key = e.prefix + e.key\n      }\n    })\n    batch.call(db, changes, opts, cb)\n  }\n  return db\n}\n\n\n})(require("__browserify_process"))\n},{"./batch":26,"./sub":29,"__browserify_process":13,"events":23,"level-fix-range":30,"level-hooks":31}],32:[function(require,module,exports){\nvar events = require(\'events\');\nvar util = require(\'util\');\n\nfunction Stream() {\n  events.EventEmitter.call(this);\n}\nutil.inherits(Stream, events.EventEmitter);\nmodule.exports = Stream;\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on(\'data\', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on(\'drain\', ondrain);\n\n  // If the \'end\' option is not supplied, dest.end() will be called when\n  // source gets the \'end\' or \'close\' events.  Only dest.end() once, and\n  // only when all sources have ended.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    dest._pipeCount = dest._pipeCount || 0;\n    dest._pipeCount++;\n\n    source.on(\'end\', onend);\n    source.on(\'close\', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest._pipeCount--;\n\n    // remove the listeners\n    cleanup();\n\n    if (dest._pipeCount > 0) {\n      // waiting for other incoming streams to end.\n      return;\n    }\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest._pipeCount--;\n\n    // remove the listeners\n    cleanup();\n\n    if (dest._pipeCount > 0) {\n      // waiting for other incoming streams to end.\n      return;\n    }\n\n    dest.destroy();\n  }\n\n  // don\'t leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (this.listeners(\'error\').length === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on(\'error\', onerror);\n  dest.on(\'error\', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener(\'data\', ondata);\n    dest.removeListener(\'drain\', ondrain);\n\n    source.removeListener(\'end\', onend);\n    source.removeListener(\'close\', onclose);\n\n    source.removeListener(\'error\', onerror);\n    dest.removeListener(\'error\', onerror);\n\n    source.removeListener(\'end\', cleanup);\n    source.removeListener(\'close\', cleanup);\n\n    dest.removeListener(\'end\', cleanup);\n    dest.removeListener(\'close\', cleanup);\n  }\n\n  source.on(\'end\', cleanup);\n  source.on(\'close\', cleanup);\n\n  dest.on(\'end\', cleanup);\n  dest.on(\'close\', cleanup);\n\n  dest.emit(\'pipe\', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n\n},{"events":23,"util":22}],33:[function(require,module,exports){\nmodule.exports = after\n\nfunction after(count, callback, err_cb) {\n    var bail = false\n    err_cb = err_cb || noop\n    proxy.count = count\n\n    return (count === 0) ? callback() : proxy\n\n    function proxy(err, result) {\n        if (proxy.count <= 0) {\n            throw new Error(\'after called too many times\')\n        }\n        --proxy.count\n\n        // after first error, rest are passed to err_cb\n        if (err) {\n            bail = true\n            callback(err)\n            // future error callbacks will go to error handler\n            callback = err_cb\n        } else if (proxy.count === 0 && !bail) {\n            callback(null, result)\n        }\n    }\n}\n\nfunction noop() {}\n\n},{}],34:[function(require,module,exports){\n/* Copyright (c) 2012-2013 LevelUP contributors\n * See list at <https://github.com/rvagg/node-levelup#contributing>\n * MIT +no-false-attribs License\n * <https://github.com/rvagg/node-levelup/blob/master/LICENSE>\n */\n\nvar util          = require(\'./util\')\n  , WriteError    = require(\'./errors\').WriteError\n\n  , getOptions    = util.getOptions\n  , dispatchError = util.dispatchError\n\nfunction Batch (levelup) {\n  this._levelup = levelup\n  this.batch = levelup.db.batch()\n  this.ops = []\n}\n\nBatch.prototype.put = function (key_, value_, options) {\n  options = getOptions(this._levelup, options)\n\n  var key   = util.encodeKey(key_, options)\n    , value = util.encodeValue(value_, options)\n\n  try {\n    this.batch.put(key, value)\n  } catch (e) {\n    throw new WriteError(e)\n  }\n  this.ops.push({ type : \'put\', key : key, value : value })\n\n  return this\n}\n\nBatch.prototype.del = function (key_, options) {\n  options = getOptions(this._levelup, options)\n\n  var key = util.encodeKey(key_, options)\n\n  try {\n    this.batch.del(key)\n  } catch (err) {\n    throw new WriteError(err)\n  }\n  this.ops.push({ type : \'del\', key : key })\n\n  return this\n}\n\nBatch.prototype.clear = function () {\n  try {\n    this.batch.clear()\n  } catch (err) {\n    throw new WriteError(err)\n  }\n\n  this.ops = []\n  return this\n}\n\nBatch.prototype.write = function (callback) {\n  var levelup = this._levelup\n    , ops     = this.ops\n\n  try {\n    this.batch.write(function (err) {\n      if (err)\n        return dispatchError(levelup, new WriteError(err), callback)\n      levelup.emit(\'batch\', ops)\n      if (callback)\n        callback()\n    })\n  } catch (err) {\n    throw new WriteError(err)\n  }\n}\n\nmodule.exports = Batch\n\n},{"./errors":36,"./util":35}],20:[function(require,module,exports){\nconst after    = require(\'after\')\n    , xtend    = require(\'xtend\')\n    , sublevel = require(\'level-sublevel\')\n\n    , DEFAULT_FREQUENCY = 10000\n\nvar startTtl = function (db, checkFrequency) {\n      db._ttl.intervalId = setInterval(function () {\n        var batch    = []\n          , subBatch = []\n          , query = {\n                keyEncoding: \'utf8\'\n              , valueEncoding: \'utf8\'\n              , end: String(Date.now())\n            }\n\n        db._ttl._checkInProgress = true\n        db._ttl.sub.createReadStream(query)\n          .on(\'data\', function (data) {\n            subBatch.push({ type: \'del\', key: data.value })\n            subBatch.push({ type: \'del\', key: data.key })\n            batch.push({ type: \'del\', key: data.value })\n          })\n          .on(\'error\', db.emit.bind(db, \'error\'))\n          .on(\'end\', function () {\n            if (batch.length) {\n              db._ttl.sub.batch(\n                  subBatch\n                , { keyEncoding: \'utf8\' }\n                , function (err) {\n                    if (err)\n                      db.emit(\'error\', err)\n                  }\n              )\n              db._ttl.batch(\n                  batch\n                , { keyEncoding: \'utf8\' }\n                , function (err) {\n                    if (err)\n                      db.emit(\'error\', err)\n                  }\n              )\n            }\n          })\n          .on(\'close\', function () {\n            db._ttl._checkInProgress = false\n            if (db._ttl._stopAfterCheck) {\n              stopTtl(db, db._ttl._stopAfterCheck)\n              db._ttl._stopAfterCheck = null\n            }\n          })\n      }, checkFrequency)\n    }\n\n  , stopTtl = function (db, callback) {\n      // can\'t close a db while an interator is in progress\n      // so if one is, defer\n      if (db._ttl._checkInProgress)\n        return db._ttl._stopAfterCheck = callback\n      clearInterval(db._ttl.intervalId)\n      callback && callback()\n    }\n\n  , ttlon = function ttlon (db, keys, ttl, callback) {\n      var exp   = String(Date.now() + ttl)\n        , batch = []\n\n      if (!Array.isArray(keys))\n        keys = [ keys ]\n\n      ttloff(db, keys, function () {\n        keys.forEach(function (key) {\n          if (typeof key != \'string\')\n            key = key.toString()\n          batch.push({ type: \'put\', key: key               , value: exp })\n          batch.push({ type: \'put\', key: exp + \'\\xff\' + key, value: key })\n        })\n\n        if (!batch.length)\n          return callback && callback()\n\n        db._ttl.sub.batch(\n            batch\n          , { keyEncoding: \'utf8\', valueEncoding: \'utf8\' }\n          , function (err) {\n              if (err)\n                db.emit(\'error\', err)\n              callback && callback()\n            }\n        )\n      })\n    }\n\n  , ttloff = function ttloff (db, keys, callback) {\n      if (!Array.isArray(keys))\n        keys = [ keys ]\n\n      var batch = []\n        , done  = after(keys.length, function (err) {\n            if (err)\n              db.emit(\'error\', err)\n\n            if (!batch.length)\n              return callback && callback()\n\n            db._ttl.sub.batch(\n                batch\n              , { keyEncoding: \'utf8\', valueEncoding: \'utf8\' }\n              , function (err) {\n                  if (err)\n                    db.emit(\'error\', err)\n                  callback && callback()\n                }\n            )\n          })\n\n      keys.forEach(function (key) {\n        if (typeof key != \'string\')\n          key = key.toString()\n\n        db._ttl.sub.get(\n            key\n          , { keyEncoding: \'utf8\', valueEncoding: \'utf8\' }\n          , function (err, exp) {\n              if (!err && exp > 0) {\n                batch.push({ type: \'del\', key: key })\n                batch.push({ type: \'del\', key: exp + \'\\xff\' + key })\n              }\n              done(err && err.name != \'NotFoundError\' && err)\n            }\n        )\n      })\n    }\n\n  , put = function (db, key, value, options, callback) {\n      var ttl\n        , done\n        , _callback = callback\n\n      if (typeof options == \'object\' && (ttl = options.ttl) > 0\n          && key !== null && key !== undefined\n          && value !== null && value !== undefined) {\n\n        done = after(2, _callback || function () {})\n        callback = done\n        ttlon(db, key, options.ttl, done)\n      }\n\n      db._ttl.put.call(db, key, value, options, callback)\n    }\n\n  , ttl = function (db, key, ttl, callback) {\n      if (ttl > 0 && key !== null && key !== undefined)\n        ttlon(db, key, ttl, callback)\n    }\n\n  , del = function (db, key, options, callback) {\n      var done\n        , _callback = callback\n      if (key !== null && key !== undefined) {\n        done = after(2, _callback || function () {})\n        callback = done\n        ttloff(db, key, done)\n      }\n\n      db._ttl.del.call(db, key, options, callback)\n    }\n\n  , batch = function (db, arr, options, callback) {\n      var ttl\n        , done\n        , on\n        , off\n        , _callback = callback\n\n      if (typeof options == \'object\' && (ttl = options.ttl) > 0 && Array.isArray(arr)) {\n        done = after(3, _callback || function () {})\n        callback = done\n\n        on  = []\n        off = []\n        arr.forEach(function (entry) {\n          if (!entry || entry.key === null || entry.key === undefined)\n            return\n\n          if (entry.type == \'put\' && entry.value !== null && entry.value !== undefined)\n            on.push(entry.key)\n          if (entry.type == \'del\')\n            off.push(entry.key)\n        })\n\n        if (on.length)\n          ttlon(db, on, options.ttl, done)\n        else\n          done()\n        if (off.length)\n          ttloff(db, off, done)\n        else\n          done()\n      }\n\n      db._ttl.batch.call(db, arr, options, callback)\n    }\n\n  , close = function (db, callback) {\n      stopTtl(db, function () {\n        if (db._ttl && typeof db._ttl.close == \'function\')\n          return db._ttl.close.call(db, callback)\n        callback && callback()\n      })\n    }\n\n  , setup = function (db, options) {\n      if (db._ttl)\n        return\n\n      options = xtend({\n          methodPrefix   : \'\'\n        , sublevel       : \'ttl\'\n        , checkFrequency : DEFAULT_FREQUENCY\n      }, options)\n\n      db = sublevel(db)\n\n      db._ttl = {\n          put   : db.put\n        , del   : db.del\n        , batch : db.batch\n        , close : db.close\n        , sub   : db.sublevel(options.sublevel)\n      }\n\n      db[options.methodPrefix + \'put\']   = put.bind(null, db)\n      db[options.methodPrefix + \'del\']   = del.bind(null, db)\n      db[options.methodPrefix + \'batch\'] = batch.bind(null, db)\n      db[options.methodPrefix + \'ttl\']   = ttl.bind(null, db)\n      db[options.methodPrefix + \'stop\']  = stopTtl.bind(null, db)\n      // we must intercept close()\n      db.close                           = close.bind(null, db)\n\n      startTtl(db, options.checkFrequency)\n\n      return db\n    }\n\nmodule.exports = setup\n\n},{"after":33,"level-sublevel":21,"xtend":37}],17:[function(require,module,exports){\n(function(process){/* Copyright (c) 2012-2013 LevelUP contributors\n * See list at <https://github.com/rvagg/node-levelup#contributing>\n * MIT +no-false-attribs License\n * <https://github.com/rvagg/node-levelup/blob/master/LICENSE>\n */\n\nvar EventEmitter   = require(\'events\').EventEmitter\n  , inherits       = require(\'util\').inherits\n  , extend         = require(\'xtend\')\n  , prr            = require(\'prr\')\n  , DeferredLevelDOWN = require(\'deferred-leveldown\')\n\n  , WriteError     = require(\'./errors\').WriteError\n  , ReadError      = require(\'./errors\').ReadError\n  , NotFoundError  = require(\'./errors\').NotFoundError\n  , OpenError      = require(\'./errors\').OpenError\n  , EncodingError  = require(\'./errors\').EncodingError\n  , InitializationError = require(\'./errors\').InitializationError\n\n  , ReadStream     = require(\'./read-stream\')\n  , WriteStream    = require(\'./write-stream\')\n  , util           = require(\'./util\')\n  , Batch          = require(\'./batch\')\n\n  , getOptions     = util.getOptions\n  , defaultOptions = util.defaultOptions\n  , getLevelDOWN   = util.getLevelDOWN\n  , dispatchError  = util.dispatchError\n\nfunction getCallback (options, callback) {\n  return typeof options == \'function\' ? options : callback\n}\n\n// Possible LevelUP#_status values:\n//  - \'new\'     - newly created, not opened or closed\n//  - \'opening\' - waiting for the database to be opened, post open()\n//  - \'open\'    - successfully opened the database, available for use\n//  - \'closing\' - waiting for the database to be closed, post close()\n//  - \'closed\'  - database has been successfully closed, should not be\n//                 used except for another open() operation\n\nfunction LevelUP (location, options, callback) {\n  if (!(this instanceof LevelUP))\n    return new LevelUP(location, options, callback)\n\n  var error\n\n  EventEmitter.call(this)\n  this.setMaxListeners(Infinity)\n\n  if (typeof location == \'function\') {\n    options = typeof options == \'object\' ? options : {}\n    options.db = location\n    location = null\n  } else if (typeof location == \'object\' && typeof location.db == \'function\') {\n    options = location\n    location = null\n  }\n\n  if (typeof options == \'function\') {\n    callback = options\n    options  = {}\n  }\n\n  if ((!options || typeof options.db != \'function\') && typeof location != \'string\') {\n    error = new InitializationError(\n        \'Must provide a location for the database\')\n    if (callback) {\n      return process.nextTick(function () {\n        callback(error)\n      })\n    }\n    throw error\n  }\n\n  options      = getOptions(this, options)\n  this.options = extend(defaultOptions, options)\n  this._status = \'new\'\n  // set this.location as enumerable but not configurable or writable\n  prr(this, \'location\', location, \'e\')\n\n  this.open(callback)\n}\n\ninherits(LevelUP, EventEmitter)\n\nLevelUP.prototype.open = function (callback) {\n  var self = this\n    , dbFactory\n    , db\n\n  if (this.isOpen()) {\n    if (callback)\n      process.nextTick(function () { callback(null, self) })\n    return this\n  }\n\n  if (this._isOpening()) {\n    return callback && this.once(\n        \'open\'\n      , function () { callback(null, self) }\n    )\n  }\n\n  this.emit(\'opening\')\n\n  this._status = \'opening\'\n  this.db      = new DeferredLevelDOWN(this.location)\n  dbFactory    = this.options.db || getLevelDOWN()\n  db           = dbFactory(this.location)\n\n  db.open(this.options, function (err) {\n    if (err) {\n      return dispatchError(self, new OpenError(err), callback)\n    } else {\n      self.db.setDb(db)\n      self.db = db\n      self._status = \'open\'\n      if (callback)\n        callback(null, self)\n      self.emit(\'open\')\n      self.emit(\'ready\')\n    }\n  })\n}\n\nLevelUP.prototype.close = function (callback) {\n  var self = this\n\n  if (this.isOpen()) {\n    this._status = \'closing\'\n    this.db.close(function () {\n      self._status = \'closed\'\n      self.emit(\'closed\')\n      if (callback)\n        callback.apply(null, arguments)\n    })\n    this.emit(\'closing\')\n    this.db = null\n  } else if (this._status == \'closed\' && callback) {\n    return process.nextTick(callback)\n  } else if (this._status == \'closing\' && callback) {\n    this.once(\'closed\', callback)\n  } else if (this._isOpening()) {\n    this.once(\'open\', function () {\n      self.close(callback)\n    })\n  }\n}\n\nLevelUP.prototype.isOpen = function () {\n  return this._status == \'open\'\n}\n\nLevelUP.prototype._isOpening = function () {\n  return this._status == \'opening\'\n}\n\nLevelUP.prototype.isClosed = function () {\n  return (/^clos/).test(this._status)\n}\n\nLevelUP.prototype.get = function (key_, options, callback) {\n  var self = this\n    , key\n\n  callback = getCallback(options, callback)\n\n  if (typeof callback != \'function\') {\n    return dispatchError(\n        this\n      , new ReadError(\'get() requires key and callback arguments\')\n    )\n  }\n\n  if (!this._isOpening() && !this.isOpen()) {\n    return dispatchError(\n        this\n      , new ReadError(\'Database is not open\')\n      , callback\n    )\n  }\n\n  options = util.getOptions(this, options)\n  key = util.encodeKey(key_, options)\n\n  options.asBuffer = util.isValueAsBuffer(options)\n\n  this.db.get(key, options, function (err, value) {\n    if (err) {\n      if ((/notfound/i).test(err)) {\n        err = new NotFoundError(\n            \'Key not found in database [\' + key_ + \']\', err)\n      } else {\n        err = new ReadError(err)\n      }\n      return dispatchError(self, err, callback)\n    }\n    if (callback) {\n      try {\n        value = util.decodeValue(value, options)\n      } catch (e) {\n        return callback(new EncodingError(e))\n      }\n      callback(null, value)\n    }\n  })\n}\n\nLevelUP.prototype.put = function (key_, value_, options, callback) {\n  var self = this\n    , key\n    , value\n\n  callback = getCallback(options, callback)\n\n  if (key_ === null || key_ === undefined\n        || value_ === null || value_ === undefined) {\n    return dispatchError(\n        this\n       , new WriteError(\'put() requires key and value arguments\')\n       , callback\n    )\n  }\n\n  if (!this._isOpening() && !this.isOpen()) {\n    return dispatchError(\n        this\n      , new WriteError(\'Database is not open\')\n      , callback\n    )\n  }\n\n  options = getOptions(this, options)\n  key     = util.encodeKey(key_, options)\n  value   = util.encodeValue(value_, options)\n\n  this.db.put(key, value, options, function (err) {\n    if (err) {\n      return dispatchError(self, new WriteError(err), callback)\n    } else {\n      self.emit(\'put\', key_, value_)\n      if (callback)\n        callback()\n    }\n  })\n}\n\nLevelUP.prototype.del = function (key_, options, callback) {\n  var self = this\n    , key\n\n  callback = getCallback(options, callback)\n\n  if (key_ === null || key_ === undefined) {\n    return dispatchError(\n        this\n      , new WriteError(\'del() requires a key argument\')\n      , callback\n    )\n  }\n\n  if (!this._isOpening() && !this.isOpen()) {\n    return dispatchError(\n        this\n      , new WriteError(\'Database is not open\')\n      , callback\n    )\n  }\n\n  options = getOptions(this, options)\n  key     = util.encodeKey(key_, options)\n\n  this.db.del(key, options, function (err) {\n    if (err) {\n      return dispatchError(self, new WriteError(err), callback)\n    } else {\n      self.emit(\'del\', key_)\n      if (callback)\n        callback()\n    }\n  })\n}\n\nLevelUP.prototype.batch = function (arr_, options, callback) {\n  var self = this\n    , keyEnc\n    , valueEnc\n    , arr\n\n  if (!arguments.length)\n    return new Batch(this)\n\n  callback = getCallback(options, callback)\n\n  if (!Array.isArray(arr_)) {\n    return dispatchError(\n        this\n      , new WriteError(\'batch() requires an array argument\')\n      , callback\n    )\n  }\n\n  if (!this._isOpening() && !this.isOpen()) {\n    return dispatchError(\n        this\n      , new WriteError(\'Database is not open\')\n      , callback\n    )\n  }\n\n  options  = getOptions(this, options)\n  keyEnc   = options.keyEncoding\n  valueEnc = options.valueEncoding\n\n  arr = arr_.map(function (e) {\n    if (e.type === undefined || e.key === undefined)\n      return {}\n\n    // inherit encoding\n    var kEnc = e.keyEncoding || keyEnc\n      , vEnc = e.valueEncoding || e.encoding || valueEnc\n      , o\n\n    // If we\'re not dealing with plain utf8 strings or plain\n    // Buffers then we have to do some work on the array to\n    // encode the keys and/or values. This includes JSON types.\n\n    if (kEnc != \'utf8\' && kEnc != \'binary\'\n        || vEnc != \'utf8\' && vEnc != \'binary\') {\n      o = {\n          type: e.type\n        , key: util.encodeKey(e.key, options, e)\n      }\n\n      if (e.value !== undefined)\n        o.value = util.encodeValue(e.value, options, e)\n\n      return o\n    } else {\n      return e\n    }\n  })\n\n  this.db.batch(arr, options, function (err) {\n    if (err) {\n      return dispatchError(self, new WriteError(err), callback)\n    } else {\n      self.emit(\'batch\', arr_)\n      if (callback)\n        callback()\n    }\n  })\n}\n\n// DEPRECATED: prefer accessing LevelDOWN for this: db.db.approximateSize()\nLevelUP.prototype.approximateSize = function (start_, end_, callback) {\n  var self = this\n    , start\n    , end\n\n  if (start_ === null || start_ === undefined\n        || end_ === null || end_ === undefined\n        || typeof callback != \'function\') {\n    return dispatchError(\n        this\n      , new ReadError(\'approximateSize() requires start, end and callback arguments\')\n      , callback\n    )\n  }\n\n  start = util.encodeKey(start_, this.options)\n  end   = util.encodeKey(end_, this.options)\n\n  if (!this._isOpening() && !this.isOpen()) {\n    return dispatchError(\n        this\n      , new WriteError(\'Database is not open\')\n      , callback\n    )\n  }\n\n  this.db.approximateSize(start, end, function (err, size) {\n    if (err) {\n      return dispatchError(self, new OpenError(err), callback)\n    } else if (callback) {\n      callback(null, size)\n    }\n  })\n}\n\nLevelUP.prototype.readStream =\nLevelUP.prototype.createReadStream = function (options) {\n  var self = this\n  options = extend(this.options, options)\n  return new ReadStream(\n      options\n    , this\n    , function (options) {\n        return self.db.iterator(options)\n      }\n  )\n}\n\nLevelUP.prototype.keyStream =\nLevelUP.prototype.createKeyStream = function (options) {\n  return this.createReadStream(extend(options, { keys: true, values: false }))\n}\n\nLevelUP.prototype.valueStream =\nLevelUP.prototype.createValueStream = function (options) {\n  return this.createReadStream(extend(options, { keys: false, values: true }))\n}\n\nLevelUP.prototype.writeStream =\nLevelUP.prototype.createWriteStream = function (options) {\n  return new WriteStream(extend(options), this)\n}\n\nLevelUP.prototype.toString = function () {\n  return \'LevelUP\'\n}\n\nfunction utilStatic (name) {\n  return function (location, callback) {\n    getLevelDOWN()[name](location, callback || function () {})\n  }\n}\n\nmodule.exports         = LevelUP\nmodule.exports.copy    = util.copy\n// DEPRECATED: prefer accessing LevelDOWN for this: require(\'leveldown\').destroy()\nmodule.exports.destroy = utilStatic(\'destroy\')\n// DEPRECATED: prefer accessing LevelDOWN for this: require(\'leveldown\').repair()\nmodule.exports.repair  = utilStatic(\'repair\')\n\n})(require("__browserify_process"))\n},{"./batch":34,"./errors":36,"./read-stream":38,"./util":35,"./write-stream":39,"__browserify_process":13,"deferred-leveldown":41,"events":23,"prr":40,"util":22,"xtend":42}],25:[function(require,module,exports){\n(function(){var Buffer = require(\'buffer\').Buffer\nvar sha = require(\'./sha\')\nvar sha256 = require(\'./sha256\')\nvar rng = require(\'./rng\')\nvar md5 = require(\'./md5\')\n\nvar algorithms = {\n  sha1: sha,\n  sha256: sha256,\n  md5: md5\n}\n\nvar blocksize = 64\nvar zeroBuffer = new Buffer(blocksize); zeroBuffer.fill(0)\nfunction hmac(fn, key, data) {\n  if(!Buffer.isBuffer(key)) key = new Buffer(key)\n  if(!Buffer.isBuffer(data)) data = new Buffer(data)\n\n  if(key.length > blocksize) {\n    key = fn(key)\n  } else if(key.length < blocksize) {\n    key = Buffer.concat([key, zeroBuffer], blocksize)\n  }\n\n  var ipad = new Buffer(blocksize), opad = new Buffer(blocksize)\n  for(var i = 0; i < blocksize; i++) {\n    ipad[i] = key[i] ^ 0x36\n    opad[i] = key[i] ^ 0x5C\n  }\n\n  var hash = fn(Buffer.concat([ipad, data]))\n  return fn(Buffer.concat([opad, hash]))\n}\n\nfunction hash(alg, key) {\n  alg = alg || \'sha1\'\n  var fn = algorithms[alg]\n  var bufs = []\n  var length = 0\n  if(!fn) error(\'algorithm:\', alg, \'is not yet supported\')\n  return {\n    update: function (data) {\n      if(!Buffer.isBuffer(data)) data = new Buffer(data)\n        \n      bufs.push(data)\n      length += data.length\n      return this\n    },\n    digest: function (enc) {\n      var buf = Buffer.concat(bufs)\n      var r = key ? hmac(fn, key, buf) : fn(buf)\n      bufs = null\n      return enc ? r.toString(enc) : r\n    }\n  }\n}\n\nfunction error () {\n  var m = [].slice.call(arguments).join(\' \')\n  throw new Error([\n    m,\n    \'we accept pull requests\',\n    \'http://github.com/dominictarr/crypto-browserify\'\n    ].join(\'\\n\'))\n}\n\nexports.createHash = function (alg) { return hash(alg) }\nexports.createHmac = function (alg, key) { return hash(alg, key) }\nexports.randomBytes = function(size, callback) {\n  if (callback && callback.call) {\n    try {\n      callback.call(this, undefined, new Buffer(rng(size)))\n    } catch (err) { callback(err) }\n  } else {\n    return new Buffer(rng(size))\n  }\n}\n\nfunction each(a, f) {\n  for(var i in a)\n    f(a[i], i)\n}\n\n// the least I can do is make error messages for the rest of the node.js/crypto api.\neach([\'createCredentials\'\n, \'createCipher\'\n, \'createCipheriv\'\n, \'createDecipher\'\n, \'createDecipheriv\'\n, \'createSign\'\n, \'createVerify\'\n, \'createDiffieHellman\'\n, \'pbkdf2\'], function (name) {\n  exports[name] = function () {\n    error(\'sorry,\', name, \'is not implemented yet\')\n  }\n})\n\n})()\n},{"./md5":47,"./rng":46,"./sha":44,"./sha256":45,"buffer":43}],27:[function(require,module,exports){\nvar proto = {}\nmodule.exports = proto\n\nproto.from = require(\'./from.js\')\nproto.to = require(\'./to.js\')\nproto.is = require(\'./is.js\')\nproto.subarray = require(\'./subarray.js\')\nproto.join = require(\'./join.js\')\nproto.copy = require(\'./copy.js\')\nproto.create = require(\'./create.js\')\n\nmix(require(\'./read.js\'), proto)\nmix(require(\'./write.js\'), proto)\n\nfunction mix(from, into) {\n  for(var key in from) {\n    into[key] = from[key]\n  }\n}\n\n},{"./copy.js":52,"./create.js":53,"./from.js":56,"./is.js":49,"./join.js":51,"./read.js":54,"./subarray.js":50,"./to.js":48,"./write.js":55}],57:[function(require,module,exports){\n\n},{}],58:[function(require,module,exports){\n(function(){module.exports={\n  "name": "levelup",\n  "description": "Fast & simple storage - a Node.js-style LevelDB wrapper",\n  "version": "0.18.2",\n  "contributors": [\n    {\n      "name": "Rod Vagg",\n      "email": "r@va.gg",\n      "url": "https://github.com/rvagg"\n    },\n    {\n      "name": "John Chesley",\n      "email": "john@chesl.es",\n      "url": "https://github.com/chesles/"\n    },\n    {\n      "name": "Jake Verbaten",\n      "email": "raynos2@gmail.com",\n      "url": "https://github.com/raynos"\n    },\n    {\n      "name": "Dominic Tarr",\n      "email": "dominic.tarr@gmail.com",\n      "url": "https://github.com/dominictarr"\n    },\n    {\n      "name": "Max Ogden",\n      "email": "max@maxogden.com",\n      "url": "https://github.com/maxogden"\n    },\n    {\n      "name": "Lars-Magnus Skog",\n      "email": "lars.magnus.skog@gmail.com",\n      "url": "https://github.com/ralphtheninja"\n    },\n    {\n      "name": "David Bj\xF6rklund",\n      "email": "david.bjorklund@gmail.com",\n      "url": "https://github.com/kesla"\n    },\n    {\n      "name": "Julian Gruber",\n      "email": "julian@juliangruber.com",\n      "url": "https://github.com/juliangruber"\n    },\n    {\n      "name": "Paolo Fragomeni",\n      "email": "paolo@async.ly",\n      "url": "https://github.com/hij1nx"\n    },\n    {\n      "name": "Anton Whalley",\n      "email": "anton.whalley@nearform.com",\n      "url": "https://github.com/No9"\n    },\n    {\n      "name": "Matteo Collina",\n      "email": "matteo.collina@gmail.com",\n      "url": "https://github.com/mcollina"\n    },\n    {\n      "name": "Pedro Teixeira",\n      "email": "pedro.teixeira@gmail.com",\n      "url": "https://github.com/pgte"\n    },\n    {\n      "name": "James Halliday",\n      "email": "mail@substack.net",\n      "url": "https://github.com/substack"\n    }\n  ],\n  "repository": {\n    "type": "git",\n    "url": "https://github.com/rvagg/node-levelup.git"\n  },\n  "homepage": "https://github.com/rvagg/node-levelup",\n  "keywords": [\n    "leveldb",\n    "stream",\n    "database",\n    "db",\n    "store",\n    "storage",\n    "json"\n  ],\n  "main": "lib/levelup.js",\n  "dependencies": {\n    "errno": "~0.1.0",\n    "concat-stream": "~0.1.1",\n    "readable-stream": "~1.0.17",\n    "xtend": "~2.1.1",\n    "prr": "~0.0.0",\n    "semver": "~2.2.1",\n    "bops": "~0.1.0",\n    "deferred-leveldown": "~0.1.0"\n  },\n  "devDependencies": {\n    "leveldown": "~0.10.0",\n    "bustermove": "*",\n    "tap": "*",\n    "referee": "*",\n    "rimraf": "*",\n    "async": "*",\n    "fstream": "*",\n    "tar": "*",\n    "mkfiletree": "*",\n    "readfiletree": "*",\n    "slow-stream": ">=0.0.4",\n    "delayed": "*",\n    "boganipsum": "*",\n    "du": "*",\n    "memdown": "*",\n    "msgpack-js": "*"\n  },\n  "browser": {\n    "leveldown": false,\n    "leveldown/package": false,\n    "semver": false\n  },\n  "scripts": {\n    "test": "tap test/*-test.js --stderr",\n    "functionaltests": "node ./test/functional/fstream-test.js && node ./test/functional/binary-data-test.js && node ./test/functional/compat-test.js",\n    "alltests": "npm test && npm run-script functionaltests"\n  },\n  "license": "MIT",\n  "readme": "LevelUP\\n=======\\n\\n![LevelDB Logo](https://twimg0-a.akamaihd.net/profile_images/3360574989/92fc472928b444980408147e5e5db2fa_bigger.png)\\n\\nFast & simple storage - a Node.js-style LevelDB wrapper\\n-------------------------------------------------------\\n\\n[![Build Status](https://secure.travis-ci.org/rvagg/node-levelup.png)](http://travis-ci.org/rvagg/node-levelup)\\n\\n[![NPM](https://nodei.co/npm/levelup.png?stars&downloads)](https://nodei.co/npm/levelup/) [![NPM](https://nodei.co/npm-dl/levelup.png)](https://nodei.co/npm/levelup/)\\n\\n\\n  * <a href=\\"#intro\\">Introduction</a>\\n  * <a href=\\"#leveldown\\">Relationship to LevelDOWN</a>\\n  * <a href=\\"#platforms\\">Tested &amp; supported platforms</a>\\n  * <a href=\\"#basic\\">Basic usage</a>\\n  * <a href=\\"#api\\">API</a>\\n  * <a href=\\"#events\\">Events</a>\\n  * <a href=\\"#json\\">JSON data</a>\\n  * <a href=\\"#custom_encodings\\">Custom encodings</a>\\n  * <a href=\\"#extending\\">Extending LevelUP</a>\\n  * <a href=\\"#multiproc\\">Multi-process access</a>\\n  * <a href=\\"#support\\">Getting support</a>\\n  * <a href=\\"#contributing\\">Contributing</a>\\n  * <a href=\\"#licence\\">Licence &amp; copyright</a>\\n\\n<a name=\\"intro\\"></a>\\nIntroduction\\n------------\\n\\n**[LevelDB](http://code.google.com/p/leveldb/)** is a simple key/value data store built by Google, inspired by BigTable. It\'s used in Google Chrome and many other products. LevelDB supports arbitrary byte arrays as both keys and values, singular *get*, *put* and *delete* operations, *batched put and delete*, bi-directional iterators and simple compression using the very fast [Snappy](http://code.google.com/p/snappy/) algorithm.\\n\\n**LevelUP** aims to expose the features of LevelDB in a **Node.js-friendly way**. All standard `Buffer` encoding types are supported, as is a special JSON encoding. LevelDB\'s iterators are exposed as a Node.js-style **readable stream** a matching **writeable stream** converts writes to *batch* operations.\\n\\nLevelDB stores entries **sorted lexicographically by keys**. This makes LevelUP\'s <a href=\\"#createReadStream\\"><code>ReadStream</code></a> interface a very powerful query mechanism.\\n\\n**LevelUP** is an **OPEN Open Source Project**, see the <a href=\\"#contributing\\">Contributing</a> section to find out what this means.\\n\\n<a name=\\"leveldown\\"></a>\\nRelationship to LevelDOWN\\n-------------------------\\n\\nLevelUP is designed to be backed by **[LevelDOWN](https://github.com/rvagg/node-leveldown/)** which provides a pure C++ binding to LevelDB and can be used as a stand-alone package if required.\\n\\n**As of version 0.9, LevelUP no longer requires LevelDOWN as a dependency so you must `npm install leveldown` when you install LevelUP.**\\n\\nLevelDOWN is now optional because LevelUP can be used with alternative backends, such as **[level.js](https://github.com/maxogden/level.js)** in the browser or [MemDOWN](https://github.com/rvagg/node-memdown) for a pure in-memory store.\\n\\nLevelUP will look for LevelDOWN and throw an error if it can\'t find it in its Node `require()` path. It will also tell you if the installed version of LevelDOWN is incompatible.\\n\\n**The [level](https://github.com/level/level) package is available as an alternative installation mechanism.** Install it instead to automatically get both LevelUP & LevelDOWN. It exposes LevelUP on its export (i.e. you can `var leveldb = require(\'level\')`).\\n\\n\\n<a name=\\"platforms\\"></a>\\nTested & supported platforms\\n----------------------------\\n\\n  * **Linux**: including ARM platforms such as Raspberry Pi *and Kindle!*\\n  * **Mac OS**\\n  * **Solaris**: including Joyent\'s SmartOS & Nodejitsu\\n  * **Windows**: Node 0.10 and above only. See installation instructions for *node-gyp\'s* dependencies [here](https://github.com/TooTallNate/node-gyp#installation), you\'ll need these (free) components from Microsoft to compile and run any native Node add-on in Windows.\\n\\n<a name=\\"basic\\"></a>\\nBasic usage\\n-----------\\n\\nFirst you need to install LevelUP!\\n\\n```sh\\n$ npm install levelup leveldown\\n```\\n\\nOr\\n\\n```sh\\n$ npm install level\\n```\\n\\n*(this second option requires you to use LevelUP by calling `var levelup = require(\'level\')`)*\\n\\n\\nAll operations are asynchronous although they don\'t necessarily require a callback if you don\'t need to know when the operation was performed.\\n\\n```js\\nvar levelup = require(\'levelup\')\\n\\n// 1) Create our database, supply location and options.\\n//    This will create or open the underlying LevelDB store.\\nvar db = levelup(\'./mydb\')\\n\\n// 2) put a key & value\\ndb.put(\'name\', \'LevelUP\', function (err) {\\n  if (err) return console.log(\'Ooops!\', err) // some kind of I/O error\\n\\n  // 3) fetch by key\\n  db.get(\'name\', function (err, value) {\\n    if (err) return console.log(\'Ooops!\', err) // likely the key was not found\\n\\n    // ta da!\\n    console.log(\'name=\' + value)\\n  })\\n})\\n```\\n\\n<a name=\\"api\\"></a>\\n## API\\n\\n  * <a href=\\"#ctor\\"><code><b>levelup()</b></code></a>\\n  * <a href=\\"#open\\"><code>db.<b>open()</b></code></a>\\n  * <a href=\\"#close\\"><code>db.<b>close()</b></code></a>\\n  * <a href=\\"#put\\"><code>db.<b>put()</b></code></a>\\n  * <a href=\\"#get\\"><code>db.<b>get()</b></code></a>\\n  * <a href=\\"#del\\"><code>db.<b>del()</b></code></a>\\n  * <a href=\\"#batch\\"><code>db.<b>batch()</b></code> *(array form)*</a>\\n  * <a href=\\"#batch_chained\\"><code>db.<b>batch()</b></code> *(chained form)*</a>\\n  * <a href=\\"#isOpen\\"><code>db.<b>isOpen()</b></code></a>\\n  * <a href=\\"#isClosed\\"><code>db.<b>isClosed()</b></code></a>\\n  * <a href=\\"#createReadStream\\"><code>db.<b>createReadStream()</b></code></a>\\n  * <a href=\\"#createKeyStream\\"><code>db.<b>createKeyStream()</b></code></a>\\n  * <a href=\\"#createValueStream\\"><code>db.<b>createValueStream()</b></code></a>\\n  * <a href=\\"#createWriteStream\\"><code>db.<b>createWriteStream()</b></code></a>\\n\\n### Special operations exposed by LevelDOWN\\n\\n  * <a href=\\"#approximateSize\\"><code>db.db.<b>approximateSize()</b></code></a>\\n  * <a href=\\"#getProperty\\"><code>db.db.<b>getProperty()</b></code></a>\\n  * <a href=\\"#destroy\\"><code><b>leveldown.destroy()</b></code></a>\\n  * <a href=\\"#repair\\"><code><b>leveldown.repair()</b></code></a>\\n\\n\\n--------------------------------------------------------\\n<a name=\\"ctor\\"></a>\\n### levelup(location[, options[, callback]])\\n### levelup(options[, callback ])\\n### levelup(db[, callback ])\\n<code>levelup()</code> is the main entry point for creating a new LevelUP instance and opening the underlying store with LevelDB.\\n\\nThis function returns a new instance of LevelUP and will also initiate an <a href=\\"#open\\"><code>open()</code></a> operation. Opening the database is an asynchronous operation which will trigger your callback if you provide one. The callback should take the form: `function (err, db) {}` where the `db` is the LevelUP instance. If you don\'t provide a callback, any read & write operations are simply queued internally until the database is fully opened.\\n\\nThis leads to two alternative ways of managing a new LevelUP instance:\\n\\n```js\\nlevelup(location, options, function (err, db) {\\n  if (err) throw err\\n  db.get(\'foo\', function (err, value) {\\n    if (err) return console.log(\'foo does not exist\')\\n    console.log(\'got foo =\', value)\\n  })\\n})\\n\\n// vs the equivalent:\\n\\nvar db = levelup(location, options) // will throw if an error occurs\\ndb.get(\'foo\', function (err, value) {\\n  if (err) return console.log(\'foo does not exist\')\\n  console.log(\'got foo =\', value)\\n})\\n```\\n\\nThe `location` argument is available as a read-only property on the returned LevelUP instance.\\n\\nThe `levelup(options, callback)` form (with optional `callback`) is only available where you provide a valid `\'db\'` property on the options object (see below). Only for back-ends that don\'t require a `location` argument, such as [MemDOWN](https://github.com/rvagg/memdown).\\n\\nFor example:\\n\\n```js\\nvar levelup = require(\'levelup\')\\nvar memdown = require(\'memdown\')\\nvar db = levelup({ db: memdown })\\n```\\n\\nThe `levelup(db, callback)` form (with optional `callback`) is only available where `db` is a factory function, as would be provided as a `\'db\'` property on an `options` object (see below). Only for back-ends that don\'t require a `location` argument, such as [MemDOWN](https://github.com/rvagg/memdown).\\n\\nFor example:\\n\\n```js\\nvar levelup = require(\'levelup\')\\nvar memdown = require(\'memdown\')\\nvar db = levelup(memdown)\\n```\\n\\n#### `options`\\n\\n`levelup()` takes an optional options object as its second argument; the following properties are accepted:\\n\\n* `\'createIfMissing\'` *(boolean, default: `true`)*: If `true`, will initialise an empty database at the specified location if one doesn\'t already exist. If `false` and a database doesn\'t exist you will receive an error in your `open()` callback and your database won\'t open.\\n\\n* `\'errorIfExists\'` *(boolean, default: `false`)*: If `true`, you will receive an error in your `open()` callback if the database exists at the specified location.\\n\\n* `\'compression\'` *(boolean, default: `true`)*: If `true`, all *compressible* data will be run through the Snappy compression algorithm before being stored. Snappy is very fast and shouldn\'t gain much speed by disabling so leave this on unless you have good reason to turn it off.\\n\\n* `\'cacheSize\'` *(number, default: `8 * 1024 * 1024`)*: The size (in bytes) of the in-memory [LRU](http://en.wikipedia.org/wiki/Cache_algorithms#Least_Recently_Used) cache with frequently used uncompressed block contents. \\n\\n* `\'keyEncoding\'` and `\'valueEncoding\'` *(string, default: `\'utf8\'`)*: The encoding of the keys and values passed through Node.js\' `Buffer` implementation (see [Buffer#toString()](http://nodejs.org/docs/latest/api/buffer.html#buffer_buf_tostring_encoding_start_end)).\\n  <p><code>\'utf8\'</code> is the default encoding for both keys and values so you can simply pass in strings and expect strings from your <code>get()</code> operations. You can also pass <code>Buffer</code> objects as keys and/or values and conversion will be performed.</p>\\n  <p>Supported encodings are: hex, utf8, ascii, binary, base64, ucs2, utf16le.</p>\\n  <p><code>\'json\'</code> encoding is also supported, see below.</p>\\n\\n* `\'db\'` *(object, default: LevelDOWN)*: LevelUP is backed by [LevelDOWN](https://github.com/rvagg/node-leveldown/) to provide an interface to LevelDB. You can completely replace the use of LevelDOWN by providing a \\"factory\\" function that will return a LevelDOWN API compatible object given a `location` argument. For further information, see [MemDOWN](https://github.com/rvagg/node-memdown/), a fully LevelDOWN API compatible replacement that uses a memory store rather than LevelDB. Also see [Abstract LevelDOWN](http://github.com/rvagg/node-abstract-leveldown), a partial implementation of the LevelDOWN API that can be used as a base prototype for a LevelDOWN substitute.\\n\\nAdditionally, each of the main interface methods accept an optional options object that can be used to override `\'keyEncoding\'` and `\'valueEncoding\'`.\\n\\n--------------------------------------------------------\\n<a name=\\"open\\"></a>\\n### db.open([callback])\\n<code>open()</code> opens the underlying LevelDB store. In general **you should never need to call this method directly** as it\'s automatically called by <a href=\\"#ctor\\"><code>levelup()</code></a>.\\n\\nHowever, it is possible to *reopen* a database after it has been closed with <a href=\\"#close\\"><code>close()</code></a>, although this is not generally advised.\\n\\n--------------------------------------------------------\\n<a name=\\"close\\"></a>\\n### db.close([callback])\\n<code>close()</code> closes the underlying LevelDB store. The callback will receive any error encountered during closing as the first argument.\\n\\nYou should always clean up your LevelUP instance by calling `close()` when you no longer need it to free up resources. A LevelDB store cannot be opened by multiple instances of LevelDB/LevelUP simultaneously.\\n\\n--------------------------------------------------------\\n<a name=\\"put\\"></a>\\n### db.put(key, value[, options][, callback])\\n<code>put()</code> is the primary method for inserting data into the store. Both the `key` and `value` can be arbitrary data objects.\\n\\nThe callback argument is optional but if you don\'t provide one and an error occurs then expect the error to be thrown.\\n\\n#### `options`\\n\\nEncoding of the `key` and `value` objects will adhere to `\'keyEncoding\'` and `\'valueEncoding\'` options provided to <a href=\\"#ctor\\"><code>levelup()</code></a>, although you can provide alternative encoding settings in the options for `put()` (it\'s recommended that you stay consistent in your encoding of keys and values in a single store).\\n\\nIf you provide a `\'sync\'` value of `true` in your `options` object, LevelDB will perform a synchronous write of the data; although the operation will be asynchronous as far as Node is concerned. Normally, LevelDB passes the data to the operating system for writing and returns immediately, however a synchronous write will use `fsync()` or equivalent so your callback won\'t be triggered until the data is actually on disk. Synchronous filesystem writes are **significantly** slower than asynchronous writes but if you want to be absolutely sure that the data is flushed then you can use `\'sync\': true`.\\n\\n--------------------------------------------------------\\n<a name=\\"get\\"></a>\\n### db.get(key[, options][, callback])\\n<code>get()</code> is the primary method for fetching data from the store. The `key` can be an arbitrary data object. If it doesn\'t exist in the store then the callback will receive an error as its first argument. A not-found err object will be of type `\'NotFoundError\'` so you can `err.type == \'NotFoundError\'` or you can perform a truthy test on the property `err.notFound`.\\n\\n```js\\ndb.get(\'foo\', function (err, value) {\\n  if (err) {\\n    if (err.notFound) {\\n      // handle a \'NotFoundError\' here\\n      return\\n    }\\n    // I/O or other error, pass it up the callback chain\\n    return callback(err)\\n  }\\n\\n  // .. handle `value` here\\n})\\n```\\n\\n#### `options`\\n\\nEncoding of the `key` object will adhere to the `\'keyEncoding\'` option provided to <a href=\\"#ctor\\"><code>levelup()</code></a>, although you can provide alternative encoding settings in the options for `get()` (it\'s recommended that you stay consistent in your encoding of keys and values in a single store).\\n\\nLevelDB will by default fill the in-memory LRU Cache with data from a call to get. Disabling this is done by setting `fillCache` to `false`. \\n\\n--------------------------------------------------------\\n<a name=\\"del\\"></a>\\n### db.del(key[, options][, callback])\\n<code>del()</code> is the primary method for removing data from the store.\\n\\n#### `options`\\n\\nEncoding of the `key` object will adhere to the `\'keyEncoding\'` option provided to <a href=\\"#ctor\\"><code>levelup()</code></a>, although you can provide alternative encoding settings in the options for `del()` (it\'s recommended that you stay consistent in your encoding of keys and values in a single store).\\n\\nA `\'sync\'` option can also be passed, see <a href=\\"#put\\"><code>put()</code></a> for details on how this works.\\n\\n--------------------------------------------------------\\n<a name=\\"batch\\"></a>\\n### db.batch(array[, options][, callback]) *(array form)*\\n<code>batch()</code> can be used for very fast bulk-write operations (both *put* and *delete*). The `array` argument should contain a list of operations to be executed sequentially, although as a whole they are performed as an atomic operation inside LevelDB. Each operation is contained in an object having the following properties: `type`, `key`, `value`, where the *type* is either `\'put\'` or `\'del\'`. In the case of `\'del\'` the `\'value\'` property is ignored. Any entries with a `\'key\'` of `null` or `undefined` will cause an error to be returned on the `callback` and any `\'type\': \'put\'` entry with a `\'value\'` of `null` or `undefined` will return an error.\\n\\n```js\\nvar ops = [\\n    { type: \'del\', key: \'father\' }\\n  , { type: \'put\', key: \'name\', value: \'Yuri Irsenovich Kim\' }\\n  , { type: \'put\', key: \'dob\', value: \'16 February 1941\' }\\n  , { type: \'put\', key: \'spouse\', value: \'Kim Young-sook\' }\\n  , { type: \'put\', key: \'occupation\', value: \'Clown\' }\\n]\\n\\ndb.batch(ops, function (err) {\\n  if (err) return console.log(\'Ooops!\', err)\\n  console.log(\'Great success dear leader!\')\\n})\\n```\\n\\n#### `options`\\n\\nSee <a href=\\"#put\\"><code>put()</code></a> for a discussion on the `options` object. You can overwrite default `\'keyEncoding\'` and `\'valueEncoding\'` and also specify the use of `sync` filesystem operations.\\n\\nIn addition to encoding options for the whole batch you can also overwrite the encoding per operation, like:\\n\\n```js\\nvar ops = [{\\n    type          : \'put\'\\n  , key           : new Buffer([1, 2, 3])\\n  , value         : { some: \'json\' }\\n  , keyEncoding   : \'binary\'\\n  , valueEncoding : \'json\'\\n}]\\n```\\n\\n--------------------------------------------------------\\n<a name=\\"batch_chained\\"></a>\\n### db.batch() *(chained form)*\\n<code>batch()</code>, when called with no arguments will return a `Batch` object which can be used to build, and eventually commit, an atomic LevelDB batch operation. Depending on how it\'s used, it is possible to obtain greater performance when using the chained form of `batch()` over the array form.\\n\\n```js\\ndb.batch()\\n  .del(\'father\')\\n  .put(\'name\', \'Yuri Irsenovich Kim\')\\n  .put(\'dob\', \'16 February 1941\')\\n  .put(\'spouse\', \'Kim Young-sook\')\\n  .put(\'occupation\', \'Clown\')\\n  .write(function () { console.log(\'Done!\') })\\n```\\n\\n<b><code>batch.put(key, value[, options])</code></b>\\n\\nQueue a *put* operation on the current batch, not committed until a `write()` is called on the batch.\\n\\nThe optional `options` argument can be used to override the default `\'keyEncoding\'` and/or `\'valueEncoding\'`.\\n\\nThis method may `throw` a `WriteError` if there is a problem with your put (such as the `value` being `null` or `undefined`).\\n\\n<b><code>batch.del(key[, options])</code></b>\\n\\nQueue a *del* operation on the current batch, not committed until a `write()` is called on the batch.\\n\\nThe optional `options` argument can be used to override the default `\'keyEncoding\'`.\\n\\nThis method may `throw` a `WriteError` if there is a problem with your delete.\\n\\n<b><code>batch.clear()</code></b>\\n\\nClear all queued operations on the current batch, any previous operations will be discarded.\\n\\n<b><code>batch.write([callback])</code></b>\\n\\nCommit the queued operations for this batch. All operations not *cleared* will be written to the database atomically, that is, they will either all succeed or fail with no partial commits. The optional `callback` will be called when the operation has completed with an *error* argument if an error has occurred; if no `callback` is supplied and an error occurs then this method will `throw` a `WriteError`.\\n\\n\\n--------------------------------------------------------\\n<a name=\\"isOpen\\"></a>\\n### db.isOpen()\\n\\nA LevelUP object can be in one of the following states:\\n\\n  * *\\"new\\"*     - newly created, not opened or closed\\n  * *\\"opening\\"* - waiting for the database to be opened\\n  * *\\"open\\"*    - successfully opened the database, available for use\\n  * *\\"closing\\"* - waiting for the database to be closed\\n  * *\\"closed\\"*  - database has been successfully closed, should not be used\\n\\n`isOpen()` will return `true` only when the state is \\"open\\".\\n\\n--------------------------------------------------------\\n<a name=\\"isClosed\\"></a>\\n### db.isClosed()\\n\\n*See <a href=\\"#put\\"><code>isOpen()</code></a>*\\n\\n`isClosed()` will return `true` only when the state is \\"closing\\" *or* \\"closed\\", it can be useful for determining if read and write operations are permissible.\\n\\n--------------------------------------------------------\\n<a name=\\"createReadStream\\"></a>\\n### db.createReadStream([options])\\n\\nYou can obtain a **ReadStream** of the full database by calling the `createReadStream()` method. The resulting stream is a complete Node.js-style [Readable Stream](http://nodejs.org/docs/latest/api/stream.html#stream_readable_stream) where `\'data\'` events emit objects with `\'key\'` and `\'value\'` pairs.\\n\\n```js\\ndb.createReadStream()\\n  .on(\'data\', function (data) {\\n    console.log(data.key, \'=\', data.value)\\n  })\\n  .on(\'error\', function (err) {\\n    console.log(\'Oh my!\', err)\\n  })\\n  .on(\'close\', function () {\\n    console.log(\'Stream closed\')\\n  })\\n  .on(\'end\', function () {\\n    console.log(\'Stream closed\')\\n  })\\n```\\n\\nThe standard `pause()`, `resume()` and `destroy()` methods are implemented on the ReadStream, as is `pipe()` (see below). `\'data\'`, \'`error\'`, `\'end\'` and `\'close\'` events are emitted.\\n\\nAdditionally, you can supply an options object as the first parameter to `createReadStream()` with the following options:\\n\\n* `\'start\'`: the key you wish to start the read at. By default it will start at the beginning of the store. Note that the *start* doesn\'t have to be an actual key that exists, LevelDB will simply find the *next* key, greater than the key you provide.\\n\\n* `\'end\'`: the key you wish to end the read on. By default it will continue until the end of the store. Again, the *end* doesn\'t have to be an actual key as an (inclusive) `<=`-type operation is performed to detect the end. You can also use the `destroy()` method instead of supplying an `\'end\'` parameter to achieve the same effect.\\n\\n* `\'reverse\'` *(boolean, default: `false`)*: a boolean, set to true if you want the stream to go in reverse order. Beware that due to the way LevelDB works, a reverse seek will be slower than a forward seek.\\n\\n* `\'keys\'` *(boolean, default: `true`)*: whether the `\'data\'` event should contain keys. If set to `true` and `\'values\'` set to `false` then `\'data\'` events will simply be keys, rather than objects with a `\'key\'` property. Used internally by the `createKeyStream()` method.\\n\\n* `\'values\'` *(boolean, default: `true`)*: whether the `\'data\'` event should contain values. If set to `true` and `\'keys\'` set to `false` then `\'data\'` events will simply be values, rather than objects with a `\'value\'` property. Used internally by the `createValueStream()` method.\\n\\n* `\'limit\'` *(number, default: `-1`)*: limit the number of results collected by this stream. This number represents a *maximum* number of results and may not be reached if you get to the end of the store or your `\'end\'` value first. A value of `-1` means there is no limit.\\n\\n* `\'fillCache\'` *(boolean, default: `false`)*: wheather LevelDB\'s LRU-cache should be filled with data read.\\n\\n* `\'keyEncoding\'` / `\'valueEncoding\'` *(string)*: the encoding applied to each read piece of data.\\n\\n--------------------------------------------------------\\n<a name=\\"createKeyStream\\"></a>\\n### db.createKeyStream([options])\\n\\nA **KeyStream** is a **ReadStream** where the `\'data\'` events are simply the keys from the database so it can be used like a traditional stream rather than an object stream.\\n\\nYou can obtain a KeyStream either by calling the `createKeyStream()` method on a LevelUP object or by passing passing an options object to `createReadStream()` with `keys` set to `true` and `values` set to `false`.\\n\\n```js\\ndb.createKeyStream()\\n  .on(\'data\', function (data) {\\n    console.log(\'key=\', data)\\n  })\\n\\n// same as:\\ndb.createReadStream({ keys: true, values: false })\\n  .on(\'data\', function (data) {\\n    console.log(\'key=\', data)\\n  })\\n```\\n\\n--------------------------------------------------------\\n<a name=\\"createValueStream\\"></a>\\n### db.createValueStream([options])\\n\\nA **ValueStream** is a **ReadStream** where the `\'data\'` events are simply the values from the database so it can be used like a traditional stream rather than an object stream.\\n\\nYou can obtain a ValueStream either by calling the `createValueStream()` method on a LevelUP object or by passing passing an options object to `createReadStream()` with `values` set to `true` and `keys` set to `false`.\\n\\n```js\\ndb.createValueStream()\\n  .on(\'data\', function (data) {\\n    console.log(\'value=\', data)\\n  })\\n\\n// same as:\\ndb.createReadStream({ keys: false, values: true })\\n  .on(\'data\', function (data) {\\n    console.log(\'value=\', data)\\n  })\\n```\\n\\n--------------------------------------------------------\\n<a name=\\"createWriteStream\\"></a>\\n### db.createWriteStream([options])\\n\\nA **WriteStream** can be obtained by calling the `createWriteStream()` method. The resulting stream is a complete Node.js-style [Writable Stream](http://nodejs.org/docs/latest/api/stream.html#stream_writable_stream) which accepts objects with `\'key\'` and `\'value\'` pairs on its `write()` method.\\n\\nThe WriteStream will buffer writes and submit them as a `batch()` operations where writes occur *within the same tick*.\\n\\n```js\\nvar ws = db.createWriteStream()\\n\\nws.on(\'error\', function (err) {\\n  console.log(\'Oh my!\', err)\\n})\\nws.on(\'close\', function () {\\n  console.log(\'Stream closed\')\\n})\\n\\nws.write({ key: \'name\', value: \'Yuri Irsenovich Kim\' })\\nws.write({ key: \'dob\', value: \'16 February 1941\' })\\nws.write({ key: \'spouse\', value: \'Kim Young-sook\' })\\nws.write({ key: \'occupation\', value: \'Clown\' })\\nws.end()\\n```\\n\\nThe standard `write()`, `end()`, `destroy()` and `destroySoon()` methods are implemented on the WriteStream. `\'drain\'`, `\'error\'`, `\'close\'` and `\'pipe\'` events are emitted.\\n\\nYou can specify encodings both for the whole stream and individual entries:\\n\\nTo set the encoding for the whole stream, provide an options object as the first parameter to `createWriteStream()` with `\'keyEncoding\'` and/or `\'valueEncoding\'`.\\n\\nTo set the encoding for an individual entry:\\n\\n```js\\nwriteStream.write({\\n    key           : new Buffer([1, 2, 3])\\n  , value         : { some: \'json\' }\\n  , keyEncoding   : \'binary\'\\n  , valueEncoding : \'json\'\\n})\\n```\\n\\n#### write({ type: \'put\' })\\n\\nIf individual `write()` operations are performed with a `\'type\'` property of `\'del\'`, they will be passed on as `\'del\'` operations to the batch.\\n\\n```js\\nvar ws = db.createWriteStream()\\n\\nws.on(\'error\', function (err) {\\n  console.log(\'Oh my!\', err)\\n})\\nws.on(\'close\', function () {\\n  console.log(\'Stream closed\')\\n})\\n\\nws.write({ type: \'del\', key: \'name\' })\\nws.write({ type: \'del\', key: \'dob\' })\\nws.write({ type: \'put\', key: \'spouse\' })\\nws.write({ type: \'del\', key: \'occupation\' })\\nws.end()\\n```\\n\\n#### db.createWriteStream({ type: \'del\' })\\n\\nIf the *WriteStream* is created with a `\'type\'` option of `\'del\'`, all `write()` operations will be interpreted as `\'del\'`, unless explicitly specified as `\'put\'`.\\n\\n```js\\nvar ws = db.createWriteStream({ type: \'del\' })\\n\\nws.on(\'error\', function (err) {\\n  console.log(\'Oh my!\', err)\\n})\\nws.on(\'close\', function () {\\n  console.log(\'Stream closed\')\\n})\\n\\nws.write({ key: \'name\' })\\nws.write({ key: \'dob\' })\\n// but it can be overridden\\nws.write({ type: \'put\', key: \'spouse\', value: \'Ri Sol-ju\' })\\nws.write({ key: \'occupation\' })\\nws.end()\\n```\\n\\n#### Pipes and Node Stream compatibility\\n\\nA ReadStream can be piped directly to a WriteStream, allowing for easy copying of an entire database. A simple `copy()` operation is included in LevelUP that performs exactly this on two open databases:\\n\\n```js\\nfunction copy (srcdb, dstdb, callback) {\\n  srcdb.createReadStream().pipe(dstdb.createWriteStream()).on(\'close\', callback)\\n}\\n```\\n\\nThe ReadStream is also [fstream](https://github.com/isaacs/fstream)-compatible which means you should be able to pipe to and from fstreams. So you can serialize and deserialize an entire database to a directory where keys are filenames and values are their contents, or even into a *tar* file using [node-tar](https://github.com/isaacs/node-tar). See the [fstream functional test](https://github.com/rvagg/node-levelup/blob/master/test/functional/fstream-test.js) for an example. *(Note: I\'m not really sure there\'s a great use-case for this but it\'s a fun example and it helps to harden the stream implementations.)*\\n\\nKeyStreams and ValueStreams can be treated like standard streams of raw data. If `\'keyEncoding\'` or `\'valueEncoding\'` is set to `\'binary\'` the `\'data\'` events will simply be standard Node `Buffer` objects straight out of the data store.\\n\\n\\n--------------------------------------------------------\\n<a name=\'approximateSize\'></a>\\n### db.db.approximateSize(start, end, callback)\\n<code>approximateSize()</code> can used to get the approximate number of bytes of file system space used by the range `[start..end)`. The result may not include recently written data.\\n\\n```js\\nvar db = require(\'level\')(\'./huge.db\')\\n\\ndb.db.approximateSize(\'a\', \'c\', function (err, size) {\\n  if (err) return console.error(\'Ooops!\', err)\\n  console.log(\'Approximate size of range is %d\', size)\\n})\\n```\\n\\n**Note:** `approximateSize()` is available via [LevelDOWN](https://github.com/rvagg/node-leveldown/), which by default is accessible as the `db` property of your LevelUP instance. This is a specific LevelDB operation and is not likely to be available where you replace LevelDOWN with an alternative back-end via the `\'db\'` option.\\n\\n\\n--------------------------------------------------------\\n<a name=\'getProperty\'></a>\\n### db.db.getProperty(property)\\n<code>getProperty</code> can be used to get internal details from LevelDB. When issued with a valid property string, a readable string will be returned (this method is synchronous).\\n\\nCurrently, the only valid properties are:\\n\\n* <b><code>\'leveldb.num-files-at-levelN\'</code></b>: returns the number of files at level *N*, where N is an integer representing a valid level (e.g. \\"0\\").\\n\\n* <b><code>\'leveldb.stats\'</code></b>: returns a multi-line string describing statistics about LevelDB\'s internal operation.\\n\\n* <b><code>\'leveldb.sstables\'</code></b>: returns a multi-line string describing all of the *sstables* that make up contents of the current database.\\n\\n\\n```js\\nvar db = require(\'level\')(\'./huge.db\')\\nconsole.log(db.db.getProperty(\'leveldb.num-files-at-level3\'))\\n// \u2192 \'243\'\\n```\\n\\n**Note:** `getProperty()` is available via [LevelDOWN](https://github.com/rvagg/node-leveldown/), which by default is accessible as the `db` property of your LevelUP instance. This is a specific LevelDB operation and is not likely to be available where you replace LevelDOWN with an alternative back-end via the `\'db\'` option.\\n\\n\\n--------------------------------------------------------\\n<a name=\\"destroy\\"></a>\\n### leveldown.destroy(location, callback)\\n<code>destroy()</code> is used to completely remove an existing LevelDB database directory. You can use this function in place of a full directory *rm* if you want to be sure to only remove LevelDB-related files. If the directory only contains LevelDB files, the directory itself will be removed as well. If there are additional, non-LevelDB files in the directory, those files, and the directory, will be left alone.\\n\\nThe callback will be called when the destroy operation is complete, with a possible `error` argument.\\n\\n**Note:** `destroy()` is available via [LevelDOWN](https://github.com/rvagg/node-leveldown/) which you will have to have available to `require()`, e.g.:\\n\\n```js\\nrequire(\'leveldown\').destroy(\'./huge.db\', function () { console.log(\'done!\') })\\n```\\n\\n--------------------------------------------------------\\n<a name=\\"repair\\"></a>\\n### leveldown.repair(location, callback)\\n<code>repair()</code> can be used to attempt a restoration of a damaged LevelDB store. From the LevelDB documentation:\\n\\n> If a DB cannot be opened, you may attempt to call this method to resurrect as much of the contents of the database as possible. Some data may be lost, so be careful when calling this function on a database that contains important information.\\n\\nYou will find information on the *repair* operation in the *LOG* file inside the store directory. \\n\\nA `repair()` can also be used to perform a compaction of the LevelDB log into table files.\\n\\nThe callback will be called when the repair operation is complete, with a possible `error` argument.\\n\\n**Note:** `destroy()` is available via [LevelDOWN](https://github.com/rvagg/node-leveldown/) which you will have to have available to `require()`, e.g.:\\n\\n```js\\nrequire(\'leveldown\').repair(\'./huge.db\', function () { console.log(\'done!\') })\\n```\\n\\n--------------------------------------------------------\\n\\n<a name=\\"events\\"></a>\\nEvents\\n------\\n\\nLevelUP emits events when the callbacks to the corresponding methods are called.\\n\\n* `db.emit(\'put\', key, value)` emitted when a new value is `\'put\'`\\n* `db.emit(\'del\', key)` emitted when a value is deleted\\n* `db.emit(\'batch\', ary)` emitted when a batch operation has executed\\n* `db.emit(\'ready\')` emitted when the database has opened (`\'open\'` is synonym)\\n* `db.emit(\'closed\')` emitted when the database has closed\\n* `db.emit(\'opening\')` emitted when the database is opening\\n* `db.emit(\'closing\')` emitted when the database is closing\\n\\nIf you do not pass a callback to an async function, and there is an error, LevelUP will `emit(\'error\', err)` instead.\\n\\n<a name=\\"json\\"></a>\\nJSON data\\n---------\\n\\nYou specify `\'json\'` encoding for both keys and/or values, you can then supply JavaScript objects to LevelUP and receive them from all fetch operations, including ReadStreams. LevelUP will automatically *stringify* your objects and store them as *utf8* and parse the strings back into objects before passing them back to you.\\n\\n<a name=\\"custom_encodings\\"></a>\\nCustom encodings\\n----------------\\n\\nA custom encoding may be provided by passing in an object as an value for `keyEncoding` or `valueEncoding` (wherever accepted), it must have the following properties:\\n\\n```js\\n{\\n    encode : function (val) { ... }\\n  , decode : function (val) { ... }\\n  , buffer : boolean // encode returns a buffer-like and decode accepts a buffer\\n  , type   : String  // name of this encoding type.\\n}\\n```\\n\\n*\\"buffer-like\\"* means either a `Buffer` if running in Node, or a Uint8Array if in a browser. Use [bops](https://github.com/chrisdickinson/bops) to get portable binary operations.\\n\\n<a name=\\"extending\\"></a>\\nExtending LevelUP\\n-----------------\\n\\nA list of <a href=\\"https://github.com/rvagg/node-levelup/wiki/Modules\\"><b>Node.js LevelDB modules and projects</b></a> can be found in the wiki.\\n\\nWhen attempting to extend the functionality of LevelUP, it is recommended that you consider using [level-hooks](https://github.com/dominictarr/level-hooks) and/or [level-sublevel](https://github.com/dominictarr/level-sublevel). **level-sublevel** is particularly helpful for keeping additional, extension-specific, data in a LevelDB store. It allows you to partition a LevelUP instance into multiple sub-instances that each correspond to discrete namespaced key ranges.\\n\\n<a name=\\"multiproc\\"></a>\\nMulti-process access\\n--------------------\\n\\nLevelDB is thread-safe but is **not** suitable for accessing with multiple processes. You should only ever have a LevelDB database open from a single Node.js process. Node.js clusters are made up of multiple processes so a LevelUP instance cannot be shared between them either.\\n\\nSee the <a href=\\"https://github.com/rvagg/node-levelup/wiki/Modules\\"><b>wiki</b></a> for some LevelUP extensions, including [multilevel](https://github.com/juliangruber/multilevel), that may help if you require a single data store to be shared across processes.\\n\\n<a name=\\"support\\"></a>\\nGetting support\\n---------------\\n\\nThere are multiple ways you can find help in using LevelDB in Node.js:\\n\\n * **IRC:** you\'ll find an active group of LevelUP users in the **##leveldb** channel on Freenode, including most of the contributors to this project.\\n * **Mailing list:** there is an active [Node.js LevelDB](https://groups.google.com/forum/#!forum/node-levelup) Google Group.\\n * **GitHub:** you\'re welcome to open an issue here on this GitHub repository if you have a question.\\n\\n<a name=\\"contributing\\"></a>\\nContributing\\n------------\\n\\nLevelUP is an **OPEN Open Source Project**. This means that:\\n\\n> Individuals making significant and valuable contributions are given commit-access to the project to contribute as they see fit. This project is more like an open wiki than a standard guarded open source project.\\n\\nSee the [CONTRIBUTING.md](https://github.com/rvagg/node-levelup/blob/master/CONTRIBUTING.md) file for more details.\\n\\n### Contributors\\n\\nLevelUP is only possible due to the excellent work of the following contributors:\\n\\n<table><tbody>\\n<tr><th align=\\"left\\">Rod Vagg</th><td><a href=\\"https://github.com/rvagg\\">GitHub/rvagg</a></td><td><a href=\\"http://twitter.com/rvagg\\">Twitter/@rvagg</a></td></tr>\\n<tr><th align=\\"left\\">John Chesley</th><td><a href=\\"https://github.com/chesles/\\">GitHub/chesles</a></td><td><a href=\\"http://twitter.com/chesles\\">Twitter/@chesles</a></td></tr>\\n<tr><th align=\\"left\\">Jake Verbaten</th><td><a href=\\"https://github.com/raynos\\">GitHub/raynos</a></td><td><a href=\\"http://twitter.com/raynos2\\">Twitter/@raynos2</a></td></tr>\\n<tr><th align=\\"left\\">Dominic Tarr</th><td><a href=\\"https://github.com/dominictarr\\">GitHub/dominictarr</a></td><td><a href=\\"http://twitter.com/dominictarr\\">Twitter/@dominictarr</a></td></tr>\\n<tr><th align=\\"left\\">Max Ogden</th><td><a href=\\"https://github.com/maxogden\\">GitHub/maxogden</a></td><td><a href=\\"http://twitter.com/maxogden\\">Twitter/@maxogden</a></td></tr>\\n<tr><th align=\\"left\\">Lars-Magnus Skog</th><td><a href=\\"https://github.com/ralphtheninja\\">GitHub/ralphtheninja</a></td><td><a href=\\"http://twitter.com/ralphtheninja\\">Twitter/@ralphtheninja</a></td></tr>\\n<tr><th align=\\"left\\">David Bj\xF6rklund</th><td><a href=\\"https://github.com/kesla\\">GitHub/kesla</a></td><td><a href=\\"http://twitter.com/david_bjorklund\\">Twitter/@david_bjorklund</a></td></tr>\\n<tr><th align=\\"left\\">Julian Gruber</th><td><a href=\\"https://github.com/juliangruber\\">GitHub/juliangruber</a></td><td><a href=\\"http://twitter.com/juliangruber\\">Twitter/@juliangruber</a></td></tr>\\n<tr><th align=\\"left\\">Paolo Fragomeni</th><td><a href=\\"https://github.com/hij1nx\\">GitHub/hij1nx</a></td><td><a href=\\"http://twitter.com/hij1nx\\">Twitter/@hij1nx</a></td></tr>\\n<tr><th align=\\"left\\">Anton Whalley</th><td><a href=\\"https://github.com/No9\\">GitHub/No9</a></td><td><a href=\\"https://twitter.com/antonwhalley\\">Twitter/@antonwhalley</a></td></tr>\\n<tr><th align=\\"left\\">Matteo Collina</th><td><a href=\\"https://github.com/mcollina\\">GitHub/mcollina</a></td><td><a href=\\"https://twitter.com/matteocollina\\">Twitter/@matteocollina</a></td></tr>\\n<tr><th align=\\"left\\">Pedro Teixeira</th><td><a href=\\"https://github.com/pgte\\">GitHub/pgte</a></td><td><a href=\\"https://twitter.com/pgte\\">Twitter/@pgte</a></td></tr>\\n<tr><th align=\\"left\\">James Halliday</th><td><a href=\\"https://github.com/substack\\">GitHub/substack</a></td><td><a href=\\"https://twitter.com/substack\\">Twitter/@substack</a></td></tr>\\n</tbody></table>\\n\\n### Windows\\n\\nA large portion of the Windows support comes from code by [Krzysztof Kowalczyk](http://blog.kowalczyk.info/) [@kjk](https://twitter.com/kjk), see his Windows LevelDB port [here](http://code.google.com/r/kkowalczyk-leveldb/). If you\'re using LevelUP on Windows, you should give him your thanks!\\n\\n\\n<a name=\\"licence\\"></a>\\nLicence &amp; copyright\\n-------------------\\n\\nCopyright (c) 2012-2013 LevelUP contributors (listed above).\\n\\nLevelUP is licensed under an MIT +no-false-attribs license. All rights not explicitly granted in the MIT license are reserved. See the included LICENSE file for more details.\\n\\n=======\\n*LevelUP builds on the excellent work of the LevelDB and Snappy teams from Google and additional contributors. LevelDB and Snappy are both issued under the [New BSD Licence](http://opensource.org/licenses/BSD-3-Clause).*\\n",\n  "readmeFilename": "README.md",\n  "bugs": {\n    "url": "https://github.com/rvagg/node-levelup/issues"\n  },\n  "_id": "levelup@0.18.2",\n  "_from": "levelup@*"\n}\n\n})()\n},{}],59:[function(require,module,exports){\n(function(){// UTILITY\nvar util = require(\'util\');\nvar Buffer = require("buffer").Buffer;\nvar pSlice = Array.prototype.slice;\n\nfunction objectKeys(object) {\n  if (Object.keys) return Object.keys(object);\n  var result = [];\n  for (var name in object) {\n    if (Object.prototype.hasOwnProperty.call(object, name)) {\n      result.push(name);\n    }\n  }\n  return result;\n}\n\n// 1. The assert module provides functions that throw\n// AssertionError\'s when particular conditions are not met. The\n// assert module must conform to the following interface.\n\nvar assert = module.exports = ok;\n\n// 2. The AssertionError is defined in assert.\n// new assert.AssertionError({ message: message,\n//                             actual: actual,\n//                             expected: expected })\n\nassert.AssertionError = function AssertionError(options) {\n  this.name = \'AssertionError\';\n  this.message = options.message;\n  this.actual = options.actual;\n  this.expected = options.expected;\n  this.operator = options.operator;\n  var stackStartFunction = options.stackStartFunction || fail;\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, stackStartFunction);\n  }\n};\n\n// assert.AssertionError instanceof Error\nutil.inherits(assert.AssertionError, Error);\n\nfunction replacer(key, value) {\n  if (value === undefined) {\n    return \'\' + value;\n  }\n  if (typeof value === \'number\' && (isNaN(value) || !isFinite(value))) {\n    return value.toString();\n  }\n  if (typeof value === \'function\' || value instanceof RegExp) {\n    return value.toString();\n  }\n  return value;\n}\n\nfunction truncate(s, n) {\n  if (typeof s == \'string\') {\n    return s.length < n ? s : s.slice(0, n);\n  } else {\n    return s;\n  }\n}\n\nassert.AssertionError.prototype.toString = function() {\n  if (this.message) {\n    return [this.name + \':\', this.message].join(\' \');\n  } else {\n    return [\n      this.name + \':\',\n      truncate(JSON.stringify(this.actual, replacer), 128),\n      this.operator,\n      truncate(JSON.stringify(this.expected, replacer), 128)\n    ].join(\' \');\n  }\n};\n\n// At present only the three keys mentioned above are used and\n// understood by the spec. Implementations or sub modules can pass\n// other keys to the AssertionError\'s constructor - they will be\n// ignored.\n\n// 3. All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided.  All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n\nfunction fail(actual, expected, message, operator, stackStartFunction) {\n  throw new assert.AssertionError({\n    message: message,\n    actual: actual,\n    expected: expected,\n    operator: operator,\n    stackStartFunction: stackStartFunction\n  });\n}\n\n// EXTENSION! allows for well behaved errors defined elsewhere.\nassert.fail = fail;\n\n// 4. Pure assertion tests whether a value is truthy, as determined\n// by !!guard.\n// assert.ok(guard, message_opt);\n// This statement is equivalent to assert.equal(true, guard,\n// message_opt);. To test strictly for the value true, use\n// assert.strictEqual(true, guard, message_opt);.\n\nfunction ok(value, message) {\n  if (!!!value) fail(value, true, message, \'==\', assert.ok);\n}\nassert.ok = ok;\n\n// 5. The equality assertion tests shallow, coercive equality with\n// ==.\n// assert.equal(actual, expected, message_opt);\n\nassert.equal = function equal(actual, expected, message) {\n  if (actual != expected) fail(actual, expected, message, \'==\', assert.equal);\n};\n\n// 6. The non-equality assertion tests for whether two objects are not equal\n// with != assert.notEqual(actual, expected, message_opt);\n\nassert.notEqual = function notEqual(actual, expected, message) {\n  if (actual == expected) {\n    fail(actual, expected, message, \'!=\', assert.notEqual);\n  }\n};\n\n// 7. The equivalence assertion tests a deep equality relation.\n// assert.deepEqual(actual, expected, message_opt);\n\nassert.deepEqual = function deepEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected)) {\n    fail(actual, expected, message, \'deepEqual\', assert.deepEqual);\n  }\n};\n\nfunction _deepEqual(actual, expected) {\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n\n  } else if (Buffer.isBuffer(actual) && Buffer.isBuffer(expected)) {\n    if (actual.length != expected.length) return false;\n\n    for (var i = 0; i < actual.length; i++) {\n      if (actual[i] !== expected[i]) return false;\n    }\n\n    return true;\n\n  // 7.2. If the expected value is a Date object, the actual value is\n  // equivalent if it is also a Date object that refers to the same time.\n  } else if (actual instanceof Date && expected instanceof Date) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3. Other pairs that do not both pass typeof value == \'object\',\n  // equivalence is determined by ==.\n  } else if (typeof actual != \'object\' && typeof expected != \'object\') {\n    return actual == expected;\n\n  // 7.4. For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical \'prototype\' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else {\n    return objEquiv(actual, expected);\n  }\n}\n\nfunction isUndefinedOrNull(value) {\n  return value === null || value === undefined;\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) == \'[object Arguments]\';\n}\n\nfunction objEquiv(a, b) {\n  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))\n    return false;\n  // an identical \'prototype\' property.\n  if (a.prototype !== b.prototype) return false;\n  //~~~I\'ve managed to break Object.keys through screwy arguments passing.\n  //   Converting to array solves the problem.\n  if (isArguments(a)) {\n    if (!isArguments(b)) {\n      return false;\n    }\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return _deepEqual(a, b);\n  }\n  try {\n    var ka = objectKeys(a),\n        kb = objectKeys(b),\n        key, i;\n  } catch (e) {//happens when one is a string literal and the other isn\'t\n    return false;\n  }\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length != kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!_deepEqual(a[key], b[key])) return false;\n  }\n  return true;\n}\n\n// 8. The non-equivalence assertion tests for any deep inequality.\n// assert.notDeepEqual(actual, expected, message_opt);\n\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected)) {\n    fail(actual, expected, message, \'notDeepEqual\', assert.notDeepEqual);\n  }\n};\n\n// 9. The strict equality assertion tests strict equality, as determined by ===.\n// assert.strictEqual(actual, expected, message_opt);\n\nassert.strictEqual = function strictEqual(actual, expected, message) {\n  if (actual !== expected) {\n    fail(actual, expected, message, \'===\', assert.strictEqual);\n  }\n};\n\n// 10. The strict non-equality assertion tests for strict inequality, as\n// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);\n\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n  if (actual === expected) {\n    fail(actual, expected, message, \'!==\', assert.notStrictEqual);\n  }\n};\n\nfunction expectedException(actual, expected) {\n  if (!actual || !expected) {\n    return false;\n  }\n\n  if (expected instanceof RegExp) {\n    return expected.test(actual);\n  } else if (actual instanceof expected) {\n    return true;\n  } else if (expected.call({}, actual) === true) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction _throws(shouldThrow, block, expected, message) {\n  var actual;\n\n  if (typeof expected === \'string\') {\n    message = expected;\n    expected = null;\n  }\n\n  try {\n    block();\n  } catch (e) {\n    actual = e;\n  }\n\n  message = (expected && expected.name ? \' (\' + expected.name + \').\' : \'.\') +\n            (message ? \' \' + message : \'.\');\n\n  if (shouldThrow && !actual) {\n    fail(\'Missing expected exception\' + message);\n  }\n\n  if (!shouldThrow && expectedException(actual, expected)) {\n    fail(\'Got unwanted exception\' + message);\n  }\n\n  if ((shouldThrow && actual && expected &&\n      !expectedException(actual, expected)) || (!shouldThrow && actual)) {\n    throw actual;\n  }\n}\n\n// 11. Expected to throw an error:\n// assert.throws(block, Error_opt, message_opt);\n\nassert.throws = function(block, /*optional*/error, /*optional*/message) {\n  _throws.apply(this, [true].concat(pSlice.call(arguments)));\n};\n\n// EXTENSION! This is annoying to write outside this module.\nassert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {\n  _throws.apply(this, [false].concat(pSlice.call(arguments)));\n};\n\nassert.ifError = function(err) { if (err) {throw err;}};\n\n})()\n},{"buffer":43,"util":22}],40:[function(require,module,exports){\n/*!\n  * prr\n  * (c) 2013 Rod Vagg <rod@vagg.org>\n  * https://github.com/rvagg/prr\n  * License: MIT\n  */\n\n(function (name, context, definition) {\n  if (typeof module != \'undefined\' && module.exports)\n    module.exports = definition()\n  else\n    context[name] = definition()\n})(\'prr\', this, function() {\n\n  var setProperty = typeof Object.defineProperty == \'function\'\n      ? function (obj, key, options) {\n          Object.defineProperty(obj, key, options)\n          return obj\n        }\n      : function (obj, key, options) { // < es5\n          obj[key] = options.value\n          return obj\n        }\n\n    , makeOptions = function (value, options) {\n        var oo = typeof options == \'object\'\n          , os = !oo && typeof options == \'string\'\n          , op = function (p) {\n              return oo\n                ? !!options[p]\n                : os\n                  ? options.indexOf(p[0]) > -1\n                  : false\n            }\n\n        return {\n            enumerable   : op(\'enumerable\')\n          , configurable : op(\'configurable\')\n          , writable     : op(\'writable\')\n          , value        : value\n        }\n      }\n\n    , prr = function (obj, key, value, options) {\n        var k\n\n        options = makeOptions(value, options)\n\n        if (typeof key == \'object\') {\n          for (k in key) {\n            if (Object.hasOwnProperty.call(key, k)) {\n              options.value = key[k]\n              setProperty(obj, k, options)\n            }\n          }\n          return obj\n        }\n\n        return setProperty(obj, key, options)\n      }\n\n  return prr\n})\n},{}],46:[function(require,module,exports){\n// Original code adapted from Robert Kieffer.\n// details at https://github.com/broofa/node-uuid\n(function() {\n  var _global = this;\n\n  var mathRNG, whatwgRNG;\n\n  // NOTE: Math.random() does not guarantee "cryptographic quality"\n  mathRNG = function(size) {\n    var bytes = new Array(size);\n    var r;\n\n    for (var i = 0, r; i < size; i++) {\n      if ((i & 0x03) == 0) r = Math.random() * 0x100000000;\n      bytes[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return bytes;\n  }\n\n  if (_global.crypto && crypto.getRandomValues) {\n    whatwgRNG = function(size) {\n      var bytes = new Uint8Array(size);\n      crypto.getRandomValues(bytes);\n      return bytes;\n    }\n  }\n\n  module.exports = whatwgRNG || mathRNG;\n\n}())\n\n},{}],29:[function(require,module,exports){\nvar EventEmitter = require(\'events\').EventEmitter\nvar inherits     = require(\'util\').inherits\nvar ranges       = require(\'string-range\')\nvar fixRange     = require(\'level-fix-range\')\nvar xtend        = require(\'xtend\')\nvar Batch        = require(\'./batch\')\n\ninherits(SubDB, EventEmitter)\n\nfunction SubDB (db, prefix, options) {\n  if(\'string\' === typeof options) {\n    console.error(\'db.sublevel(name, seperator<string>) is depreciated\')\n    console.error(\'use db.sublevel(name, {sep: separator})) if you must\')\n    options = {sep: options}\n  }\n  if(!(this instanceof SubDB)) return new SubDB(db, prefix, options)\n  if(!db)     throw new Error(\'must provide db\')\n  if(!prefix) throw new Error(\'must provide prefix\')\n\n  options = options || {}\n  options.sep = options.sep || \'\\xff\'\n\n  this._parent = db\n  this._options = options\n  this.options = options\n  this._prefix = prefix\n  this._root = root(this)\n  db.sublevels[prefix] = this\n  this.sublevels = {}\n  this.methods = {}\n  var self = this\n  this.hooks = {\n    pre: function () {\n      return self.pre.apply(self, arguments)\n    },\n    post: function () {\n      return self.post.apply(self, arguments)\n    }\n  }\n}\n\nvar SDB = SubDB.prototype\n\nSDB._key = function (key) {\n  var sep = this._options.sep\n  return sep\n    + this._prefix\n    + sep\n    + key\n}\n\nSDB._getOptsAndCb = function (opts, cb) {\n  if (typeof opts == \'function\') {\n    cb = opts\n    opts = {}\n  }\n  return { opts: xtend(opts, this._options), cb: cb }\n}\n\nSDB.sublevel = function (prefix, options) {\n  if(this.sublevels[prefix])\n    return this.sublevels[prefix]\n  return new SubDB(this, prefix, options || this._options)\n}\n\nSDB.put = function (key, value, opts, cb) {\n  var res = this._getOptsAndCb(opts, cb)\n  this._root.put(this.prefix(key), value, res.opts, res.cb)\n}\n\nSDB.get = function (key, opts, cb) {\n  var res = this._getOptsAndCb(opts, cb)\n  this._root.get(this.prefix(key), res.opts, res.cb)\n}\n\nSDB.del = function (key, opts, cb) {\n  var res = this._getOptsAndCb(opts, cb)\n  this._root.del(this.prefix(key), res.opts, res.cb)\n}\n\nSDB.batch = function (changes, opts, cb) {\n  if(!Array.isArray(changes))\n    return new Batch(this)\n  var self = this,\n      res = this._getOptsAndCb(opts, cb)\n  changes.forEach(function (ch) {\n\n    //OH YEAH, WE NEED TO VALIDATE THAT UPDATING THIS KEY/PREFIX IS ALLOWED\n    if(\'string\' === typeof ch.prefix)\n      ch.key = ch.prefix + ch.key\n    else\n      ch.key = (ch.prefix || self).prefix(ch.key)\n\n    if(ch.prefix) ch.prefix = null\n  })\n  this._root.batch(changes, res.opts, res.cb)\n}\n\nSDB._getKeyEncoding = function () {\n  if(this.options.keyEncoding)\n    return this.options.keyEncoding\n  if(this._parent && this._parent._getKeyEncoding)\n    return this._parent._getKeyEncoding()\n}\n\nSDB._getValueEncoding = function () {\n  if(this.options.valueEncoding)\n    return this.options.valueEncoding\n  if(this._parent && this._parent._getValueEncoding)\n    return this._parent._getValueEncoding()\n}\n\nSDB.prefix = function (key) {\n  var sep = this._options.sep\n  return this._parent.prefix() + sep + this._prefix + sep + (key || \'\')\n}\n\nSDB.keyStream =\nSDB.createKeyStream = function (opts) {\n  opts = opts || {}\n  opts.keys = true\n  opts.values = false\n  return this.createReadStream(opts)\n}\n\nSDB.valueStream =\nSDB.createValueStream = function (opts) {\n  opts = opts || {}\n  opts.keys = false\n  opts.values = true\n  opts.keys = false\n  return this.createReadStream(opts)\n}\n\nfunction selectivelyMerge(_opts, opts) {\n  [ \'valueEncoding\'\n  , \'encoding\'\n  , \'keyEncoding\'\n  , \'reverse\'\n  , \'values\'\n  , \'keys\'\n  , \'limit\'\n  , \'fillCache\'\n  ]\n  .forEach(function (k) {\n    if (opts.hasOwnProperty(k)) _opts[k] = opts[k]\n  })\n}\n\nSDB.readStream =\nSDB.createReadStream = function (opts) {\n  opts = opts || {}\n  var r = root(this)\n  var p = this.prefix()\n\n  var _opts = ranges.prefix(opts, p)\n  selectivelyMerge(_opts, xtend(opts, this._options))\n\n  var s = r.createReadStream(_opts)\n\n  if(_opts.values === false) {\n    var read = s.read\n    if (read) {\n      s.read = function (size) {\n        var val = read.call(this, size)\n        if (val) val = val.substring(p.length)\n        return val\n      }\n    } else {\n      var emit = s.emit\n      s.emit = function (event, val) {\n        if(event === \'data\') {\n          emit.call(this, \'data\', val.substring(p.length))\n        } else\n          emit.call(this, event, val)\n      }\n    }\n    return s\n  } else if(_opts.keys === false)\n    return s\n  else {\n    var read = s.read\n    if (read) {\n      s.read = function (size) {\n        var d = read.call(this, size)\n        if (d) d.key = d.key.substring(p.length)\n        return d\n      }\n    } else {\n      s.on(\'data\', function (d) {\n        //mutate the prefix!\n        //this doesn\'t work for createKeyStream admittedly.\n        d.key = d.key.substring(p.length)\n      })\n    }\n    return s\n  }\n}\n\n\nSDB.writeStream =\nSDB.createWriteStream = function () {\n  var r = root(this)\n  var p = this.prefix()\n  var ws = r.createWriteStream.apply(r, arguments)\n  var write = ws.write\n\n  var encoding = this._options.encoding\n  var valueEncoding = this._options.valueEncoding\n  var keyEncoding = this._options.keyEncoding\n\n  // slight optimization, if no encoding was specified at all,\n  // which will be the case most times, make write not check at all\n  var nocheck = !encoding && !valueEncoding && !keyEncoding\n\n  ws.write = nocheck\n    ? function (data) {\n        data.key = p + data.key\n        return write.call(ws, data)\n      }\n    : function (data) {\n        data.key = p + data.key\n\n        // not merging all options here since this happens on every write and things could get slowed down\n        // at this point we only consider encoding important to propagate\n        if (encoding && typeof data.encoding === \'undefined\')\n          data.encoding = encoding\n        if (valueEncoding && typeof data.valueEncoding === \'undefined\')\n          data.valueEncoding = valueEncoding\n        if (keyEncoding && typeof data.keyEncoding === \'undefined\')\n          data.keyEncoding = keyEncoding\n\n        return write.call(ws, data)\n      }\n  return ws\n}\n\nSDB.approximateSize = function () {\n  var r = root(db)\n  return r.approximateSize.apply(r, arguments)\n}\n\nfunction root(db) {\n  if(!db._parent) return db\n  return root(db._parent)\n}\n\nSDB.pre = function (range, hook) {\n  if(!hook) hook = range, range = null\n  range = ranges.prefix(range, this.prefix(), this._options.sep)\n  var r = root(this._parent)\n  var p = this.prefix()\n  return r.hooks.pre(fixRange(range), function (ch, add, batch) {\n    hook({\n      key: ch.key.substring(p.length),\n      value: ch.value,\n      type: ch.type\n    }, function (ch, _p) {\n      //maybe remove the second add arg now\n      //that op can have prefix?\n      add(ch, ch.prefix ? _p : (_p || p))\n    }, batch)\n  })\n}\n\nSDB.post = function (range, hook) {\n  if(!hook) hook = range, range = null\n  var r = root(this._parent)\n  var p = this.prefix()\n  range = ranges.prefix(range, p, this._options.sep)\n  return r.hooks.post(fixRange(range), function (data) {\n    hook({key: data.key.substring(p.length), value: data.value, type: data.type})\n  })\n}\n\nvar exports = module.exports = SubDB\n\n\n},{"./batch":26,"events":23,"level-fix-range":30,"string-range":61,"util":22,"xtend":60}],49:[function(require,module,exports){\n\nmodule.exports = function(buffer) {\n  return buffer instanceof Uint8Array;\n}\n\n},{}],50:[function(require,module,exports){\nmodule.exports = subarray\n\nfunction subarray(buf, from, to) {\n  return buf.subarray(from || 0, to || buf.length)\n}\n\n},{}],51:[function(require,module,exports){\nmodule.exports = join\n\nfunction join(targets, hint) {\n  if(!targets.length) {\n    return new Uint8Array(0)\n  }\n\n  var len = hint !== undefined ? hint : get_length(targets)\n    , out = new Uint8Array(len)\n    , cur = targets[0]\n    , curlen = cur.length\n    , curidx = 0\n    , curoff = 0\n    , i = 0\n\n  while(i < len) {\n    if(curoff === curlen) {\n      curoff = 0\n      ++curidx\n      cur = targets[curidx]\n      curlen = cur && cur.length\n      continue\n    }\n    out[i++] = cur[curoff++] \n  }\n\n  return out\n}\n\nfunction get_length(targets) {\n  var size = 0\n  for(var i = 0, len = targets.length; i < len; ++i) {\n    size += targets[i].byteLength\n  }\n  return size\n}\n\n},{}],52:[function(require,module,exports){\nmodule.exports = copy\n\nvar slice = [].slice\n\nfunction copy(source, target, target_start, source_start, source_end) {\n  target_start = arguments.length < 3 ? 0 : target_start\n  source_start = arguments.length < 4 ? 0 : source_start\n  source_end = arguments.length < 5 ? source.length : source_end\n\n  if(source_end === source_start) {\n    return\n  }\n\n  if(target.length === 0 || source.length === 0) {\n    return\n  }\n\n  if(source_end > source.length) {\n    source_end = source.length\n  }\n\n  if(target.length - target_start < source_end - source_start) {\n    source_end = target.length - target_start + source_start\n  }\n\n  if(source.buffer !== target.buffer) {\n    return fast_copy(source, target, target_start, source_start, source_end)\n  }\n  return slow_copy(source, target, target_start, source_start, source_end)\n}\n\nfunction fast_copy(source, target, target_start, source_start, source_end) {\n  var len = (source_end - source_start) + target_start\n\n  for(var i = target_start, j = source_start;\n      i < len;\n      ++i,\n      ++j) {\n    target[i] = source[j]\n  }\n}\n\nfunction slow_copy(from, to, j, i, jend) {\n  // the buffers could overlap.\n  var iend = jend + i\n    , tmp = new Uint8Array(slice.call(from, i, iend))\n    , x = 0\n\n  for(; i < iend; ++i, ++x) {\n    to[j++] = tmp[x]\n  }\n}\n\n},{}],53:[function(require,module,exports){\nmodule.exports = function(size) {\n  return new Uint8Array(size)\n}\n\n},{}],62:[function(require,module,exports){\n(function(process){/* Copyright (c) 2013 Rod Vagg, MIT License */\n\nfunction AbstractIterator (db) {\n  this.db = db\n  this._ended = false\n  this._nexting = false\n}\n\nAbstractIterator.prototype.next = function (callback) {\n  var self = this\n\n  if (typeof callback != \'function\')\n    throw new Error(\'next() requires a callback argument\')\n\n  if (self._ended)\n    return callback(new Error(\'cannot call next() after end()\'))\n  if (self._nexting)\n    return callback(new Error(\'cannot call next() before previous next() has completed\'))\n\n  self._nexting = true\n  if (typeof self._next == \'function\') {\n    return self._next(function () {\n      self._nexting = false\n      callback.apply(null, arguments)\n    })\n  }\n\n  process.nextTick(function () {\n    self._nexting = false\n    callback()\n  })\n}\n\nAbstractIterator.prototype.end = function (callback) {\n  if (typeof callback != \'function\')\n    throw new Error(\'end() requires a callback argument\')\n\n  if (this._ended)\n    return callback(new Error(\'end() already called on iterator\'))\n\n  this._ended = true\n\n  if (typeof this._end == \'function\')\n    return this._end(callback)\n\n  process.nextTick(callback)\n}\n\nmodule.exports = AbstractIterator\n\n})(require("__browserify_process"))\n},{"__browserify_process":13}],63:[function(require,module,exports){\n(function(process){/* Copyright (c) 2013 Rod Vagg, MIT License */\n\nfunction AbstractChainedBatch (db) {\n  this._db         = db\n  this._operations = []\n  this._written    = false\n}\n\nAbstractChainedBatch.prototype._checkWritten = function () {\n  if (this._written)\n    throw new Error(\'write() already called on this batch\')\n}\n\nAbstractChainedBatch.prototype.put = function (key, value) {\n  this._checkWritten()\n\n  var err = this._db._checkKeyValue(key, \'key\', this._db._isBuffer)\n  if (err) throw err\n  err = this._db._checkKeyValue(value, \'value\', this._db._isBuffer)\n  if (err) throw err\n\n  if (!this._db._isBuffer(key)) key = String(key)\n  if (!this._db._isBuffer(value)) value = String(value)\n\n  if (typeof this._put == \'function\' )\n    this._put(key, value)\n  else\n    this._operations.push({ type: \'put\', key: key, value: value })\n\n  return this\n}\n\nAbstractChainedBatch.prototype.del = function (key) {\n  this._checkWritten()\n\n  var err = this._db._checkKeyValue(key, \'key\', this._db._isBuffer)\n  if (err) throw err\n\n  if (!this._db._isBuffer(key)) key = String(key)\n\n  if (typeof this._del == \'function\' )\n    this._del(key)\n  else\n    this._operations.push({ type: \'del\', key: key })\n\n  return this\n}\n\nAbstractChainedBatch.prototype.clear = function () {\n  this._checkWritten()\n\n  this._operations = []\n\n  if (typeof this._clear == \'function\' )\n    this._clear()\n\n  return this\n}\n\nAbstractChainedBatch.prototype.write = function (options, callback) {\n  this._checkWritten()\n\n  if (typeof options == \'function\')\n    callback = options\n  if (typeof callback != \'function\')\n    throw new Error(\'write() requires a callback argument\')\n  if (typeof options != \'object\')\n    options = {}\n\n  this._written = true\n\n  if (typeof this._write == \'function\' )\n    return this._write(callback)\n\n  if (typeof this._db._batch == \'function\')\n    return this._db._batch(this._operations, options, callback)\n\n  process.nextTick(callback)\n}\n\nmodule.exports = AbstractChainedBatch\n})(require("__browserify_process"))\n},{"__browserify_process":13}],64:[function(require,module,exports){\nmodule.exports = hasKeys\n\nfunction hasKeys(source) {\n    return source !== null &&\n        (typeof source === "object" ||\n        typeof source === "function")\n}\n\n},{}],65:[function(require,module,exports){\nexports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {\n  var e, m,\n      eLen = nBytes * 8 - mLen - 1,\n      eMax = (1 << eLen) - 1,\n      eBias = eMax >> 1,\n      nBits = -7,\n      i = isBE ? 0 : (nBytes - 1),\n      d = isBE ? 1 : -1,\n      s = buffer[offset + i];\n\n  i += d;\n\n  e = s & ((1 << (-nBits)) - 1);\n  s >>= (-nBits);\n  nBits += eLen;\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);\n\n  m = e & ((1 << (-nBits)) - 1);\n  e >>= (-nBits);\n  nBits += mLen;\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);\n\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity);\n  } else {\n    m = m + Math.pow(2, mLen);\n    e = e - eBias;\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n};\n\nexports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {\n  var e, m, c,\n      eLen = nBytes * 8 - mLen - 1,\n      eMax = (1 << eLen) - 1,\n      eBias = eMax >> 1,\n      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),\n      i = isBE ? (nBytes - 1) : 0,\n      d = isBE ? -1 : 1,\n      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;\n\n  value = Math.abs(value);\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0;\n    e = eMax;\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2);\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * Math.pow(2, 1 - eBias);\n    }\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n      e = 0;\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);\n\n  e = (e << mLen) | m;\n  eLen += mLen;\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);\n\n  buffer[offset + i - d] |= s * 128;\n};\n\n},{}],61:[function(require,module,exports){\n\n//force to a valid range\nvar range = exports.range = function (obj) {\n  return null == obj ? {} : \'string\' === typeof range ? {\n      min: range, max: range + \'\\xff\'\n    } :  obj\n}\n\n//turn into a sub range.\nvar prefix = exports.prefix = function (range, within, term) {\n  range = exports.range(range)\n  var _range = {}\n  term = term || \'\\xff\'\n  if(range instanceof RegExp || \'function\' == typeof range) {\n    _range.min = within\n    _range.max   = within + term,\n    _range.inner = function (k) {\n      var j = k.substring(within.length)\n      if(range.test)\n        return range.test(j)\n      return range(j)\n    }\n  }\n  else if(\'object\' === typeof range) {\n    _range.min = within + (range.min || range.start || \'\')\n    _range.max = within + (range.max || range.end   || (term || \'~\'))\n    _range.reverse = !!range.reverse\n  }\n  return _range\n}\n\n//return a function that checks a range\nvar checker = exports.checker = function (range) {\n  if(!range) range = {}\n\n  if (\'string\' === typeof range)\n    return function (key) {\n      return key.indexOf(range) == 0\n    }\n  else if(range instanceof RegExp)\n    return function (key) {\n      return range.test(key)\n    }\n  else if(\'object\' === typeof range)\n    return function (key) {\n      var min = range.min || range.start\n      var max = range.max || range.end\n\n      // fixes keys passed as ints from sublevels\n      key = String(key)\n\n      return (\n        !min || key >= min\n      ) && (\n        !max || key <= max\n      ) && (\n        !range.inner || (\n          range.inner.test \n            ? range.inner.test(key)\n            : range.inner(key)\n        )\n      )\n    }\n  else if(\'function\' === typeof range)\n    return range\n}\n//check if a key is within a range.\nvar satifies = exports.satisfies = function (key, range) {\n  return checker(range)(key)\n}\n\n\n\n},{}],28:[function(require,module,exports){\n(function(process,Buffer){/* Copyright (c) 2013 Rod Vagg, MIT License */\n\nvar xtend                = require(\'xtend\')\n  , AbstractIterator     = require(\'./abstract-iterator\')\n  , AbstractChainedBatch = require(\'./abstract-chained-batch\')\n\nfunction AbstractLevelDOWN (location) {\n  if (!arguments.length || location === undefined)\n    throw new Error(\'constructor requires at least a location argument\')\n\n  if (typeof location != \'string\')\n    throw new Error(\'constructor requires a location string argument\')\n\n  this.location = location\n}\n\nAbstractLevelDOWN.prototype.open = function (options, callback) {\n  if (typeof options == \'function\')\n    callback = options\n\n  if (typeof callback != \'function\')\n    throw new Error(\'open() requires a callback argument\')\n\n  if (typeof options != \'object\')\n    options = {}\n\n  if (typeof this._open == \'function\')\n    return this._open(options, callback)\n\n  process.nextTick(callback)\n}\n\nAbstractLevelDOWN.prototype.close = function (callback) {\n  if (typeof callback != \'function\')\n    throw new Error(\'close() requires a callback argument\')\n\n  if (typeof this._close == \'function\')\n    return this._close(callback)\n\n  process.nextTick(callback)\n}\n\nAbstractLevelDOWN.prototype.get = function (key, options, callback) {\n  var err\n\n  if (typeof options == \'function\')\n    callback = options\n\n  if (typeof callback != \'function\')\n    throw new Error(\'get() requires a callback argument\')\n\n  if (err = this._checkKeyValue(key, \'key\', this._isBuffer))\n    return callback(err)\n\n  if (!this._isBuffer(key))\n    key = String(key)\n\n  if (typeof options != \'object\')\n    options = {}\n\n  if (typeof this._get == \'function\')\n    return this._get(key, options, callback)\n\n  process.nextTick(function () { callback(new Error(\'NotFound\')) })\n}\n\nAbstractLevelDOWN.prototype.put = function (key, value, options, callback) {\n  var err\n\n  if (typeof options == \'function\')\n    callback = options\n\n  if (typeof callback != \'function\')\n    throw new Error(\'put() requires a callback argument\')\n\n  if (err = this._checkKeyValue(key, \'key\', this._isBuffer))\n    return callback(err)\n\n  if (err = this._checkKeyValue(value, \'value\', this._isBuffer))\n    return callback(err)\n\n  if (!this._isBuffer(key))\n    key = String(key)\n\n  // coerce value to string in node, don\'t touch it in browser\n  // (indexeddb can store any JS type)\n  if (!this._isBuffer(value) && !process.browser)\n    value = String(value)\n\n  if (typeof options != \'object\')\n    options = {}\n\n  if (typeof this._put == \'function\')\n    return this._put(key, value, options, callback)\n\n  process.nextTick(callback)\n}\n\nAbstractLevelDOWN.prototype.del = function (key, options, callback) {\n  var err\n\n  if (typeof options == \'function\')\n    callback = options\n\n  if (typeof callback != \'function\')\n    throw new Error(\'del() requires a callback argument\')\n\n  if (err = this._checkKeyValue(key, \'key\', this._isBuffer))\n    return callback(err)\n\n  if (!this._isBuffer(key))\n    key = String(key)\n\n  if (typeof options != \'object\')\n    options = {}\n\n  if (typeof this._del == \'function\')\n    return this._del(key, options, callback)\n\n  process.nextTick(callback)\n}\n\nAbstractLevelDOWN.prototype.batch = function (array, options, callback) {\n  if (!arguments.length)\n    return this._chainedBatch()\n\n  if (typeof options == \'function\')\n    callback = options\n\n  if (typeof callback != \'function\')\n    throw new Error(\'batch(array) requires a callback argument\')\n\n  if (!Array.isArray(array))\n    return callback(new Error(\'batch(array) requires an array argument\'))\n\n  if (typeof options != \'object\')\n    options = {}\n\n  var i = 0\n    , l = array.length\n    , e\n    , err\n\n  for (; i < l; i++) {\n    e = array[i]\n    if (typeof e != \'object\')\n      continue\n\n    if (err = this._checkKeyValue(e.type, \'type\', this._isBuffer))\n      return callback(err)\n\n    if (err = this._checkKeyValue(e.key, \'key\', this._isBuffer))\n      return callback(err)\n\n    if (e.type == \'put\') {\n      if (err = this._checkKeyValue(e.value, \'value\', this._isBuffer))\n        return callback(err)\n    }\n  }\n\n  if (typeof this._batch == \'function\')\n    return this._batch(array, options, callback)\n\n  process.nextTick(callback)\n}\n\n//TODO: remove from here, not a necessary primitive\nAbstractLevelDOWN.prototype.approximateSize = function (start, end, callback) {\n  if (   start == null\n      || end == null\n      || typeof start == \'function\'\n      || typeof end == \'function\') {\n    throw new Error(\'approximateSize() requires valid `start`, `end` and `callback` arguments\')\n  }\n\n  if (typeof callback != \'function\')\n    throw new Error(\'approximateSize() requires a callback argument\')\n\n  if (!this._isBuffer(start))\n    start = String(start)\n\n  if (!this._isBuffer(end))\n    end = String(end)\n\n  if (typeof this._approximateSize == \'function\')\n    return this._approximateSize(start, end, callback)\n\n  process.nextTick(function () {\n    callback(null, 0)\n  })\n}\n\nAbstractLevelDOWN.prototype._setupIteratorOptions = function (options) {\n  var self = this\n\n  options = xtend(options)\n\n  ;[ \'start\', \'end\', \'gt\', \'gte\', \'lt\', \'lte\' ].forEach(function (o) {\n    if (options[o] && self._isBuffer(options[o]) && options[o].length === 0)\n      delete options[o]\n  })\n\n  options.reverse = !!options.reverse\n\n  // fix `start` so it takes into account gt, gte, lt, lte as appropriate\n  if (options.reverse && options.lt)\n    options.start = options.lt\n  if (options.reverse && options.lte)\n    options.start = options.lte\n  if (!options.reverse && options.gt)\n    options.start = options.gt\n  if (!options.reverse && options.gte)\n    options.start = options.gte\n\n  if ((options.reverse && options.lt && !options.lte)\n    || (!options.reverse && options.gt && !options.gte))\n    options.exclusiveStart = true // start should *not* include matching key\n\n  return options\n}\n\nAbstractLevelDOWN.prototype.iterator = function (options) {\n  if (typeof options != \'object\')\n    options = {}\n\n  options = this._setupIteratorOptions(options)\n\n  if (typeof this._iterator == \'function\')\n    return this._iterator(options)\n\n  return new AbstractIterator(this)\n}\n\nAbstractLevelDOWN.prototype._chainedBatch = function () {\n  return new AbstractChainedBatch(this)\n}\n\nAbstractLevelDOWN.prototype._isBuffer = function (obj) {\n  return Buffer.isBuffer(obj)\n}\n\nAbstractLevelDOWN.prototype._checkKeyValue = function (obj, type) {\n  if (obj === null || obj === undefined)\n    return new Error(type + \' cannot be `null` or `undefined`\')\n\n  if (obj === null || obj === undefined)\n    return new Error(type + \' cannot be `null` or `undefined`\')\n\n  if (this._isBuffer(obj)) {\n    if (obj.length === 0)\n      return new Error(type + \' cannot be an empty Buffer\')\n  } else if (String(obj) === \'\')\n    return new Error(type + \' cannot be an empty String\')\n}\n\nmodule.exports.AbstractLevelDOWN    = AbstractLevelDOWN\nmodule.exports.AbstractIterator     = AbstractIterator\nmodule.exports.AbstractChainedBatch = AbstractChainedBatch\n\n})(require("__browserify_process"),require("__browserify_buffer").Buffer)\n},{"./abstract-chained-batch":63,"./abstract-iterator":62,"__browserify_buffer":12,"__browserify_process":13,"xtend":66}],36:[function(require,module,exports){\n/* Copyright (c) 2012-2013 LevelUP contributors\n * See list at <https://github.com/rvagg/node-levelup#contributing>\n * MIT +no-false-attribs License\n * <https://github.com/rvagg/node-levelup/blob/master/LICENSE>\n */\n\nvar createError   = require(\'errno\').create\n  , LevelUPError  = createError(\'LevelUPError\')\n  , NotFoundError = createError(\'NotFoundError\', LevelUPError)\n\nNotFoundError.prototype.notFound = true\nNotFoundError.prototype.status   = 404\n\nmodule.exports = {\n    LevelUPError        : LevelUPError\n  , InitializationError : createError(\'InitializationError\', LevelUPError)\n  , OpenError           : createError(\'OpenError\', LevelUPError)\n  , ReadError           : createError(\'ReadError\', LevelUPError)\n  , WriteError          : createError(\'WriteError\', LevelUPError)\n  , NotFoundError       : NotFoundError\n  , EncodingError       : createError(\'EncodingError\', LevelUPError)\n}\n},{"errno":67}],37:[function(require,module,exports){\nvar Keys = require("object-keys")\nvar hasKeys = require("./has-keys")\n\nmodule.exports = extend\n\nfunction extend() {\n    var target = {}\n\n    for (var i = 0; i < arguments.length; i++) {\n        var source = arguments[i]\n\n        if (!hasKeys(source)) {\n            continue\n        }\n\n        var keys = Keys(source)\n\n        for (var j = 0; j < keys.length; j++) {\n            var name = keys[j]\n            target[name] = source[name]\n        }\n    }\n\n    return target\n}\n\n},{"./has-keys":64,"object-keys":68}],43:[function(require,module,exports){\n(function(){var assert = require(\'assert\');\nexports.Buffer = Buffer;\nexports.SlowBuffer = Buffer;\nBuffer.poolSize = 8192;\nexports.INSPECT_MAX_BYTES = 50;\n\nfunction Buffer(subject, encoding, offset) {\n  if (!(this instanceof Buffer)) {\n    return new Buffer(subject, encoding, offset);\n  }\n  this.parent = this;\n  this.offset = 0;\n\n  var type;\n\n  // Are we slicing?\n  if (typeof offset === \'number\') {\n    this.length = coerce(encoding);\n    this.offset = offset;\n  } else {\n    // Find the length\n    switch (type = typeof subject) {\n      case \'number\':\n        this.length = coerce(subject);\n        break;\n\n      case \'string\':\n        this.length = Buffer.byteLength(subject, encoding);\n        break;\n\n      case \'object\': // Assume object is an array\n        this.length = coerce(subject.length);\n        break;\n\n      default:\n        throw new Error(\'First argument needs to be a number, \' +\n                        \'array or string.\');\n    }\n\n    // Treat array-ish objects as a byte array.\n    if (isArrayIsh(subject)) {\n      for (var i = 0; i < this.length; i++) {\n        if (subject instanceof Buffer) {\n          this[i] = subject.readUInt8(i);\n        }\n        else {\n          this[i] = subject[i];\n        }\n      }\n    } else if (type == \'string\') {\n      // We are a string\n      this.length = this.write(subject, 0, encoding);\n    } else if (type === \'number\') {\n      for (var i = 0; i < this.length; i++) {\n        this[i] = 0;\n      }\n    }\n  }\n}\n\nBuffer.prototype.get = function get(i) {\n  if (i < 0 || i >= this.length) throw new Error(\'oob\');\n  return this[i];\n};\n\nBuffer.prototype.set = function set(i, v) {\n  if (i < 0 || i >= this.length) throw new Error(\'oob\');\n  return this[i] = v;\n};\n\nBuffer.byteLength = function (str, encoding) {\n  switch (encoding || "utf8") {\n    case \'hex\':\n      return str.length / 2;\n\n    case \'utf8\':\n    case \'utf-8\':\n      return utf8ToBytes(str).length;\n\n    case \'ascii\':\n    case \'binary\':\n      return str.length;\n\n    case \'base64\':\n      return base64ToBytes(str).length;\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n};\n\nBuffer.prototype.utf8Write = function (string, offset, length) {\n  var bytes, pos;\n  return Buffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);\n};\n\nBuffer.prototype.asciiWrite = function (string, offset, length) {\n  var bytes, pos;\n  return Buffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);\n};\n\nBuffer.prototype.binaryWrite = Buffer.prototype.asciiWrite;\n\nBuffer.prototype.base64Write = function (string, offset, length) {\n  var bytes, pos;\n  return Buffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);\n};\n\nBuffer.prototype.base64Slice = function (start, end) {\n  var bytes = Array.prototype.slice.apply(this, arguments)\n  return require("base64-js").fromByteArray(bytes);\n};\n\nBuffer.prototype.utf8Slice = function () {\n  var bytes = Array.prototype.slice.apply(this, arguments);\n  var res = "";\n  var tmp = "";\n  var i = 0;\n  while (i < bytes.length) {\n    if (bytes[i] <= 0x7F) {\n      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);\n      tmp = "";\n    } else\n      tmp += "%" + bytes[i].toString(16);\n\n    i++;\n  }\n\n  return res + decodeUtf8Char(tmp);\n}\n\nBuffer.prototype.asciiSlice = function () {\n  var bytes = Array.prototype.slice.apply(this, arguments);\n  var ret = "";\n  for (var i = 0; i < bytes.length; i++)\n    ret += String.fromCharCode(bytes[i]);\n  return ret;\n}\n\nBuffer.prototype.binarySlice = Buffer.prototype.asciiSlice;\n\nBuffer.prototype.inspect = function() {\n  var out = [],\n      len = this.length;\n  for (var i = 0; i < len; i++) {\n    out[i] = toHex(this[i]);\n    if (i == exports.INSPECT_MAX_BYTES) {\n      out[i + 1] = \'...\';\n      break;\n    }\n  }\n  return \'<Buffer \' + out.join(\' \') + \'>\';\n};\n\n\nBuffer.prototype.hexSlice = function(start, end) {\n  var len = this.length;\n\n  if (!start || start < 0) start = 0;\n  if (!end || end < 0 || end > len) end = len;\n\n  var out = \'\';\n  for (var i = start; i < end; i++) {\n    out += toHex(this[i]);\n  }\n  return out;\n};\n\n\nBuffer.prototype.toString = function(encoding, start, end) {\n  encoding = String(encoding || \'utf8\').toLowerCase();\n  start = +start || 0;\n  if (typeof end == \'undefined\') end = this.length;\n\n  // Fastpath empty strings\n  if (+end == start) {\n    return \'\';\n  }\n\n  switch (encoding) {\n    case \'hex\':\n      return this.hexSlice(start, end);\n\n    case \'utf8\':\n    case \'utf-8\':\n      return this.utf8Slice(start, end);\n\n    case \'ascii\':\n      return this.asciiSlice(start, end);\n\n    case \'binary\':\n      return this.binarySlice(start, end);\n\n    case \'base64\':\n      return this.base64Slice(start, end);\n\n    case \'ucs2\':\n    case \'ucs-2\':\n      return this.ucs2Slice(start, end);\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n};\n\n\nBuffer.prototype.hexWrite = function(string, offset, length) {\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length;\n  if (strLen % 2) {\n    throw new Error(\'Invalid hex string\');\n  }\n  if (length > strLen / 2) {\n    length = strLen / 2;\n  }\n  for (var i = 0; i < length; i++) {\n    var byte = parseInt(string.substr(i * 2, 2), 16);\n    if (isNaN(byte)) throw new Error(\'Invalid hex string\');\n    this[offset + i] = byte;\n  }\n  Buffer._charsWritten = i * 2;\n  return i;\n};\n\n\nBuffer.prototype.write = function(string, offset, length, encoding) {\n  // Support both (string, offset, length, encoding)\n  // and the legacy (string, encoding, offset, length)\n  if (isFinite(offset)) {\n    if (!isFinite(length)) {\n      encoding = length;\n      length = undefined;\n    }\n  } else {  // legacy\n    var swap = encoding;\n    encoding = offset;\n    offset = length;\n    length = swap;\n  }\n\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n  encoding = String(encoding || \'utf8\').toLowerCase();\n\n  switch (encoding) {\n    case \'hex\':\n      return this.hexWrite(string, offset, length);\n\n    case \'utf8\':\n    case \'utf-8\':\n      return this.utf8Write(string, offset, length);\n\n    case \'ascii\':\n      return this.asciiWrite(string, offset, length);\n\n    case \'binary\':\n      return this.binaryWrite(string, offset, length);\n\n    case \'base64\':\n      return this.base64Write(string, offset, length);\n\n    case \'ucs2\':\n    case \'ucs-2\':\n      return this.ucs2Write(string, offset, length);\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n};\n\n\n// slice(start, end)\nBuffer.prototype.slice = function(start, end) {\n  if (end === undefined) end = this.length;\n\n  if (end > this.length) {\n    throw new Error(\'oob\');\n  }\n  if (start > end) {\n    throw new Error(\'oob\');\n  }\n\n  return new Buffer(this, end - start, +start);\n};\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function(target, target_start, start, end) {\n  var source = this;\n  start || (start = 0);\n  if (end === undefined || isNaN(end)) {\n    end = this.length;\n  }\n  target_start || (target_start = 0);\n\n  if (end < start) throw new Error(\'sourceEnd < sourceStart\');\n\n  // Copy 0 bytes; we\'re done\n  if (end === start) return 0;\n  if (target.length == 0 || source.length == 0) return 0;\n\n  if (target_start < 0 || target_start >= target.length) {\n    throw new Error(\'targetStart out of bounds\');\n  }\n\n  if (start < 0 || start >= source.length) {\n    throw new Error(\'sourceStart out of bounds\');\n  }\n\n  if (end < 0 || end > source.length) {\n    throw new Error(\'sourceEnd out of bounds\');\n  }\n\n  // Are we oob?\n  if (end > this.length) {\n    end = this.length;\n  }\n\n  if (target.length - target_start < end - start) {\n    end = target.length - target_start + start;\n  }\n\n  var temp = [];\n  for (var i=start; i<end; i++) {\n    assert.ok(typeof this[i] !== \'undefined\', "copying undefined buffer bytes!");\n    temp.push(this[i]);\n  }\n\n  for (var i=target_start; i<target_start+temp.length; i++) {\n    target[i] = temp[i-target_start];\n  }\n};\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function fill(value, start, end) {\n  value || (value = 0);\n  start || (start = 0);\n  end || (end = this.length);\n\n  if (typeof value === \'string\') {\n    value = value.charCodeAt(0);\n  }\n  if (!(typeof value === \'number\') || isNaN(value)) {\n    throw new Error(\'value is not a number\');\n  }\n\n  if (end < start) throw new Error(\'end < start\');\n\n  // Fill 0 bytes; we\'re done\n  if (end === start) return 0;\n  if (this.length == 0) return 0;\n\n  if (start < 0 || start >= this.length) {\n    throw new Error(\'start out of bounds\');\n  }\n\n  if (end < 0 || end > this.length) {\n    throw new Error(\'end out of bounds\');\n  }\n\n  for (var i = start; i < end; i++) {\n    this[i] = value;\n  }\n}\n\n// Static methods\nBuffer.isBuffer = function isBuffer(b) {\n  return b instanceof Buffer || b instanceof Buffer;\n};\n\nBuffer.concat = function (list, totalLength) {\n  if (!isArray(list)) {\n    throw new Error("Usage: Buffer.concat(list, [totalLength])\\n \\\n      list should be an Array.");\n  }\n\n  if (list.length === 0) {\n    return new Buffer(0);\n  } else if (list.length === 1) {\n    return list[0];\n  }\n\n  if (typeof totalLength !== \'number\') {\n    totalLength = 0;\n    for (var i = 0; i < list.length; i++) {\n      var buf = list[i];\n      totalLength += buf.length;\n    }\n  }\n\n  var buffer = new Buffer(totalLength);\n  var pos = 0;\n  for (var i = 0; i < list.length; i++) {\n    var buf = list[i];\n    buf.copy(buffer, pos);\n    pos += buf.length;\n  }\n  return buffer;\n};\n\n// helpers\n\nfunction coerce(length) {\n  // Coerce length to a number (possibly NaN), round up\n  // in case it\'s fractional (e.g. 123.456) then do a\n  // double negate to coerce a NaN to 0. Easy, right?\n  length = ~~Math.ceil(+length);\n  return length < 0 ? 0 : length;\n}\n\nfunction isArray(subject) {\n  return (Array.isArray ||\n    function(subject){\n      return {}.toString.apply(subject) == \'[object Array]\'\n    })\n    (subject)\n}\n\nfunction isArrayIsh(subject) {\n  return isArray(subject) || Buffer.isBuffer(subject) ||\n         subject && typeof subject === \'object\' &&\n         typeof subject.length === \'number\';\n}\n\nfunction toHex(n) {\n  if (n < 16) return \'0\' + n.toString(16);\n  return n.toString(16);\n}\n\nfunction utf8ToBytes(str) {\n  var byteArray = [];\n  for (var i = 0; i < str.length; i++)\n    if (str.charCodeAt(i) <= 0x7F)\n      byteArray.push(str.charCodeAt(i));\n    else {\n      var h = encodeURIComponent(str.charAt(i)).substr(1).split(\'%\');\n      for (var j = 0; j < h.length; j++)\n        byteArray.push(parseInt(h[j], 16));\n    }\n\n  return byteArray;\n}\n\nfunction asciiToBytes(str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++ )\n    // Node\'s code seems to be doing this and not & 0x7F..\n    byteArray.push( str.charCodeAt(i) & 0xFF );\n\n  return byteArray;\n}\n\nfunction base64ToBytes(str) {\n  return require("base64-js").toByteArray(str);\n}\n\nfunction blitBuffer(src, dst, offset, length) {\n  var pos, i = 0;\n  while (i < length) {\n    if ((i+offset >= dst.length) || (i >= src.length))\n      break;\n\n    dst[i + offset] = src[i];\n    i++;\n  }\n  return i;\n}\n\nfunction decodeUtf8Char(str) {\n  try {\n    return decodeURIComponent(str);\n  } catch (err) {\n    return String.fromCharCode(0xFFFD); // UTF 8 invalid char\n  }\n}\n\n// read/write bit-twiddling\n\nBuffer.prototype.readUInt8 = function(offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  if (offset >= buffer.length) return;\n\n  return buffer[offset];\n};\n\nfunction readUInt16(buffer, offset, isBigEndian, noAssert) {\n  var val = 0;\n\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 1 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  if (offset >= buffer.length) return 0;\n\n  if (isBigEndian) {\n    val = buffer[offset] << 8;\n    if (offset + 1 < buffer.length) {\n      val |= buffer[offset + 1];\n    }\n  } else {\n    val = buffer[offset];\n    if (offset + 1 < buffer.length) {\n      val |= buffer[offset + 1] << 8;\n    }\n  }\n\n  return val;\n}\n\nBuffer.prototype.readUInt16LE = function(offset, noAssert) {\n  return readUInt16(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readUInt16BE = function(offset, noAssert) {\n  return readUInt16(this, offset, true, noAssert);\n};\n\nfunction readUInt32(buffer, offset, isBigEndian, noAssert) {\n  var val = 0;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  if (offset >= buffer.length) return 0;\n\n  if (isBigEndian) {\n    if (offset + 1 < buffer.length)\n      val = buffer[offset + 1] << 16;\n    if (offset + 2 < buffer.length)\n      val |= buffer[offset + 2] << 8;\n    if (offset + 3 < buffer.length)\n      val |= buffer[offset + 3];\n    val = val + (buffer[offset] << 24 >>> 0);\n  } else {\n    if (offset + 2 < buffer.length)\n      val = buffer[offset + 2] << 16;\n    if (offset + 1 < buffer.length)\n      val |= buffer[offset + 1] << 8;\n    val |= buffer[offset];\n    if (offset + 3 < buffer.length)\n      val = val + (buffer[offset + 3] << 24 >>> 0);\n  }\n\n  return val;\n}\n\nBuffer.prototype.readUInt32LE = function(offset, noAssert) {\n  return readUInt32(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readUInt32BE = function(offset, noAssert) {\n  return readUInt32(this, offset, true, noAssert);\n};\n\n\n/*\n * Signed integer types, yay team! A reminder on how two\'s complement actually\n * works. The first bit is the signed bit, i.e. tells us whether or not the\n * number should be positive or negative. If the two\'s complement value is\n * positive, then we\'re done, as it\'s equivalent to the unsigned representation.\n *\n * Now if the number is positive, you\'re pretty much done, you can just leverage\n * the unsigned translations and return those. Unfortunately, negative numbers\n * aren\'t quite that straightforward.\n *\n * At first glance, one might be inclined to use the traditional formula to\n * translate binary numbers between the positive and negative values in two\'s\n * complement. (Though it doesn\'t quite work for the most negative value)\n * Mainly:\n *  - invert all the bits\n *  - add one to the result\n *\n * Of course, this doesn\'t quite work in Javascript. Take for example the value\n * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of\n * course, Javascript will do the following:\n *\n * > ~0xff80\n * -65409\n *\n * Whoh there, Javascript, that\'s not quite right. But wait, according to\n * Javascript that\'s perfectly correct. When Javascript ends up seeing the\n * constant 0xff80, it has no notion that it is actually a signed number. It\n * assumes that we\'ve input the unsigned value 0xff80. Thus, when it does the\n * binary negation, it casts it into a signed value, (positive 0xff80). Then\n * when you perform binary negation on that, it turns it into a negative number.\n *\n * Instead, we\'re going to have to use the following general formula, that works\n * in a rather Javascript friendly way. I\'m glad we don\'t support this kind of\n * weird numbering scheme in the kernel.\n *\n * (BIT-MAX - (unsigned)val + 1) * -1\n *\n * The astute observer, may think that this doesn\'t make sense for 8-bit numbers\n * (really it isn\'t necessary for them). However, when you get 16-bit numbers,\n * you do. Let\'s go back to our prior example and see how this will look:\n *\n * (0xffff - 0xff80 + 1) * -1\n * (0x007f + 1) * -1\n * (0x0080) * -1\n */\nBuffer.prototype.readInt8 = function(offset, noAssert) {\n  var buffer = this;\n  var neg;\n\n  if (!noAssert) {\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  if (offset >= buffer.length) return;\n\n  neg = buffer[offset] & 0x80;\n  if (!neg) {\n    return (buffer[offset]);\n  }\n\n  return ((0xff - buffer[offset] + 1) * -1);\n};\n\nfunction readInt16(buffer, offset, isBigEndian, noAssert) {\n  var neg, val;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 1 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  val = readUInt16(buffer, offset, isBigEndian, noAssert);\n  neg = val & 0x8000;\n  if (!neg) {\n    return val;\n  }\n\n  return (0xffff - val + 1) * -1;\n}\n\nBuffer.prototype.readInt16LE = function(offset, noAssert) {\n  return readInt16(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readInt16BE = function(offset, noAssert) {\n  return readInt16(this, offset, true, noAssert);\n};\n\nfunction readInt32(buffer, offset, isBigEndian, noAssert) {\n  var neg, val;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  val = readUInt32(buffer, offset, isBigEndian, noAssert);\n  neg = val & 0x80000000;\n  if (!neg) {\n    return (val);\n  }\n\n  return (0xffffffff - val + 1) * -1;\n}\n\nBuffer.prototype.readInt32LE = function(offset, noAssert) {\n  return readInt32(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readInt32BE = function(offset, noAssert) {\n  return readInt32(this, offset, true, noAssert);\n};\n\nfunction readFloat(buffer, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  return require(\'./buffer_ieee754\').readIEEE754(buffer, offset, isBigEndian,\n      23, 4);\n}\n\nBuffer.prototype.readFloatLE = function(offset, noAssert) {\n  return readFloat(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readFloatBE = function(offset, noAssert) {\n  return readFloat(this, offset, true, noAssert);\n};\n\nfunction readDouble(buffer, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset + 7 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  return require(\'./buffer_ieee754\').readIEEE754(buffer, offset, isBigEndian,\n      52, 8);\n}\n\nBuffer.prototype.readDoubleLE = function(offset, noAssert) {\n  return readDouble(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readDoubleBE = function(offset, noAssert) {\n  return readDouble(this, offset, true, noAssert);\n};\n\n\n/*\n * We have to make sure that the value is a valid integer. This means that it is\n * non-negative. It has no fractional component and that it does not exceed the\n * maximum allowed value.\n *\n *      value           The number to check for validity\n *\n *      max             The maximum value\n */\nfunction verifuint(value, max) {\n  assert.ok(typeof (value) == \'number\',\n      \'cannot write a non-number as a number\');\n\n  assert.ok(value >= 0,\n      \'specified a negative value for writing an unsigned value\');\n\n  assert.ok(value <= max, \'value is larger than maximum value for type\');\n\n  assert.ok(Math.floor(value) === value, \'value has a fractional component\');\n}\n\nBuffer.prototype.writeUInt8 = function(value, offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset < buffer.length,\n        \'trying to write beyond buffer length\');\n\n    verifuint(value, 0xff);\n  }\n\n  if (offset < buffer.length) {\n    buffer[offset] = value;\n  }\n};\n\nfunction writeUInt16(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 1 < buffer.length,\n        \'trying to write beyond buffer length\');\n\n    verifuint(value, 0xffff);\n  }\n\n  for (var i = 0; i < Math.min(buffer.length - offset, 2); i++) {\n    buffer[offset + i] =\n        (value & (0xff << (8 * (isBigEndian ? 1 - i : i)))) >>>\n            (isBigEndian ? 1 - i : i) * 8;\n  }\n\n}\n\nBuffer.prototype.writeUInt16LE = function(value, offset, noAssert) {\n  writeUInt16(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeUInt16BE = function(value, offset, noAssert) {\n  writeUInt16(this, value, offset, true, noAssert);\n};\n\nfunction writeUInt32(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'trying to write beyond buffer length\');\n\n    verifuint(value, 0xffffffff);\n  }\n\n  for (var i = 0; i < Math.min(buffer.length - offset, 4); i++) {\n    buffer[offset + i] =\n        (value >>> (isBigEndian ? 3 - i : i) * 8) & 0xff;\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function(value, offset, noAssert) {\n  writeUInt32(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeUInt32BE = function(value, offset, noAssert) {\n  writeUInt32(this, value, offset, true, noAssert);\n};\n\n\n/*\n * We now move onto our friends in the signed number category. Unlike unsigned\n * numbers, we\'re going to have to worry a bit more about how we put values into\n * arrays. Since we are only worrying about signed 32-bit values, we\'re in\n * slightly better shape. Unfortunately, we really can\'t do our favorite binary\n * & in this system. It really seems to do the wrong thing. For example:\n *\n * > -32 & 0xff\n * 224\n *\n * What\'s happening above is really: 0xe0 & 0xff = 0xe0. However, the results of\n * this aren\'t treated as a signed number. Ultimately a bad thing.\n *\n * What we\'re going to want to do is basically create the unsigned equivalent of\n * our representation and pass that off to the wuint* functions. To do that\n * we\'re going to do the following:\n *\n *  - if the value is positive\n *      we can pass it directly off to the equivalent wuint\n *  - if the value is negative\n *      we do the following computation:\n *         mb + val + 1, where\n *         mb   is the maximum unsigned value in that byte size\n *         val  is the Javascript negative integer\n *\n *\n * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If\n * you do out the computations:\n *\n * 0xffff - 128 + 1\n * 0xffff - 127\n * 0xff80\n *\n * You can then encode this value as the signed version. This is really rather\n * hacky, but it should work and get the job done which is our goal here.\n */\n\n/*\n * A series of checks to make sure we actually have a signed 32-bit number\n */\nfunction verifsint(value, max, min) {\n  assert.ok(typeof (value) == \'number\',\n      \'cannot write a non-number as a number\');\n\n  assert.ok(value <= max, \'value larger than maximum allowed value\');\n\n  assert.ok(value >= min, \'value smaller than minimum allowed value\');\n\n  assert.ok(Math.floor(value) === value, \'value has a fractional component\');\n}\n\nfunction verifIEEE754(value, max, min) {\n  assert.ok(typeof (value) == \'number\',\n      \'cannot write a non-number as a number\');\n\n  assert.ok(value <= max, \'value larger than maximum allowed value\');\n\n  assert.ok(value >= min, \'value smaller than minimum allowed value\');\n}\n\nBuffer.prototype.writeInt8 = function(value, offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifsint(value, 0x7f, -0x80);\n  }\n\n  if (value >= 0) {\n    buffer.writeUInt8(value, offset, noAssert);\n  } else {\n    buffer.writeUInt8(0xff + value + 1, offset, noAssert);\n  }\n};\n\nfunction writeInt16(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 1 < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifsint(value, 0x7fff, -0x8000);\n  }\n\n  if (value >= 0) {\n    writeUInt16(buffer, value, offset, isBigEndian, noAssert);\n  } else {\n    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);\n  }\n}\n\nBuffer.prototype.writeInt16LE = function(value, offset, noAssert) {\n  writeInt16(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeInt16BE = function(value, offset, noAssert) {\n  writeInt16(this, value, offset, true, noAssert);\n};\n\nfunction writeInt32(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifsint(value, 0x7fffffff, -0x80000000);\n  }\n\n  if (value >= 0) {\n    writeUInt32(buffer, value, offset, isBigEndian, noAssert);\n  } else {\n    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);\n  }\n}\n\nBuffer.prototype.writeInt32LE = function(value, offset, noAssert) {\n  writeInt32(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeInt32BE = function(value, offset, noAssert) {\n  writeInt32(this, value, offset, true, noAssert);\n};\n\nfunction writeFloat(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);\n  }\n\n  require(\'./buffer_ieee754\').writeIEEE754(buffer, value, offset, isBigEndian,\n      23, 4);\n}\n\nBuffer.prototype.writeFloatLE = function(value, offset, noAssert) {\n  writeFloat(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeFloatBE = function(value, offset, noAssert) {\n  writeFloat(this, value, offset, true, noAssert);\n};\n\nfunction writeDouble(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 7 < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);\n  }\n\n  require(\'./buffer_ieee754\').writeIEEE754(buffer, value, offset, isBigEndian,\n      52, 8);\n}\n\nBuffer.prototype.writeDoubleLE = function(value, offset, noAssert) {\n  writeDouble(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeDoubleBE = function(value, offset, noAssert) {\n  writeDouble(this, value, offset, true, noAssert);\n};\n\n})()\n},{"./buffer_ieee754":65,"assert":59,"base64-js":69}],44:[function(require,module,exports){\n/*\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined\n * in FIPS PUB 180-1\n * Version 2.1a Copyright Paul Johnston 2000 - 2002.\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for details.\n */\n\nvar helpers = require(\'./helpers\');\n\n/*\n * Calculate the SHA-1 of an array of big-endian words, and a bit length\n */\nfunction core_sha1(x, len)\n{\n  /* append padding */\n  x[len >> 5] |= 0x80 << (24 - len % 32);\n  x[((len + 64 >> 9) << 4) + 15] = len;\n\n  var w = Array(80);\n  var a =  1732584193;\n  var b = -271733879;\n  var c = -1732584194;\n  var d =  271733878;\n  var e = -1009589776;\n\n  for(var i = 0; i < x.length; i += 16)\n  {\n    var olda = a;\n    var oldb = b;\n    var oldc = c;\n    var oldd = d;\n    var olde = e;\n\n    for(var j = 0; j < 80; j++)\n    {\n      if(j < 16) w[j] = x[i + j];\n      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);\n      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),\n                       safe_add(safe_add(e, w[j]), sha1_kt(j)));\n      e = d;\n      d = c;\n      c = rol(b, 30);\n      b = a;\n      a = t;\n    }\n\n    a = safe_add(a, olda);\n    b = safe_add(b, oldb);\n    c = safe_add(c, oldc);\n    d = safe_add(d, oldd);\n    e = safe_add(e, olde);\n  }\n  return Array(a, b, c, d, e);\n\n}\n\n/*\n * Perform the appropriate triplet combination function for the current\n * iteration\n */\nfunction sha1_ft(t, b, c, d)\n{\n  if(t < 20) return (b & c) | ((~b) & d);\n  if(t < 40) return b ^ c ^ d;\n  if(t < 60) return (b & c) | (b & d) | (c & d);\n  return b ^ c ^ d;\n}\n\n/*\n * Determine the appropriate additive constant for the current iteration\n */\nfunction sha1_kt(t)\n{\n  return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :\n         (t < 60) ? -1894007588 : -899497514;\n}\n\n/*\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n * to work around bugs in some JS interpreters.\n */\nfunction safe_add(x, y)\n{\n  var lsw = (x & 0xFFFF) + (y & 0xFFFF);\n  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  return (msw << 16) | (lsw & 0xFFFF);\n}\n\n/*\n * Bitwise rotate a 32-bit number to the left.\n */\nfunction rol(num, cnt)\n{\n  return (num << cnt) | (num >>> (32 - cnt));\n}\n\nmodule.exports = function sha1(buf) {\n  return helpers.hash(buf, core_sha1, 20, true);\n};\n\n},{"./helpers":70}],45:[function(require,module,exports){\n\n/**\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined\n * in FIPS 180-2\n * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n *\n */\n\nvar helpers = require(\'./helpers\');\n\nvar safe_add = function(x, y) {\n  var lsw = (x & 0xFFFF) + (y & 0xFFFF);\n  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  return (msw << 16) | (lsw & 0xFFFF);\n};\n\nvar S = function(X, n) {\n  return (X >>> n) | (X << (32 - n));\n};\n\nvar R = function(X, n) {\n  return (X >>> n);\n};\n\nvar Ch = function(x, y, z) {\n  return ((x & y) ^ ((~x) & z));\n};\n\nvar Maj = function(x, y, z) {\n  return ((x & y) ^ (x & z) ^ (y & z));\n};\n\nvar Sigma0256 = function(x) {\n  return (S(x, 2) ^ S(x, 13) ^ S(x, 22));\n};\n\nvar Sigma1256 = function(x) {\n  return (S(x, 6) ^ S(x, 11) ^ S(x, 25));\n};\n\nvar Gamma0256 = function(x) {\n  return (S(x, 7) ^ S(x, 18) ^ R(x, 3));\n};\n\nvar Gamma1256 = function(x) {\n  return (S(x, 17) ^ S(x, 19) ^ R(x, 10));\n};\n\nvar core_sha256 = function(m, l) {\n  var K = new Array(0x428A2F98,0x71374491,0xB5C0FBCF,0xE9B5DBA5,0x3956C25B,0x59F111F1,0x923F82A4,0xAB1C5ED5,0xD807AA98,0x12835B01,0x243185BE,0x550C7DC3,0x72BE5D74,0x80DEB1FE,0x9BDC06A7,0xC19BF174,0xE49B69C1,0xEFBE4786,0xFC19DC6,0x240CA1CC,0x2DE92C6F,0x4A7484AA,0x5CB0A9DC,0x76F988DA,0x983E5152,0xA831C66D,0xB00327C8,0xBF597FC7,0xC6E00BF3,0xD5A79147,0x6CA6351,0x14292967,0x27B70A85,0x2E1B2138,0x4D2C6DFC,0x53380D13,0x650A7354,0x766A0ABB,0x81C2C92E,0x92722C85,0xA2BFE8A1,0xA81A664B,0xC24B8B70,0xC76C51A3,0xD192E819,0xD6990624,0xF40E3585,0x106AA070,0x19A4C116,0x1E376C08,0x2748774C,0x34B0BCB5,0x391C0CB3,0x4ED8AA4A,0x5B9CCA4F,0x682E6FF3,0x748F82EE,0x78A5636F,0x84C87814,0x8CC70208,0x90BEFFFA,0xA4506CEB,0xBEF9A3F7,0xC67178F2);\n  var HASH = new Array(0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A, 0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19);\n    var W = new Array(64);\n    var a, b, c, d, e, f, g, h, i, j;\n    var T1, T2;\n  /* append padding */\n  m[l >> 5] |= 0x80 << (24 - l % 32);\n  m[((l + 64 >> 9) << 4) + 15] = l;\n  for (var i = 0; i < m.length; i += 16) {\n    a = HASH[0]; b = HASH[1]; c = HASH[2]; d = HASH[3]; e = HASH[4]; f = HASH[5]; g = HASH[6]; h = HASH[7];\n    for (var j = 0; j < 64; j++) {\n      if (j < 16) {\n        W[j] = m[j + i];\n      } else {\n        W[j] = safe_add(safe_add(safe_add(Gamma1256(W[j - 2]), W[j - 7]), Gamma0256(W[j - 15])), W[j - 16]);\n      }\n      T1 = safe_add(safe_add(safe_add(safe_add(h, Sigma1256(e)), Ch(e, f, g)), K[j]), W[j]);\n      T2 = safe_add(Sigma0256(a), Maj(a, b, c));\n      h = g; g = f; f = e; e = safe_add(d, T1); d = c; c = b; b = a; a = safe_add(T1, T2);\n    }\n    HASH[0] = safe_add(a, HASH[0]); HASH[1] = safe_add(b, HASH[1]); HASH[2] = safe_add(c, HASH[2]); HASH[3] = safe_add(d, HASH[3]);\n    HASH[4] = safe_add(e, HASH[4]); HASH[5] = safe_add(f, HASH[5]); HASH[6] = safe_add(g, HASH[6]); HASH[7] = safe_add(h, HASH[7]);\n  }\n  return HASH;\n};\n\nmodule.exports = function sha256(buf) {\n  return helpers.hash(buf, core_sha256, 32, true);\n};\n\n},{"./helpers":70}],47:[function(require,module,exports){\n/*\r\n * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\r\n * Digest Algorithm, as defined in RFC 1321.\r\n * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.\r\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\r\n * Distributed under the BSD License\r\n * See http://pajhome.org.uk/crypt/md5 for more info.\r\n */\r\n\r\nvar helpers = require(\'./helpers\');\r\n\r\n/*\r\n * Perform a simple self-test to see if the VM is working\r\n */\r\nfunction md5_vm_test()\r\n{\r\n  return hex_md5("abc") == "900150983cd24fb0d6963f7d28e17f72";\r\n}\r\n\r\n/*\r\n * Calculate the MD5 of an array of little-endian words, and a bit length\r\n */\r\nfunction core_md5(x, len)\r\n{\r\n  /* append padding */\r\n  x[len >> 5] |= 0x80 << ((len) % 32);\r\n  x[(((len + 64) >>> 9) << 4) + 14] = len;\r\n\r\n  var a =  1732584193;\r\n  var b = -271733879;\r\n  var c = -1732584194;\r\n  var d =  271733878;\r\n\r\n  for(var i = 0; i < x.length; i += 16)\r\n  {\r\n    var olda = a;\r\n    var oldb = b;\r\n    var oldc = c;\r\n    var oldd = d;\r\n\r\n    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);\r\n    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);\r\n    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);\r\n    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);\r\n    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);\r\n    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);\r\n    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);\r\n    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);\r\n    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);\r\n    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);\r\n    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);\r\n    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);\r\n    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);\r\n    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);\r\n    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);\r\n    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);\r\n\r\n    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);\r\n    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);\r\n    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);\r\n    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);\r\n    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);\r\n    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);\r\n    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);\r\n    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);\r\n    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);\r\n    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);\r\n    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);\r\n    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);\r\n    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);\r\n    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);\r\n    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);\r\n    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);\r\n\r\n    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);\r\n    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);\r\n    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);\r\n    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);\r\n    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);\r\n    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);\r\n    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);\r\n    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);\r\n    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);\r\n    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);\r\n    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);\r\n    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);\r\n    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);\r\n    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);\r\n    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);\r\n    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);\r\n\r\n    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);\r\n    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);\r\n    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);\r\n    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);\r\n    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);\r\n    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);\r\n    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);\r\n    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);\r\n    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);\r\n    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);\r\n    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);\r\n    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);\r\n    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);\r\n    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);\r\n    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);\r\n    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);\r\n\r\n    a = safe_add(a, olda);\r\n    b = safe_add(b, oldb);\r\n    c = safe_add(c, oldc);\r\n    d = safe_add(d, oldd);\r\n  }\r\n  return Array(a, b, c, d);\r\n\r\n}\r\n\r\n/*\r\n * These functions implement the four basic operations the algorithm uses.\r\n */\r\nfunction md5_cmn(q, a, b, x, s, t)\r\n{\r\n  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);\r\n}\r\nfunction md5_ff(a, b, c, d, x, s, t)\r\n{\r\n  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);\r\n}\r\nfunction md5_gg(a, b, c, d, x, s, t)\r\n{\r\n  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);\r\n}\r\nfunction md5_hh(a, b, c, d, x, s, t)\r\n{\r\n  return md5_cmn(b ^ c ^ d, a, b, x, s, t);\r\n}\r\nfunction md5_ii(a, b, c, d, x, s, t)\r\n{\r\n  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);\r\n}\r\n\r\n/*\r\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\r\n * to work around bugs in some JS interpreters.\r\n */\r\nfunction safe_add(x, y)\r\n{\r\n  var lsw = (x & 0xFFFF) + (y & 0xFFFF);\r\n  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\r\n  return (msw << 16) | (lsw & 0xFFFF);\r\n}\r\n\r\n/*\r\n * Bitwise rotate a 32-bit number to the left.\r\n */\r\nfunction bit_rol(num, cnt)\r\n{\r\n  return (num << cnt) | (num >>> (32 - cnt));\r\n}\r\n\r\nmodule.exports = function md5(buf) {\r\n  return helpers.hash(buf, core_md5, 16);\r\n};\r\n\n},{"./helpers":70}],30:[function(require,module,exports){\nvar clone = require(\'clone\')\n\nmodule.exports = \nfunction fixRange(opts) {\n  opts = clone(opts)\n\n  var reverse = opts.reverse\n  var end     = opts.max || opts.end\n  var start   = opts.min || opts.start\n\n  var range = [start, end]\n  if(start != null && end != null)\n    range.sort()\n  if(reverse)\n    range = range.reverse()\n\n  opts.start   = range[0]\n  opts.end     = range[1]\n\n  delete opts.min\n  delete opts.max\n\n  return opts\n}\n\n},{"clone":71}],38:[function(require,module,exports){\n/* Copyright (c) 2012-2013 LevelUP contributors\n * See list at <https://github.com/rvagg/node-levelup#contributing>\n * MIT +no-false-attribs License <https://github.com/rvagg/node-levelup/blob/master/LICENSE>\n */\n\n// NOTE: we are fixed to readable-stream@1.0.x for now\n// for pure Streams2 across Node versions\nvar Readable      = require(\'readable-stream\').Readable\n  , inherits      = require(\'util\').inherits\n  , extend        = require(\'xtend\')\n  , EncodingError = require(\'./errors\').EncodingError\n  , util          = require(\'./util\')\n\n  , defaultOptions = { keys: true, values: true }\n\n  , makeKeyValueData = function (key, value) {\n      return {\n          key: util.decodeKey(key, this._options)\n        , value: util.decodeValue(value, this._options)\n      }\n    }\n  , makeKeyData = function (key) {\n      return util.decodeKey(key, this._options)\n    }\n  , makeValueData = function (_, value) {\n      return util.decodeValue(value, this._options)\n    }\n  , makeNoData = function () { return null }\n\nfunction ReadStream (options, db, iteratorFactory) {\n  if (!(this instanceof ReadStream))\n    return new ReadStream(options, db, iteratorFactory)\n\n  Readable.call(this, { objectMode: true, highWaterMark: options.highWaterMark })\n\n  // purely to keep `db` around until we\'re done so it\'s not GCed if the user doesn\'t keep a ref\n  this._db = db\n\n  options = this._options = extend(defaultOptions, options)\n\n  this._keyEncoding   = options.keyEncoding   || options.encoding\n  this._valueEncoding = options.valueEncoding || options.encoding\n\n  if (typeof this._options.start != \'undefined\')\n    this._options.start = util.encodeKey(this._options.start, this._options)\n  if (typeof this._options.end != \'undefined\')\n    this._options.end = util.encodeKey(this._options.end, this._options)\n  if (typeof this._options.limit != \'number\')\n    this._options.limit = -1\n\n  this._options.keyAsBuffer   = util.isKeyAsBuffer(this._options)\n\n  this._options.valueAsBuffer = util.isValueAsBuffer(this._options)\n\n  this._makeData = this._options.keys && this._options.values\n    ? makeKeyValueData : this._options.keys\n      ? makeKeyData : this._options.values\n        ? makeValueData : makeNoData\n\n  var self = this\n  if (!this._db.isOpen()) {\n    this._db.once(\'ready\', function () {\n      self._iterator = iteratorFactory(self._options)\n    })\n  } else\n    this._iterator = iteratorFactory(this._options)\n}\n\ninherits(ReadStream, Readable)\n\nReadStream.prototype._read = function read () {\n  var self = this\n  if (!self._db.isOpen()) {\n    return self._db.once(\'ready\', function () { read.call(self) })\n  }\n  if (self._destroyed)\n    return\n \n  self._iterator.next(function(err, key, value) {\n    if (err || (key === undefined && value === undefined)) {\n      if (!err && !self._destroyed)\n        self.push(null)\n      return self._cleanup(err)\n    }\n\n    try {\n      value = self._makeData(key, value)\n    } catch (e) {\n      return self._cleanup(new EncodingError(e))\n    }\n    if (!self._destroyed)\n      self.push(value)\n  })\n}\n\nReadStream.prototype._cleanup = function (err) {\n  if (this._destroyed)\n    return\n\n  this._destroyed = true\n\n  var self = this\n  if (err)\n    self.emit(\'error\', err)\n\n  self._iterator.end(function () {\n    self._iterator = null\n    self.emit(\'close\')\n  })\n}\n\nReadStream.prototype.destroy = function () {\n  this._cleanup()\n}\n\nReadStream.prototype.toString = function () {\n  return \'LevelUP.ReadStream\'\n}\n\nmodule.exports = ReadStream\n\n},{"./errors":36,"./util":35,"readable-stream":72,"util":22,"xtend":42}],39:[function(require,module,exports){\n(function(process){/* Copyright (c) 2012-2013 LevelUP contributors\n * See list at <https://github.com/rvagg/node-levelup#contributing>\n * MIT +no-false-attribs License\n * <https://github.com/rvagg/node-levelup/blob/master/LICENSE>\n */\n\nvar Stream       = require(\'stream\').Stream\n  , inherits     = require(\'util\').inherits\n  , extend       = require(\'xtend\')\n  , concatStream = require(\'concat-stream\')\n\n  , setImmediate = process.nextTick\n\n  , getOptions   = require(\'./util\').getOptions\n\n  , defaultOptions = { type: \'put\' }\n\nfunction WriteStream (options, db) {\n  if (!(this instanceof WriteStream))\n    return new WriteStream(options, db)\n\n  Stream.call(this)\n  this._options = extend(defaultOptions, getOptions(db, options))\n  this._db      = db\n  this._buffer  = []\n  this._status  = \'init\'\n  this._end     = false\n  this.writable = true\n  this.readable = false\n\n  var self = this\n    , ready = function () {\n        if (!self.writable)\n          return\n        self._status = \'ready\'\n        self.emit(\'ready\')\n        self._process()\n      }\n\n  if (db.isOpen())\n    setImmediate(ready)\n  else\n    db.once(\'ready\', ready)\n}\n\ninherits(WriteStream, Stream)\n\nWriteStream.prototype.write = function (data) {\n  if (!this.writable)\n    return false\n  this._buffer.push(data)\n  if (this._status != \'init\')\n    this._processDelayed()\n  if (this._options.maxBufferLength &&\n      this._buffer.length > this._options.maxBufferLength) {\n    this._writeBlock = true\n    return false\n  }\n  return true\n}\n\nWriteStream.prototype.end = function (data) {\n  var self = this\n  if (data)\n    this.write(data)\n  setImmediate(function () {\n    self._end = true\n    self._process()\n  })\n}\n\nWriteStream.prototype.destroy = function () {\n  this.writable = false\n  this.end()\n}\n\nWriteStream.prototype.destroySoon = function () {\n  this.end()\n}\n\nWriteStream.prototype.add = function (entry) {\n  if (!entry.props)\n    return\n  if (entry.props.Directory)\n    entry.pipe(this._db.writeStream(this._options))\n  else if (entry.props.File || entry.File || entry.type == \'File\')\n    this._write(entry)\n  return true\n}\n\nWriteStream.prototype._processDelayed = function () {\n  var self = this\n  setImmediate(function () {\n    self._process()\n  })\n}\n\nWriteStream.prototype._process = function () {\n  var buffer\n    , self = this\n\n    , cb = function (err) {\n        if (!self.writable)\n          return\n        if (self._status != \'closed\')\n          self._status = \'ready\'\n        if (err) {\n          self.writable = false\n          return self.emit(\'error\', err)\n        }\n        self._process()\n      }\n\n  if (self._status != \'ready\' && self.writable) {\n    if (self._buffer.length && self._status != \'closed\')\n      self._processDelayed()\n    return\n  }\n\n  if (self._buffer.length && self.writable) {\n    self._status = \'writing\'\n    buffer       = self._buffer\n    self._buffer = []\n\n    self._db.batch(buffer.map(function (d) {\n      return {\n          type          : d.type || self._options.type\n        , key           : d.key\n        , value         : d.value\n        , keyEncoding   : d.keyEncoding || self._options.keyEncoding\n        , valueEncoding : d.valueEncoding\n            || d.encoding\n            || self._options.valueEncoding\n      }\n    }), cb)\n\n    if (self._writeBlock) {\n      self._writeBlock = false\n      self.emit(\'drain\')\n    }\n\n    // don\'t allow close until callback has returned\n    return\n  }\n\n  if (self._end && self._status != \'closed\') {\n    self._status  = \'closed\'\n    self.writable = false\n    self.emit(\'close\')\n  }\n}\n\nWriteStream.prototype._write = function (entry) {\n  var key = entry.path || entry.props.path\n    , self = this\n\n  if (!key)\n    return\n\n  entry.pipe(concatStream(function (err, data) {\n    if (err) {\n      self.writable = false\n      return self.emit(\'error\', err)\n    }\n\n    if (self._options.fstreamRoot &&\n        key.indexOf(self._options.fstreamRoot) > -1)\n      key = key.substr(self._options.fstreamRoot.length + 1)\n\n    self.write({ key: key, value: data })\n  }))\n}\n\nWriteStream.prototype.toString = function () {\n  return \'LevelUP.WriteStream\'\n}\n\nmodule.exports = WriteStream\n\n})(require("__browserify_process"))\n},{"./util":35,"__browserify_process":13,"concat-stream":73,"stream":32,"util":22,"xtend":42}],35:[function(require,module,exports){\n/* Copyright (c) 2012-2013 LevelUP contributors\n * See list at <https://github.com/rvagg/node-levelup#contributing>\n * MIT +no-false-attribs License\n * <https://github.com/rvagg/node-levelup/blob/master/LICENSE>\n */\n\nvar extend        = require(\'xtend\')\n  , LevelUPError  = require(\'./errors\').LevelUPError\n  , bops          = require(\'bops\')\n\n  , encodingNames = [\n        \'hex\'\n      , \'utf8\'\n      , \'utf-8\'\n      , \'ascii\'\n      , \'binary\'\n      , \'base64\'\n      , \'ucs2\'\n      , \'ucs-2\'\n      , \'utf16le\'\n      , \'utf-16le\'\n    ]\n\n  , defaultOptions = {\n        createIfMissing : true\n      , errorIfExists   : false\n      , keyEncoding     : \'utf8\'\n      , valueEncoding   : \'utf8\'\n      , compression     : true\n    }\n\n  , leveldown\n\n  , encodings = (function () {\n      function isBinary (data) {\n        return data === undefined || data === null || bops.is(data)\n      }\n\n      var encodings = {}\n      encodings.utf8 = encodings[\'utf-8\'] = {\n          encode : function (data) {\n            return isBinary(data) ? data : String(data)\n          }\n        , decode : function (data) { return data }\n        , buffer : false\n        , type   : \'utf8\'\n      }\n      encodings.json = {\n          encode : JSON.stringify\n        , decode : JSON.parse\n        , buffer : false\n        , type   : \'json\'\n      }\n      encodingNames.forEach(function (type) {\n        if (encodings[type])\n          return\n        encodings[type] = {\n            encode : function (data) {\n              return isBinary(data) ? data : bops.from(data, type)\n            }\n          , decode : function (buffer) {\n              return bops.from(buffer, type)\n            }\n          , buffer : true\n          , type   : type // useful for debugging purposes\n        }\n      })\n      return encodings\n    })()\n\n  , encodingOpts = (function () {\n      var eo = {}\n      encodingNames.forEach(function (e) {\n        eo[e] = { valueEncoding : e }\n      })\n      return eo\n    }())\n\nfunction copy (srcdb, dstdb, callback) {\n  srcdb.readStream()\n    .pipe(dstdb.writeStream())\n    .on(\'close\', callback ? callback : function () {})\n    .on(\'error\', callback ? callback : function (err) { throw err })\n}\n\nfunction getOptions (levelup, options) {\n  var s = typeof options == \'string\' // just an encoding\n  if (!s && options && options.encoding && !options.valueEncoding)\n    options.valueEncoding = options.encoding\n  return extend(\n      (levelup && levelup.options) || {}\n    , s ? encodingOpts[options] || encodingOpts[defaultOptions.valueEncoding]\n        : options\n  )\n}\n\nfunction getLevelDOWN () {\n  if (leveldown)\n    return leveldown\n\n  var requiredVersion       = require(\'../package.json\').devDependencies.leveldown\n    , missingLevelDOWNError = \'Could not locate LevelDOWN, try `npm install leveldown`\'\n    , leveldownVersion\n\n  try {\n    leveldownVersion = require(\'leveldown/package\').version\n  } catch (e) {\n    throw new LevelUPError(missingLevelDOWNError)\n  }\n\n  if (!require(\'semver\').satisfies(leveldownVersion, requiredVersion)) {\n    throw new LevelUPError(\n        \'Installed version of LevelDOWN (\'\n      + leveldownVersion\n      + \') does not match required version (\'\n      + requiredVersion\n      + \')\'\n    )\n  }\n\n  try {\n    return leveldown = require(\'leveldown\')\n  } catch (e) {\n    throw new LevelUPError(missingLevelDOWNError)\n  }\n}\n\nfunction dispatchError (levelup, error, callback) {\n  return typeof callback == \'function\'\n    ? callback(error)\n    : levelup.emit(\'error\', error)\n}\n\nfunction getKeyEncoder (options, op) {\n  var type = ((op && op.keyEncoding) || options.keyEncoding) || \'utf8\'\n  return encodings[type] || type\n}\n\nfunction getValueEncoder (options, op) {\n  var type = (((op && (op.valueEncoding || op.encoding))\n      || options.valueEncoding || options.encoding)) || \'utf8\'\n  return encodings[type] || type\n}\n\nfunction encodeKey (key, options, op) {\n  return getKeyEncoder(options, op).encode(key)\n}\n\nfunction encodeValue (value, options, op) {\n  return getValueEncoder(options, op).encode(value)\n}\n\nfunction decodeKey (key, options) {\n  return getKeyEncoder(options).decode(key)\n}\n\nfunction decodeValue (value, options) {\n  return getValueEncoder(options).decode(value)\n}\n\nfunction isValueAsBuffer (options, op) {\n  return getValueEncoder(options, op).buffer\n}\n\nfunction isKeyAsBuffer (options, op) {\n  return getKeyEncoder(options, op).buffer\n}\n\nmodule.exports = {\n    defaultOptions  : defaultOptions\n  , copy            : copy\n  , getOptions      : getOptions\n  , getLevelDOWN    : getLevelDOWN\n  , dispatchError   : dispatchError\n  , encodeKey       : encodeKey\n  , encodeValue     : encodeValue\n  , isValueAsBuffer : isValueAsBuffer\n  , isKeyAsBuffer   : isKeyAsBuffer\n  , decodeValue     : decodeValue\n  , decodeKey       : decodeKey\n}\n\n},{"../package.json":58,"./errors":36,"bops":74,"leveldown":57,"leveldown/package":57,"semver":57,"xtend":42}],54:[function(require,module,exports){\nmodule.exports = {\n    readUInt8:      read_uint8\n  , readInt8:       read_int8\n  , readUInt16LE:   read_uint16_le\n  , readUInt32LE:   read_uint32_le\n  , readInt16LE:    read_int16_le\n  , readInt32LE:    read_int32_le\n  , readFloatLE:    read_float_le\n  , readDoubleLE:   read_double_le\n  , readUInt16BE:   read_uint16_be\n  , readUInt32BE:   read_uint32_be\n  , readInt16BE:    read_int16_be\n  , readInt32BE:    read_int32_be\n  , readFloatBE:    read_float_be\n  , readDoubleBE:   read_double_be\n}\n\nvar map = require(\'./mapped.js\')\n\nfunction read_uint8(target, at) {\n  return target[at]\n}\n\nfunction read_int8(target, at) {\n  var v = target[at];\n  return v < 0x80 ? v : v - 0x100\n}\n\nfunction read_uint16_le(target, at) {\n  var dv = map.get(target);\n  return dv.getUint16(at + target.byteOffset, true)\n}\n\nfunction read_uint32_le(target, at) {\n  var dv = map.get(target);\n  return dv.getUint32(at + target.byteOffset, true)\n}\n\nfunction read_int16_le(target, at) {\n  var dv = map.get(target);\n  return dv.getInt16(at + target.byteOffset, true)\n}\n\nfunction read_int32_le(target, at) {\n  var dv = map.get(target);\n  return dv.getInt32(at + target.byteOffset, true)\n}\n\nfunction read_float_le(target, at) {\n  var dv = map.get(target);\n  return dv.getFloat32(at + target.byteOffset, true)\n}\n\nfunction read_double_le(target, at) {\n  var dv = map.get(target);\n  return dv.getFloat64(at + target.byteOffset, true)\n}\n\nfunction read_uint16_be(target, at) {\n  var dv = map.get(target);\n  return dv.getUint16(at + target.byteOffset, false)\n}\n\nfunction read_uint32_be(target, at) {\n  var dv = map.get(target);\n  return dv.getUint32(at + target.byteOffset, false)\n}\n\nfunction read_int16_be(target, at) {\n  var dv = map.get(target);\n  return dv.getInt16(at + target.byteOffset, false)\n}\n\nfunction read_int32_be(target, at) {\n  var dv = map.get(target);\n  return dv.getInt32(at + target.byteOffset, false)\n}\n\nfunction read_float_be(target, at) {\n  var dv = map.get(target);\n  return dv.getFloat32(at + target.byteOffset, false)\n}\n\nfunction read_double_be(target, at) {\n  var dv = map.get(target);\n  return dv.getFloat64(at + target.byteOffset, false)\n}\n\n},{"./mapped.js":75}],55:[function(require,module,exports){\nmodule.exports = {\n    writeUInt8:      write_uint8\n  , writeInt8:       write_int8\n  , writeUInt16LE:   write_uint16_le\n  , writeUInt32LE:   write_uint32_le\n  , writeInt16LE:    write_int16_le\n  , writeInt32LE:    write_int32_le\n  , writeFloatLE:    write_float_le\n  , writeDoubleLE:   write_double_le\n  , writeUInt16BE:   write_uint16_be\n  , writeUInt32BE:   write_uint32_be\n  , writeInt16BE:    write_int16_be\n  , writeInt32BE:    write_int32_be\n  , writeFloatBE:    write_float_be\n  , writeDoubleBE:   write_double_be\n}\n\nvar map = require(\'./mapped.js\')\n\nfunction write_uint8(target, value, at) {\n  return target[at] = value\n}\n\nfunction write_int8(target, value, at) {\n  return target[at] = value < 0 ? value + 0x100 : value\n}\n\nfunction write_uint16_le(target, value, at) {\n  var dv = map.get(target);\n  return dv.setUint16(at + target.byteOffset, value, true)\n}\n\nfunction write_uint32_le(target, value, at) {\n  var dv = map.get(target);\n  return dv.setUint32(at + target.byteOffset, value, true)\n}\n\nfunction write_int16_le(target, value, at) {\n  var dv = map.get(target);\n  return dv.setInt16(at + target.byteOffset, value, true)\n}\n\nfunction write_int32_le(target, value, at) {\n  var dv = map.get(target);\n  return dv.setInt32(at + target.byteOffset, value, true)\n}\n\nfunction write_float_le(target, value, at) {\n  var dv = map.get(target);\n  return dv.setFloat32(at + target.byteOffset, value, true)\n}\n\nfunction write_double_le(target, value, at) {\n  var dv = map.get(target);\n  return dv.setFloat64(at + target.byteOffset, value, true)\n}\n\nfunction write_uint16_be(target, value, at) {\n  var dv = map.get(target);\n  return dv.setUint16(at + target.byteOffset, value, false)\n}\n\nfunction write_uint32_be(target, value, at) {\n  var dv = map.get(target);\n  return dv.setUint32(at + target.byteOffset, value, false)\n}\n\nfunction write_int16_be(target, value, at) {\n  var dv = map.get(target);\n  return dv.setInt16(at + target.byteOffset, value, false)\n}\n\nfunction write_int32_be(target, value, at) {\n  var dv = map.get(target);\n  return dv.setInt32(at + target.byteOffset, value, false)\n}\n\nfunction write_float_be(target, value, at) {\n  var dv = map.get(target);\n  return dv.setFloat32(at + target.byteOffset, value, false)\n}\n\nfunction write_double_be(target, value, at) {\n  var dv = map.get(target);\n  return dv.setFloat64(at + target.byteOffset, value, false)\n}\n\n},{"./mapped.js":75}],76:[function(require,module,exports){\nmodule.exports = hasKeys\n\nfunction hasKeys(source) {\n    return source !== null &&\n        (typeof source === "object" ||\n        typeof source === "function")\n}\n\n},{}],69:[function(require,module,exports){\n(function (exports) {\n\t\'use strict\';\n\n\tvar lookup = \'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\';\n\n\tfunction b64ToByteArray(b64) {\n\t\tvar i, j, l, tmp, placeHolders, arr;\n\t\n\t\tif (b64.length % 4 > 0) {\n\t\t\tthrow \'Invalid string. Length must be a multiple of 4\';\n\t\t}\n\n\t\t// the number of equal signs (place holders)\n\t\t// if there are two placeholders, than the two characters before it\n\t\t// represent one byte\n\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t// this is just a cheap hack to not do indexOf twice\n\t\tplaceHolders = b64.indexOf(\'=\');\n\t\tplaceHolders = placeHolders > 0 ? b64.length - placeHolders : 0;\n\n\t\t// base64 is 4/3 + up to two characters of the original data\n\t\tarr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);\n\n\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length;\n\n\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);\n\t\t\tarr.push((tmp & 0xFF0000) >> 16);\n\t\t\tarr.push((tmp & 0xFF00) >> 8);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t}\n\n\t\tif (placeHolders === 2) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t} else if (placeHolders === 1) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);\n\t\t\tarr.push((tmp >> 8) & 0xFF);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t}\n\n\t\treturn arr;\n\t}\n\n\tfunction uint8ToBase64(uint8) {\n\t\tvar i,\n\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\toutput = "",\n\t\t\ttemp, length;\n\n\t\tfunction tripletToBase64 (num) {\n\t\t\treturn lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n\t\t};\n\n\t\t// go through the array every three bytes, we\'ll deal with trailing stuff later\n\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);\n\t\t\toutput += tripletToBase64(temp);\n\t\t}\n\n\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\tswitch (extraBytes) {\n\t\t\tcase 1:\n\t\t\t\ttemp = uint8[uint8.length - 1];\n\t\t\t\toutput += lookup[temp >> 2];\n\t\t\t\toutput += lookup[(temp << 4) & 0x3F];\n\t\t\t\toutput += \'==\';\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);\n\t\t\t\toutput += lookup[temp >> 10];\n\t\t\t\toutput += lookup[(temp >> 4) & 0x3F];\n\t\t\t\toutput += lookup[(temp << 2) & 0x3F];\n\t\t\t\toutput += \'=\';\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn output;\n\t}\n\n\tmodule.exports.toByteArray = b64ToByteArray;\n\tmodule.exports.fromByteArray = uint8ToBase64;\n}());\n\n},{}],70:[function(require,module,exports){\n(function(){var Buffer = require(\'buffer\').Buffer;\nvar intSize = 4;\nvar zeroBuffer = new Buffer(intSize); zeroBuffer.fill(0);\nvar chrsz = 8;\n\nfunction toArray(buf, bigEndian) {\n  if ((buf.length % intSize) !== 0) {\n    var len = buf.length + (intSize - (buf.length % intSize));\n    buf = Buffer.concat([buf, zeroBuffer], len);\n  }\n\n  var arr = [];\n  var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;\n  for (var i = 0; i < buf.length; i += intSize) {\n    arr.push(fn.call(buf, i));\n  }\n  return arr;\n}\n\nfunction toBuffer(arr, size, bigEndian) {\n  var buf = new Buffer(size);\n  var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;\n  for (var i = 0; i < arr.length; i++) {\n    fn.call(buf, arr[i], i * 4, true);\n  }\n  return buf;\n}\n\nfunction hash(buf, fn, hashSize, bigEndian) {\n  if (!Buffer.isBuffer(buf)) buf = new Buffer(buf);\n  var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);\n  return toBuffer(arr, hashSize, bigEndian);\n}\n\nmodule.exports = { hash: hash };\n\n})()\n},{"buffer":43}],71:[function(require,module,exports){\n(function(Buffer){"use strict";\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\nvar util = {\n  isArray: function (ar) {\n    return Array.isArray(ar) || (typeof ar === \'object\' && objectToString(ar) === \'[object Array]\');\n  },\n  isDate: function (d) {\n    return typeof d === \'object\' && objectToString(d) === \'[object Date]\';\n  },\n  isRegExp: function (re) {\n    return typeof re === \'object\' && objectToString(re) === \'[object RegExp]\';\n  },\n  getRegExpFlags: function (re) {\n    var flags = \'\';\n    re.global && (flags += \'g\');\n    re.ignoreCase && (flags += \'i\');\n    re.multiline && (flags += \'m\');\n    return flags;\n  }\n};\n\nif (typeof module === \'object\')\n  module.exports = clone;\n\n/**\n * Clones (copies) an Object using deep copying.\n *\n * This function supports circular references by default, but if you are certain\n * there are no circular references in your object, you can save some CPU time\n * by calling clone(obj, false).\n *\n * Caution: if `circular` is false and `parent` contains circular references,\n * your program may enter an infinite loop and crash.\n *\n * @param `parent` - the object to be cloned\n * @param `circular` - set to true if the object to be cloned may contain\n *    circular references. (optional - true by default)\n*/\nfunction clone(parent, circular) {\n  if (typeof circular == \'undefined\')\n    circular = true;\n\n  var useBuffer = typeof Buffer != \'undefined\';\n\n  var circularParent = {};\n  var circularResolved = {};\n  var circularReplace = [];\n\n  function _clone(parent, context, child, cIndex) {\n    var i; // Use local context within this function\n    // Deep clone all properties of parent into child\n    if (typeof parent == \'object\') {\n      if (parent == null)\n        return parent;\n      // Check for circular references\n      for(i in circularParent)\n        if (circularParent[i] === parent) {\n          // We found a circular reference\n          circularReplace.push({\'resolveTo\': i, \'child\': child, \'i\': cIndex});\n          return null; //Just return null for now...\n          // we will resolve circular references later\n        }\n\n      // Add to list of all parent objects\n      circularParent[context] = parent;\n      // Now continue cloning...\n      if (util.isArray(parent)) {\n        child = [];\n        for(i in parent)\n          child[i] = _clone(parent[i], context + \'[\' + i + \']\', child, i);\n      }\n      else if (util.isDate(parent))\n        child = new Date(parent.getTime());\n      else if (util.isRegExp(parent)) {\n        child = new RegExp(parent.source, util.getRegExpFlags(parent));\n        if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n      } else if (useBuffer && Buffer.isBuffer(parent))\n      {\n        child = new Buffer(parent.length);\n        parent.copy(child);\n      }\n      else {\n        child = {};\n\n        // Also copy prototype over to new cloned object\n        child.__proto__ = parent.__proto__;\n        for(i in parent)\n          child[i] = _clone(parent[i], context + \'[\' + i + \']\', child, i);\n      }\n\n      // Add to list of all cloned objects\n      circularResolved[context] = child;\n    }\n    else\n      child = parent; //Just a simple shallow copy will do\n    return child;\n  }\n\n  var i;\n  if (circular) {\n    var cloned = _clone(parent, \'*\');\n\n    // Now this object has been cloned. Let\'s check to see if there are any\n    // circular references for it\n    for(i in circularReplace) {\n      var c = circularReplace[i];\n      if (c && c.child && c.i in c.child) {\n        c.child[c.i] = circularResolved[c.resolveTo];\n      }\n    }\n    return cloned;\n  } else {\n    // Deep clone all properties of parent into child\n    var child;\n    if (typeof parent == \'object\') {\n      if (parent == null)\n        return parent;\n      if (parent.constructor.name === \'Array\') {\n        child = [];\n        for(i in parent)\n          child[i] = clone(parent[i], circular);\n      }\n      else if (util.isDate(parent))\n        child = new Date(parent.getTime() );\n      else if (util.isRegExp(parent)) {\n        child = new RegExp(parent.source, util.getRegExpFlags(parent));\n        if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n      } else {\n        child = {};\n        child.__proto__ = parent.__proto__;\n        for(i in parent)\n          child[i] = clone(parent[i], circular);\n      }\n    }\n    else\n      child = parent; // Just a simple shallow clone will do\n    return child;\n  }\n}\n\n/**\n * Simple flat clone using prototype, accepts only objects, usefull for property\n * override on FLAT configuration object (no nested props).\n *\n * USE WITH CAUTION! This may not behave as you wish if you do not know how this\n * works.\n */\nclone.clonePrototype = function(parent) {\n  if (parent === null)\n    return null;\n\n  var c = function () {};\n  c.prototype = parent;\n  return new c();\n};\n\n})(require("__browserify_buffer").Buffer)\n},{"__browserify_buffer":12}],41:[function(require,module,exports){\n(function(process){var util              = require(\'util\')\n  , bops              = require(\'bops\')\n  , AbstractLevelDOWN = require(\'abstract-leveldown\').AbstractLevelDOWN\n\nfunction DeferredLevelDOWN (location) {\n  AbstractLevelDOWN.call(this, typeof location == \'string\' ? location : \'\') // optional location, who cares?\n  this._db         = undefined\n  this._operations = []\n}\n\nutil.inherits(DeferredLevelDOWN, AbstractLevelDOWN)\n\n// called by LevelUP when we have a real DB to take its place\nDeferredLevelDOWN.prototype.setDb = function (db) {\n  this._db = db\n  this._operations.forEach(function (op) {\n    db[op.method].apply(db, op.args)\n  })\n}\n\nDeferredLevelDOWN.prototype._open = function (options, callback) {\n  return process.nextTick(callback)\n}\n\n// queue a new deferred operation\nDeferredLevelDOWN.prototype._operation = function (method, args) {\n  if (this._db)\n    return this._db[method].apply(this._db, args)\n  this._operations.push({ method: method, args: args })\n}\n\n// deferrables\n\'put get del batch approximateSize\'.split(\' \').forEach(function (m) {\n  DeferredLevelDOWN.prototype[\'_\' + m] = function () {\n    this._operation(m, arguments)\n  }\n})\n\nDeferredLevelDOWN.prototype._isBuffer = function (obj) {\n  return bops.is(obj)\n}\n\n// don\'t need to implement this as LevelUP\'s ReadStream checks for \'ready\' state\nDeferredLevelDOWN.prototype._iterator = function () {\n  throw new TypeError(\'not implemented\')\n}\n\nmodule.exports = DeferredLevelDOWN\n})(require("__browserify_process"))\n},{"__browserify_process":13,"abstract-leveldown":78,"bops":77,"util":22}],73:[function(require,module,exports){\n(function(Buffer){var stream = require(\'stream\')\nvar util = require(\'util\')\n\nfunction ConcatStream(cb) {\n  stream.Stream.call(this)\n  this.writable = true\n  if (cb) this.cb = cb\n  this.body = []\n  this.on(\'error\', function(err) {\n    if (this.cb) this.cb(err)\n  })\n}\n\nutil.inherits(ConcatStream, stream.Stream)\n\nConcatStream.prototype.write = function(chunk) {\n  this.body.push(chunk)\n}\n\nConcatStream.prototype.destroy = function() {}\n\nConcatStream.prototype.arrayConcat = function(arrs) {\n  if (arrs.length === 0) return []\n  if (arrs.length === 1) return arrs[0]\n  return arrs.reduce(function (a, b) { return a.concat(b) })\n}\n\nConcatStream.prototype.isArray = function(arr) {\n  return Array.isArray(arr)\n}\n\nConcatStream.prototype.getBody = function () {\n  if (this.body.length === 0) return\n  if (typeof(this.body[0]) === "string") return this.body.join(\'\')\n  if (this.isArray(this.body[0])) return this.arrayConcat(this.body)\n  if (typeof(Buffer) !== "undefined" && Buffer.isBuffer(this.body[0])) {\n    return Buffer.concat(this.body)\n  }\n  return this.body\n}\n\nConcatStream.prototype.end = function() {\n  if (this.cb) this.cb(false, this.getBody())\n}\n\nmodule.exports = function(cb) {\n  return new ConcatStream(cb)\n}\n\nmodule.exports.ConcatStream = ConcatStream\n\n})(require("__browserify_buffer").Buffer)\n},{"__browserify_buffer":12,"stream":32,"util":22}],75:[function(require,module,exports){\nvar proto\n  , map\n\nmodule.exports = proto = {}\n\nmap = typeof WeakMap === \'undefined\' ? null : new WeakMap\n\nproto.get = !map ? no_weakmap_get : get\n\nfunction no_weakmap_get(target) {\n  return new DataView(target.buffer, 0)\n}\n\nfunction get(target) {\n  var out = map.get(target.buffer)\n  if(!out) {\n    map.set(target.buffer, out = new DataView(target.buffer, 0))\n  }\n  return out\n}\n\n},{}],42:[function(require,module,exports){\nvar Keys = require("object-keys")\nvar hasKeys = require("./has-keys")\n\nmodule.exports = extend\n\nfunction extend() {\n    var target = {}\n\n    for (var i = 0; i < arguments.length; i++) {\n        var source = arguments[i]\n\n        if (!hasKeys(source)) {\n            continue\n        }\n\n        var keys = Keys(source)\n\n        for (var j = 0; j < keys.length; j++) {\n            var name = keys[j]\n            target[name] = source[name]\n        }\n    }\n\n    return target\n}\n\n},{"./has-keys":76,"object-keys":79}],31:[function(require,module,exports){\nvar ranges = require(\'string-range\')\n\nmodule.exports = function (db) {\n\n  if(db.hooks) {\n    return     \n  }\n\n  var posthooks = []\n  var prehooks  = []\n\n  function getPrefix (p) {\n    return p && (\n        \'string\' ===   typeof p        ? p\n      : \'string\' ===   typeof p.prefix ? p.prefix\n      : \'function\' === typeof p.prefix ? p.prefix()\n      :                                  \'\'\n      )\n  }\n\n  function getKeyEncoding (db) {\n    if(db && db._getKeyEncoding)\n      return db._getKeyEncoding(db)\n  }\n\n  function getValueEncoding (db) {\n    if(db && db._getValueEncoding)\n      return db._getValueEncoding(db)\n  }\n\n  function remover (array, item) {\n    return function () {\n      var i = array.indexOf(item)\n      if(!~i) return false        \n      array.splice(i, 1)\n      return true\n    }\n  }\n\n  db.hooks = {\n    post: function (prefix, hook) {\n      if(!hook) hook = prefix, prefix = \'\'\n      var h = {test: ranges.checker(prefix), hook: hook}\n      posthooks.push(h)\n      return remover(posthooks, h)\n    },\n    pre: function (prefix, hook) {\n      if(!hook) hook = prefix, prefix = \'\'\n      var h = {test: ranges.checker(prefix), hook: hook}\n      prehooks.push(h)\n      return remover(prehooks, h)\n    },\n    posthooks: posthooks,\n    prehooks: prehooks\n  }\n\n  //POST HOOKS\n\n  function each (e) {\n    if(e && e.type) {\n      posthooks.forEach(function (h) {\n        if(h.test(e.key)) h.hook(e)\n      })\n    }\n  }\n\n  db.on(\'put\', function (key, val) {\n    each({type: \'put\', key: key, value: val})\n  })\n  db.on(\'del\', function (key, val) {\n    each({type: \'del\', key: key, value: val})\n  })\n  db.on(\'batch\', function onBatch (ary) {\n    ary.forEach(each)\n  })\n\n  //PRE HOOKS\n\n  var put = db.put\n  var del = db.del\n  var batch = db.batch\n\n  function callHooks (isBatch, b, opts, cb) {\n    try {\n    b.forEach(function hook(e, i) {\n      prehooks.forEach(function (h) {\n        if(h.test(String(e.key))) {\n          //optimize this?\n          //maybe faster to not create a new object each time?\n          //have one object and expose scope to it?\n          var context = {\n            add: function (ch, db) {\n              if(typeof ch === \'undefined\') {\n                return this\n              }\n              if(ch === false)\n                return delete b[i]\n              var prefix = (\n                getPrefix(ch.prefix) || \n                getPrefix(db) || \n                h.prefix || \'\'\n              )  \n              //don\'t leave a circular json object there incase using multilevel.\n              if(prefix) ch.prefix = prefix\n              ch.key = prefix + ch.key\n              if(h.test(String(ch.key))) {\n                //this usually means a stack overflow.\n                throw new Error(\'prehook cannot insert into own range\')\n              }\n              var ke = ch.keyEncoding   || getKeyEncoding(ch.prefix)\n              var ve = ch.valueEncoding || getValueEncoding(ch.prefix)\n              if(ke) ch.keyEncoding = ke\n              if(ve) ch.valueEncoding = ve\n\n              b.push(ch)\n              hook(ch, b.length - 1)\n              return this\n            },\n            put: function (ch, db) {\n              if(\'object\' === typeof ch) ch.type = \'put\'\n              return this.add(ch, db)\n            },\n            del: function (ch, db) {\n              if(\'object\' === typeof ch) ch.type = \'del\'\n              return this.add(ch, db)\n            },\n            veto: function () {\n              return this.add(false)\n            }\n          }\n          h.hook.call(context, e, context.add, b)\n        }\n      })\n    })\n    } catch (err) {\n      return (cb || opts)(err)\n    }\n    b = b.filter(function (e) {\n      return e && e.type //filter out empty items\n    })\n\n    if(b.length == 1 && !isBatch) {\n      var change = b[0]\n      return change.type == \'put\' \n        ? put.call(db, change.key, change.value, opts, cb) \n        : del.call(db, change.key, opts, cb)  \n    }\n    return batch.call(db, b, opts, cb)\n  }\n\n  db.put = function (key, value, opts, cb ) {\n    var batch = [{key: key, value: value, type: \'put\'}]\n    return callHooks(false, batch, opts, cb)\n  }\n\n  db.del = function (key, opts, cb) {\n    var batch = [{key: key, type: \'del\'}]\n    return callHooks(false, batch, opts, cb)\n  }\n\n  db.batch = function (batch, opts, cb) {\n    return callHooks(true, batch, opts, cb)\n  }\n}\n\n},{"string-range":61}],80:[function(require,module,exports){\nmodule.exports = hasKeys\n\nfunction hasKeys(source) {\n    return source !== null &&\n        (typeof source === "object" ||\n        typeof source === "function")\n}\n\n},{}],72:[function(require,module,exports){\nexports = module.exports = require(\'./lib/_stream_readable.js\');\nexports.Readable = exports;\nexports.Writable = require(\'./lib/_stream_writable.js\');\nexports.Duplex = require(\'./lib/_stream_duplex.js\');\nexports.Transform = require(\'./lib/_stream_transform.js\');\nexports.PassThrough = require(\'./lib/_stream_passthrough.js\');\n\n},{"./lib/_stream_duplex.js":83,"./lib/_stream_passthrough.js":85,"./lib/_stream_readable.js":81,"./lib/_stream_transform.js":84,"./lib/_stream_writable.js":82}],74:[function(require,module,exports){\nvar proto = {}\nmodule.exports = proto\n\nproto.from = require(\'./from.js\')\nproto.to = require(\'./to.js\')\nproto.is = require(\'./is.js\')\nproto.subarray = require(\'./subarray.js\')\nproto.join = require(\'./join.js\')\nproto.copy = require(\'./copy.js\')\nproto.create = require(\'./create.js\')\n\nmix(require(\'./read.js\'), proto)\nmix(require(\'./write.js\'), proto)\n\nfunction mix(from, into) {\n  for(var key in from) {\n    into[key] = from[key]\n  }\n}\n\n},{"./copy.js":91,"./create.js":92,"./from.js":86,"./is.js":88,"./join.js":90,"./read.js":93,"./subarray.js":89,"./to.js":87,"./write.js":94}],67:[function(require,module,exports){\n(function(){var all = module.exports.all = [\n {\n  "errno": -1,\n  "code": "UNKNOWN",\n  "description": "unknown error"\n },\n {\n  "errno": 0,\n  "code": "OK",\n  "description": "success"\n },\n {\n  "errno": 1,\n  "code": "EOF",\n  "description": "end of file"\n },\n {\n  "errno": 2,\n  "code": "EADDRINFO",\n  "description": "getaddrinfo error"\n },\n {\n  "errno": 3,\n  "code": "EACCES",\n  "description": "permission denied"\n },\n {\n  "errno": 4,\n  "code": "EAGAIN",\n  "description": "resource temporarily unavailable"\n },\n {\n  "errno": 5,\n  "code": "EADDRINUSE",\n  "description": "address already in use"\n },\n {\n  "errno": 6,\n  "code": "EADDRNOTAVAIL",\n  "description": "address not available"\n },\n {\n  "errno": 7,\n  "code": "EAFNOSUPPORT",\n  "description": "address family not supported"\n },\n {\n  "errno": 8,\n  "code": "EALREADY",\n  "description": "connection already in progress"\n },\n {\n  "errno": 9,\n  "code": "EBADF",\n  "description": "bad file descriptor"\n },\n {\n  "errno": 10,\n  "code": "EBUSY",\n  "description": "resource busy or locked"\n },\n {\n  "errno": 11,\n  "code": "ECONNABORTED",\n  "description": "software caused connection abort"\n },\n {\n  "errno": 12,\n  "code": "ECONNREFUSED",\n  "description": "connection refused"\n },\n {\n  "errno": 13,\n  "code": "ECONNRESET",\n  "description": "connection reset by peer"\n },\n {\n  "errno": 14,\n  "code": "EDESTADDRREQ",\n  "description": "destination address required"\n },\n {\n  "errno": 15,\n  "code": "EFAULT",\n  "description": "bad address in system call argument"\n },\n {\n  "errno": 16,\n  "code": "EHOSTUNREACH",\n  "description": "host is unreachable"\n },\n {\n  "errno": 17,\n  "code": "EINTR",\n  "description": "interrupted system call"\n },\n {\n  "errno": 18,\n  "code": "EINVAL",\n  "description": "invalid argument"\n },\n {\n  "errno": 19,\n  "code": "EISCONN",\n  "description": "socket is already connected"\n },\n {\n  "errno": 20,\n  "code": "EMFILE",\n  "description": "too many open files"\n },\n {\n  "errno": 21,\n  "code": "EMSGSIZE",\n  "description": "message too long"\n },\n {\n  "errno": 22,\n  "code": "ENETDOWN",\n  "description": "network is down"\n },\n {\n  "errno": 23,\n  "code": "ENETUNREACH",\n  "description": "network is unreachable"\n },\n {\n  "errno": 24,\n  "code": "ENFILE",\n  "description": "file table overflow"\n },\n {\n  "errno": 25,\n  "code": "ENOBUFS",\n  "description": "no buffer space available"\n },\n {\n  "errno": 26,\n  "code": "ENOMEM",\n  "description": "not enough memory"\n },\n {\n  "errno": 27,\n  "code": "ENOTDIR",\n  "description": "not a directory"\n },\n {\n  "errno": 28,\n  "code": "EISDIR",\n  "description": "illegal operation on a directory"\n },\n {\n  "errno": 29,\n  "code": "ENONET",\n  "description": "machine is not on the network"\n },\n {\n  "errno": 31,\n  "code": "ENOTCONN",\n  "description": "socket is not connected"\n },\n {\n  "errno": 32,\n  "code": "ENOTSOCK",\n  "description": "socket operation on non-socket"\n },\n {\n  "errno": 33,\n  "code": "ENOTSUP",\n  "description": "operation not supported on socket"\n },\n {\n  "errno": 34,\n  "code": "ENOENT",\n  "description": "no such file or directory"\n },\n {\n  "errno": 35,\n  "code": "ENOSYS",\n  "description": "function not implemented"\n },\n {\n  "errno": 36,\n  "code": "EPIPE",\n  "description": "broken pipe"\n },\n {\n  "errno": 37,\n  "code": "EPROTO",\n  "description": "protocol error"\n },\n {\n  "errno": 38,\n  "code": "EPROTONOSUPPORT",\n  "description": "protocol not supported"\n },\n {\n  "errno": 39,\n  "code": "EPROTOTYPE",\n  "description": "protocol wrong type for socket"\n },\n {\n  "errno": 40,\n  "code": "ETIMEDOUT",\n  "description": "connection timed out"\n },\n {\n  "errno": 41,\n  "code": "ECHARSET",\n  "description": "invalid Unicode character"\n },\n {\n  "errno": 42,\n  "code": "EAIFAMNOSUPPORT",\n  "description": "address family for hostname not supported"\n },\n {\n  "errno": 44,\n  "code": "EAISERVICE",\n  "description": "servname not supported for ai_socktype"\n },\n {\n  "errno": 45,\n  "code": "EAISOCKTYPE",\n  "description": "ai_socktype not supported"\n },\n {\n  "errno": 46,\n  "code": "ESHUTDOWN",\n  "description": "cannot send after transport endpoint shutdown"\n },\n {\n  "errno": 47,\n  "code": "EEXIST",\n  "description": "file already exists"\n },\n {\n  "errno": 48,\n  "code": "ESRCH",\n  "description": "no such process"\n },\n {\n  "errno": 49,\n  "code": "ENAMETOOLONG",\n  "description": "name too long"\n },\n {\n  "errno": 50,\n  "code": "EPERM",\n  "description": "operation not permitted"\n },\n {\n  "errno": 51,\n  "code": "ELOOP",\n  "description": "too many symbolic links encountered"\n },\n {\n  "errno": 52,\n  "code": "EXDEV",\n  "description": "cross-device link not permitted"\n },\n {\n  "errno": 53,\n  "code": "ENOTEMPTY",\n  "description": "directory not empty"\n },\n {\n  "errno": 54,\n  "code": "ENOSPC",\n  "description": "no space left on device"\n },\n {\n  "errno": 55,\n  "code": "EIO",\n  "description": "i/o error"\n },\n {\n  "errno": 56,\n  "code": "EROFS",\n  "description": "read-only file system"\n },\n {\n  "errno": 57,\n  "code": "ENODEV",\n  "description": "no such device"\n },\n {\n  "errno": 58,\n  "code": "ESPIPE",\n  "description": "invalid seek"\n },\n {\n  "errno": 59,\n  "code": "ECANCELED",\n  "description": "operation canceled"\n }\n]\n\n\nmodule.exports.errno = {\n    \'-1\': all[0]\n  , \'0\': all[1]\n  , \'1\': all[2]\n  , \'2\': all[3]\n  , \'3\': all[4]\n  , \'4\': all[5]\n  , \'5\': all[6]\n  , \'6\': all[7]\n  , \'7\': all[8]\n  , \'8\': all[9]\n  , \'9\': all[10]\n  , \'10\': all[11]\n  , \'11\': all[12]\n  , \'12\': all[13]\n  , \'13\': all[14]\n  , \'14\': all[15]\n  , \'15\': all[16]\n  , \'16\': all[17]\n  , \'17\': all[18]\n  , \'18\': all[19]\n  , \'19\': all[20]\n  , \'20\': all[21]\n  , \'21\': all[22]\n  , \'22\': all[23]\n  , \'23\': all[24]\n  , \'24\': all[25]\n  , \'25\': all[26]\n  , \'26\': all[27]\n  , \'27\': all[28]\n  , \'28\': all[29]\n  , \'29\': all[30]\n  , \'31\': all[31]\n  , \'32\': all[32]\n  , \'33\': all[33]\n  , \'34\': all[34]\n  , \'35\': all[35]\n  , \'36\': all[36]\n  , \'37\': all[37]\n  , \'38\': all[38]\n  , \'39\': all[39]\n  , \'40\': all[40]\n  , \'41\': all[41]\n  , \'42\': all[42]\n  , \'44\': all[43]\n  , \'45\': all[44]\n  , \'46\': all[45]\n  , \'47\': all[46]\n  , \'48\': all[47]\n  , \'49\': all[48]\n  , \'50\': all[49]\n  , \'51\': all[50]\n  , \'52\': all[51]\n  , \'53\': all[52]\n  , \'54\': all[53]\n  , \'55\': all[54]\n  , \'56\': all[55]\n  , \'57\': all[56]\n  , \'58\': all[57]\n  , \'59\': all[58]\n}\n\n\nmodule.exports.code = {\n    \'UNKNOWN\': all[0]\n  , \'OK\': all[1]\n  , \'EOF\': all[2]\n  , \'EADDRINFO\': all[3]\n  , \'EACCES\': all[4]\n  , \'EAGAIN\': all[5]\n  , \'EADDRINUSE\': all[6]\n  , \'EADDRNOTAVAIL\': all[7]\n  , \'EAFNOSUPPORT\': all[8]\n  , \'EALREADY\': all[9]\n  , \'EBADF\': all[10]\n  , \'EBUSY\': all[11]\n  , \'ECONNABORTED\': all[12]\n  , \'ECONNREFUSED\': all[13]\n  , \'ECONNRESET\': all[14]\n  , \'EDESTADDRREQ\': all[15]\n  , \'EFAULT\': all[16]\n  , \'EHOSTUNREACH\': all[17]\n  , \'EINTR\': all[18]\n  , \'EINVAL\': all[19]\n  , \'EISCONN\': all[20]\n  , \'EMFILE\': all[21]\n  , \'EMSGSIZE\': all[22]\n  , \'ENETDOWN\': all[23]\n  , \'ENETUNREACH\': all[24]\n  , \'ENFILE\': all[25]\n  , \'ENOBUFS\': all[26]\n  , \'ENOMEM\': all[27]\n  , \'ENOTDIR\': all[28]\n  , \'EISDIR\': all[29]\n  , \'ENONET\': all[30]\n  , \'ENOTCONN\': all[31]\n  , \'ENOTSOCK\': all[32]\n  , \'ENOTSUP\': all[33]\n  , \'ENOENT\': all[34]\n  , \'ENOSYS\': all[35]\n  , \'EPIPE\': all[36]\n  , \'EPROTO\': all[37]\n  , \'EPROTONOSUPPORT\': all[38]\n  , \'EPROTOTYPE\': all[39]\n  , \'ETIMEDOUT\': all[40]\n  , \'ECHARSET\': all[41]\n  , \'EAIFAMNOSUPPORT\': all[42]\n  , \'EAISERVICE\': all[43]\n  , \'EAISOCKTYPE\': all[44]\n  , \'ESHUTDOWN\': all[45]\n  , \'EEXIST\': all[46]\n  , \'ESRCH\': all[47]\n  , \'ENAMETOOLONG\': all[48]\n  , \'EPERM\': all[49]\n  , \'ELOOP\': all[50]\n  , \'EXDEV\': all[51]\n  , \'ENOTEMPTY\': all[52]\n  , \'ENOSPC\': all[53]\n  , \'EIO\': all[54]\n  , \'EROFS\': all[55]\n  , \'ENODEV\': all[56]\n  , \'ESPIPE\': all[57]\n  , \'ECANCELED\': all[58]\n}\n\n\nmodule.exports.custom = require("./custom")(module.exports)\nmodule.exports.create = module.exports.custom.createError\n})()\n},{"./custom":95}],68:[function(require,module,exports){\nmodule.exports = Object.keys || require(\'./shim\');\n\n\n},{"./shim":96}],60:[function(require,module,exports){\nvar Keys = require("object-keys")\nvar hasKeys = require("./has-keys")\n\nmodule.exports = extend\n\nfunction extend() {\n    var target = {}\n\n    for (var i = 0; i < arguments.length; i++) {\n        var source = arguments[i]\n\n        if (!hasKeys(source)) {\n            continue\n        }\n\n        var keys = Keys(source)\n\n        for (var j = 0; j < keys.length; j++) {\n            var name = keys[j]\n            target[name] = source[name]\n        }\n    }\n\n    return target\n}\n\n},{"./has-keys":80,"object-keys":97}],88:[function(require,module,exports){\n\nmodule.exports = function(buffer) {\n  return buffer instanceof Uint8Array;\n}\n\n},{}],89:[function(require,module,exports){\nmodule.exports = subarray\n\nfunction subarray(buf, from, to) {\n  return buf.subarray(from || 0, to || buf.length)\n}\n\n},{}],90:[function(require,module,exports){\nmodule.exports = join\n\nfunction join(targets, hint) {\n  if(!targets.length) {\n    return new Uint8Array(0)\n  }\n\n  var len = hint !== undefined ? hint : get_length(targets)\n    , out = new Uint8Array(len)\n    , cur = targets[0]\n    , curlen = cur.length\n    , curidx = 0\n    , curoff = 0\n    , i = 0\n\n  while(i < len) {\n    if(curoff === curlen) {\n      curoff = 0\n      ++curidx\n      cur = targets[curidx]\n      curlen = cur && cur.length\n      continue\n    }\n    out[i++] = cur[curoff++] \n  }\n\n  return out\n}\n\nfunction get_length(targets) {\n  var size = 0\n  for(var i = 0, len = targets.length; i < len; ++i) {\n    size += targets[i].byteLength\n  }\n  return size\n}\n\n},{}],91:[function(require,module,exports){\nmodule.exports = copy\n\nvar slice = [].slice\n\nfunction copy(source, target, target_start, source_start, source_end) {\n  target_start = arguments.length < 3 ? 0 : target_start\n  source_start = arguments.length < 4 ? 0 : source_start\n  source_end = arguments.length < 5 ? source.length : source_end\n\n  if(source_end === source_start) {\n    return\n  }\n\n  if(target.length === 0 || source.length === 0) {\n    return\n  }\n\n  if(source_end > source.length) {\n    source_end = source.length\n  }\n\n  if(target.length - target_start < source_end - source_start) {\n    source_end = target.length - target_start + source_start\n  }\n\n  if(source.buffer !== target.buffer) {\n    return fast_copy(source, target, target_start, source_start, source_end)\n  }\n  return slow_copy(source, target, target_start, source_start, source_end)\n}\n\nfunction fast_copy(source, target, target_start, source_start, source_end) {\n  var len = (source_end - source_start) + target_start\n\n  for(var i = target_start, j = source_start;\n      i < len;\n      ++i,\n      ++j) {\n    target[i] = source[j]\n  }\n}\n\nfunction slow_copy(from, to, j, i, jend) {\n  // the buffers could overlap.\n  var iend = jend + i\n    , tmp = new Uint8Array(slice.call(from, i, iend))\n    , x = 0\n\n  for(; i < iend; ++i, ++x) {\n    to[j++] = tmp[x]\n  }\n}\n\n},{}],92:[function(require,module,exports){\nmodule.exports = function(size) {\n  return new Uint8Array(size)\n}\n\n},{}],56:[function(require,module,exports){\nmodule.exports = from\n\nvar base64 = require(\'base64-js\')\n\nvar decoders = {\n    hex: from_hex\n  , utf8: from_utf\n  , base64: from_base64\n}\n\nfunction from(source, encoding) {\n  if(Array.isArray(source)) {\n    return new Uint8Array(source)\n  }\n\n  return decoders[encoding || \'utf8\'](source)\n}\n\nfunction from_hex(str) {\n  var size = str.length / 2\n    , buf = new Uint8Array(size)\n    , character = \'\'\n\n  for(var i = 0, len = str.length; i < len; ++i) {\n    character += str.charAt(i)\n\n    if(i > 0 && (i % 2) === 1) {\n      buf[i>>>1] = parseInt(character, 16)\n      character = \'\' \n    }\n  }\n\n  return buf \n}\n\nfunction from_utf(str) {\n  var arr = []\n    , code\n\n  for(var i = 0, len = str.length; i < len; ++i) {\n    code = fixed_cca(str, i)\n\n    if(code === false) {\n      continue\n    }\n\n    if(code < 0x80) {\n      arr[arr.length] = code\n\n      continue\n    }\n\n    codepoint_to_bytes(arr, code)\n  }\n\n  return new Uint8Array(arr)\n}\n\nfunction codepoint_to_bytes(arr, code) {\n  // find MSB, use that to determine byte count\n  var copy_code = code\n    , bit_count = 0\n    , byte_count\n    , prefix\n    , _byte\n    , pos\n\n  do {\n    ++bit_count\n  } while(copy_code >>>= 1)\n\n  byte_count = Math.ceil((bit_count - 1) / 5) | 0\n  prefix = [0, 0, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc][byte_count]\n  pos = [0, 0, 3, 4, 5, 6, 7][byte_count]\n\n  _byte |= prefix\n\n  bit_count = (7 - pos) + 6 * (byte_count - 1)\n\n  while(bit_count) {\n    _byte |= +!!(code & (1 << bit_count)) << (7 - pos)\n    ++pos\n\n    if(pos % 8 === 0) {\n      arr[arr.length] = _byte\n      _byte = 0x80\n      pos = 2\n    }\n\n    --bit_count\n  }\n\n  if(pos) {\n    _byte |= +!!(code & 1) << (7 - pos)\n    arr[arr.length] = _byte\n  }\n}\n\nfunction pad(str) {\n  while(str.length < 8) {\n    str = \'0\' + str\n  }\n\n  return str\n}\n\nfunction fixed_cca(str, idx) {\n  idx = idx || 0\n\n  var code = str.charCodeAt(idx)\n    , lo\n    , hi\n\n  if(0xD800 <= code && code <= 0xDBFF) {\n    lo = str.charCodeAt(idx + 1)\n    hi = code\n\n    if(isNaN(lo)) {\n      throw new Error(\'High surrogate not followed by low surrogate\')\n    }\n\n    return ((hi - 0xD800) * 0x400) + (lo - 0xDC00) + 0x10000\n  }\n\n  if(0xDC00 <= code && code <= 0xDFFF) {\n    return false\n  }\n\n  return code\n}\n\nfunction from_base64(str) {\n  return new Uint8Array(base64.toByteArray(str)) \n}\n\n},{"base64-js":98}],99:[function(require,module,exports){\nmodule.exports = hasKeys\n\nfunction hasKeys(source) {\n    return source !== null &&\n        (typeof source === "object" ||\n        typeof source === "function")\n}\n\n},{}],48:[function(require,module,exports){\nmodule.exports = to\n\nvar base64 = require(\'base64-js\')\n  , toutf8 = require(\'to-utf8\')\n\nvar encoders = {\n    hex: to_hex\n  , utf8: to_utf\n  , base64: to_base64\n}\n\nfunction to(buf, encoding) {\n  return encoders[encoding || \'utf8\'](buf)\n}\n\nfunction to_hex(buf) {\n  var str = \'\'\n    , byt\n\n  for(var i = 0, len = buf.length; i < len; ++i) {\n    byt = buf[i]\n    str += ((byt & 0xF0) >>> 4).toString(16)\n    str += (byt & 0x0F).toString(16)\n  }\n\n  return str\n}\n\nfunction to_utf(buf) {\n  return toutf8(buf)\n}\n\nfunction to_base64(buf) {\n  return base64.fromByteArray(buf)\n}\n\n\n},{"base64-js":98,"to-utf8":100}],77:[function(require,module,exports){\nvar proto = {}\nmodule.exports = proto\n\nproto.from = require(\'./from.js\')\nproto.to = require(\'./to.js\')\nproto.is = require(\'./is.js\')\nproto.subarray = require(\'./subarray.js\')\nproto.join = require(\'./join.js\')\nproto.copy = require(\'./copy.js\')\nproto.create = require(\'./create.js\')\n\nmix(require(\'./read.js\'), proto)\nmix(require(\'./write.js\'), proto)\n\nfunction mix(from, into) {\n  for(var key in from) {\n    into[key] = from[key]\n  }\n}\n\n},{"./copy.js":106,"./create.js":107,"./from.js":101,"./is.js":103,"./join.js":105,"./read.js":108,"./subarray.js":104,"./to.js":102,"./write.js":109}],78:[function(require,module,exports){\n(function(process,Buffer){/* Copyright (c) 2013 Rod Vagg, MIT License */\n\nvar AbstractIterator     = require(\'./abstract-iterator\')\n  , AbstractChainedBatch = require(\'./abstract-chained-batch\')\n\nfunction AbstractLevelDOWN (location) {\n  if (!arguments.length || location === undefined)\n    throw new Error(\'constructor requires at least a location argument\')\n\n  if (typeof location != \'string\')\n    throw new Error(\'constructor requires a location string argument\')\n\n  this.location = location\n}\n\nAbstractLevelDOWN.prototype.open = function (options, callback) {\n  if (typeof options == \'function\')\n    callback = options\n  if (typeof callback != \'function\')\n    throw new Error(\'open() requires a callback argument\')\n  if (typeof options != \'object\')\n    options = {}\n\n  if (typeof this._open == \'function\')\n    return this._open(options, callback)\n\n  process.nextTick(callback)\n}\n\nAbstractLevelDOWN.prototype.close = function (callback) {\n  if (typeof callback != \'function\')\n    throw new Error(\'close() requires a callback argument\')\n\n  if (typeof this._close == \'function\')\n    return this._close(callback)\n\n  process.nextTick(callback)\n}\n\nAbstractLevelDOWN.prototype.get = function (key, options, callback) {\n  var self = this\n  if (typeof options == \'function\')\n    callback = options\n  if (typeof callback != \'function\')\n    throw new Error(\'get() requires a callback argument\')\n  var err = self._checkKeyValue(key, \'key\', self._isBuffer)\n  if (err) return callback(err)\n  if (!self._isBuffer(key)) key = String(key)\n  if (typeof options != \'object\')\n    options = {}\n\n  if (typeof self._get == \'function\')\n    return self._get(key, options, callback)\n\n  process.nextTick(function () { callback(new Error(\'NotFound\')) })\n}\n\nAbstractLevelDOWN.prototype.put = function (key, value, options, callback) {\n  if (typeof options == \'function\')\n    callback = options\n  if (typeof callback != \'function\')\n    throw new Error(\'put() requires a callback argument\')\n  var err = this._checkKeyValue(key, \'key\', this._isBuffer)\n  if (err) return callback(err)\n  err = this._checkKeyValue(value, \'value\', this._isBuffer)\n  if (err) return callback(err)\n  if (!this._isBuffer(key)) key = String(key)\n  // coerce value to string in node, dont touch it in browser\n  // (indexeddb can store any JS type)\n  if (!this._isBuffer(value) && !process.browser) value = String(value)\n  if (typeof options != \'object\')\n    options = {}\n  if (typeof this._put == \'function\')\n    return this._put(key, value, options, callback)\n\n  process.nextTick(callback)\n}\n\nAbstractLevelDOWN.prototype.del = function (key, options, callback) {\n  if (typeof options == \'function\')\n    callback = options\n  if (typeof callback != \'function\')\n    throw new Error(\'del() requires a callback argument\')\n  var err = this._checkKeyValue(key, \'key\', this._isBuffer)\n  if (err) return callback(err)\n  if (!this._isBuffer(key)) key = String(key)\n  if (typeof options != \'object\')\n    options = {}\n\n\n  if (typeof this._del == \'function\')\n    return this._del(key, options, callback)\n\n  process.nextTick(callback)\n}\n\nAbstractLevelDOWN.prototype.batch = function (array, options, callback) {\n  if (!arguments.length)\n    return this._chainedBatch()\n\n  if (typeof options == \'function\')\n    callback = options\n  if (typeof callback != \'function\')\n    throw new Error(\'batch(array) requires a callback argument\')\n  if (!Array.isArray(array))\n    return callback(new Error(\'batch(array) requires an array argument\'))\n  if (typeof options != \'object\')\n    options = {}\n\n  var i = 0\n    , l = array.length\n    , e\n    , err\n\n  for (; i < l; i++) {\n    e = array[i]\n    if (typeof e != \'object\') continue;\n\n    err = this._checkKeyValue(e.type, \'type\', this._isBuffer)\n    if (err) return callback(err)\n\n    err = this._checkKeyValue(e.key, \'key\', this._isBuffer)\n    if (err) return callback(err)\n\n    if (e.type == \'put\') {\n      err = this._checkKeyValue(e.value, \'value\', this._isBuffer)\n      if (err) return callback(err)\n    }\n  }\n\n  if (typeof this._batch == \'function\')\n    return this._batch(array, options, callback)\n\n  process.nextTick(callback)\n}\n\nAbstractLevelDOWN.prototype.approximateSize = function (start, end, callback) {\n  if (start == null || end == null || typeof start == \'function\' || typeof end == \'function\')\n    throw new Error(\'approximateSize() requires valid `start`, `end` and `callback` arguments\')\n  if (typeof callback != \'function\')\n    throw new Error(\'approximateSize() requires a callback argument\')\n\n  if (!this._isBuffer(start)) start = String(start)\n  if (!this._isBuffer(end)) end = String(end)\n  if (typeof this._approximateSize == \'function\')\n    return this._approximateSize(start, end, callback)\n\n  process.nextTick(function () { callback(null, 0) })\n}\n\nAbstractLevelDOWN.prototype.iterator = function (options) {\n  if (typeof options != \'object\')\n    options = {}\n\n  if (typeof this._iterator == \'function\')\n    return this._iterator(options)\n\n  return new AbstractIterator(this)\n}\n\nAbstractLevelDOWN.prototype._chainedBatch = function () {\n  return new AbstractChainedBatch(this)\n}\n\nAbstractLevelDOWN.prototype._isBuffer = function (obj) {\n  return Buffer.isBuffer(obj)\n}\n\nAbstractLevelDOWN.prototype._checkKeyValue = function (obj, type) {\n  if (obj === null || obj === undefined)\n    return new Error(type + \' cannot be `null` or `undefined`\')\n  if (obj === null || obj === undefined)\n    return new Error(type + \' cannot be `null` or `undefined`\')\n  if (this._isBuffer(obj)) {\n    if (obj.length === 0)\n      return new Error(type + \' cannot be an empty Buffer\')\n  } else if (String(obj) === \'\')\n    return new Error(type + \' cannot be an empty String\')\n}\n\nmodule.exports.AbstractLevelDOWN    = AbstractLevelDOWN\nmodule.exports.AbstractIterator     = AbstractIterator\nmodule.exports.AbstractChainedBatch = AbstractChainedBatch\n\n})(require("__browserify_process"),require("__browserify_buffer").Buffer)\n},{"./abstract-chained-batch":111,"./abstract-iterator":110,"__browserify_buffer":12,"__browserify_process":13}],66:[function(require,module,exports){\nvar Keys = require("object-keys")\nvar hasKeys = require("./has-keys")\n\nmodule.exports = extend\n\nfunction extend() {\n    var target = {}\n\n    for (var i = 0; i < arguments.length; i++) {\n        var source = arguments[i]\n\n        if (!hasKeys(source)) {\n            continue\n        }\n\n        var keys = Keys(source)\n\n        for (var j = 0; j < keys.length; j++) {\n            var name = keys[j]\n            target[name] = source[name]\n        }\n    }\n\n    return target\n}\n\n},{"./has-keys":99,"object-keys":112}],79:[function(require,module,exports){\nmodule.exports = Object.keys || require(\'./shim\');\n\n\n},{"./shim":113}],98:[function(require,module,exports){\n(function (exports) {\n\t\'use strict\';\n\n\tvar lookup = \'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\';\n\n\tfunction b64ToByteArray(b64) {\n\t\tvar i, j, l, tmp, placeHolders, arr;\n\t\n\t\tif (b64.length % 4 > 0) {\n\t\t\tthrow \'Invalid string. Length must be a multiple of 4\';\n\t\t}\n\n\t\t// the number of equal signs (place holders)\n\t\t// if there are two placeholders, than the two characters before it\n\t\t// represent one byte\n\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t// this is just a cheap hack to not do indexOf twice\n\t\tplaceHolders = b64.indexOf(\'=\');\n\t\tplaceHolders = placeHolders > 0 ? b64.length - placeHolders : 0;\n\n\t\t// base64 is 4/3 + up to two characters of the original data\n\t\tarr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);\n\n\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length;\n\n\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);\n\t\t\tarr.push((tmp & 0xFF0000) >> 16);\n\t\t\tarr.push((tmp & 0xFF00) >> 8);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t}\n\n\t\tif (placeHolders === 2) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t} else if (placeHolders === 1) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);\n\t\t\tarr.push((tmp >> 8) & 0xFF);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t}\n\n\t\treturn arr;\n\t}\n\n\tfunction uint8ToBase64(uint8) {\n\t\tvar i,\n\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\toutput = "",\n\t\t\ttemp, length;\n\n\t\tfunction tripletToBase64 (num) {\n\t\t\treturn lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n\t\t};\n\n\t\t// go through the array every three bytes, we\'ll deal with trailing stuff later\n\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);\n\t\t\toutput += tripletToBase64(temp);\n\t\t}\n\n\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\tswitch (extraBytes) {\n\t\t\tcase 1:\n\t\t\t\ttemp = uint8[uint8.length - 1];\n\t\t\t\toutput += lookup[temp >> 2];\n\t\t\t\toutput += lookup[(temp << 4) & 0x3F];\n\t\t\t\toutput += \'==\';\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);\n\t\t\t\toutput += lookup[temp >> 10];\n\t\t\t\toutput += lookup[(temp >> 4) & 0x3F];\n\t\t\t\toutput += lookup[(temp << 2) & 0x3F];\n\t\t\t\toutput += \'=\';\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn output;\n\t}\n\n\tmodule.exports.toByteArray = b64ToByteArray;\n\tmodule.exports.fromByteArray = uint8ToBase64;\n}());\n\n},{}],100:[function(require,module,exports){\nmodule.exports = to_utf8\n\nvar out = []\n  , col = []\n  , fcc = String.fromCharCode\n  , mask = [0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01]\n  , unmask = [\n      0x00\n    , 0x01\n    , 0x02 | 0x01\n    , 0x04 | 0x02 | 0x01\n    , 0x08 | 0x04 | 0x02 | 0x01\n    , 0x10 | 0x08 | 0x04 | 0x02 | 0x01\n    , 0x20 | 0x10 | 0x08 | 0x04 | 0x02 | 0x01\n    , 0x40 | 0x20 | 0x10 | 0x08 | 0x04 | 0x02 | 0x01\n  ]\n\nfunction to_utf8(bytes, start, end) {\n  start = start === undefined ? 0 : start\n  end = end === undefined ? bytes.length : end\n\n  var idx = 0\n    , hi = 0x80\n    , collecting = 0\n    , pos\n    , by\n\n  col.length =\n  out.length = 0\n\n  while(idx < bytes.length) {\n    by = bytes[idx]\n    if(!collecting && by & hi) {\n      pos = find_pad_position(by)\n      collecting += pos\n      if(pos < 8) {\n        col[col.length] = by & unmask[6 - pos]\n      }\n    } else if(collecting) {\n      col[col.length] = by & unmask[6]\n      --collecting\n      if(!collecting && col.length) {\n        out[out.length] = fcc(reduced(col, pos))\n        col.length = 0\n      }\n    } else { \n      out[out.length] = fcc(by)\n    }\n    ++idx\n  }\n  if(col.length && !collecting) {\n    out[out.length] = fcc(reduced(col, pos))\n    col.length = 0\n  }\n  return out.join(\'\')\n}\n\nfunction find_pad_position(byt) {\n  for(var i = 0; i < 7; ++i) {\n    if(!(byt & mask[i])) {\n      break\n    }\n  }\n  return i\n}\n\nfunction reduced(list) {\n  var out = 0\n  for(var i = 0, len = list.length; i < len; ++i) {\n    out |= list[i] << ((len - i - 1) * 6)\n  }\n  return out\n}\n\n},{}],103:[function(require,module,exports){\n\nmodule.exports = function(buffer) {\n  return buffer instanceof Uint8Array;\n}\n\n},{}],104:[function(require,module,exports){\nmodule.exports = subarray\n\nfunction subarray(buf, from, to) {\n  return buf.subarray(from || 0, to || buf.length)\n}\n\n},{}],105:[function(require,module,exports){\nmodule.exports = join\n\nfunction join(targets, hint) {\n  if(!targets.length) {\n    return new Uint8Array(0)\n  }\n\n  var len = hint !== undefined ? hint : get_length(targets)\n    , out = new Uint8Array(len)\n    , cur = targets[0]\n    , curlen = cur.length\n    , curidx = 0\n    , curoff = 0\n    , i = 0\n\n  while(i < len) {\n    if(curoff === curlen) {\n      curoff = 0\n      ++curidx\n      cur = targets[curidx]\n      curlen = cur && cur.length\n      continue\n    }\n    out[i++] = cur[curoff++] \n  }\n\n  return out\n}\n\nfunction get_length(targets) {\n  var size = 0\n  for(var i = 0, len = targets.length; i < len; ++i) {\n    size += targets[i].byteLength\n  }\n  return size\n}\n\n},{}],106:[function(require,module,exports){\nmodule.exports = copy\n\nvar slice = [].slice\n\nfunction copy(source, target, target_start, source_start, source_end) {\n  target_start = arguments.length < 3 ? 0 : target_start\n  source_start = arguments.length < 4 ? 0 : source_start\n  source_end = arguments.length < 5 ? source.length : source_end\n\n  if(source_end === source_start) {\n    return\n  }\n\n  if(target.length === 0 || source.length === 0) {\n    return\n  }\n\n  if(source_end > source.length) {\n    source_end = source.length\n  }\n\n  if(target.length - target_start < source_end - source_start) {\n    source_end = target.length - target_start + source_start\n  }\n\n  if(source.buffer !== target.buffer) {\n    return fast_copy(source, target, target_start, source_start, source_end)\n  }\n  return slow_copy(source, target, target_start, source_start, source_end)\n}\n\nfunction fast_copy(source, target, target_start, source_start, source_end) {\n  var len = (source_end - source_start) + target_start\n\n  for(var i = target_start, j = source_start;\n      i < len;\n      ++i,\n      ++j) {\n    target[i] = source[j]\n  }\n}\n\nfunction slow_copy(from, to, j, i, jend) {\n  // the buffers could overlap.\n  var iend = jend + i\n    , tmp = new Uint8Array(slice.call(from, i, iend))\n    , x = 0\n\n  for(; i < iend; ++i, ++x) {\n    to[j++] = tmp[x]\n  }\n}\n\n},{}],107:[function(require,module,exports){\nmodule.exports = function(size) {\n  return new Uint8Array(size)\n}\n\n},{}],110:[function(require,module,exports){\n(function(process){/* Copyright (c) 2013 Rod Vagg, MIT License */\n\nfunction AbstractIterator (db) {\n  this.db = db\n  this._ended = false\n  this._nexting = false\n}\n\nAbstractIterator.prototype.next = function (callback) {\n  var self = this\n\n  if (typeof callback != \'function\')\n    throw new Error(\'next() requires a callback argument\')\n\n  if (self._ended)\n    return callback(new Error(\'cannot call next() after end()\'))\n  if (self._nexting)\n    return callback(new Error(\'cannot call next() before previous next() has completed\'))\n\n  self._nexting = true\n  if (typeof self._next == \'function\') {\n    return self._next(function () {\n      self._nexting = false\n      callback.apply(null, arguments)\n    })\n  }\n\n  process.nextTick(function () {\n    self._nexting = false\n    callback()\n  })\n}\n\nAbstractIterator.prototype.end = function (callback) {\n  if (typeof callback != \'function\')\n    throw new Error(\'end() requires a callback argument\')\n\n  if (this._ended)\n    return callback(new Error(\'end() already called on iterator\'))\n\n  this._ended = true\n\n  if (typeof this._end == \'function\')\n    return this._end(callback)\n\n  process.nextTick(callback)\n}\n\nmodule.exports = AbstractIterator\n\n})(require("__browserify_process"))\n},{"__browserify_process":13}],111:[function(require,module,exports){\n(function(process){/* Copyright (c) 2013 Rod Vagg, MIT License */\n\nfunction AbstractChainedBatch (db) {\n  this._db         = db\n  this._operations = []\n  this._written    = false\n}\n\nAbstractChainedBatch.prototype._checkWritten = function () {\n  if (this._written)\n    throw new Error(\'write() already called on this batch\')\n}\n\nAbstractChainedBatch.prototype.put = function (key, value) {\n  this._checkWritten()\n\n  var err = this._db._checkKeyValue(key, \'key\', this._db._isBuffer)\n  if (err) throw err\n  err = this._db._checkKeyValue(value, \'value\', this._db._isBuffer)\n  if (err) throw err\n\n  if (!this._db._isBuffer(key)) key = String(key)\n  if (!this._db._isBuffer(value)) value = String(value)\n\n  if (typeof this._put == \'function\' )\n    this._put(key, value)\n  else\n    this._operations.push({ type: \'put\', key: key, value: value })\n\n  return this\n}\n\nAbstractChainedBatch.prototype.del = function (key) {\n  this._checkWritten()\n\n  var err = this._db._checkKeyValue(key, \'key\', this._db._isBuffer)\n  if (err) throw err\n\n  if (!this._db._isBuffer(key)) key = String(key)\n\n  if (typeof this._del == \'function\' )\n    this._del(key)\n  else\n    this._operations.push({ type: \'del\', key: key })\n\n  return this\n}\n\nAbstractChainedBatch.prototype.clear = function () {\n  this._checkWritten()\n\n  this._operations = []\n\n  if (typeof this._clear == \'function\' )\n    this._clear()\n\n  return this\n}\n\nAbstractChainedBatch.prototype.write = function (options, callback) {\n  this._checkWritten()\n\n  if (typeof options == \'function\')\n    callback = options\n  if (typeof callback != \'function\')\n    throw new Error(\'write() requires a callback argument\')\n  if (typeof options != \'object\')\n    options = {}\n\n  this._written = true\n\n  if (typeof this._write == \'function\' )\n    return this._write(callback)\n\n  if (typeof this._db._batch == \'function\')\n    return this._db._batch(this._operations, options, callback)\n\n  process.nextTick(callback)\n}\n\nmodule.exports = AbstractChainedBatch\n})(require("__browserify_process"))\n},{"__browserify_process":13}],93:[function(require,module,exports){\nmodule.exports = {\n    readUInt8:      read_uint8\n  , readInt8:       read_int8\n  , readUInt16LE:   read_uint16_le\n  , readUInt32LE:   read_uint32_le\n  , readInt16LE:    read_int16_le\n  , readInt32LE:    read_int32_le\n  , readFloatLE:    read_float_le\n  , readDoubleLE:   read_double_le\n  , readUInt16BE:   read_uint16_be\n  , readUInt32BE:   read_uint32_be\n  , readInt16BE:    read_int16_be\n  , readInt32BE:    read_int32_be\n  , readFloatBE:    read_float_be\n  , readDoubleBE:   read_double_be\n}\n\nvar map = require(\'./mapped.js\')\n\nfunction read_uint8(target, at) {\n  return target[at]\n}\n\nfunction read_int8(target, at) {\n  var v = target[at];\n  return v < 0x80 ? v : v - 0x100\n}\n\nfunction read_uint16_le(target, at) {\n  var dv = map.get(target);\n  return dv.getUint16(at + target.byteOffset, true)\n}\n\nfunction read_uint32_le(target, at) {\n  var dv = map.get(target);\n  return dv.getUint32(at + target.byteOffset, true)\n}\n\nfunction read_int16_le(target, at) {\n  var dv = map.get(target);\n  return dv.getInt16(at + target.byteOffset, true)\n}\n\nfunction read_int32_le(target, at) {\n  var dv = map.get(target);\n  return dv.getInt32(at + target.byteOffset, true)\n}\n\nfunction read_float_le(target, at) {\n  var dv = map.get(target);\n  return dv.getFloat32(at + target.byteOffset, true)\n}\n\nfunction read_double_le(target, at) {\n  var dv = map.get(target);\n  return dv.getFloat64(at + target.byteOffset, true)\n}\n\nfunction read_uint16_be(target, at) {\n  var dv = map.get(target);\n  return dv.getUint16(at + target.byteOffset, false)\n}\n\nfunction read_uint32_be(target, at) {\n  var dv = map.get(target);\n  return dv.getUint32(at + target.byteOffset, false)\n}\n\nfunction read_int16_be(target, at) {\n  var dv = map.get(target);\n  return dv.getInt16(at + target.byteOffset, false)\n}\n\nfunction read_int32_be(target, at) {\n  var dv = map.get(target);\n  return dv.getInt32(at + target.byteOffset, false)\n}\n\nfunction read_float_be(target, at) {\n  var dv = map.get(target);\n  return dv.getFloat32(at + target.byteOffset, false)\n}\n\nfunction read_double_be(target, at) {\n  var dv = map.get(target);\n  return dv.getFloat64(at + target.byteOffset, false)\n}\n\n},{"./mapped.js":114}],94:[function(require,module,exports){\nmodule.exports = {\n    writeUInt8:      write_uint8\n  , writeInt8:       write_int8\n  , writeUInt16LE:   write_uint16_le\n  , writeUInt32LE:   write_uint32_le\n  , writeInt16LE:    write_int16_le\n  , writeInt32LE:    write_int32_le\n  , writeFloatLE:    write_float_le\n  , writeDoubleLE:   write_double_le\n  , writeUInt16BE:   write_uint16_be\n  , writeUInt32BE:   write_uint32_be\n  , writeInt16BE:    write_int16_be\n  , writeInt32BE:    write_int32_be\n  , writeFloatBE:    write_float_be\n  , writeDoubleBE:   write_double_be\n}\n\nvar map = require(\'./mapped.js\')\n\nfunction write_uint8(target, value, at) {\n  return target[at] = value\n}\n\nfunction write_int8(target, value, at) {\n  return target[at] = value < 0 ? value + 0x100 : value\n}\n\nfunction write_uint16_le(target, value, at) {\n  var dv = map.get(target);\n  return dv.setUint16(at + target.byteOffset, value, true)\n}\n\nfunction write_uint32_le(target, value, at) {\n  var dv = map.get(target);\n  return dv.setUint32(at + target.byteOffset, value, true)\n}\n\nfunction write_int16_le(target, value, at) {\n  var dv = map.get(target);\n  return dv.setInt16(at + target.byteOffset, value, true)\n}\n\nfunction write_int32_le(target, value, at) {\n  var dv = map.get(target);\n  return dv.setInt32(at + target.byteOffset, value, true)\n}\n\nfunction write_float_le(target, value, at) {\n  var dv = map.get(target);\n  return dv.setFloat32(at + target.byteOffset, value, true)\n}\n\nfunction write_double_le(target, value, at) {\n  var dv = map.get(target);\n  return dv.setFloat64(at + target.byteOffset, value, true)\n}\n\nfunction write_uint16_be(target, value, at) {\n  var dv = map.get(target);\n  return dv.setUint16(at + target.byteOffset, value, false)\n}\n\nfunction write_uint32_be(target, value, at) {\n  var dv = map.get(target);\n  return dv.setUint32(at + target.byteOffset, value, false)\n}\n\nfunction write_int16_be(target, value, at) {\n  var dv = map.get(target);\n  return dv.setInt16(at + target.byteOffset, value, false)\n}\n\nfunction write_int32_be(target, value, at) {\n  var dv = map.get(target);\n  return dv.setInt32(at + target.byteOffset, value, false)\n}\n\nfunction write_float_be(target, value, at) {\n  var dv = map.get(target);\n  return dv.setFloat32(at + target.byteOffset, value, false)\n}\n\nfunction write_double_be(target, value, at) {\n  var dv = map.get(target);\n  return dv.setFloat64(at + target.byteOffset, value, false)\n}\n\n},{"./mapped.js":114}],82:[function(require,module,exports){\n(function(process,Buffer){// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, cb), and it\'ll handle all\n// the drain event emission and buffering.\n\nmodule.exports = Writable;\nWritable.WritableState = WritableState;\n\nvar util = require(\'util\');\nvar assert = require(\'assert\');\nvar Stream = require(\'stream\');\n\nutil.inherits(Writable, Stream);\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n}\n\nfunction WritableState(options, stream) {\n  options = options || {};\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  // cast to ints.\n  this.highWaterMark = ~~this.highWaterMark;\n\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when \'finish\' is emitted\n  this.finished = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is \'binary\' so we have to make this configurable.\n  // Everything else in the universe uses \'utf8\', though.\n  this.defaultEncoding = options.defaultEncoding || \'utf8\';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we\'re waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we\'re in the middle of a write.\n  this.writing = false;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, becuase any\n  // actions that shouldn\'t happen until "later" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we\'re processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don\'t\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that\'s passed to _write(chunk,cb)\n  this.onwrite = function(er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.buffer = [];\n}\n\nfunction Writable(options) {\n  // Writable ctor is applied to Duplexes, though they\'re not\n  // instanceof Writable, they\'re instanceof Readable.\n  if (!(this instanceof Writable) && !(this instanceof require(\'./_stream_duplex\')))\n    return new Writable(options);\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function() {\n  this.emit(\'error\', new Error(\'Cannot pipe. Not readable.\'));\n};\n\n\nfunction writeAfterEnd(stream, state, cb) {\n  var er = new Error(\'write after end\');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit(\'error\', er);\n  process.nextTick(function() {\n    cb(er);\n  });\n}\n\n// If we get something that is not a buffer, string, null, or undefined,\n// and we\'re not in objectMode, then that\'s an error.\n// Otherwise stream chunks are all considered to be of length=1, and the\n// watermarks determine how many objects to keep in the buffer, rather than\n// how many bytes or characters.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  if (!Buffer.isBuffer(chunk) &&\n      \'string\' !== typeof chunk &&\n      chunk !== null &&\n      chunk !== undefined &&\n      !state.objectMode) {\n    var er = new TypeError(\'Invalid non-string/buffer chunk\');\n    stream.emit(\'error\', er);\n    process.nextTick(function() {\n      cb(er);\n    });\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function(chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  if (typeof encoding === \'function\') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (Buffer.isBuffer(chunk))\n    encoding = \'buffer\';\n  else if (!encoding)\n    encoding = state.defaultEncoding;\n\n  if (typeof cb !== \'function\')\n    cb = function() {};\n\n  if (state.ended)\n    writeAfterEnd(this, state, cb);\n  else if (validChunk(this, state, chunk, cb))\n    ret = writeOrBuffer(this, state, chunk, encoding, cb);\n\n  return ret;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode &&\n      state.decodeStrings !== false &&\n      typeof chunk === \'string\') {\n    chunk = new Buffer(chunk, encoding);\n  }\n  return chunk;\n}\n\n// if we\'re already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, chunk, encoding, cb) {\n  chunk = decodeChunk(state, chunk, encoding);\n  if (Buffer.isBuffer(chunk))\n    encoding = \'buffer\';\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret)\n    state.needDrain = true;\n\n  if (state.writing)\n    state.buffer.push(new WriteReq(chunk, encoding, cb));\n  else\n    doWrite(stream, state, len, chunk, encoding, cb);\n\n  return ret;\n}\n\nfunction doWrite(stream, state, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  if (sync)\n    process.nextTick(function() {\n      cb(er);\n    });\n  else\n    cb(er);\n\n  stream.emit(\'error\', er);\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er)\n    onwriteError(stream, state, sync, er, cb);\n  else {\n    // Check if we\'re actually ready to finish, but don\'t emit yet\n    var finished = needFinish(stream, state);\n\n    if (!finished && !state.bufferProcessing && state.buffer.length)\n      clearBuffer(stream, state);\n\n    if (sync) {\n      process.nextTick(function() {\n        afterWrite(stream, state, finished, cb);\n      });\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished)\n    onwriteDrain(stream, state);\n  cb();\n  if (finished)\n    finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don\'t\n// emit \'drain\' before the write() consumer gets the \'false\' return\n// value, and has a chance to attach a \'drain\' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit(\'drain\');\n  }\n}\n\n\n// if there\'s something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n\n  for (var c = 0; c < state.buffer.length; c++) {\n    var entry = state.buffer[c];\n    var chunk = entry.chunk;\n    var encoding = entry.encoding;\n    var cb = entry.callback;\n    var len = state.objectMode ? 1 : chunk.length;\n\n    doWrite(stream, state, len, chunk, encoding, cb);\n\n    // if we didn\'t call the onwrite immediately, then\n    // it means that we need to wait until it does.\n    // also, that means that the chunk and cb are currently\n    // being processed, so move the buffer counter past them.\n    if (state.writing) {\n      c++;\n      break;\n    }\n  }\n\n  state.bufferProcessing = false;\n  if (c < state.buffer.length)\n    state.buffer = state.buffer.slice(c);\n  else\n    state.buffer.length = 0;\n}\n\nWritable.prototype._write = function(chunk, encoding, cb) {\n  cb(new Error(\'not implemented\'));\n};\n\nWritable.prototype.end = function(chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === \'function\') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === \'function\') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (typeof chunk !== \'undefined\' && chunk !== null)\n    this.write(chunk, encoding);\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished)\n    endWritable(this, state, cb);\n};\n\n\nfunction needFinish(stream, state) {\n  return (state.ending &&\n          state.length === 0 &&\n          !state.finished &&\n          !state.writing);\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(stream, state);\n  if (need) {\n    state.finished = true;\n    stream.emit(\'finish\');\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished)\n      process.nextTick(cb);\n    else\n      stream.once(\'finish\', cb);\n  }\n  state.ended = true;\n}\n\n})(require("__browserify_process"),require("__browserify_buffer").Buffer)\n},{"./_stream_duplex":83,"__browserify_buffer":12,"__browserify_process":13,"assert":59,"stream":32,"util":22}],83:[function(require,module,exports){\n(function(process){// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn\'t have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\nmodule.exports = Duplex;\nvar util = require(\'util\');\nvar Readable = require(\'./_stream_readable\');\nvar Writable = require(\'./_stream_writable\');\n\nutil.inherits(Duplex, Readable);\n\nObject.keys(Writable.prototype).forEach(function(method) {\n  if (!Duplex.prototype[method])\n    Duplex.prototype[method] = Writable.prototype[method];\n});\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex))\n    return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false)\n    this.readable = false;\n\n  if (options && options.writable === false)\n    this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false)\n    this.allowHalfOpen = false;\n\n  this.once(\'end\', onend);\n}\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we\'re ok.\n  if (this.allowHalfOpen || this._writableState.ended)\n    return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  process.nextTick(this.end.bind(this));\n}\n\n})(require("__browserify_process"))\n},{"./_stream_readable":81,"./_stream_writable":82,"__browserify_process":13,"util":22}],84:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it\'s called a "filter",\n// but that\'s not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it\'s not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here\'s how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there\'s a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there\'s enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb\'s as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit \'readable\' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there\'d be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\nmodule.exports = Transform;\n\nvar Duplex = require(\'./_stream_duplex\');\nvar util = require(\'util\');\nutil.inherits(Transform, Duplex);\n\n\nfunction TransformState(options, stream) {\n  this.afterTransform = function(er, data) {\n    return afterTransform(stream, er, data);\n  };\n\n  this.needTransform = false;\n  this.transforming = false;\n  this.writecb = null;\n  this.writechunk = null;\n}\n\nfunction afterTransform(stream, er, data) {\n  var ts = stream._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb)\n    return stream.emit(\'error\', new Error(\'no writecb in Transform class\'));\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data !== null && data !== undefined)\n    stream.push(data);\n\n  if (cb)\n    cb(er);\n\n  var rs = stream._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    stream._read(rs.highWaterMark);\n  }\n}\n\n\nfunction Transform(options) {\n  if (!(this instanceof Transform))\n    return new Transform(options);\n\n  Duplex.call(this, options);\n\n  var ts = this._transformState = new TransformState(options, this);\n\n  // when the writable side finishes, then flush out anything remaining.\n  var stream = this;\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  this.once(\'finish\', function() {\n    if (\'function\' === typeof this._flush)\n      this._flush(function(er) {\n        done(stream, er);\n      });\n    else\n      done(stream);\n  });\n}\n\nTransform.prototype.push = function(chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// \'chunk\' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call \'push\' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that\'ll put the hurt on the whole operation.  If you\n// never call cb(), then you\'ll never get another chunk.\nTransform.prototype._transform = function(chunk, encoding, cb) {\n  throw new Error(\'not implemented\');\n};\n\nTransform.prototype._write = function(chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform ||\n        rs.needReadable ||\n        rs.length < rs.highWaterMark)\n      this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn\'t matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function(n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we\'ve asked for it.\n    ts.needTransform = true;\n  }\n};\n\n\nfunction done(stream, er) {\n  if (er)\n    return stream.emit(\'error\', er);\n\n  // if there\'s nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  var ws = stream._writableState;\n  var rs = stream._readableState;\n  var ts = stream._transformState;\n\n  if (ws.length)\n    throw new Error(\'calling transform done when ws.length != 0\');\n\n  if (ts.transforming)\n    throw new Error(\'calling transform done when still transforming\');\n\n  return stream.push(null);\n}\n\n},{"./_stream_duplex":83,"util":22}],85:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\nmodule.exports = PassThrough;\n\nvar Transform = require(\'./_stream_transform\');\nvar util = require(\'util\');\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough))\n    return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function(chunk, encoding, cb) {\n  cb(null, chunk);\n};\n\n},{"./_stream_transform":84,"util":22}],96:[function(require,module,exports){\n(function () {\n\t"use strict";\n\n\t// modified from https://github.com/kriskowal/es5-shim\n\tvar has = Object.prototype.hasOwnProperty,\n\t\ttoString = Object.prototype.toString,\n\t\tforEach = require(\'./foreach\'),\n\t\tisArgs = require(\'./isArguments\'),\n\t\thasDontEnumBug = !({\'toString\': null}).propertyIsEnumerable(\'toString\'),\n\t\thasProtoEnumBug = (function () {}).propertyIsEnumerable(\'prototype\'),\n\t\tdontEnums = [\n\t\t\t"toString",\n\t\t\t"toLocaleString",\n\t\t\t"valueOf",\n\t\t\t"hasOwnProperty",\n\t\t\t"isPrototypeOf",\n\t\t\t"propertyIsEnumerable",\n\t\t\t"constructor"\n\t\t],\n\t\tkeysShim;\n\n\tkeysShim = function keys(object) {\n\t\tvar isObject = object !== null && typeof object === \'object\',\n\t\t\tisFunction = toString.call(object) === \'[object Function]\',\n\t\t\tisArguments = isArgs(object),\n\t\t\ttheKeys = [];\n\n\t\tif (!isObject && !isFunction && !isArguments) {\n\t\t\tthrow new TypeError("Object.keys called on a non-object");\n\t\t}\n\n\t\tif (isArguments) {\n\t\t\tforEach(object, function (value) {\n\t\t\t\ttheKeys.push(value);\n\t\t\t});\n\t\t} else {\n\t\t\tvar name,\n\t\t\t\tskipProto = hasProtoEnumBug && isFunction;\n\n\t\t\tfor (name in object) {\n\t\t\t\tif (!(skipProto && name === \'prototype\') && has.call(object, name)) {\n\t\t\t\t\ttheKeys.push(name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (hasDontEnumBug) {\n\t\t\tvar ctor = object.constructor,\n\t\t\t\tskipConstructor = ctor && ctor.prototype === object;\n\n\t\t\tforEach(dontEnums, function (dontEnum) {\n\t\t\t\tif (!(skipConstructor && dontEnum === \'constructor\') && has.call(object, dontEnum)) {\n\t\t\t\t\ttheKeys.push(dontEnum);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn theKeys;\n\t};\n\n\tmodule.exports = keysShim;\n}());\n\n\n},{"./foreach":115,"./isArguments":116}],97:[function(require,module,exports){\nmodule.exports = Object.keys || require(\'./shim\');\n\n\n},{"./shim":117}],114:[function(require,module,exports){\nvar proto\n  , map\n\nmodule.exports = proto = {}\n\nmap = typeof WeakMap === \'undefined\' ? null : new WeakMap\n\nproto.get = !map ? no_weakmap_get : get\n\nfunction no_weakmap_get(target) {\n  return new DataView(target.buffer, 0)\n}\n\nfunction get(target) {\n  var out = map.get(target.buffer)\n  if(!out) {\n    map.set(target.buffer, out = new DataView(target.buffer, 0))\n  }\n  return out\n}\n\n},{}],108:[function(require,module,exports){\nmodule.exports = {\n    readUInt8:      read_uint8\n  , readInt8:       read_int8\n  , readUInt16LE:   read_uint16_le\n  , readUInt32LE:   read_uint32_le\n  , readInt16LE:    read_int16_le\n  , readInt32LE:    read_int32_le\n  , readFloatLE:    read_float_le\n  , readDoubleLE:   read_double_le\n  , readUInt16BE:   read_uint16_be\n  , readUInt32BE:   read_uint32_be\n  , readInt16BE:    read_int16_be\n  , readInt32BE:    read_int32_be\n  , readFloatBE:    read_float_be\n  , readDoubleBE:   read_double_be\n}\n\nvar map = require(\'./mapped.js\')\n\nfunction read_uint8(target, at) {\n  return target[at]\n}\n\nfunction read_int8(target, at) {\n  var v = target[at];\n  return v < 0x80 ? v : v - 0x100\n}\n\nfunction read_uint16_le(target, at) {\n  var dv = map.get(target);\n  return dv.getUint16(at + target.byteOffset, true)\n}\n\nfunction read_uint32_le(target, at) {\n  var dv = map.get(target);\n  return dv.getUint32(at + target.byteOffset, true)\n}\n\nfunction read_int16_le(target, at) {\n  var dv = map.get(target);\n  return dv.getInt16(at + target.byteOffset, true)\n}\n\nfunction read_int32_le(target, at) {\n  var dv = map.get(target);\n  return dv.getInt32(at + target.byteOffset, true)\n}\n\nfunction read_float_le(target, at) {\n  var dv = map.get(target);\n  return dv.getFloat32(at + target.byteOffset, true)\n}\n\nfunction read_double_le(target, at) {\n  var dv = map.get(target);\n  return dv.getFloat64(at + target.byteOffset, true)\n}\n\nfunction read_uint16_be(target, at) {\n  var dv = map.get(target);\n  return dv.getUint16(at + target.byteOffset, false)\n}\n\nfunction read_uint32_be(target, at) {\n  var dv = map.get(target);\n  return dv.getUint32(at + target.byteOffset, false)\n}\n\nfunction read_int16_be(target, at) {\n  var dv = map.get(target);\n  return dv.getInt16(at + target.byteOffset, false)\n}\n\nfunction read_int32_be(target, at) {\n  var dv = map.get(target);\n  return dv.getInt32(at + target.byteOffset, false)\n}\n\nfunction read_float_be(target, at) {\n  var dv = map.get(target);\n  return dv.getFloat32(at + target.byteOffset, false)\n}\n\nfunction read_double_be(target, at) {\n  var dv = map.get(target);\n  return dv.getFloat64(at + target.byteOffset, false)\n}\n\n},{"./mapped.js":118}],109:[function(require,module,exports){\nmodule.exports = {\n    writeUInt8:      write_uint8\n  , writeInt8:       write_int8\n  , writeUInt16LE:   write_uint16_le\n  , writeUInt32LE:   write_uint32_le\n  , writeInt16LE:    write_int16_le\n  , writeInt32LE:    write_int32_le\n  , writeFloatLE:    write_float_le\n  , writeDoubleLE:   write_double_le\n  , writeUInt16BE:   write_uint16_be\n  , writeUInt32BE:   write_uint32_be\n  , writeInt16BE:    write_int16_be\n  , writeInt32BE:    write_int32_be\n  , writeFloatBE:    write_float_be\n  , writeDoubleBE:   write_double_be\n}\n\nvar map = require(\'./mapped.js\')\n\nfunction write_uint8(target, value, at) {\n  return target[at] = value\n}\n\nfunction write_int8(target, value, at) {\n  return target[at] = value < 0 ? value + 0x100 : value\n}\n\nfunction write_uint16_le(target, value, at) {\n  var dv = map.get(target);\n  return dv.setUint16(at + target.byteOffset, value, true)\n}\n\nfunction write_uint32_le(target, value, at) {\n  var dv = map.get(target);\n  return dv.setUint32(at + target.byteOffset, value, true)\n}\n\nfunction write_int16_le(target, value, at) {\n  var dv = map.get(target);\n  return dv.setInt16(at + target.byteOffset, value, true)\n}\n\nfunction write_int32_le(target, value, at) {\n  var dv = map.get(target);\n  return dv.setInt32(at + target.byteOffset, value, true)\n}\n\nfunction write_float_le(target, value, at) {\n  var dv = map.get(target);\n  return dv.setFloat32(at + target.byteOffset, value, true)\n}\n\nfunction write_double_le(target, value, at) {\n  var dv = map.get(target);\n  return dv.setFloat64(at + target.byteOffset, value, true)\n}\n\nfunction write_uint16_be(target, value, at) {\n  var dv = map.get(target);\n  return dv.setUint16(at + target.byteOffset, value, false)\n}\n\nfunction write_uint32_be(target, value, at) {\n  var dv = map.get(target);\n  return dv.setUint32(at + target.byteOffset, value, false)\n}\n\nfunction write_int16_be(target, value, at) {\n  var dv = map.get(target);\n  return dv.setInt16(at + target.byteOffset, value, false)\n}\n\nfunction write_int32_be(target, value, at) {\n  var dv = map.get(target);\n  return dv.setInt32(at + target.byteOffset, value, false)\n}\n\nfunction write_float_be(target, value, at) {\n  var dv = map.get(target);\n  return dv.setFloat32(at + target.byteOffset, value, false)\n}\n\nfunction write_double_be(target, value, at) {\n  var dv = map.get(target);\n  return dv.setFloat64(at + target.byteOffset, value, false)\n}\n\n},{"./mapped.js":118}],115:[function(require,module,exports){\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toString = Object.prototype.toString;\n\nvar isFunction = function (fn) {\n\tvar isFunc = (typeof fn === \'function\' && !(fn instanceof RegExp)) || toString.call(fn) === \'[object Function]\';\n\tif (!isFunc && typeof window !== \'undefined\') {\n\t\tisFunc = fn === window.setTimeout || fn === window.alert || fn === window.confirm || fn === window.prompt;\n\t}\n\treturn isFunc;\n};\n\nmodule.exports = function forEach(obj, fn) {\n\tif (!isFunction(fn)) {\n\t\tthrow new TypeError(\'iterator must be a function\');\n\t}\n\tvar i, k,\n\t\tisString = typeof obj === \'string\',\n\t\tl = obj.length,\n\t\tcontext = arguments.length > 2 ? arguments[2] : null;\n\tif (l === +l) {\n\t\tfor (i = 0; i < l; i++) {\n\t\t\tif (context === null) {\n\t\t\t\tfn(isString ? obj.charAt(i) : obj[i], i, obj);\n\t\t\t} else {\n\t\t\t\tfn.call(context, isString ? obj.charAt(i) : obj[i], i, obj);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (k in obj) {\n\t\t\tif (hasOwn.call(obj, k)) {\n\t\t\t\tif (context === null) {\n\t\t\t\t\tfn(obj[k], k, obj);\n\t\t\t\t} else {\n\t\t\t\t\tfn.call(context, obj[k], k, obj);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n\n},{}],116:[function(require,module,exports){\nvar toString = Object.prototype.toString;\n\nmodule.exports = function isArguments(value) {\n\tvar str = toString.call(value);\n\tvar isArguments = str === \'[object Arguments]\';\n\tif (!isArguments) {\n\t\tisArguments = str !== \'[object Array]\'\n\t\t\t&& value !== null\n\t\t\t&& typeof value === \'object\'\n\t\t\t&& typeof value.length === \'number\'\n\t\t\t&& value.length >= 0\n\t\t\t&& toString.call(value.callee) === \'[object Function]\';\n\t}\n\treturn isArguments;\n};\n\n\n},{}],112:[function(require,module,exports){\nmodule.exports = Object.keys || require(\'./shim\');\n\n\n},{"./shim":119}],113:[function(require,module,exports){\n(function () {\n\t"use strict";\n\n\t// modified from https://github.com/kriskowal/es5-shim\n\tvar has = Object.prototype.hasOwnProperty,\n\t\ttoString = Object.prototype.toString,\n\t\tforEach = require(\'./foreach\'),\n\t\tisArgs = require(\'./isArguments\'),\n\t\thasDontEnumBug = !({\'toString\': null}).propertyIsEnumerable(\'toString\'),\n\t\thasProtoEnumBug = (function () {}).propertyIsEnumerable(\'prototype\'),\n\t\tdontEnums = [\n\t\t\t"toString",\n\t\t\t"toLocaleString",\n\t\t\t"valueOf",\n\t\t\t"hasOwnProperty",\n\t\t\t"isPrototypeOf",\n\t\t\t"propertyIsEnumerable",\n\t\t\t"constructor"\n\t\t],\n\t\tkeysShim;\n\n\tkeysShim = function keys(object) {\n\t\tvar isObject = object !== null && typeof object === \'object\',\n\t\t\tisFunction = toString.call(object) === \'[object Function]\',\n\t\t\tisArguments = isArgs(object),\n\t\t\ttheKeys = [];\n\n\t\tif (!isObject && !isFunction && !isArguments) {\n\t\t\tthrow new TypeError("Object.keys called on a non-object");\n\t\t}\n\n\t\tif (isArguments) {\n\t\t\tforEach(object, function (value) {\n\t\t\t\ttheKeys.push(value);\n\t\t\t});\n\t\t} else {\n\t\t\tvar name,\n\t\t\t\tskipProto = hasProtoEnumBug && isFunction;\n\n\t\t\tfor (name in object) {\n\t\t\t\tif (!(skipProto && name === \'prototype\') && has.call(object, name)) {\n\t\t\t\t\ttheKeys.push(name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (hasDontEnumBug) {\n\t\t\tvar ctor = object.constructor,\n\t\t\t\tskipConstructor = ctor && ctor.prototype === object;\n\n\t\t\tforEach(dontEnums, function (dontEnum) {\n\t\t\t\tif (!(skipConstructor && dontEnum === \'constructor\') && has.call(object, dontEnum)) {\n\t\t\t\t\ttheKeys.push(dontEnum);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn theKeys;\n\t};\n\n\tmodule.exports = keysShim;\n}());\n\n\n},{"./foreach":120,"./isArguments":121}],118:[function(require,module,exports){\nvar proto\n  , map\n\nmodule.exports = proto = {}\n\nmap = typeof WeakMap === \'undefined\' ? null : new WeakMap\n\nproto.get = !map ? no_weakmap_get : get\n\nfunction no_weakmap_get(target) {\n  return new DataView(target.buffer, 0)\n}\n\nfunction get(target) {\n  var out = map.get(target.buffer)\n  if(!out) {\n    map.set(target.buffer, out = new DataView(target.buffer, 0))\n  }\n  return out\n}\n\n},{}],120:[function(require,module,exports){\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toString = Object.prototype.toString;\n\nvar isFunction = function (fn) {\n\tvar isFunc = (typeof fn === \'function\' && !(fn instanceof RegExp)) || toString.call(fn) === \'[object Function]\';\n\tif (!isFunc && typeof window !== \'undefined\') {\n\t\tisFunc = fn === window.setTimeout || fn === window.alert || fn === window.confirm || fn === window.prompt;\n\t}\n\treturn isFunc;\n};\n\nmodule.exports = function forEach(obj, fn) {\n\tif (!isFunction(fn)) {\n\t\tthrow new TypeError(\'iterator must be a function\');\n\t}\n\tvar i, k,\n\t\tisString = typeof obj === \'string\',\n\t\tl = obj.length,\n\t\tcontext = arguments.length > 2 ? arguments[2] : null;\n\tif (l === +l) {\n\t\tfor (i = 0; i < l; i++) {\n\t\t\tif (context === null) {\n\t\t\t\tfn(isString ? obj.charAt(i) : obj[i], i, obj);\n\t\t\t} else {\n\t\t\t\tfn.call(context, isString ? obj.charAt(i) : obj[i], i, obj);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (k in obj) {\n\t\t\tif (hasOwn.call(obj, k)) {\n\t\t\t\tif (context === null) {\n\t\t\t\t\tfn(obj[k], k, obj);\n\t\t\t\t} else {\n\t\t\t\t\tfn.call(context, obj[k], k, obj);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n\n},{}],121:[function(require,module,exports){\nvar toString = Object.prototype.toString;\n\nmodule.exports = function isArguments(value) {\n\tvar str = toString.call(value);\n\tvar isArguments = str === \'[object Arguments]\';\n\tif (!isArguments) {\n\t\tisArguments = str !== \'[object Array]\'\n\t\t\t&& value !== null\n\t\t\t&& typeof value === \'object\'\n\t\t\t&& typeof value.length === \'number\'\n\t\t\t&& value.length >= 0\n\t\t\t&& toString.call(value.callee) === \'[object Function]\';\n\t}\n\treturn isArguments;\n};\n\n\n},{}],95:[function(require,module,exports){\nconst prr = require(\'prr\')\n\nfunction init (type, message, cause) {\n  prr(this, {\n      type    : type\n    , name    : type\n      // can be passed just a \'cause\'\n    , cause   : typeof message != \'string\' ? message : cause\n    , message : !!message && typeof message != \'string\' ? message.message : message\n\n  }, \'ewr\')\n}\n\n// generic prototype, not intended to be actually used - helpful for `instanceof`\nfunction CustomError (message, cause) {\n  Error.call(this)\n  if (Error.captureStackTrace)\n    Error.captureStackTrace(this, arguments.callee)\n  init.call(this, \'CustomError\', message, cause)\n}\n\nCustomError.prototype = new Error()\n\nfunction createError (errno, type, proto) {\n  var err = function (message, cause) {\n    init.call(this, type, message, cause)\n    //TODO: the specificity here is stupid, errno should be available everywhere\n    if (type == \'FilesystemError\') {\n      this.code    = this.cause.code\n      this.path    = this.cause.path\n      this.errno   = this.cause.errno\n      this.message =\n        (errno.errno[this.cause.errno]\n          ? errno.errno[this.cause.errno].description\n          : this.cause.message)\n        + (this.cause.path ? \' [\' + this.cause.path + \']\' : \'\')\n    }\n    Error.call(this)\n    if (Error.captureStackTrace)\n      Error.captureStackTrace(this, arguments.callee)\n  }\n  err.prototype = !!proto ? new proto() : new CustomError()\n  return err\n}\n\nmodule.exports = function (errno) {\n  var ce = function (type, proto) {\n    return createError(errno, type, proto)\n  }\n  return {\n      CustomError     : CustomError\n    , FilesystemError : ce(\'FilesystemError\')\n    , createError     : ce\n  }\n}\n\n},{"prr":40}],81:[function(require,module,exports){\n(function(process,Buffer){// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Readable;\nReadable.ReadableState = ReadableState;\n\nvar EE = require(\'events\').EventEmitter;\nif (!EE.listenerCount) EE.listenerCount = function(emitter, type) {\n  return emitter.listeners(type).length;\n};\nvar Stream = require(\'stream\');\nvar util = require(\'util\');\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nfunction ReadableState(options, stream) {\n  options = options || {};\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means "don\'t call _read preemptively ever"\n  var hwm = options.highWaterMark;\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;\n\n  // cast to ints.\n  this.highWaterMark = ~~this.highWaterMark;\n\n  this.buffer = [];\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = false;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // In streams that never have any data, and do push(null) right away,\n  // the consumer can miss the \'end\' event if they do some I/O before\n  // consuming the stream.  So, we don\'t emit(\'end\') until some reading\n  // happens.\n  this.calledRead = false;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, becuase any\n  // actions that shouldn\'t happen until "later" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we\'re awaiting a \'readable\' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is \'binary\' so we have to make this configurable.\n  // Everything else in the universe uses \'utf8\', though.\n  this.defaultEncoding = options.defaultEncoding || \'utf8\';\n\n  // when piping, we only care about \'readable\' events that happen\n  // after read()ing all the bytes and not getting any pushback.\n  this.ranOut = false;\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder)\n      StringDecoder = require(\'string_decoder/\').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  if (!(this instanceof Readable))\n    return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  Stream.call(this);\n}\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function(chunk, encoding) {\n  var state = this._readableState;\n\n  if (typeof chunk === \'string\' && !state.objectMode) {\n    encoding = encoding || state.defaultEncoding;\n    if (encoding !== state.encoding) {\n      chunk = new Buffer(chunk, encoding);\n      encoding = \'\';\n    }\n  }\n\n  return readableAddChunk(this, state, chunk, encoding, false);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function(chunk) {\n  var state = this._readableState;\n  return readableAddChunk(this, state, chunk, \'\', true);\n};\n\nfunction readableAddChunk(stream, state, chunk, encoding, addToFront) {\n  var er = chunkInvalid(state, chunk);\n  if (er) {\n    stream.emit(\'error\', er);\n  } else if (chunk === null || chunk === undefined) {\n    state.reading = false;\n    if (!state.ended)\n      onEofChunk(stream, state);\n  } else if (state.objectMode || chunk && chunk.length > 0) {\n    if (state.ended && !addToFront) {\n      var e = new Error(\'stream.push() after EOF\');\n      stream.emit(\'error\', e);\n    } else if (state.endEmitted && addToFront) {\n      var e = new Error(\'stream.unshift() after end event\');\n      stream.emit(\'error\', e);\n    } else {\n      if (state.decoder && !addToFront && !encoding)\n        chunk = state.decoder.write(chunk);\n\n      // update the buffer info.\n      state.length += state.objectMode ? 1 : chunk.length;\n      if (addToFront) {\n        state.buffer.unshift(chunk);\n      } else {\n        state.reading = false;\n        state.buffer.push(chunk);\n      }\n\n      if (state.needReadable)\n        emitReadable(stream);\n\n      maybeReadMore(stream, state);\n    }\n  } else if (!addToFront) {\n    state.reading = false;\n  }\n\n  return needMoreData(state);\n}\n\n\n\n// if it\'s past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// \'readable\' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended &&\n         (state.needReadable ||\n          state.length < state.highWaterMark ||\n          state.length === 0);\n}\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function(enc) {\n  if (!StringDecoder)\n    StringDecoder = require(\'string_decoder/\').StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n};\n\n// Don\'t raise the hwm > 128MB\nvar MAX_HWM = 0x800000;\nfunction roundUpToNextPowerOf2(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2\n    n--;\n    for (var p = 1; p < 32; p <<= 1) n |= n >> p;\n    n++;\n  }\n  return n;\n}\n\nfunction howMuchToRead(n, state) {\n  if (state.length === 0 && state.ended)\n    return 0;\n\n  if (state.objectMode)\n    return n === 0 ? 0 : 1;\n\n  if (isNaN(n) || n === null) {\n    // only flow one buffer at a time\n    if (state.flowing && state.buffer.length)\n      return state.buffer[0].length;\n    else\n      return state.length;\n  }\n\n  if (n <= 0)\n    return 0;\n\n  // If we\'re asking for more than the target buffer level,\n  // then raise the water mark.  Bump up to the next highest\n  // power of 2, to prevent increasing it excessively in tiny\n  // amounts.\n  if (n > state.highWaterMark)\n    state.highWaterMark = roundUpToNextPowerOf2(n);\n\n  // don\'t have that much.  return null, unless we\'ve ended.\n  if (n > state.length) {\n    if (!state.ended) {\n      state.needReadable = true;\n      return 0;\n    } else\n      return state.length;\n  }\n\n  return n;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function(n) {\n  var state = this._readableState;\n  state.calledRead = true;\n  var nOrig = n;\n\n  if (typeof n !== \'number\' || n > 0)\n    state.emittedReadable = false;\n\n  // if we\'re doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the \'readable\' event and move on.\n  if (n === 0 &&\n      state.needReadable &&\n      (state.length >= state.highWaterMark || state.ended)) {\n    emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we\'ve ended, and we\'re now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0)\n      endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn\'t mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it\'s safe to emit\n  // \'readable\' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length - n <= state.highWaterMark)\n    doRead = true;\n\n  // however, if we\'ve ended, then there\'s no point, and if we\'re already\n  // reading, then it\'s unnecessary.\n  if (state.ended || state.reading)\n    doRead = false;\n\n  if (doRead) {\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0)\n      state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n  }\n\n  // If _read called its callback synchronously, then `reading`\n  // will be false, and we need to re-evaluate how much data we\n  // can return to the user.\n  if (doRead && !state.reading)\n    n = howMuchToRead(nOrig, state);\n\n  var ret;\n  if (n > 0)\n    ret = fromList(n, state);\n  else\n    ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  }\n\n  state.length -= n;\n\n  // If we have nothing in the buffer, then we want to know\n  // as soon as we *do* get something into the buffer.\n  if (state.length === 0 && !state.ended)\n    state.needReadable = true;\n\n  // If we happened to read() exactly the remaining amount in the\n  // buffer, and the EOF has been seen at this point, then make sure\n  // that we emit \'end\' on the very next tick.\n  if (state.ended && !state.endEmitted && state.length === 0)\n    endReadable(this);\n\n  return ret;\n};\n\nfunction chunkInvalid(state, chunk) {\n  var er = null;\n  if (!Buffer.isBuffer(chunk) &&\n      \'string\' !== typeof chunk &&\n      chunk !== null &&\n      chunk !== undefined &&\n      !state.objectMode &&\n      !er) {\n    er = new TypeError(\'Invalid non-string/buffer chunk\');\n  }\n  return er;\n}\n\n\nfunction onEofChunk(stream, state) {\n  if (state.decoder && !state.ended) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // if we\'ve ended and we have some data left, then emit\n  // \'readable\' now to make sure it gets picked up.\n  if (state.length > 0)\n    emitReadable(stream);\n  else\n    endReadable(stream);\n}\n\n// Don\'t emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that\'s not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (state.emittedReadable)\n    return;\n\n  state.emittedReadable = true;\n  if (state.sync)\n    process.nextTick(function() {\n      emitReadable_(stream);\n    });\n  else\n    emitReadable_(stream);\n}\n\nfunction emitReadable_(stream) {\n  stream.emit(\'readable\');\n}\n\n\n// at this point, the user has presumably seen the \'readable\' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it\'s in progress.\n// However, if we\'re not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(function() {\n      maybeReadMore_(stream, state);\n    });\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended &&\n         state.length < state.highWaterMark) {\n    stream.read(0);\n    if (len === state.length)\n      // didn\'t get any data, stop spinning.\n      break;\n    else\n      len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, "length" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function(n) {\n  this.emit(\'error\', new Error(\'not implemented\'));\n};\n\nReadable.prototype.pipe = function(dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&\n              dest !== process.stdout &&\n              dest !== process.stderr;\n\n  var endFn = doEnd ? onend : cleanup;\n  if (state.endEmitted)\n    process.nextTick(endFn);\n  else\n    src.once(\'end\', endFn);\n\n  dest.on(\'unpipe\', onunpipe);\n  function onunpipe(readable) {\n    if (readable !== src) return;\n    cleanup();\n  }\n\n  function onend() {\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on(\'drain\', ondrain);\n\n  function cleanup() {\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener(\'close\', onclose);\n    dest.removeListener(\'finish\', onfinish);\n    dest.removeListener(\'drain\', ondrain);\n    dest.removeListener(\'error\', onerror);\n    dest.removeListener(\'unpipe\', onunpipe);\n    src.removeListener(\'end\', onend);\n    src.removeListener(\'end\', cleanup);\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don\'t know, then assume that we are waiting for one.\n    if (!dest._writableState || dest._writableState.needDrain)\n      ondrain();\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don\'t suppress the throwing behavior for this.\n  function onerror(er) {\n    unpipe();\n    dest.removeListener(\'error\', onerror);\n    if (EE.listenerCount(dest, \'error\') === 0)\n      dest.emit(\'error\', er);\n  }\n  // This is a brutally ugly hack to make sure that our error handler\n  // is attached before any userland ones.  NEVER DO THIS.\n  if (!dest._events || !dest._events.error)\n    dest.on(\'error\', onerror);\n  else if (Array.isArray(dest._events.error))\n    dest._events.error.unshift(onerror);\n  else\n    dest._events.error = [onerror, dest._events.error];\n\n\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener(\'finish\', onfinish);\n    unpipe();\n  }\n  dest.once(\'close\', onclose);\n  function onfinish() {\n    dest.removeListener(\'close\', onclose);\n    unpipe();\n  }\n  dest.once(\'finish\', onfinish);\n\n  function unpipe() {\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it\'s being piped to\n  dest.emit(\'pipe\', src);\n\n  // start the flow if it hasn\'t been started already.\n  if (!state.flowing) {\n    // the handler that waits for readable events after all\n    // the data gets sucked out in flow.\n    // This would be easier to follow with a .once() handler\n    // in flow(), but that is too slow.\n    this.on(\'readable\', pipeOnReadable);\n\n    state.flowing = true;\n    process.nextTick(function() {\n      flow(src);\n    });\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function() {\n    var dest = this;\n    var state = src._readableState;\n    state.awaitDrain--;\n    if (state.awaitDrain === 0)\n      flow(src);\n  };\n}\n\nfunction flow(src) {\n  var state = src._readableState;\n  var chunk;\n  state.awaitDrain = 0;\n\n  function write(dest, i, list) {\n    var written = dest.write(chunk);\n    if (false === written) {\n      state.awaitDrain++;\n    }\n  }\n\n  while (state.pipesCount && null !== (chunk = src.read())) {\n\n    if (state.pipesCount === 1)\n      write(state.pipes, 0, null);\n    else\n      state.pipes.forEach(write);\n\n    src.emit(\'data\', chunk);\n\n    // if anyone needs a drain, then we have to wait for that.\n    if (state.awaitDrain > 0)\n      return;\n  }\n\n  // if every destination was unpiped, either before entering this\n  // function, or in the while loop, then stop flowing.\n  //\n  // NB: This is a pretty rare edge case.\n  if (state.pipesCount === 0) {\n    state.flowing = false;\n\n    // if there were data event listeners added, then switch to old mode.\n    if (EE.listenerCount(src, \'data\') > 0)\n      emitDataEvents(src);\n    return;\n  }\n\n  // at this point, no one needed a drain, so we just ran out of data\n  // on the next readable event, start it over again.\n  state.ranOut = true;\n}\n\nfunction pipeOnReadable() {\n  if (this._readableState.ranOut) {\n    this._readableState.ranOut = false;\n    flow(this);\n  }\n}\n\n\nReadable.prototype.unpipe = function(dest) {\n  var state = this._readableState;\n\n  // if we\'re not piping anywhere, then do nothing.\n  if (state.pipesCount === 0)\n    return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it\'s not the right one.\n    if (dest && dest !== state.pipes)\n      return this;\n\n    if (!dest)\n      dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    this.removeListener(\'readable\', pipeOnReadable);\n    state.flowing = false;\n    if (dest)\n      dest.emit(\'unpipe\', this);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    this.removeListener(\'readable\', pipeOnReadable);\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++)\n      dests[i].emit(\'unpipe\', this);\n    return this;\n  }\n\n  // try to find the right one.\n  var i = state.pipes.indexOf(dest);\n  if (i === -1)\n    return this;\n\n  state.pipes.splice(i, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1)\n    state.pipes = state.pipes[0];\n\n  dest.emit(\'unpipe\', this);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function(ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  if (ev === \'data\' && !this._readableState.flowing)\n    emitDataEvents(this);\n\n  if (ev === \'readable\' && this.readable) {\n    var state = this._readableState;\n    if (!state.readableListening) {\n      state.readableListening = true;\n      state.emittedReadable = false;\n      state.needReadable = true;\n      if (!state.reading) {\n        this.read(0);\n      } else if (state.length) {\n        emitReadable(this, state);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function() {\n  emitDataEvents(this);\n  this.read(0);\n  this.emit(\'resume\');\n};\n\nReadable.prototype.pause = function() {\n  emitDataEvents(this, true);\n  this.emit(\'pause\');\n};\n\nfunction emitDataEvents(stream, startPaused) {\n  var state = stream._readableState;\n\n  if (state.flowing) {\n    // https://github.com/isaacs/readable-stream/issues/16\n    throw new Error(\'Cannot switch to old mode now.\');\n  }\n\n  var paused = startPaused || false;\n  var readable = false;\n\n  // convert to an old-style stream.\n  stream.readable = true;\n  stream.pipe = Stream.prototype.pipe;\n  stream.on = stream.addListener = Stream.prototype.on;\n\n  stream.on(\'readable\', function() {\n    readable = true;\n\n    var c;\n    while (!paused && (null !== (c = stream.read())))\n      stream.emit(\'data\', c);\n\n    if (c === null) {\n      readable = false;\n      stream._readableState.needReadable = true;\n    }\n  });\n\n  stream.pause = function() {\n    paused = true;\n    this.emit(\'pause\');\n  };\n\n  stream.resume = function() {\n    paused = false;\n    if (readable)\n      process.nextTick(function() {\n        stream.emit(\'readable\');\n      });\n    else\n      this.read(0);\n    this.emit(\'resume\');\n  };\n\n  // now make it start, just in case it hadn\'t already.\n  stream.emit(\'readable\');\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function(stream) {\n  var state = this._readableState;\n  var paused = false;\n\n  var self = this;\n  stream.on(\'end\', function() {\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length)\n        self.push(chunk);\n    }\n\n    self.push(null);\n  });\n\n  stream.on(\'data\', function(chunk) {\n    if (state.decoder)\n      chunk = state.decoder.write(chunk);\n    if (!chunk || !state.objectMode && !chunk.length)\n      return;\n\n    var ret = self.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (typeof stream[i] === \'function\' &&\n        typeof this[i] === \'undefined\') {\n      this[i] = function(method) { return function() {\n        return stream[method].apply(stream, arguments);\n      }}(i);\n    }\n  }\n\n  // proxy certain important events.\n  var events = [\'error\', \'close\', \'destroy\', \'pause\', \'resume\'];\n  events.forEach(function(ev) {\n    stream.on(ev, self.emit.bind(self, ev));\n  });\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  self._read = function(n) {\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return self;\n};\n\n\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\nfunction fromList(n, state) {\n  var list = state.buffer;\n  var length = state.length;\n  var stringMode = !!state.decoder;\n  var objectMode = !!state.objectMode;\n  var ret;\n\n  // nothing in the list, definitely empty.\n  if (list.length === 0)\n    return null;\n\n  if (length === 0)\n    ret = null;\n  else if (objectMode)\n    ret = list.shift();\n  else if (!n || n >= length) {\n    // read it all, truncate the array.\n    if (stringMode)\n      ret = list.join(\'\');\n    else\n      ret = Buffer.concat(list, length);\n    list.length = 0;\n  } else {\n    // read just some of it.\n    if (n < list[0].length) {\n      // just take a part of the first list item.\n      // slice is the same for buffers and strings.\n      var buf = list[0];\n      ret = buf.slice(0, n);\n      list[0] = buf.slice(n);\n    } else if (n === list[0].length) {\n      // first list is a perfect match\n      ret = list.shift();\n    } else {\n      // complex case.\n      // we have enough to cover it, but it spans past the first buffer.\n      if (stringMode)\n        ret = \'\';\n      else\n        ret = new Buffer(n);\n\n      var c = 0;\n      for (var i = 0, l = list.length; i < l && c < n; i++) {\n        var buf = list[0];\n        var cpy = Math.min(n - c, buf.length);\n\n        if (stringMode)\n          ret += buf.slice(0, cpy);\n        else\n          buf.copy(ret, c, 0, cpy);\n\n        if (cpy < buf.length)\n          list[0] = buf.slice(cpy);\n        else\n          list.shift();\n\n        c += cpy;\n      }\n    }\n  }\n\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0)\n    throw new Error(\'endReadable called on non-empty stream\');\n\n  if (!state.endEmitted && state.calledRead) {\n    state.ended = true;\n    process.nextTick(function() {\n      // Check that we didn\'t get one last unshift.\n      if (!state.endEmitted && state.length === 0) {\n        state.endEmitted = true;\n        stream.readable = false;\n        stream.emit(\'end\');\n      }\n    });\n  }\n}\n\n})(require("__browserify_process"),require("__browserify_buffer").Buffer)\n},{"__browserify_buffer":12,"__browserify_process":13,"events":23,"stream":32,"string_decoder/":122,"util":22}],86:[function(require,module,exports){\nmodule.exports = from\n\nvar base64 = require(\'base64-js\')\n\nvar decoders = {\n    hex: from_hex\n  , utf8: from_utf\n  , base64: from_base64\n}\n\nfunction from(source, encoding) {\n  if(Array.isArray(source)) {\n    return new Uint8Array(source)\n  }\n\n  return decoders[encoding || \'utf8\'](source)\n}\n\nfunction from_hex(str) {\n  var size = str.length / 2\n    , buf = new Uint8Array(size)\n    , character = \'\'\n\n  for(var i = 0, len = str.length; i < len; ++i) {\n    character += str.charAt(i)\n\n    if(i > 0 && (i % 2) === 1) {\n      buf[i>>>1] = parseInt(character, 16)\n      character = \'\' \n    }\n  }\n\n  return buf \n}\n\nfunction from_utf(str) {\n  var arr = []\n    , code\n\n  for(var i = 0, len = str.length; i < len; ++i) {\n    code = fixed_cca(str, i)\n\n    if(code === false) {\n      continue\n    }\n\n    if(code < 0x80) {\n      arr[arr.length] = code\n\n      continue\n    }\n\n    codepoint_to_bytes(arr, code)\n  }\n\n  return new Uint8Array(arr)\n}\n\nfunction codepoint_to_bytes(arr, code) {\n  // find MSB, use that to determine byte count\n  var copy_code = code\n    , bit_count = 0\n    , byte_count\n    , prefix\n    , _byte\n    , pos\n\n  do {\n    ++bit_count\n  } while(copy_code >>>= 1)\n\n  byte_count = Math.ceil((bit_count - 1) / 5) | 0\n  prefix = [0, 0, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc][byte_count]\n  pos = [0, 0, 3, 4, 5, 6, 7][byte_count]\n\n  _byte |= prefix\n\n  bit_count = (7 - pos) + 6 * (byte_count - 1)\n\n  while(bit_count) {\n    _byte |= +!!(code & (1 << bit_count)) << (7 - pos)\n    ++pos\n\n    if(pos % 8 === 0) {\n      arr[arr.length] = _byte\n      _byte = 0x80\n      pos = 2\n    }\n\n    --bit_count\n  }\n\n  if(pos) {\n    _byte |= +!!(code & 1) << (7 - pos)\n    arr[arr.length] = _byte\n  }\n}\n\nfunction pad(str) {\n  while(str.length < 8) {\n    str = \'0\' + str\n  }\n\n  return str\n}\n\nfunction fixed_cca(str, idx) {\n  idx = idx || 0\n\n  var code = str.charCodeAt(idx)\n    , lo\n    , hi\n\n  if(0xD800 <= code && code <= 0xDBFF) {\n    lo = str.charCodeAt(idx + 1)\n    hi = code\n\n    if(isNaN(lo)) {\n      throw new Error(\'High surrogate not followed by low surrogate\')\n    }\n\n    return ((hi - 0xD800) * 0x400) + (lo - 0xDC00) + 0x10000\n  }\n\n  if(0xDC00 <= code && code <= 0xDFFF) {\n    return false\n  }\n\n  return code\n}\n\nfunction from_base64(str) {\n  return new Uint8Array(base64.toByteArray(str)) \n}\n\n},{"base64-js":123}],87:[function(require,module,exports){\nmodule.exports = to\n\nvar base64 = require(\'base64-js\')\n  , toutf8 = require(\'to-utf8\')\n\nvar encoders = {\n    hex: to_hex\n  , utf8: to_utf\n  , base64: to_base64\n}\n\nfunction to(buf, encoding) {\n  return encoders[encoding || \'utf8\'](buf)\n}\n\nfunction to_hex(buf) {\n  var str = \'\'\n    , byt\n\n  for(var i = 0, len = buf.length; i < len; ++i) {\n    byt = buf[i]\n    str += ((byt & 0xF0) >>> 4).toString(16)\n    str += (byt & 0x0F).toString(16)\n  }\n\n  return str\n}\n\nfunction to_utf(buf) {\n  return toutf8(buf)\n}\n\nfunction to_base64(buf) {\n  return base64.fromByteArray(buf)\n}\n\n\n},{"base64-js":123,"to-utf8":124}],122:[function(require,module,exports){\n(function(){// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar Buffer = require(\'buffer\').Buffer;\n\nvar isBufferEncoding = Buffer.isEncoding\n  || function(encoding) {\n       switch (encoding && encoding.toLowerCase()) {\n         case \'hex\': case \'utf8\': case \'utf-8\': case \'ascii\': case \'binary\': case \'base64\': case \'ucs2\': case \'ucs-2\': case \'utf16le\': case \'utf-16le\': case \'raw\': return true;\n         default: return false;\n       }\n     }\n\n\nfunction assertEncoding(encoding) {\n  if (encoding && !isBufferEncoding(encoding)) {\n    throw new Error(\'Unknown encoding: \' + encoding);\n  }\n}\n\nvar StringDecoder = exports.StringDecoder = function(encoding) {\n  this.encoding = (encoding || \'utf8\').toLowerCase().replace(/[-_]/, \'\');\n  assertEncoding(encoding);\n  switch (this.encoding) {\n    case \'utf8\':\n      // CESU-8 represents each of Surrogate Pair by 3-bytes\n      this.surrogateSize = 3;\n      break;\n    case \'ucs2\':\n    case \'utf16le\':\n      // UTF-16 represents each of Surrogate Pair by 2-bytes\n      this.surrogateSize = 2;\n      this.detectIncompleteChar = utf16DetectIncompleteChar;\n      break;\n    case \'base64\':\n      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.\n      this.surrogateSize = 3;\n      this.detectIncompleteChar = base64DetectIncompleteChar;\n      break;\n    default:\n      this.write = passThroughWrite;\n      return;\n  }\n\n  this.charBuffer = new Buffer(6);\n  this.charReceived = 0;\n  this.charLength = 0;\n};\n\n\nStringDecoder.prototype.write = function(buffer) {\n  var charStr = \'\';\n  var offset = 0;\n\n  // if our last write ended with an incomplete multibyte character\n  while (this.charLength) {\n    // determine how many remaining bytes this buffer has to offer for this char\n    var i = (buffer.length >= this.charLength - this.charReceived) ?\n                this.charLength - this.charReceived :\n                buffer.length;\n\n    // add the new bytes to the char buffer\n    buffer.copy(this.charBuffer, this.charReceived, offset, i);\n    this.charReceived += (i - offset);\n    offset = i;\n\n    if (this.charReceived < this.charLength) {\n      // still not enough chars in this buffer? wait for more ...\n      return \'\';\n    }\n\n    // get the character that was split\n    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);\n\n    // lead surrogate (D800-DBFF) is also the incomplete character\n    var charCode = charStr.charCodeAt(charStr.length - 1);\n    if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n      this.charLength += this.surrogateSize;\n      charStr = \'\';\n      continue;\n    }\n    this.charReceived = this.charLength = 0;\n\n    // if there are no more bytes in this buffer, just emit our char\n    if (i == buffer.length) return charStr;\n\n    // otherwise cut off the characters end from the beginning of this buffer\n    buffer = buffer.slice(i, buffer.length);\n    break;\n  }\n\n  var lenIncomplete = this.detectIncompleteChar(buffer);\n\n  var end = buffer.length;\n  if (this.charLength) {\n    // buffer the incomplete character bytes we got\n    buffer.copy(this.charBuffer, 0, buffer.length - lenIncomplete, end);\n    this.charReceived = lenIncomplete;\n    end -= lenIncomplete;\n  }\n\n  charStr += buffer.toString(this.encoding, 0, end);\n\n  var end = charStr.length - 1;\n  var charCode = charStr.charCodeAt(end);\n  // lead surrogate (D800-DBFF) is also the incomplete character\n  if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n    var size = this.surrogateSize;\n    this.charLength += size;\n    this.charReceived += size;\n    this.charBuffer.copy(this.charBuffer, size, 0, size);\n    this.charBuffer.write(charStr.charAt(charStr.length - 1), this.encoding);\n    return charStr.substring(0, end);\n  }\n\n  // or just emit the charStr\n  return charStr;\n};\n\nStringDecoder.prototype.detectIncompleteChar = function(buffer) {\n  // determine how many bytes we have to check at the end of this buffer\n  var i = (buffer.length >= 3) ? 3 : buffer.length;\n\n  // Figure out if one of the last i bytes of our buffer announces an\n  // incomplete char.\n  for (; i > 0; i--) {\n    var c = buffer[buffer.length - i];\n\n    // See http://en.wikipedia.org/wiki/UTF-8#Description\n\n    // 110XXXXX\n    if (i == 1 && c >> 5 == 0x06) {\n      this.charLength = 2;\n      break;\n    }\n\n    // 1110XXXX\n    if (i <= 2 && c >> 4 == 0x0E) {\n      this.charLength = 3;\n      break;\n    }\n\n    // 11110XXX\n    if (i <= 3 && c >> 3 == 0x1E) {\n      this.charLength = 4;\n      break;\n    }\n  }\n\n  return i;\n};\n\nStringDecoder.prototype.end = function(buffer) {\n  var res = \'\';\n  if (buffer && buffer.length)\n    res = this.write(buffer);\n\n  if (this.charReceived) {\n    var cr = this.charReceived;\n    var buf = this.charBuffer;\n    var enc = this.encoding;\n    res += buf.slice(0, cr).toString(enc);\n  }\n\n  return res;\n};\n\nfunction passThroughWrite(buffer) {\n  return buffer.toString(this.encoding);\n}\n\nfunction utf16DetectIncompleteChar(buffer) {\n  var incomplete = this.charReceived = buffer.length % 2;\n  this.charLength = incomplete ? 2 : 0;\n  return incomplete;\n}\n\nfunction base64DetectIncompleteChar(buffer) {\n  var incomplete = this.charReceived = buffer.length % 3;\n  this.charLength = incomplete ? 3 : 0;\n  return incomplete;\n}\n\n})()\n},{"buffer":43}],123:[function(require,module,exports){\n(function (exports) {\n\t\'use strict\';\n\n\tvar lookup = \'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\';\n\n\tfunction b64ToByteArray(b64) {\n\t\tvar i, j, l, tmp, placeHolders, arr;\n\t\n\t\tif (b64.length % 4 > 0) {\n\t\t\tthrow \'Invalid string. Length must be a multiple of 4\';\n\t\t}\n\n\t\t// the number of equal signs (place holders)\n\t\t// if there are two placeholders, than the two characters before it\n\t\t// represent one byte\n\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t// this is just a cheap hack to not do indexOf twice\n\t\tplaceHolders = b64.indexOf(\'=\');\n\t\tplaceHolders = placeHolders > 0 ? b64.length - placeHolders : 0;\n\n\t\t// base64 is 4/3 + up to two characters of the original data\n\t\tarr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);\n\n\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length;\n\n\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);\n\t\t\tarr.push((tmp & 0xFF0000) >> 16);\n\t\t\tarr.push((tmp & 0xFF00) >> 8);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t}\n\n\t\tif (placeHolders === 2) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t} else if (placeHolders === 1) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);\n\t\t\tarr.push((tmp >> 8) & 0xFF);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t}\n\n\t\treturn arr;\n\t}\n\n\tfunction uint8ToBase64(uint8) {\n\t\tvar i,\n\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\toutput = "",\n\t\t\ttemp, length;\n\n\t\tfunction tripletToBase64 (num) {\n\t\t\treturn lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n\t\t};\n\n\t\t// go through the array every three bytes, we\'ll deal with trailing stuff later\n\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);\n\t\t\toutput += tripletToBase64(temp);\n\t\t}\n\n\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\tswitch (extraBytes) {\n\t\t\tcase 1:\n\t\t\t\ttemp = uint8[uint8.length - 1];\n\t\t\t\toutput += lookup[temp >> 2];\n\t\t\t\toutput += lookup[(temp << 4) & 0x3F];\n\t\t\t\toutput += \'==\';\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);\n\t\t\t\toutput += lookup[temp >> 10];\n\t\t\t\toutput += lookup[(temp >> 4) & 0x3F];\n\t\t\t\toutput += lookup[(temp << 2) & 0x3F];\n\t\t\t\toutput += \'=\';\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn output;\n\t}\n\n\tmodule.exports.toByteArray = b64ToByteArray;\n\tmodule.exports.fromByteArray = uint8ToBase64;\n}());\n\n},{}],124:[function(require,module,exports){\nmodule.exports = to_utf8\n\nvar out = []\n  , col = []\n  , fcc = String.fromCharCode\n  , mask = [0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01]\n  , unmask = [\n      0x00\n    , 0x01\n    , 0x02 | 0x01\n    , 0x04 | 0x02 | 0x01\n    , 0x08 | 0x04 | 0x02 | 0x01\n    , 0x10 | 0x08 | 0x04 | 0x02 | 0x01\n    , 0x20 | 0x10 | 0x08 | 0x04 | 0x02 | 0x01\n    , 0x40 | 0x20 | 0x10 | 0x08 | 0x04 | 0x02 | 0x01\n  ]\n\nfunction to_utf8(bytes, start, end) {\n  start = start === undefined ? 0 : start\n  end = end === undefined ? bytes.length : end\n\n  var idx = 0\n    , hi = 0x80\n    , collecting = 0\n    , pos\n    , by\n\n  col.length =\n  out.length = 0\n\n  while(idx < bytes.length) {\n    by = bytes[idx]\n    if(!collecting && by & hi) {\n      pos = find_pad_position(by)\n      collecting += pos\n      if(pos < 8) {\n        col[col.length] = by & unmask[6 - pos]\n      }\n    } else if(collecting) {\n      col[col.length] = by & unmask[6]\n      --collecting\n      if(!collecting && col.length) {\n        out[out.length] = fcc(reduced(col, pos))\n        col.length = 0\n      }\n    } else { \n      out[out.length] = fcc(by)\n    }\n    ++idx\n  }\n  if(col.length && !collecting) {\n    out[out.length] = fcc(reduced(col, pos))\n    col.length = 0\n  }\n  return out.join(\'\')\n}\n\nfunction find_pad_position(byt) {\n  for(var i = 0; i < 7; ++i) {\n    if(!(byt & mask[i])) {\n      break\n    }\n  }\n  return i\n}\n\nfunction reduced(list) {\n  var out = 0\n  for(var i = 0, len = list.length; i < len; ++i) {\n    out |= list[i] << ((len - i - 1) * 6)\n  }\n  return out\n}\n\n},{}],119:[function(require,module,exports){\n(function () {\n\t"use strict";\n\n\t// modified from https://github.com/kriskowal/es5-shim\n\tvar has = Object.prototype.hasOwnProperty,\n\t\ttoString = Object.prototype.toString,\n\t\tforEach = require(\'./foreach\'),\n\t\tisArgs = require(\'./isArguments\'),\n\t\thasDontEnumBug = !({\'toString\': null}).propertyIsEnumerable(\'toString\'),\n\t\thasProtoEnumBug = (function () {}).propertyIsEnumerable(\'prototype\'),\n\t\tdontEnums = [\n\t\t\t"toString",\n\t\t\t"toLocaleString",\n\t\t\t"valueOf",\n\t\t\t"hasOwnProperty",\n\t\t\t"isPrototypeOf",\n\t\t\t"propertyIsEnumerable",\n\t\t\t"constructor"\n\t\t],\n\t\tkeysShim;\n\n\tkeysShim = function keys(object) {\n\t\tvar isObject = object !== null && typeof object === \'object\',\n\t\t\tisFunction = toString.call(object) === \'[object Function]\',\n\t\t\tisArguments = isArgs(object),\n\t\t\ttheKeys = [];\n\n\t\tif (!isObject && !isFunction && !isArguments) {\n\t\t\tthrow new TypeError("Object.keys called on a non-object");\n\t\t}\n\n\t\tif (isArguments) {\n\t\t\tforEach(object, function (value) {\n\t\t\t\ttheKeys.push(value);\n\t\t\t});\n\t\t} else {\n\t\t\tvar name,\n\t\t\t\tskipProto = hasProtoEnumBug && isFunction;\n\n\t\t\tfor (name in object) {\n\t\t\t\tif (!(skipProto && name === \'prototype\') && has.call(object, name)) {\n\t\t\t\t\ttheKeys.push(name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (hasDontEnumBug) {\n\t\t\tvar ctor = object.constructor,\n\t\t\t\tskipConstructor = ctor && ctor.prototype === object;\n\n\t\t\tforEach(dontEnums, function (dontEnum) {\n\t\t\t\tif (!(skipConstructor && dontEnum === \'constructor\') && has.call(object, dontEnum)) {\n\t\t\t\t\ttheKeys.push(dontEnum);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn theKeys;\n\t};\n\n\tmodule.exports = keysShim;\n}());\n\n\n},{"./foreach":125,"./isArguments":126}],101:[function(require,module,exports){\nmodule.exports = from\n\nvar base64 = require(\'base64-js\')\n\nvar decoders = {\n    hex: from_hex\n  , utf8: from_utf\n  , base64: from_base64\n}\n\nfunction from(source, encoding) {\n  if(Array.isArray(source)) {\n    return new Uint8Array(source)\n  }\n\n  return decoders[encoding || \'utf8\'](source)\n}\n\nfunction from_hex(str) {\n  var size = str.length / 2\n    , buf = new Uint8Array(size)\n    , character = \'\'\n\n  for(var i = 0, len = str.length; i < len; ++i) {\n    character += str.charAt(i)\n\n    if(i > 0 && (i % 2) === 1) {\n      buf[i>>>1] = parseInt(character, 16)\n      character = \'\' \n    }\n  }\n\n  return buf \n}\n\nfunction from_utf(str) {\n  var bytes = []\n    , tmp\n    , ch\n\n  for(var i = 0, len = str.length; i < len; ++i) {\n    ch = str.charCodeAt(i)\n    if(ch & 0x80) {\n      tmp = encodeURIComponent(str.charAt(i)).substr(1).split(\'%\')\n      for(var j = 0, jlen = tmp.length; j < jlen; ++j) {\n        bytes[bytes.length] = parseInt(tmp[j], 16)\n      }\n    } else {\n      bytes[bytes.length] = ch \n    }\n  }\n\n  return new Uint8Array(bytes)\n}\n\nfunction from_base64(str) {\n  return new Uint8Array(base64.toByteArray(str)) \n}\n\n},{"base64-js":127}],117:[function(require,module,exports){\n(function () {\n\t"use strict";\n\n\t// modified from https://github.com/kriskowal/es5-shim\n\tvar has = Object.prototype.hasOwnProperty,\n\t\tis = require(\'is\'),\n\t\tforEach = require(\'foreach\'),\n\t\thasDontEnumBug = !({\'toString\': null}).propertyIsEnumerable(\'toString\'),\n\t\tdontEnums = [\n\t\t\t"toString",\n\t\t\t"toLocaleString",\n\t\t\t"valueOf",\n\t\t\t"hasOwnProperty",\n\t\t\t"isPrototypeOf",\n\t\t\t"propertyIsEnumerable",\n\t\t\t"constructor"\n\t\t],\n\t\tkeysShim;\n\n\tkeysShim = function keys(object) {\n\t\tif (!is.object(object) && !is.array(object)) {\n\t\t\tthrow new TypeError("Object.keys called on a non-object");\n\t\t}\n\n\t\tvar name, theKeys = [];\n\t\tfor (name in object) {\n\t\t\tif (has.call(object, name)) {\n\t\t\t\ttheKeys.push(name);\n\t\t\t}\n\t\t}\n\n\t\tif (hasDontEnumBug) {\n\t\t\tforEach(dontEnums, function (dontEnum) {\n\t\t\t\tif (has.call(object, dontEnum)) {\n\t\t\t\t\ttheKeys.push(dontEnum);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn theKeys;\n\t};\n\n\tmodule.exports = keysShim;\n}());\n\n\n},{"foreach":129,"is":128}],102:[function(require,module,exports){\nmodule.exports = to\n\nvar base64 = require(\'base64-js\')\n  , toutf8 = require(\'to-utf8\')\n\nvar encoders = {\n    hex: to_hex\n  , utf8: to_utf\n  , base64: to_base64\n}\n\nfunction to(buf, encoding) {\n  return encoders[encoding || \'utf8\'](buf)\n}\n\nfunction to_hex(buf) {\n  var str = \'\'\n    , byt\n\n  for(var i = 0, len = buf.length; i < len; ++i) {\n    byt = buf[i]\n    str += ((byt & 0xF0) >>> 4).toString(16)\n    str += (byt & 0x0F).toString(16)\n  }\n\n  return str\n}\n\nfunction to_utf(buf) {\n  return toutf8(buf)\n}\n\nfunction to_base64(buf) {\n  return base64.fromByteArray(buf)\n}\n\n\n},{"base64-js":127,"to-utf8":130}],125:[function(require,module,exports){\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toString = Object.prototype.toString;\n\nvar isFunction = function (fn) {\n\tvar isFunc = (typeof fn === \'function\' && !(fn instanceof RegExp)) || toString.call(fn) === \'[object Function]\';\n\tif (!isFunc && typeof window !== \'undefined\') {\n\t\tisFunc = fn === window.setTimeout || fn === window.alert || fn === window.confirm || fn === window.prompt;\n\t}\n\treturn isFunc;\n};\n\nmodule.exports = function forEach(obj, fn) {\n\tif (!isFunction(fn)) {\n\t\tthrow new TypeError(\'iterator must be a function\');\n\t}\n\tvar i, k,\n\t\tisString = typeof obj === \'string\',\n\t\tl = obj.length,\n\t\tcontext = arguments.length > 2 ? arguments[2] : null;\n\tif (l === +l) {\n\t\tfor (i = 0; i < l; i++) {\n\t\t\tif (context === null) {\n\t\t\t\tfn(isString ? obj.charAt(i) : obj[i], i, obj);\n\t\t\t} else {\n\t\t\t\tfn.call(context, isString ? obj.charAt(i) : obj[i], i, obj);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (k in obj) {\n\t\t\tif (hasOwn.call(obj, k)) {\n\t\t\t\tif (context === null) {\n\t\t\t\t\tfn(obj[k], k, obj);\n\t\t\t\t} else {\n\t\t\t\t\tfn.call(context, obj[k], k, obj);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n\n},{}],126:[function(require,module,exports){\nvar toString = Object.prototype.toString;\n\nmodule.exports = function isArguments(value) {\n\tvar str = toString.call(value);\n\tvar isArguments = str === \'[object Arguments]\';\n\tif (!isArguments) {\n\t\tisArguments = str !== \'[object Array]\'\n\t\t\t&& value !== null\n\t\t\t&& typeof value === \'object\'\n\t\t\t&& typeof value.length === \'number\'\n\t\t\t&& value.length >= 0\n\t\t\t&& toString.call(value.callee) === \'[object Function]\';\n\t}\n\treturn isArguments;\n};\n\n\n},{}],127:[function(require,module,exports){\n(function (exports) {\n\t\'use strict\';\n\n\tvar lookup = \'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\';\n\n\tfunction b64ToByteArray(b64) {\n\t\tvar i, j, l, tmp, placeHolders, arr;\n\t\n\t\tif (b64.length % 4 > 0) {\n\t\t\tthrow \'Invalid string. Length must be a multiple of 4\';\n\t\t}\n\n\t\t// the number of equal signs (place holders)\n\t\t// if there are two placeholders, than the two characters before it\n\t\t// represent one byte\n\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t// this is just a cheap hack to not do indexOf twice\n\t\tplaceHolders = b64.indexOf(\'=\');\n\t\tplaceHolders = placeHolders > 0 ? b64.length - placeHolders : 0;\n\n\t\t// base64 is 4/3 + up to two characters of the original data\n\t\tarr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);\n\n\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length;\n\n\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);\n\t\t\tarr.push((tmp & 0xFF0000) >> 16);\n\t\t\tarr.push((tmp & 0xFF00) >> 8);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t}\n\n\t\tif (placeHolders === 2) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t} else if (placeHolders === 1) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);\n\t\t\tarr.push((tmp >> 8) & 0xFF);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t}\n\n\t\treturn arr;\n\t}\n\n\tfunction uint8ToBase64(uint8) {\n\t\tvar i,\n\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\toutput = "",\n\t\t\ttemp, length;\n\n\t\tfunction tripletToBase64 (num) {\n\t\t\treturn lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n\t\t};\n\n\t\t// go through the array every three bytes, we\'ll deal with trailing stuff later\n\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);\n\t\t\toutput += tripletToBase64(temp);\n\t\t}\n\n\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\tswitch (extraBytes) {\n\t\t\tcase 1:\n\t\t\t\ttemp = uint8[uint8.length - 1];\n\t\t\t\toutput += lookup[temp >> 2];\n\t\t\t\toutput += lookup[(temp << 4) & 0x3F];\n\t\t\t\toutput += \'==\';\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);\n\t\t\t\toutput += lookup[temp >> 10];\n\t\t\t\toutput += lookup[(temp >> 4) & 0x3F];\n\t\t\t\toutput += lookup[(temp << 2) & 0x3F];\n\t\t\t\toutput += \'=\';\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn output;\n\t}\n\n\tmodule.exports.toByteArray = b64ToByteArray;\n\tmodule.exports.fromByteArray = uint8ToBase64;\n}());\n\n},{}],128:[function(require,module,exports){\n\n/**!\n * is\n * the definitive JavaScript type testing library\n * \n * @copyright 2013 Enrico Marino\n * @license MIT\n */\n\nvar objProto = Object.prototype;\nvar owns = objProto.hasOwnProperty;\nvar toString = objProto.toString;\nvar isActualNaN = function (value) {\n  return value !== value;\n};\nvar NON_HOST_TYPES = {\n  "boolean": 1,\n  "number": 1,\n  "string": 1,\n  "undefined": 1\n};\n\n/**\n * Expose `is`\n */\n\nvar is = module.exports = {};\n\n/**\n * Test general.\n */\n\n/**\n * is.type\n * Test if `value` is a type of `type`.\n *\n * @param {Mixed} value value to test\n * @param {String} type type\n * @return {Boolean} true if `value` is a type of `type`, false otherwise\n * @api public\n */\n\nis.a =\nis.type = function (value, type) {\n  return typeof value === type;\n};\n\n/**\n * is.defined\n * Test if `value` is defined.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if \'value\' is defined, false otherwise\n * @api public\n */\n\nis.defined = function (value) {\n  return value !== undefined;\n};\n\n/**\n * is.empty\n * Test if `value` is empty.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is empty, false otherwise\n * @api public\n */\n\nis.empty = function (value) {\n  var type = toString.call(value);\n  var key;\n\n  if (\'[object Array]\' === type || \'[object Arguments]\' === type) {\n    return value.length === 0;\n  }\n\n  if (\'[object Object]\' === type) {\n    for (key in value) if (owns.call(value, key)) return false;\n    return true;\n  }\n\n  if (\'[object String]\' === type) {\n    return \'\' === value;\n  }\n\n  return false;\n};\n\n/**\n * is.equal\n * Test if `value` is equal to `other`.\n *\n * @param {Mixed} value value to test\n * @param {Mixed} other value to compare with\n * @return {Boolean} true if `value` is equal to `other`, false otherwise\n */\n\nis.equal = function (value, other) {\n  var type = toString.call(value)\n  var key;\n\n  if (type !== toString.call(other)) {\n    return false;\n  }\n\n  if (\'[object Object]\' === type) {\n    for (key in value) {\n      if (!is.equal(value[key], other[key])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  if (\'[object Array]\' === type) {\n    key = value.length;\n    if (key !== other.length) {\n      return false;\n    }\n    while (--key) {\n      if (!is.equal(value[key], other[key])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  if (\'[object Function]\' === type) {\n    return value.prototype === other.prototype;\n  }\n\n  if (\'[object Date]\' === type) {\n    return value.getTime() === other.getTime();\n  }\n\n  return value === other;\n};\n\n/**\n * is.hosted\n * Test if `value` is hosted by `host`.\n *\n * @param {Mixed} value to test\n * @param {Mixed} host host to test with\n * @return {Boolean} true if `value` is hosted by `host`, false otherwise\n * @api public\n */\n\nis.hosted = function (value, host) {\n  var type = typeof host[value];\n  return type === \'object\' ? !!host[value] : !NON_HOST_TYPES[type];\n};\n\n/**\n * is.instance\n * Test if `value` is an instance of `constructor`.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is an instance of `constructor`\n * @api public\n */\n\nis.instance = is[\'instanceof\'] = function (value, constructor) {\n  return value instanceof constructor;\n};\n\n/**\n * is.null\n * Test if `value` is null.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is null, false otherwise\n * @api public\n */\n\nis[\'null\'] = function (value) {\n  return value === null;\n};\n\n/**\n * is.undefined\n * Test if `value` is undefined.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is undefined, false otherwise\n * @api public\n */\n\nis.undefined = function (value) {\n  return value === undefined;\n};\n\n/**\n * Test arguments.\n */\n\n/**\n * is.arguments\n * Test if `value` is an arguments object.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is an arguments object, false otherwise\n * @api public\n */\n\nis.arguments = function (value) {\n  var isStandardArguments = \'[object Arguments]\' === toString.call(value);\n  var isOldArguments = !is.array(value) && is.arraylike(value) && is.object(value) && is.fn(value.callee);\n  return isStandardArguments || isOldArguments;\n};\n\n/**\n * Test array.\n */\n\n/**\n * is.array\n * Test if \'value\' is an array.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is an array, false otherwise\n * @api public\n */\n\nis.array = function (value) {\n  return \'[object Array]\' === toString.call(value);\n};\n\n/**\n * is.arguments.empty\n * Test if `value` is an empty arguments object.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is an empty arguments object, false otherwise\n * @api public\n */\nis.arguments.empty = function (value) {\n  return is.arguments(value) && value.length === 0;\n};\n\n/**\n * is.array.empty\n * Test if `value` is an empty array.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is an empty array, false otherwise\n * @api public\n */\nis.array.empty = function (value) {\n  return is.array(value) && value.length === 0;\n};\n\n/**\n * is.arraylike\n * Test if `value` is an arraylike object.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is an arguments object, false otherwise\n * @api public\n */\n\nis.arraylike = function (value) {\n  return !!value && !is.boolean(value)\n    && owns.call(value, \'length\')\n    && isFinite(value.length)\n    && is.number(value.length)\n    && value.length >= 0;\n};\n\n/**\n * Test boolean.\n */\n\n/**\n * is.boolean\n * Test if `value` is a boolean.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is a boolean, false otherwise\n * @api public\n */\n\nis.boolean = function (value) {\n  return \'[object Boolean]\' === toString.call(value);\n};\n\n/**\n * is.false\n * Test if `value` is false.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is false, false otherwise\n * @api public\n */\n\nis[\'false\'] = function (value) {\n  return is.boolean(value) && (value === false || value.valueOf() === false);\n};\n\n/**\n * is.true\n * Test if `value` is true.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is true, false otherwise\n * @api public\n */\n\nis[\'true\'] = function (value) {\n  return is.boolean(value) && (value === true || value.valueOf() === true);\n};\n\n/**\n * Test date.\n */\n\n/**\n * is.date\n * Test if `value` is a date.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is a date, false otherwise\n * @api public\n */\n\nis.date = function (value) {\n  return \'[object Date]\' === toString.call(value);\n};\n\n/**\n * Test element.\n */\n\n/**\n * is.element\n * Test if `value` is an html element.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is an HTML Element, false otherwise\n * @api public\n */\n\nis.element = function (value) {\n  return value !== undefined\n    && typeof HTMLElement !== \'undefined\'\n    && value instanceof HTMLElement\n    && value.nodeType === 1;\n};\n\n/**\n * Test error.\n */\n\n/**\n * is.error\n * Test if `value` is an error object.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is an error object, false otherwise\n * @api public\n */\n\nis.error = function (value) {\n  return \'[object Error]\' === toString.call(value);\n};\n\n/**\n * Test function.\n */\n\n/**\n * is.fn / is.function (deprecated)\n * Test if `value` is a function.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is a function, false otherwise\n * @api public\n */\n\nis.fn = is[\'function\'] = function (value) {\n  var isAlert = typeof window !== \'undefined\' && value === window.alert;\n  return isAlert || \'[object Function]\' === toString.call(value);\n};\n\n/**\n * Test number.\n */\n\n/**\n * is.number\n * Test if `value` is a number.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is a number, false otherwise\n * @api public\n */\n\nis.number = function (value) {\n  return \'[object Number]\' === toString.call(value);\n};\n\n/**\n * is.infinite\n * Test if `value` is positive or negative infinity.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is positive or negative Infinity, false otherwise\n * @api public\n */\nis.infinite = function (value) {\n  return value === Infinity || value === -Infinity;\n};\n\n/**\n * is.decimal\n * Test if `value` is a decimal number.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is a decimal number, false otherwise\n * @api public\n */\n\nis.decimal = function (value) {\n  return is.number(value) && !isActualNaN(value) && !is.infinite(value) && value % 1 !== 0;\n};\n\n/**\n * is.divisibleBy\n * Test if `value` is divisible by `n`.\n *\n * @param {Number} value value to test\n * @param {Number} n dividend\n * @return {Boolean} true if `value` is divisible by `n`, false otherwise\n * @api public\n */\n\nis.divisibleBy = function (value, n) {\n  var isDividendInfinite = is.infinite(value);\n  var isDivisorInfinite = is.infinite(n);\n  var isNonZeroNumber = is.number(value) && !isActualNaN(value) && is.number(n) && !isActualNaN(n) && n !== 0;\n  return isDividendInfinite || isDivisorInfinite || (isNonZeroNumber && value % n === 0);\n};\n\n/**\n * is.int\n * Test if `value` is an integer.\n *\n * @param value to test\n * @return {Boolean} true if `value` is an integer, false otherwise\n * @api public\n */\n\nis.int = function (value) {\n  return is.number(value) && !isActualNaN(value) && value % 1 === 0;\n};\n\n/**\n * is.maximum\n * Test if `value` is greater than \'others\' values.\n *\n * @param {Number} value value to test\n * @param {Array} others values to compare with\n * @return {Boolean} true if `value` is greater than `others` values\n * @api public\n */\n\nis.maximum = function (value, others) {\n  if (isActualNaN(value)) {\n    throw new TypeError(\'NaN is not a valid value\');\n  } else if (!is.arraylike(others)) {\n    throw new TypeError(\'second argument must be array-like\');\n  }\n  var len = others.length;\n\n  while (--len >= 0) {\n    if (value < others[len]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n * is.minimum\n * Test if `value` is less than `others` values.\n *\n * @param {Number} value value to test\n * @param {Array} others values to compare with\n * @return {Boolean} true if `value` is less than `others` values\n * @api public\n */\n\nis.minimum = function (value, others) {\n  if (isActualNaN(value)) {\n    throw new TypeError(\'NaN is not a valid value\');\n  } else if (!is.arraylike(others)) {\n    throw new TypeError(\'second argument must be array-like\');\n  }\n  var len = others.length;\n\n  while (--len >= 0) {\n    if (value > others[len]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n * is.nan\n * Test if `value` is not a number.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is not a number, false otherwise\n * @api public\n */\n\nis.nan = function (value) {\n  return !is.number(value) || value !== value;\n};\n\n/**\n * is.even\n * Test if `value` is an even number.\n *\n * @param {Number} value value to test\n * @return {Boolean} true if `value` is an even number, false otherwise\n * @api public\n */\n\nis.even = function (value) {\n  return is.infinite(value) || (is.number(value) && value === value && value % 2 === 0);\n};\n\n/**\n * is.odd\n * Test if `value` is an odd number.\n *\n * @param {Number} value value to test\n * @return {Boolean} true if `value` is an odd number, false otherwise\n * @api public\n */\n\nis.odd = function (value) {\n  return is.infinite(value) || (is.number(value) && value === value && value % 2 !== 0);\n};\n\n/**\n * is.ge\n * Test if `value` is greater than or equal to `other`.\n *\n * @param {Number} value value to test\n * @param {Number} other value to compare with\n * @return {Boolean}\n * @api public\n */\n\nis.ge = function (value, other) {\n  if (isActualNaN(value) || isActualNaN(other)) {\n    throw new TypeError(\'NaN is not a valid value\');\n  }\n  return !is.infinite(value) && !is.infinite(other) && value >= other;\n};\n\n/**\n * is.gt\n * Test if `value` is greater than `other`.\n *\n * @param {Number} value value to test\n * @param {Number} other value to compare with\n * @return {Boolean}\n * @api public\n */\n\nis.gt = function (value, other) {\n  if (isActualNaN(value) || isActualNaN(other)) {\n    throw new TypeError(\'NaN is not a valid value\');\n  }\n  return !is.infinite(value) && !is.infinite(other) && value > other;\n};\n\n/**\n * is.le\n * Test if `value` is less than or equal to `other`.\n *\n * @param {Number} value value to test\n * @param {Number} other value to compare with\n * @return {Boolean} if \'value\' is less than or equal to \'other\'\n * @api public\n */\n\nis.le = function (value, other) {\n  if (isActualNaN(value) || isActualNaN(other)) {\n    throw new TypeError(\'NaN is not a valid value\');\n  }\n  return !is.infinite(value) && !is.infinite(other) && value <= other;\n};\n\n/**\n * is.lt\n * Test if `value` is less than `other`.\n *\n * @param {Number} value value to test\n * @param {Number} other value to compare with\n * @return {Boolean} if `value` is less than `other`\n * @api public\n */\n\nis.lt = function (value, other) {\n  if (isActualNaN(value) || isActualNaN(other)) {\n    throw new TypeError(\'NaN is not a valid value\');\n  }\n  return !is.infinite(value) && !is.infinite(other) && value < other;\n};\n\n/**\n * is.within\n * Test if `value` is within `start` and `finish`.\n *\n * @param {Number} value value to test\n * @param {Number} start lower bound\n * @param {Number} finish upper bound\n * @return {Boolean} true if \'value\' is is within \'start\' and \'finish\'\n * @api public\n */\nis.within = function (value, start, finish) {\n  if (isActualNaN(value) || isActualNaN(start) || isActualNaN(finish)) {\n    throw new TypeError(\'NaN is not a valid value\');\n  } else if (!is.number(value) || !is.number(start) || !is.number(finish)) {\n    throw new TypeError(\'all arguments must be numbers\');\n  }\n  var isAnyInfinite = is.infinite(value) || is.infinite(start) || is.infinite(finish);\n  return isAnyInfinite || (value >= start && value <= finish);\n};\n\n/**\n * Test object.\n */\n\n/**\n * is.object\n * Test if `value` is an object.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is an object, false otherwise\n * @api public\n */\n\nis.object = function (value) {\n  return value && \'[object Object]\' === toString.call(value);\n};\n\n/**\n * is.hash\n * Test if `value` is a hash - a plain object literal.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is a hash, false otherwise\n * @api public\n */\n\nis.hash = function (value) {\n  return is.object(value) && value.constructor === Object && !value.nodeType && !value.setInterval;\n};\n\n/**\n * Test regexp.\n */\n\n/**\n * is.regexp\n * Test if `value` is a regular expression.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if `value` is a regexp, false otherwise\n * @api public\n */\n\nis.regexp = function (value) {\n  return \'[object RegExp]\' === toString.call(value);\n};\n\n/**\n * Test string.\n */\n\n/**\n * is.string\n * Test if `value` is a string.\n *\n * @param {Mixed} value value to test\n * @return {Boolean} true if \'value\' is a string, false otherwise\n * @api public\n */\n\nis.string = function (value) {\n  return \'[object String]\' === toString.call(value);\n};\n\n\n},{}],129:[function(require,module,exports){\n\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toString = Object.prototype.toString;\n\nmodule.exports = function forEach (obj, fn, ctx) {\n    if (toString.call(fn) !== \'[object Function]\') {\n        throw new TypeError(\'iterator must be a function\');\n    }\n    var l = obj.length;\n    if (l === +l) {\n        for (var i = 0; i < l; i++) {\n            fn.call(ctx, obj[i], i, obj);\n        }\n    } else {\n        for (var k in obj) {\n            if (hasOwn.call(obj, k)) {\n                fn.call(ctx, obj[k], k, obj);\n            }\n        }\n    }\n};\n\n\n},{}],130:[function(require,module,exports){\nmodule.exports = to_utf8\n\nvar out = []\n  , col = []\n  , fcc = String.fromCharCode\n  , mask = [0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01]\n  , unmask = [\n      0x00\n    , 0x01\n    , 0x02 | 0x01\n    , 0x04 | 0x02 | 0x01\n    , 0x08 | 0x04 | 0x02 | 0x01\n    , 0x10 | 0x08 | 0x04 | 0x02 | 0x01\n    , 0x20 | 0x10 | 0x08 | 0x04 | 0x02 | 0x01\n    , 0x40 | 0x20 | 0x10 | 0x08 | 0x04 | 0x02 | 0x01\n  ]\n\nfunction to_utf8(bytes, start, end) {\n  start = start === undefined ? 0 : start\n  end = end === undefined ? bytes.length : end\n\n  var idx = 0\n    , hi = 0x80\n    , collecting = 0\n    , pos\n    , by\n\n  col.length =\n  out.length = 0\n\n  while(idx < bytes.length) {\n    by = bytes[idx]\n    if(!collecting && by & hi) {\n      pos = find_pad_position(by)\n      collecting += pos\n      if(pos < 8) {\n        col[col.length] = by & unmask[6 - pos]\n      }\n    } else if(collecting) {\n      col[col.length] = by & unmask[6]\n      --collecting\n      if(!collecting && col.length) {\n        out[out.length] = fcc(reduced(col, pos))\n        col.length = 0\n      }\n    } else { \n      out[out.length] = fcc(by)\n    }\n    ++idx\n  }\n  if(col.length && !collecting) {\n    out[out.length] = fcc(reduced(col, pos))\n    col.length = 0\n  }\n  return out.join(\'\')\n}\n\nfunction find_pad_position(byt) {\n  for(var i = 0; i < 7; ++i) {\n    if(!(byt & mask[i])) {\n      break\n    }\n  }\n  return i\n}\n\nfunction reduced(list) {\n  var out = 0\n  for(var i = 0, len = list.length; i < len; ++i) {\n    out |= list[i] << ((len - i - 1) * 6)\n  }\n  return out\n}\n\n},{}]},{},[2])\n;'],{type:"text/javascript"})));

var ndn = require('ndn-browser-shim')


ndn.keygen = require('./ndn-keygen.js');
ndn.rtc = require('./ndn-rtc.js');
ndn.io = require('./ndn-io.js');
ndn.dc = require('./ndn-dc.js');
ndn.dc.accessDaemon(nfd);
ndn.x = require('./ndn-x.js');
ndn.utils = require('./utils.js')
ndn.cache = require('./ndn-cache.js')
ndn.fd = nfd;
//ndn.th = require('./ndn-telehashTransport.js')
var initmc = new MessageChannel()

ndn.init = function(opts, app) {

  opts.init = false;
  var keyPort = new MessageChannel()
  nfd.postMessage({port: "keyPort"},[keyPort.port2])

  xinit = function(id, cert, priPem, pubPem){
    ndn.x.init(nfd, id)
    ndn.id = id
    ndn.io.accessDaemon(nfd, cert, priPem, pubPem)
    //console.log('posting message to app')
    initmc.port1.postMessage('up')
    //ndn.th.init(ndn, priPem, pubPem);
    ndn.globalKeyManager.certificate = cert
    ndn.globalKeyManager.publicKey = pubPem
    ndn.globalKeyManager.privateKey = priPem

    opts.init = true;
    nfd.postMessage(opts);
    ndn.r = new Worker(window.URL.createObjectURL(new Blob([';(function(e,t,n){function i(n,s){if(!t[n]){if(!e[n]){var o=typeof require=="function"&&require;if(!s&&o)return o(n,!0);if(r)return r(n,!0);throw new Error("Cannot find module \'"+n+"\'")}var u=t[n]={exports:{}};e[n][0].call(u.exports,function(t){var r=e[n][1][t];return i(r?r:t)},u,u.exports)}return t[n].exports}var r=typeof require=="function"&&require;for(var s=0;s<n.length;s++)i(n[s]);return i})({1:[function(require,module,exports){\n//Global Namespacing for the ndnr\n\nvar level = require(\'levelup\');\nvar down = require(\'level-js\');\n\nfunction indexedDBOk() {\n  return "indexedDB" in window;\n};\n\nvar RegisteredPrefix = function RegisteredPrefix(prefix, closure)\n{\n  this.prefix = prefix;        // String\n  this.closure = closure;  // Closure\n};\n\nvar ndn = require(\'ndn-browser-shim\');\nvar local = require(\'./ndn-MessageChannelTransport.js\')\nvar Name = ndn.Name;\nvar utils = require(\'./utils.js\')\n\n/**\n * Database constructor\n * @prefix: application prefix (used as database name) STRING (may contain globally routable prefix)\n */\n\nvar ndnr = {};\n\n\n\n// vvvv THIS IS THE GOOD STUFF vvvv Plus NDN-helpers. NEED to Refactor and streamline useIndexedDB a little but it seems to be working good\n\nndnr.interestHandler = function(prefix, interest, transport) {\n  //console.log("onInterest called for incoming interest: ", interest.toUri());\n  interest.face = self.face;\n  if (utils.nameHasCommandMarker(interest.name)) {\n    console.log(\'incoming interest has command marker \', utils.getCommandMarker(interest.name));\n    executeCommand(prefix, interest, transport);\n    return;\n  } else {\n    //console.log(\'attempting to fulfill interest\');\n    fulfillInterest(prefix, interest, transport);\n  };\n};\n\n\n//TODO: Flesh out this subroutine, it is the keystone of the library, handle interest selectors, etc\nfunction fulfillInterest(prefix, interest, transport) {\n  //console.log(\'repo fulfilling interest\')\n  var objectStoreName = utils.normalizeNameToObjectStore(interest.name),\n      dbName = prefix.toUri(),\n      getContent = {},\n      suffixIndex = 0,\n      contentKey = \'%00\';\n      if ((interest.childSelector == 0) || (interest.childSelector == undefined)) {\n        var reverse = false;\n      } else {\n        var reverse = true;\n      };\n\n  if (utils.endsWithSegmentNumber(interest.name)) {\n    // A specific segment of a data object is being requested, so don\'t bother querying for loose matches, just return or drop\n    var requestedSegment = utils.getSegmentInteger(interest.name)\n    var segAr = utils.initSegment(requestedSegment)\n    //console.log(requestedSegment, interest.name.components)\n    var db = level(objectStoreName, {db: down})\n    db.get(requestedSegment, function(er, data) {\n      if (er == undefined) {\n        if (interest.publisherPublicKeyDigest != undefined) {\n          var d = new ndn.Data()\n          d.decode(data)\n          if (ndn.DataUtils.arraysEqual(d.signedInfo.publisher.publisherPublicKeyDigest, interest.publisherPublicKeyDigest.publisherPublicKeyDigest)) {\n            transport.send(data)\n          } else {\n            console.log(\'got data not matching publisherPublicKeyDigest interest selector\')\n          }\n        } else {\n          transport.send(data)\n        }\n      }\n    });\n  } else {\n    // A general interest. Interpret according to selectors and return the first segment of the best matching dataset\n    var suffixIndex = 0;\n    var hit = false\n    function crawl(q, lastfail) {\n      var cursor, start, end;\n      console.log(q)\n      cursor = level(q,{db:down, createIfMissing: false})\n      if (lastfail && (reverse == true)) {\n        var tmp = lastfail[lastfail.length - 1]\n        lastfail[lastfail.length - 1] = tmp - 1\n        end = lastfail\n      } else if (lastfail) {\n        var tmp = lastfail[lastfail.length - 1]\n        lastfail[lastfail.length - 1] = tmp + 1\n        start = lastfail\n      }\n      var read = false\n      cursor.createReadStream({start: start, end: end, reverse: reverse, limit: 1}).on(\'data\', function(data) {\n        read = true\n        if ((interest.exclude == null) || (!interest.exclude.matches(new ndn.Name.Component(data.key)))) {\n          console.log(\'Suffix is not excluded\', data.key);\n          if (data.key == "%00") {\n            console.log(\'got to data\');\n            if ((interest.minSuffixComponents == null) || (suffixIndex >= interest.minSuffixComponents )) {\n              console.log(\'more than minimum suffix components\');\n              level(data.value,{db:down}).get(\'0\', function(err, data){\n                if (interest.publisherPublicKeyDigest != undefined) {\n                  var d = new ndn.Data()\n                  d.decode(data)\n                  if (ndn.DataUtils.arraysEqual(d.signedInfo.publisher.publisherPublicKeyDigest, interest.publisherPublicKeyDigest.publisherPublicKeyDigest)) {\n                    transport.send(data)\n                  } else {\n                    crawl(q, contentKey)\n                  }\n                } else {\n                  transport.send(data)\n                }\n              })\n            } else {\n              console.log(\'not enough suffix\')\n              crawl(q, contentKey)\n            }\n          } else {\n            console.log(\'keep crawling\')\n\n            if ((interest.maxSuffixComponents == null) || (suffixIndex  < interest.maxSuffixComponents)) {\n              suffixIndex++\n              crawl(data.value)\n            } else {\n              console.log(\'reached max suffix\');\n              crawl(q,  data.key)\n            }\n          }\n\n        } else {\n          console.log(\'name component is excluded in interest,\')\n          crawl(q, data.key)\n        }\n      }).on(\'end\', function(err,data){\n        if ((read == false) && (((interest.minSuffixComponents == null) && (suffixIndex > 0)) || (suffixIndex > interest.minSuffixComponents ))) {\n          //we\'ve exhasted this depth, need to go up a level, and we have the leeway from minSuffix to allow\n          var comps = q.split(\'/\')\n          var fail = comps.pop()\n          var newQ = comps.join(\'/\')\n          crawl(newQ, new ndn.Name.Component(fail).value)\n        }\n\n      })\n    }\n  var query = interest.name.toUri()\n  crawl(query)\n  }\n};\n\n\nfunction recursiveSegmentRequest(face, prefix, objectStoreName) {\n  var firstSegmentName = new ndn.Name(objectStoreName);\n  var contentArray = [];\n\n  function putContentArray () {\n    var dbName = prefix.toUri();\n    var collector = new MessageChannel()\n    var finalSegment = contentArray.length - 1\n    var db = level(objectStoreName,{db:down})\n    function putSegment(seg) {\n      var encoded = contentArray[seg].encode()\n      var arSeg = utils.initSegment(seg)\n      db.put(seg, encoded)\n      console.log(\'put seg \', seg)\n      contentArray.pop()\n\n      if (contentArray.length > 0) {\n        currentSegment = contentArray.length - 1\n        putSegment(currentSegment)\n      } else {\n        var t1 = new Date().getTime()\n        console.log(t1 - t0)\n\n      }\n    }\n    putSegment(finalSegment)\n\n  }\n\n\n  var interestsInFlight = 0;\n  var windowSize = 10;\n  var t0 = new Date().getTime()\n  var segmentRequested = [];\n  var whenNotGottenTriggered = false\n\n  var name = firstSegmentName.getPrefix(-1)\n\n\n\n\n\n\n  var recievedSegments = 0;\n  var numberOfSegments = null\n  var onData = function(interest, co) {\n    interestsInFlight--;\n    recievedSegments++;\n    console.log(co)\n    var segmentNumber = utils.getSegmentInteger(co.name)\n    if (numberOfSegments == null) {\n      numberOfSegments = 1 + ndn.DataUtils.bigEndianToUnsignedInt(co.signedInfo.finalBlockID);\n    }\n    //console.log(segmentNumber);\n    if (contentArray[segmentNumber] == undefined) {\n        contentArray[segmentNumber] = co\n      }\n\n\n\n    //console.log(recievedSegments, finalSegmentNumber, interestsInFlight);\n    if (recievedSegments == numberOfSegments) {\n        console.log(\'got all segment\', contentArray.length);\n        var t1 = new Date().getTime()\n        console.log(t1 - t0)\n        putContentArray()\n    } else {\n      if (interestsInFlight < windowSize) {\n        for (var i = 0; i < numberOfSegments; i++) {\n          if ((contentArray[i] == undefined) && (segmentRequested[i] == undefined)) {\n            var newName = co.name.getPrefix(-1).appendSegment(i)\n            var newInterest = new ndn.Interest(newName)\n            console.log(newName.toUri())\n            utils.setNonce(newInterest)\n            newInterest.interestLifetime = 4000\n            self.face.expressInterest(newInterest, onData, onTimeout)\n            segmentRequested[i] = 0;\n            interestsInFlight++\n            if (interestsInFlight == windowSize) {\n              //stop iterating\n              i = numberOfSegments;\n            }\n          }\n        }\n      }\n    }\n  }\n  var onTimeout = function(interest) {\n    var seg = utils.getSegmentInteger(interest.name)\n    if (segmentRequested[seg] < 3) {\n      segmentRequested[seg]++\n      var newInterest = new ndn.Interest(interest.name);\n      utils.setNonce(newInterest)\n      newInterest.interestLifetime = 4000\n      self.face.expressInterest(newInterest, onData, onTimeout)\n\n    } else if ((whenNotGottenTriggered == false)) {\n      whenNotGottenTriggered = true;\n      self.postMessage({responseTo: "fetch", success: false, uri: name.toUri()})\n    }\n  }\n\n  var segName = new ndn.Name(name)\n  segName.appendSegment(0)\n  var interest = new ndn.Interest(segName);\n  utils.setNonce(interest)\n  interest.interestLifetime = 4000\n  //console.log(interest.name.toUri())\n\n  self.face.expressInterest(interest, onData, onTimeout);\n\n}\n\nfunction buildObjectStoreTree(prefix, objectStoreName, onFinished, arg) {\n  var dbName = prefix.toUri(),\n      properName = new ndn.Name(objectStoreName),\n      uriArray = utils.getAllPrefixes(properName),\n      toCreate = [],\n      evaluate = {},\n      growTree = {},\n      contentKey = utils.initSegment(0),\n      version;\n  var comps = objectStoreName.split(\'/\')\n  for (var i = comps.length - 1; i > 0; i-- ) {\n    console.log(comps)\n    var value = comps.join(\'/\')\n    var keyComp = comps.pop()\n\n    var slevel = comps.join(\'/\') || \'/\'\n    level(slevel,{db:down}).put(keyComp, value)\n\n  }\n  if (arg != undefined) {\n    onFinished(arg, prefix, objectStoreName)\n  } else {\n    onFinished()\n  }\n\n};\n\nfunction executeCommand(prefix, interest, transport) {\n  var command = utils.getCommandMarker(interest.name).split(\'%7E\')[0];\n\n  if (command in ndnr.commandMarkers) {\n    console.log("executing recognized command ", command);\n    ndnr.commandMarkers[command](prefix, interest, transport);\n  } else {\n    console.log("ignoring unrecognized command ", command);\n  };\n};\n\n\nndnr.commandMarkers = {};\n\n\nndnr.commandMarkers["%C1.R.sw"] = function startWrite( prefix, interest) {\n  var localName = utils.getNameWithoutCommandMarker(interest.name),\n      objectStoreName = utils.normalizeNameToObjectStore(localName);\n\n\n  console.log("Building objectStore Tree for ", objectStoreName, this);\n\n  buildObjectStoreTree(prefix, objectStoreName, recursiveSegmentRequest, interest.face);\n};\n\nndnr.commandMarkers["%C1.R.sw"].component = new Name.Component([0xc1, 0x2e, 0x52, 0x2e, 0x73, 0x77]);\n\nonmessage = function(e){\n  var uri = e.data.uri,\n      port = e.ports[0]\n\n  self.face = new ndn.Face({host:32, port:31, getTransport: function(){return new local.transport(port)}})\n  self.face.transport.connect(self.face, function(){console.log(\'connecting to daemon from repo\')})\n\n  if(!indexedDBOk) return console.log(\'no indexedDb\');  // No IndexedDB support\n  var prefixUri = (new ndn.Name(uri)).toUri(),       // normalize\n      initDb = {};\n\n  this.prefix = prefixUri\n\n  var prefix = new ndn.Name(uri)\n  var closure = new ndn.Face.CallbackClosure(null, null, ndnr.interestHandler, prefix, self.face.transport);\n  ndn.Face.registeredPrefixTable.push(new RegisteredPrefix(prefix, closure));\n\n\n  //rFace.registerPrefix(new ndn.Name(prefix), this.interestHandler);\n\n  initDb.onupgradeneeded = function(e) {\n    console.log("Version 1 of database ", prefixUri, "created");\n    self.postMessage(\'repo open\')\n  };\n  console.log(ndn)\n\n};\n\n\n},{"./ndn-MessageChannelTransport.js":2,"./utils.js":3,"level-js":5,"levelup":4,"ndn-browser-shim":6}],7:[function(require,module,exports){\nvar LOG = 0\nmodule.exports = LOG;\n\n},{}],8:[function(require,module,exports){\nrequire=(function(e,t,n,r){function i(r){if(!n[r]){if(!t[r]){if(e)return e(r);throw new Error("Cannot find module \'"+r+"\'")}var s=n[r]={exports:{}};t[r][0](function(e){var n=t[r][1][e];return i(n?n:e)},s,s.exports)}return n[r].exports}for(var s=0;s<r.length;s++)i(r[s]);return i})(typeof require!=="undefined"&&require,{1:[function(require,module,exports){\nexports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {\n  var e, m,\n      eLen = nBytes * 8 - mLen - 1,\n      eMax = (1 << eLen) - 1,\n      eBias = eMax >> 1,\n      nBits = -7,\n      i = isBE ? 0 : (nBytes - 1),\n      d = isBE ? 1 : -1,\n      s = buffer[offset + i];\n\n  i += d;\n\n  e = s & ((1 << (-nBits)) - 1);\n  s >>= (-nBits);\n  nBits += eLen;\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);\n\n  m = e & ((1 << (-nBits)) - 1);\n  e >>= (-nBits);\n  nBits += mLen;\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);\n\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity);\n  } else {\n    m = m + Math.pow(2, mLen);\n    e = e - eBias;\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n};\n\nexports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {\n  var e, m, c,\n      eLen = nBytes * 8 - mLen - 1,\n      eMax = (1 << eLen) - 1,\n      eBias = eMax >> 1,\n      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),\n      i = isBE ? (nBytes - 1) : 0,\n      d = isBE ? -1 : 1,\n      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;\n\n  value = Math.abs(value);\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0;\n    e = eMax;\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2);\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * Math.pow(2, 1 - eBias);\n    }\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n      e = 0;\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);\n\n  e = (e << mLen) | m;\n  eLen += mLen;\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);\n\n  buffer[offset + i - d] |= s * 128;\n};\n\n},{}],2:[function(require,module,exports){\n(function(){// UTILITY\nvar util = require(\'util\');\nvar Buffer = require("buffer").Buffer;\nvar pSlice = Array.prototype.slice;\n\nfunction objectKeys(object) {\n  if (Object.keys) return Object.keys(object);\n  var result = [];\n  for (var name in object) {\n    if (Object.prototype.hasOwnProperty.call(object, name)) {\n      result.push(name);\n    }\n  }\n  return result;\n}\n\n// 1. The assert module provides functions that throw\n// AssertionError\'s when particular conditions are not met. The\n// assert module must conform to the following interface.\n\nvar assert = module.exports = ok;\n\n// 2. The AssertionError is defined in assert.\n// new assert.AssertionError({ message: message,\n//                             actual: actual,\n//                             expected: expected })\n\nassert.AssertionError = function AssertionError(options) {\n  this.name = \'AssertionError\';\n  this.message = options.message;\n  this.actual = options.actual;\n  this.expected = options.expected;\n  this.operator = options.operator;\n  var stackStartFunction = options.stackStartFunction || fail;\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, stackStartFunction);\n  }\n};\nutil.inherits(assert.AssertionError, Error);\n\nfunction replacer(key, value) {\n  if (value === undefined) {\n    return \'\' + value;\n  }\n  if (typeof value === \'number\' && (isNaN(value) || !isFinite(value))) {\n    return value.toString();\n  }\n  if (typeof value === \'function\' || value instanceof RegExp) {\n    return value.toString();\n  }\n  return value;\n}\n\nfunction truncate(s, n) {\n  if (typeof s == \'string\') {\n    return s.length < n ? s : s.slice(0, n);\n  } else {\n    return s;\n  }\n}\n\nassert.AssertionError.prototype.toString = function() {\n  if (this.message) {\n    return [this.name + \':\', this.message].join(\' \');\n  } else {\n    return [\n      this.name + \':\',\n      truncate(JSON.stringify(this.actual, replacer), 128),\n      this.operator,\n      truncate(JSON.stringify(this.expected, replacer), 128)\n    ].join(\' \');\n  }\n};\n\n// assert.AssertionError instanceof Error\n\nassert.AssertionError.__proto__ = Error.prototype;\n\n// At present only the three keys mentioned above are used and\n// understood by the spec. Implementations or sub modules can pass\n// other keys to the AssertionError\'s constructor - they will be\n// ignored.\n\n// 3. All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided.  All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n\nfunction fail(actual, expected, message, operator, stackStartFunction) {\n  throw new assert.AssertionError({\n    message: message,\n    actual: actual,\n    expected: expected,\n    operator: operator,\n    stackStartFunction: stackStartFunction\n  });\n}\n\n// EXTENSION! allows for well behaved errors defined elsewhere.\nassert.fail = fail;\n\n// 4. Pure assertion tests whether a value is truthy, as determined\n// by !!guard.\n// assert.ok(guard, message_opt);\n// This statement is equivalent to assert.equal(true, guard,\n// message_opt);. To test strictly for the value true, use\n// assert.strictEqual(true, guard, message_opt);.\n\nfunction ok(value, message) {\n  if (!!!value) fail(value, true, message, \'==\', assert.ok);\n}\nassert.ok = ok;\n\n// 5. The equality assertion tests shallow, coercive equality with\n// ==.\n// assert.equal(actual, expected, message_opt);\n\nassert.equal = function equal(actual, expected, message) {\n  if (actual != expected) fail(actual, expected, message, \'==\', assert.equal);\n};\n\n// 6. The non-equality assertion tests for whether two objects are not equal\n// with != assert.notEqual(actual, expected, message_opt);\n\nassert.notEqual = function notEqual(actual, expected, message) {\n  if (actual == expected) {\n    fail(actual, expected, message, \'!=\', assert.notEqual);\n  }\n};\n\n// 7. The equivalence assertion tests a deep equality relation.\n// assert.deepEqual(actual, expected, message_opt);\n\nassert.deepEqual = function deepEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected)) {\n    fail(actual, expected, message, \'deepEqual\', assert.deepEqual);\n  }\n};\n\nfunction _deepEqual(actual, expected) {\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n\n  } else if (Buffer.isBuffer(actual) && Buffer.isBuffer(expected)) {\n    if (actual.length != expected.length) return false;\n\n    for (var i = 0; i < actual.length; i++) {\n      if (actual[i] !== expected[i]) return false;\n    }\n\n    return true;\n\n  // 7.2. If the expected value is a Date object, the actual value is\n  // equivalent if it is also a Date object that refers to the same time.\n  } else if (actual instanceof Date && expected instanceof Date) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3. Other pairs that do not both pass typeof value == \'object\',\n  // equivalence is determined by ==.\n  } else if (typeof actual != \'object\' && typeof expected != \'object\') {\n    return actual == expected;\n\n  // 7.4. For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical \'prototype\' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else {\n    return objEquiv(actual, expected);\n  }\n}\n\nfunction isUndefinedOrNull(value) {\n  return value === null || value === undefined;\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) == \'[object Arguments]\';\n}\n\nfunction objEquiv(a, b) {\n  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))\n    return false;\n  // an identical \'prototype\' property.\n  if (a.prototype !== b.prototype) return false;\n  //~~~I\'ve managed to break Object.keys through screwy arguments passing.\n  //   Converting to array solves the problem.\n  if (isArguments(a)) {\n    if (!isArguments(b)) {\n      return false;\n    }\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return _deepEqual(a, b);\n  }\n  try {\n    var ka = objectKeys(a),\n        kb = objectKeys(b),\n        key, i;\n  } catch (e) {//happens when one is a string literal and the other isn\'t\n    return false;\n  }\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length != kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!_deepEqual(a[key], b[key])) return false;\n  }\n  return true;\n}\n\n// 8. The non-equivalence assertion tests for any deep inequality.\n// assert.notDeepEqual(actual, expected, message_opt);\n\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected)) {\n    fail(actual, expected, message, \'notDeepEqual\', assert.notDeepEqual);\n  }\n};\n\n// 9. The strict equality assertion tests strict equality, as determined by ===.\n// assert.strictEqual(actual, expected, message_opt);\n\nassert.strictEqual = function strictEqual(actual, expected, message) {\n  if (actual !== expected) {\n    fail(actual, expected, message, \'===\', assert.strictEqual);\n  }\n};\n\n// 10. The strict non-equality assertion tests for strict inequality, as\n// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);\n\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n  if (actual === expected) {\n    fail(actual, expected, message, \'!==\', assert.notStrictEqual);\n  }\n};\n\nfunction expectedException(actual, expected) {\n  if (!actual || !expected) {\n    return false;\n  }\n\n  if (expected instanceof RegExp) {\n    return expected.test(actual);\n  } else if (actual instanceof expected) {\n    return true;\n  } else if (expected.call({}, actual) === true) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction _throws(shouldThrow, block, expected, message) {\n  var actual;\n\n  if (typeof expected === \'string\') {\n    message = expected;\n    expected = null;\n  }\n\n  try {\n    block();\n  } catch (e) {\n    actual = e;\n  }\n\n  message = (expected && expected.name ? \' (\' + expected.name + \').\' : \'.\') +\n            (message ? \' \' + message : \'.\');\n\n  if (shouldThrow && !actual) {\n    fail(\'Missing expected exception\' + message);\n  }\n\n  if (!shouldThrow && expectedException(actual, expected)) {\n    fail(\'Got unwanted exception\' + message);\n  }\n\n  if ((shouldThrow && actual && expected &&\n      !expectedException(actual, expected)) || (!shouldThrow && actual)) {\n    throw actual;\n  }\n}\n\n// 11. Expected to throw an error:\n// assert.throws(block, Error_opt, message_opt);\n\nassert.throws = function(block, /*optional*/error, /*optional*/message) {\n  _throws.apply(this, [true].concat(pSlice.call(arguments)));\n};\n\n// EXTENSION! This is annoying to write outside this module.\nassert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {\n  _throws.apply(this, [false].concat(pSlice.call(arguments)));\n};\n\nassert.ifError = function(err) { if (err) {throw err;}};\n\n})()\n},{"util":3,"buffer":4}],"buffer-browserify":[function(require,module,exports){\nmodule.exports=require(\'q9TxCC\');\n},{}],"q9TxCC":[function(require,module,exports){\n(function(){function SlowBuffer (size) {\n    this.length = size;\n};\n\nvar assert = require(\'assert\');\n\nexports.INSPECT_MAX_BYTES = 50;\n\n\nfunction toHex(n) {\n  if (n < 16) return \'0\' + n.toString(16);\n  return n.toString(16);\n}\n\nfunction utf8ToBytes(str) {\n  var byteArray = [];\n  for (var i = 0; i < str.length; i++)\n    if (str.charCodeAt(i) <= 0x7F)\n      byteArray.push(str.charCodeAt(i));\n    else {\n      var h = encodeURIComponent(str.charAt(i)).substr(1).split(\'%\');\n      for (var j = 0; j < h.length; j++)\n        byteArray.push(parseInt(h[j], 16));\n    }\n\n  return byteArray;\n}\n\nfunction asciiToBytes(str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++ )\n    // Node\'s code seems to be doing this and not & 0x7F..\n    byteArray.push( str.charCodeAt(i) & 0xFF );\n\n  return byteArray;\n}\n\nfunction base64ToBytes(str) {\n  return require("base64-js").toByteArray(str);\n}\n\nSlowBuffer.byteLength = function (str, encoding) {\n  switch (encoding || "utf8") {\n    case \'hex\':\n      return str.length / 2;\n\n    case \'utf8\':\n    case \'utf-8\':\n      return utf8ToBytes(str).length;\n\n    case \'ascii\':\n    case \'binary\':\n      return str.length;\n\n    case \'base64\':\n      return base64ToBytes(str).length;\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n};\n\nfunction blitBuffer(src, dst, offset, length) {\n  var pos, i = 0;\n  while (i < length) {\n    if ((i+offset >= dst.length) || (i >= src.length))\n      break;\n\n    dst[i + offset] = src[i];\n    i++;\n  }\n  return i;\n}\n\nSlowBuffer.prototype.utf8Write = function (string, offset, length) {\n  var bytes, pos;\n  return SlowBuffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);\n};\n\nSlowBuffer.prototype.asciiWrite = function (string, offset, length) {\n  var bytes, pos;\n  return SlowBuffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);\n};\n\nSlowBuffer.prototype.binaryWrite = SlowBuffer.prototype.asciiWrite;\n\nSlowBuffer.prototype.base64Write = function (string, offset, length) {\n  var bytes, pos;\n  return SlowBuffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);\n};\n\nSlowBuffer.prototype.base64Slice = function (start, end) {\n  var bytes = Array.prototype.slice.apply(this, arguments)\n  return require("base64-js").fromByteArray(bytes);\n}\n\nfunction decodeUtf8Char(str) {\n  try {\n    return decodeURIComponent(str);\n  } catch (err) {\n    return String.fromCharCode(0xFFFD); // UTF 8 invalid char\n  }\n}\n\nSlowBuffer.prototype.utf8Slice = function () {\n  var bytes = Array.prototype.slice.apply(this, arguments);\n  var res = "";\n  var tmp = "";\n  var i = 0;\n  while (i < bytes.length) {\n    if (bytes[i] <= 0x7F) {\n      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);\n      tmp = "";\n    } else\n      tmp += "%" + bytes[i].toString(16);\n\n    i++;\n  }\n\n  return res + decodeUtf8Char(tmp);\n}\n\nSlowBuffer.prototype.asciiSlice = function () {\n  var bytes = Array.prototype.slice.apply(this, arguments);\n  var ret = "";\n  for (var i = 0; i < bytes.length; i++)\n    ret += String.fromCharCode(bytes[i]);\n  return ret;\n}\n\nSlowBuffer.prototype.binarySlice = SlowBuffer.prototype.asciiSlice;\n\nSlowBuffer.prototype.inspect = function() {\n  var out = [],\n      len = this.length;\n  for (var i = 0; i < len; i++) {\n    out[i] = toHex(this[i]);\n    if (i == exports.INSPECT_MAX_BYTES) {\n      out[i + 1] = \'...\';\n      break;\n    }\n  }\n  return \'<SlowBuffer \' + out.join(\' \') + \'>\';\n};\n\n\nSlowBuffer.prototype.hexSlice = function(start, end) {\n  var len = this.length;\n\n  if (!start || start < 0) start = 0;\n  if (!end || end < 0 || end > len) end = len;\n\n  var out = \'\';\n  for (var i = start; i < end; i++) {\n    out += toHex(this[i]);\n  }\n  return out;\n};\n\n\nSlowBuffer.prototype.toString = function(encoding, start, end) {\n  encoding = String(encoding || \'utf8\').toLowerCase();\n  start = +start || 0;\n  if (typeof end == \'undefined\') end = this.length;\n\n  // Fastpath empty strings\n  if (+end == start) {\n    return \'\';\n  }\n\n  switch (encoding) {\n    case \'hex\':\n      return this.hexSlice(start, end);\n\n    case \'utf8\':\n    case \'utf-8\':\n      return this.utf8Slice(start, end);\n\n    case \'ascii\':\n      return this.asciiSlice(start, end);\n\n    case \'binary\':\n      return this.binarySlice(start, end);\n\n    case \'base64\':\n      return this.base64Slice(start, end);\n\n    case \'ucs2\':\n    case \'ucs-2\':\n      return this.ucs2Slice(start, end);\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n};\n\n\nSlowBuffer.prototype.hexWrite = function(string, offset, length) {\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length;\n  if (strLen % 2) {\n    throw new Error(\'Invalid hex string\');\n  }\n  if (length > strLen / 2) {\n    length = strLen / 2;\n  }\n  for (var i = 0; i < length; i++) {\n    var byte = parseInt(string.substr(i * 2, 2), 16);\n    if (isNaN(byte)) throw new Error(\'Invalid hex string\');\n    this[offset + i] = byte;\n  }\n  SlowBuffer._charsWritten = i * 2;\n  return i;\n};\n\n\nSlowBuffer.prototype.write = function(string, offset, length, encoding) {\n  // Support both (string, offset, length, encoding)\n  // and the legacy (string, encoding, offset, length)\n  if (isFinite(offset)) {\n    if (!isFinite(length)) {\n      encoding = length;\n      length = undefined;\n    }\n  } else {  // legacy\n    var swap = encoding;\n    encoding = offset;\n    offset = length;\n    length = swap;\n  }\n\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n  encoding = String(encoding || \'utf8\').toLowerCase();\n\n  switch (encoding) {\n    case \'hex\':\n      return this.hexWrite(string, offset, length);\n\n    case \'utf8\':\n    case \'utf-8\':\n      return this.utf8Write(string, offset, length);\n\n    case \'ascii\':\n      return this.asciiWrite(string, offset, length);\n\n    case \'binary\':\n      return this.binaryWrite(string, offset, length);\n\n    case \'base64\':\n      return this.base64Write(string, offset, length);\n\n    case \'ucs2\':\n    case \'ucs-2\':\n      return this.ucs2Write(string, offset, length);\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n};\n\n\n// slice(start, end)\nSlowBuffer.prototype.slice = function(start, end) {\n  if (end === undefined) end = this.length;\n\n  if (end > this.length) {\n    throw new Error(\'oob\');\n  }\n  if (start > end) {\n    throw new Error(\'oob\');\n  }\n\n  return new Buffer(this, end - start, +start);\n};\n\nSlowBuffer.prototype.copy = function(target, targetstart, sourcestart, sourceend) {\n  var temp = [];\n  for (var i=sourcestart; i<sourceend; i++) {\n    assert.ok(typeof this[i] !== \'undefined\', "copying undefined buffer bytes!");\n    temp.push(this[i]);\n  }\n\n  for (var i=targetstart; i<targetstart+temp.length; i++) {\n    target[i] = temp[i-targetstart];\n  }\n};\n\nSlowBuffer.prototype.fill = function(value, start, end) {\n  if (end > this.length) {\n    throw new Error(\'oob\');\n  }\n  if (start > end) {\n    throw new Error(\'oob\');\n  }\n\n  for (var i = start; i < end; i++) {\n    this[i] = value;\n  }\n}\n\nfunction coerce(length) {\n  // Coerce length to a number (possibly NaN), round up\n  // in case it\'s fractional (e.g. 123.456) then do a\n  // double negate to coerce a NaN to 0. Easy, right?\n  length = ~~Math.ceil(+length);\n  return length < 0 ? 0 : length;\n}\n\n\n// Buffer\n\nfunction Buffer(subject, encoding, offset) {\n  if (!(this instanceof Buffer)) {\n    return new Buffer(subject, encoding, offset);\n  }\n\n  var type;\n\n  // Are we slicing?\n  if (typeof offset === \'number\') {\n    this.length = coerce(encoding);\n    this.parent = subject;\n    this.offset = offset;\n  } else {\n    // Find the length\n    switch (type = typeof subject) {\n      case \'number\':\n        this.length = coerce(subject);\n        break;\n\n      case \'string\':\n        this.length = Buffer.byteLength(subject, encoding);\n        break;\n\n      case \'object\': // Assume object is an array\n        this.length = coerce(subject.length);\n        break;\n\n      default:\n        throw new Error(\'First argument needs to be a number, \' +\n                        \'array or string.\');\n    }\n\n    if (this.length > Buffer.poolSize) {\n      // Big buffer, just alloc one.\n      this.parent = new SlowBuffer(this.length);\n      this.offset = 0;\n\n    } else {\n      // Small buffer.\n      if (!pool || pool.length - pool.used < this.length) allocPool();\n      this.parent = pool;\n      this.offset = pool.used;\n      pool.used += this.length;\n    }\n\n    // Treat array-ish objects as a byte array.\n    if (isArrayIsh(subject)) {\n      for (var i = 0; i < this.length; i++) {\n        if (subject instanceof Buffer) {\n          this.parent[i + this.offset] = subject.readUInt8(i);\n        }\n        else {\n          this.parent[i + this.offset] = subject[i];\n        }\n      }\n    } else if (type == \'string\') {\n      // We are a string\n      this.length = this.write(subject, 0, encoding);\n    }\n  }\n\n}\n\nfunction isArrayIsh(subject) {\n  return Array.isArray(subject) || Buffer.isBuffer(subject) ||\n         subject && typeof subject === \'object\' &&\n         typeof subject.length === \'number\';\n}\n\nexports.SlowBuffer = SlowBuffer;\nexports.Buffer = Buffer;\n\nBuffer.poolSize = 8 * 1024;\nvar pool;\n\nfunction allocPool() {\n  pool = new SlowBuffer(Buffer.poolSize);\n  pool.used = 0;\n}\n\n\n// Static methods\nBuffer.isBuffer = function isBuffer(b) {\n  return b instanceof Buffer || b instanceof SlowBuffer;\n};\n\nBuffer.concat = function (list, totalLength) {\n  if (!Array.isArray(list)) {\n    throw new Error("Usage: Buffer.concat(list, [totalLength])\\n \\\n      list should be an Array.");\n  }\n\n  if (list.length === 0) {\n    return new Buffer(0);\n  } else if (list.length === 1) {\n    return list[0];\n  }\n\n  if (typeof totalLength !== \'number\') {\n    totalLength = 0;\n    for (var i = 0; i < list.length; i++) {\n      var buf = list[i];\n      totalLength += buf.length;\n    }\n  }\n\n  var buffer = new Buffer(totalLength);\n  var pos = 0;\n  for (var i = 0; i < list.length; i++) {\n    var buf = list[i];\n    buf.copy(buffer, pos);\n    pos += buf.length;\n  }\n  return buffer;\n};\n\n// Inspect\nBuffer.prototype.inspect = function inspect() {\n  var out = [],\n      len = this.length;\n\n  for (var i = 0; i < len; i++) {\n    out[i] = toHex(this.parent[i + this.offset]);\n    if (i == exports.INSPECT_MAX_BYTES) {\n      out[i + 1] = \'...\';\n      break;\n    }\n  }\n\n  return \'<Buffer \' + out.join(\' \') + \'>\';\n};\n\n\nBuffer.prototype.get = function get(i) {\n  if (i < 0 || i >= this.length) throw new Error(\'oob\');\n  return this.parent[this.offset + i];\n};\n\n\nBuffer.prototype.set = function set(i, v) {\n  if (i < 0 || i >= this.length) throw new Error(\'oob\');\n  return this.parent[this.offset + i] = v;\n};\n\n\n// write(string, offset = 0, length = buffer.length-offset, encoding = \'utf8\')\nBuffer.prototype.write = function(string, offset, length, encoding) {\n  // Support both (string, offset, length, encoding)\n  // and the legacy (string, encoding, offset, length)\n  if (isFinite(offset)) {\n    if (!isFinite(length)) {\n      encoding = length;\n      length = undefined;\n    }\n  } else {  // legacy\n    var swap = encoding;\n    encoding = offset;\n    offset = length;\n    length = swap;\n  }\n\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n  encoding = String(encoding || \'utf8\').toLowerCase();\n\n  var ret;\n  switch (encoding) {\n    case \'hex\':\n      ret = this.parent.hexWrite(string, this.offset + offset, length);\n      break;\n\n    case \'utf8\':\n    case \'utf-8\':\n      ret = this.parent.utf8Write(string, this.offset + offset, length);\n      break;\n\n    case \'ascii\':\n      ret = this.parent.asciiWrite(string, this.offset + offset, length);\n      break;\n\n    case \'binary\':\n      ret = this.parent.binaryWrite(string, this.offset + offset, length);\n      break;\n\n    case \'base64\':\n      // Warning: maxLength not taken into account in base64Write\n      ret = this.parent.base64Write(string, this.offset + offset, length);\n      break;\n\n    case \'ucs2\':\n    case \'ucs-2\':\n      ret = this.parent.ucs2Write(string, this.offset + offset, length);\n      break;\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n\n  Buffer._charsWritten = SlowBuffer._charsWritten;\n\n  return ret;\n};\n\n\n// toString(encoding, start=0, end=buffer.length)\nBuffer.prototype.toString = function(encoding, start, end) {\n  encoding = String(encoding || \'utf8\').toLowerCase();\n\n  if (typeof start == \'undefined\' || start < 0) {\n    start = 0;\n  } else if (start > this.length) {\n    start = this.length;\n  }\n\n  if (typeof end == \'undefined\' || end > this.length) {\n    end = this.length;\n  } else if (end < 0) {\n    end = 0;\n  }\n\n  start = start + this.offset;\n  end = end + this.offset;\n\n  switch (encoding) {\n    case \'hex\':\n      return this.parent.hexSlice(start, end);\n\n    case \'utf8\':\n    case \'utf-8\':\n      return this.parent.utf8Slice(start, end);\n\n    case \'ascii\':\n      return this.parent.asciiSlice(start, end);\n\n    case \'binary\':\n      return this.parent.binarySlice(start, end);\n\n    case \'base64\':\n      return this.parent.base64Slice(start, end);\n\n    case \'ucs2\':\n    case \'ucs-2\':\n      return this.parent.ucs2Slice(start, end);\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n};\n\n\n// byteLength\nBuffer.byteLength = SlowBuffer.byteLength;\n\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function fill(value, start, end) {\n  value || (value = 0);\n  start || (start = 0);\n  end || (end = this.length);\n\n  if (typeof value === \'string\') {\n    value = value.charCodeAt(0);\n  }\n  if (!(typeof value === \'number\') || isNaN(value)) {\n    throw new Error(\'value is not a number\');\n  }\n\n  if (end < start) throw new Error(\'end < start\');\n\n  // Fill 0 bytes; we\'re done\n  if (end === start) return 0;\n  if (this.length == 0) return 0;\n\n  if (start < 0 || start >= this.length) {\n    throw new Error(\'start out of bounds\');\n  }\n\n  if (end < 0 || end > this.length) {\n    throw new Error(\'end out of bounds\');\n  }\n\n  return this.parent.fill(value,\n                          start + this.offset,\n                          end + this.offset);\n};\n\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function(target, target_start, start, end) {\n  var source = this;\n  start || (start = 0);\n  end || (end = this.length);\n  target_start || (target_start = 0);\n\n  if (end < start) throw new Error(\'sourceEnd < sourceStart\');\n\n  // Copy 0 bytes; we\'re done\n  if (end === start) return 0;\n  if (target.length == 0 || source.length == 0) return 0;\n\n  if (target_start < 0 || target_start >= target.length) {\n    throw new Error(\'targetStart out of bounds\');\n  }\n\n  if (start < 0 || start >= source.length) {\n    throw new Error(\'sourceStart out of bounds\');\n  }\n\n  if (end < 0 || end > source.length) {\n    throw new Error(\'sourceEnd out of bounds\');\n  }\n\n  // Are we oob?\n  if (end > this.length) {\n    end = this.length;\n  }\n\n  if (target.length - target_start < end - start) {\n    end = target.length - target_start + start;\n  }\n\n  return this.parent.copy(target.parent,\n                          target_start + target.offset,\n                          start + this.offset,\n                          end + this.offset);\n};\n\n\n// slice(start, end)\nBuffer.prototype.slice = function(start, end) {\n  if (end === undefined) end = this.length;\n  if (end > this.length) throw new Error(\'oob\');\n  if (start > end) throw new Error(\'oob\');\n\n  return new Buffer(this.parent, end - start, +start + this.offset);\n};\n\n\n// Legacy methods for backwards compatibility.\n\nBuffer.prototype.utf8Slice = function(start, end) {\n  return this.toString(\'utf8\', start, end);\n};\n\nBuffer.prototype.binarySlice = function(start, end) {\n  return this.toString(\'binary\', start, end);\n};\n\nBuffer.prototype.asciiSlice = function(start, end) {\n  return this.toString(\'ascii\', start, end);\n};\n\nBuffer.prototype.utf8Write = function(string, offset) {\n  return this.write(string, offset, \'utf8\');\n};\n\nBuffer.prototype.binaryWrite = function(string, offset) {\n  return this.write(string, offset, \'binary\');\n};\n\nBuffer.prototype.asciiWrite = function(string, offset) {\n  return this.write(string, offset, \'ascii\');\n};\n\nBuffer.prototype.readUInt8 = function(offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  if (offset >= buffer.length) return;\n\n  return buffer.parent[buffer.offset + offset];\n};\n\nfunction readUInt16(buffer, offset, isBigEndian, noAssert) {\n  var val = 0;\n\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 1 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  if (offset >= buffer.length) return 0;\n\n  if (isBigEndian) {\n    val = buffer.parent[buffer.offset + offset] << 8;\n    if (offset + 1 < buffer.length) {\n      val |= buffer.parent[buffer.offset + offset + 1];\n    }\n  } else {\n    val = buffer.parent[buffer.offset + offset];\n    if (offset + 1 < buffer.length) {\n      val |= buffer.parent[buffer.offset + offset + 1] << 8;\n    }\n  }\n\n  return val;\n}\n\nBuffer.prototype.readUInt16LE = function(offset, noAssert) {\n  return readUInt16(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readUInt16BE = function(offset, noAssert) {\n  return readUInt16(this, offset, true, noAssert);\n};\n\nfunction readUInt32(buffer, offset, isBigEndian, noAssert) {\n  var val = 0;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  if (offset >= buffer.length) return 0;\n\n  if (isBigEndian) {\n    if (offset + 1 < buffer.length)\n      val = buffer.parent[buffer.offset + offset + 1] << 16;\n    if (offset + 2 < buffer.length)\n      val |= buffer.parent[buffer.offset + offset + 2] << 8;\n    if (offset + 3 < buffer.length)\n      val |= buffer.parent[buffer.offset + offset + 3];\n    val = val + (buffer.parent[buffer.offset + offset] << 24 >>> 0);\n  } else {\n    if (offset + 2 < buffer.length)\n      val = buffer.parent[buffer.offset + offset + 2] << 16;\n    if (offset + 1 < buffer.length)\n      val |= buffer.parent[buffer.offset + offset + 1] << 8;\n    val |= buffer.parent[buffer.offset + offset];\n    if (offset + 3 < buffer.length)\n      val = val + (buffer.parent[buffer.offset + offset + 3] << 24 >>> 0);\n  }\n\n  return val;\n}\n\nBuffer.prototype.readUInt32LE = function(offset, noAssert) {\n  return readUInt32(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readUInt32BE = function(offset, noAssert) {\n  return readUInt32(this, offset, true, noAssert);\n};\n\n\n/*\n * Signed integer types, yay team! A reminder on how two\'s complement actually\n * works. The first bit is the signed bit, i.e. tells us whether or not the\n * number should be positive or negative. If the two\'s complement value is\n * positive, then we\'re done, as it\'s equivalent to the unsigned representation.\n *\n * Now if the number is positive, you\'re pretty much done, you can just leverage\n * the unsigned translations and return those. Unfortunately, negative numbers\n * aren\'t quite that straightforward.\n *\n * At first glance, one might be inclined to use the traditional formula to\n * translate binary numbers between the positive and negative values in two\'s\n * complement. (Though it doesn\'t quite work for the most negative value)\n * Mainly:\n *  - invert all the bits\n *  - add one to the result\n *\n * Of course, this doesn\'t quite work in Javascript. Take for example the value\n * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of\n * course, Javascript will do the following:\n *\n * > ~0xff80\n * -65409\n *\n * Whoh there, Javascript, that\'s not quite right. But wait, according to\n * Javascript that\'s perfectly correct. When Javascript ends up seeing the\n * constant 0xff80, it has no notion that it is actually a signed number. It\n * assumes that we\'ve input the unsigned value 0xff80. Thus, when it does the\n * binary negation, it casts it into a signed value, (positive 0xff80). Then\n * when you perform binary negation on that, it turns it into a negative number.\n *\n * Instead, we\'re going to have to use the following general formula, that works\n * in a rather Javascript friendly way. I\'m glad we don\'t support this kind of\n * weird numbering scheme in the kernel.\n *\n * (BIT-MAX - (unsigned)val + 1) * -1\n *\n * The astute observer, may think that this doesn\'t make sense for 8-bit numbers\n * (really it isn\'t necessary for them). However, when you get 16-bit numbers,\n * you do. Let\'s go back to our prior example and see how this will look:\n *\n * (0xffff - 0xff80 + 1) * -1\n * (0x007f + 1) * -1\n * (0x0080) * -1\n */\nBuffer.prototype.readInt8 = function(offset, noAssert) {\n  var buffer = this;\n  var neg;\n\n  if (!noAssert) {\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  if (offset >= buffer.length) return;\n\n  neg = buffer.parent[buffer.offset + offset] & 0x80;\n  if (!neg) {\n    return (buffer.parent[buffer.offset + offset]);\n  }\n\n  return ((0xff - buffer.parent[buffer.offset + offset] + 1) * -1);\n};\n\nfunction readInt16(buffer, offset, isBigEndian, noAssert) {\n  var neg, val;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 1 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  val = readUInt16(buffer, offset, isBigEndian, noAssert);\n  neg = val & 0x8000;\n  if (!neg) {\n    return val;\n  }\n\n  return (0xffff - val + 1) * -1;\n}\n\nBuffer.prototype.readInt16LE = function(offset, noAssert) {\n  return readInt16(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readInt16BE = function(offset, noAssert) {\n  return readInt16(this, offset, true, noAssert);\n};\n\nfunction readInt32(buffer, offset, isBigEndian, noAssert) {\n  var neg, val;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  val = readUInt32(buffer, offset, isBigEndian, noAssert);\n  neg = val & 0x80000000;\n  if (!neg) {\n    return (val);\n  }\n\n  return (0xffffffff - val + 1) * -1;\n}\n\nBuffer.prototype.readInt32LE = function(offset, noAssert) {\n  return readInt32(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readInt32BE = function(offset, noAssert) {\n  return readInt32(this, offset, true, noAssert);\n};\n\nfunction readFloat(buffer, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  return require(\'./buffer_ieee754\').readIEEE754(buffer, offset, isBigEndian,\n      23, 4);\n}\n\nBuffer.prototype.readFloatLE = function(offset, noAssert) {\n  return readFloat(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readFloatBE = function(offset, noAssert) {\n  return readFloat(this, offset, true, noAssert);\n};\n\nfunction readDouble(buffer, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset + 7 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  return require(\'./buffer_ieee754\').readIEEE754(buffer, offset, isBigEndian,\n      52, 8);\n}\n\nBuffer.prototype.readDoubleLE = function(offset, noAssert) {\n  return readDouble(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readDoubleBE = function(offset, noAssert) {\n  return readDouble(this, offset, true, noAssert);\n};\n\n\n/*\n * We have to make sure that the value is a valid integer. This means that it is\n * non-negative. It has no fractional component and that it does not exceed the\n * maximum allowed value.\n *\n *      value           The number to check for validity\n *\n *      max             The maximum value\n */\nfunction verifuint(value, max) {\n  assert.ok(typeof (value) == \'number\',\n      \'cannot write a non-number as a number\');\n\n  assert.ok(value >= 0,\n      \'specified a negative value for writing an unsigned value\');\n\n  assert.ok(value <= max, \'value is larger than maximum value for type\');\n\n  assert.ok(Math.floor(value) === value, \'value has a fractional component\');\n}\n\nBuffer.prototype.writeUInt8 = function(value, offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset < buffer.length,\n        \'trying to write beyond buffer length\');\n\n    verifuint(value, 0xff);\n  }\n\n  if (offset < buffer.length) {\n    buffer.parent[buffer.offset + offset] = value;\n  }\n};\n\nfunction writeUInt16(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 1 < buffer.length,\n        \'trying to write beyond buffer length\');\n\n    verifuint(value, 0xffff);\n  }\n\n  for (var i = 0; i < Math.min(buffer.length - offset, 2); i++) {\n    buffer.parent[buffer.offset + offset + i] =\n        (value & (0xff << (8 * (isBigEndian ? 1 - i : i)))) >>>\n            (isBigEndian ? 1 - i : i) * 8;\n  }\n\n}\n\nBuffer.prototype.writeUInt16LE = function(value, offset, noAssert) {\n  writeUInt16(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeUInt16BE = function(value, offset, noAssert) {\n  writeUInt16(this, value, offset, true, noAssert);\n};\n\nfunction writeUInt32(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'trying to write beyond buffer length\');\n\n    verifuint(value, 0xffffffff);\n  }\n\n  for (var i = 0; i < Math.min(buffer.length - offset, 4); i++) {\n    buffer.parent[buffer.offset + offset + i] =\n        (value >>> (isBigEndian ? 3 - i : i) * 8) & 0xff;\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function(value, offset, noAssert) {\n  writeUInt32(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeUInt32BE = function(value, offset, noAssert) {\n  writeUInt32(this, value, offset, true, noAssert);\n};\n\n\n/*\n * We now move onto our friends in the signed number category. Unlike unsigned\n * numbers, we\'re going to have to worry a bit more about how we put values into\n * arrays. Since we are only worrying about signed 32-bit values, we\'re in\n * slightly better shape. Unfortunately, we really can\'t do our favorite binary\n * & in this system. It really seems to do the wrong thing. For example:\n *\n * > -32 & 0xff\n * 224\n *\n * What\'s happening above is really: 0xe0 & 0xff = 0xe0. However, the results of\n * this aren\'t treated as a signed number. Ultimately a bad thing.\n *\n * What we\'re going to want to do is basically create the unsigned equivalent of\n * our representation and pass that off to the wuint* functions. To do that\n * we\'re going to do the following:\n *\n *  - if the value is positive\n *      we can pass it directly off to the equivalent wuint\n *  - if the value is negative\n *      we do the following computation:\n *         mb + val + 1, where\n *         mb   is the maximum unsigned value in that byte size\n *         val  is the Javascript negative integer\n *\n *\n * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If\n * you do out the computations:\n *\n * 0xffff - 128 + 1\n * 0xffff - 127\n * 0xff80\n *\n * You can then encode this value as the signed version. This is really rather\n * hacky, but it should work and get the job done which is our goal here.\n */\n\n/*\n * A series of checks to make sure we actually have a signed 32-bit number\n */\nfunction verifsint(value, max, min) {\n  assert.ok(typeof (value) == \'number\',\n      \'cannot write a non-number as a number\');\n\n  assert.ok(value <= max, \'value larger than maximum allowed value\');\n\n  assert.ok(value >= min, \'value smaller than minimum allowed value\');\n\n  assert.ok(Math.floor(value) === value, \'value has a fractional component\');\n}\n\nfunction verifIEEE754(value, max, min) {\n  assert.ok(typeof (value) == \'number\',\n      \'cannot write a non-number as a number\');\n\n  assert.ok(value <= max, \'value larger than maximum allowed value\');\n\n  assert.ok(value >= min, \'value smaller than minimum allowed value\');\n}\n\nBuffer.prototype.writeInt8 = function(value, offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifsint(value, 0x7f, -0x80);\n  }\n\n  if (value >= 0) {\n    buffer.writeUInt8(value, offset, noAssert);\n  } else {\n    buffer.writeUInt8(0xff + value + 1, offset, noAssert);\n  }\n};\n\nfunction writeInt16(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 1 < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifsint(value, 0x7fff, -0x8000);\n  }\n\n  if (value >= 0) {\n    writeUInt16(buffer, value, offset, isBigEndian, noAssert);\n  } else {\n    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);\n  }\n}\n\nBuffer.prototype.writeInt16LE = function(value, offset, noAssert) {\n  writeInt16(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeInt16BE = function(value, offset, noAssert) {\n  writeInt16(this, value, offset, true, noAssert);\n};\n\nfunction writeInt32(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifsint(value, 0x7fffffff, -0x80000000);\n  }\n\n  if (value >= 0) {\n    writeUInt32(buffer, value, offset, isBigEndian, noAssert);\n  } else {\n    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);\n  }\n}\n\nBuffer.prototype.writeInt32LE = function(value, offset, noAssert) {\n  writeInt32(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeInt32BE = function(value, offset, noAssert) {\n  writeInt32(this, value, offset, true, noAssert);\n};\n\nfunction writeFloat(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);\n  }\n\n  require(\'./buffer_ieee754\').writeIEEE754(buffer, value, offset, isBigEndian,\n      23, 4);\n}\n\nBuffer.prototype.writeFloatLE = function(value, offset, noAssert) {\n  writeFloat(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeFloatBE = function(value, offset, noAssert) {\n  writeFloat(this, value, offset, true, noAssert);\n};\n\nfunction writeDouble(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 7 < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);\n  }\n\n  require(\'./buffer_ieee754\').writeIEEE754(buffer, value, offset, isBigEndian,\n      52, 8);\n}\n\nBuffer.prototype.writeDoubleLE = function(value, offset, noAssert) {\n  writeDouble(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeDoubleBE = function(value, offset, noAssert) {\n  writeDouble(this, value, offset, true, noAssert);\n};\n\nSlowBuffer.prototype.readUInt8 = Buffer.prototype.readUInt8;\nSlowBuffer.prototype.readUInt16LE = Buffer.prototype.readUInt16LE;\nSlowBuffer.prototype.readUInt16BE = Buffer.prototype.readUInt16BE;\nSlowBuffer.prototype.readUInt32LE = Buffer.prototype.readUInt32LE;\nSlowBuffer.prototype.readUInt32BE = Buffer.prototype.readUInt32BE;\nSlowBuffer.prototype.readInt8 = Buffer.prototype.readInt8;\nSlowBuffer.prototype.readInt16LE = Buffer.prototype.readInt16LE;\nSlowBuffer.prototype.readInt16BE = Buffer.prototype.readInt16BE;\nSlowBuffer.prototype.readInt32LE = Buffer.prototype.readInt32LE;\nSlowBuffer.prototype.readInt32BE = Buffer.prototype.readInt32BE;\nSlowBuffer.prototype.readFloatLE = Buffer.prototype.readFloatLE;\nSlowBuffer.prototype.readFloatBE = Buffer.prototype.readFloatBE;\nSlowBuffer.prototype.readDoubleLE = Buffer.prototype.readDoubleLE;\nSlowBuffer.prototype.readDoubleBE = Buffer.prototype.readDoubleBE;\nSlowBuffer.prototype.writeUInt8 = Buffer.prototype.writeUInt8;\nSlowBuffer.prototype.writeUInt16LE = Buffer.prototype.writeUInt16LE;\nSlowBuffer.prototype.writeUInt16BE = Buffer.prototype.writeUInt16BE;\nSlowBuffer.prototype.writeUInt32LE = Buffer.prototype.writeUInt32LE;\nSlowBuffer.prototype.writeUInt32BE = Buffer.prototype.writeUInt32BE;\nSlowBuffer.prototype.writeInt8 = Buffer.prototype.writeInt8;\nSlowBuffer.prototype.writeInt16LE = Buffer.prototype.writeInt16LE;\nSlowBuffer.prototype.writeInt16BE = Buffer.prototype.writeInt16BE;\nSlowBuffer.prototype.writeInt32LE = Buffer.prototype.writeInt32LE;\nSlowBuffer.prototype.writeInt32BE = Buffer.prototype.writeInt32BE;\nSlowBuffer.prototype.writeFloatLE = Buffer.prototype.writeFloatLE;\nSlowBuffer.prototype.writeFloatBE = Buffer.prototype.writeFloatBE;\nSlowBuffer.prototype.writeDoubleLE = Buffer.prototype.writeDoubleLE;\nSlowBuffer.prototype.writeDoubleBE = Buffer.prototype.writeDoubleBE;\n\n})()\n},{"assert":2,"./buffer_ieee754":1,"base64-js":5}],3:[function(require,module,exports){\nvar events = require(\'events\');\n\nexports.isArray = isArray;\nexports.isDate = function(obj){return Object.prototype.toString.call(obj) === \'[object Date]\'};\nexports.isRegExp = function(obj){return Object.prototype.toString.call(obj) === \'[object RegExp]\'};\n\n\nexports.print = function () {};\nexports.puts = function () {};\nexports.debug = function() {};\n\nexports.inspect = function(obj, showHidden, depth, colors) {\n  var seen = [];\n\n  var stylize = function(str, styleType) {\n    // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\n    var styles =\n        { \'bold\' : [1, 22],\n          \'italic\' : [3, 23],\n          \'underline\' : [4, 24],\n          \'inverse\' : [7, 27],\n          \'white\' : [37, 39],\n          \'grey\' : [90, 39],\n          \'black\' : [30, 39],\n          \'blue\' : [34, 39],\n          \'cyan\' : [36, 39],\n          \'green\' : [32, 39],\n          \'magenta\' : [35, 39],\n          \'red\' : [31, 39],\n          \'yellow\' : [33, 39] };\n\n    var style =\n        { \'special\': \'cyan\',\n          \'number\': \'blue\',\n          \'boolean\': \'yellow\',\n          \'undefined\': \'grey\',\n          \'null\': \'bold\',\n          \'string\': \'green\',\n          \'date\': \'magenta\',\n          // "name": intentionally not styling\n          \'regexp\': \'red\' }[styleType];\n\n    if (style) {\n      return \'\\033[\' + styles[style][0] + \'m\' + str +\n             \'\\033[\' + styles[style][1] + \'m\';\n    } else {\n      return str;\n    }\n  };\n  if (! colors) {\n    stylize = function(str, styleType) { return str; };\n  }\n\n  function format(value, recurseTimes) {\n    // Provide a hook for user-specified inspect functions.\n    // Check that value is an object with an inspect function on it\n    if (value && typeof value.inspect === \'function\' &&\n        // Filter out the util module, it\'s inspect function is special\n        value !== exports &&\n        // Also filter out any prototype objects using the circular check.\n        !(value.constructor && value.constructor.prototype === value)) {\n      return value.inspect(recurseTimes);\n    }\n\n    // Primitive types cannot have properties\n    switch (typeof value) {\n      case \'undefined\':\n        return stylize(\'undefined\', \'undefined\');\n\n      case \'string\':\n        var simple = \'\\\'\' + JSON.stringify(value).replace(/^"|"$/g, \'\')\n                                                 .replace(/\'/g, "\\\\\'")\n                                                 .replace(/\\\\"/g, \'"\') + \'\\\'\';\n        return stylize(simple, \'string\');\n\n      case \'number\':\n        return stylize(\'\' + value, \'number\');\n\n      case \'boolean\':\n        return stylize(\'\' + value, \'boolean\');\n    }\n    // For some reason typeof null is "object", so special case here.\n    if (value === null) {\n      return stylize(\'null\', \'null\');\n    }\n\n    // Look up the keys of the object.\n    var visible_keys = Object_keys(value);\n    var keys = showHidden ? Object_getOwnPropertyNames(value) : visible_keys;\n\n    // Functions without properties can be shortcutted.\n    if (typeof value === \'function\' && keys.length === 0) {\n      if (isRegExp(value)) {\n        return stylize(\'\' + value, \'regexp\');\n      } else {\n        var name = value.name ? \': \' + value.name : \'\';\n        return stylize(\'[Function\' + name + \']\', \'special\');\n      }\n    }\n\n    // Dates without properties can be shortcutted\n    if (isDate(value) && keys.length === 0) {\n      return stylize(value.toUTCString(), \'date\');\n    }\n\n    var base, type, braces;\n    // Determine the object type\n    if (isArray(value)) {\n      type = \'Array\';\n      braces = [\'[\', \']\'];\n    } else {\n      type = \'Object\';\n      braces = [\'{\', \'}\'];\n    }\n\n    // Make functions say that they are functions\n    if (typeof value === \'function\') {\n      var n = value.name ? \': \' + value.name : \'\';\n      base = (isRegExp(value)) ? \' \' + value : \' [Function\' + n + \']\';\n    } else {\n      base = \'\';\n    }\n\n    // Make dates with properties first say the date\n    if (isDate(value)) {\n      base = \' \' + value.toUTCString();\n    }\n\n    if (keys.length === 0) {\n      return braces[0] + base + braces[1];\n    }\n\n    if (recurseTimes < 0) {\n      if (isRegExp(value)) {\n        return stylize(\'\' + value, \'regexp\');\n      } else {\n        return stylize(\'[Object]\', \'special\');\n      }\n    }\n\n    seen.push(value);\n\n    var output = keys.map(function(key) {\n      var name, str;\n      if (value.__lookupGetter__) {\n        if (value.__lookupGetter__(key)) {\n          if (value.__lookupSetter__(key)) {\n            str = stylize(\'[Getter/Setter]\', \'special\');\n          } else {\n            str = stylize(\'[Getter]\', \'special\');\n          }\n        } else {\n          if (value.__lookupSetter__(key)) {\n            str = stylize(\'[Setter]\', \'special\');\n          }\n        }\n      }\n      if (visible_keys.indexOf(key) < 0) {\n        name = \'[\' + key + \']\';\n      }\n      if (!str) {\n        if (seen.indexOf(value[key]) < 0) {\n          if (recurseTimes === null) {\n            str = format(value[key]);\n          } else {\n            str = format(value[key], recurseTimes - 1);\n          }\n          if (str.indexOf(\'\\n\') > -1) {\n            if (isArray(value)) {\n              str = str.split(\'\\n\').map(function(line) {\n                return \'  \' + line;\n              }).join(\'\\n\').substr(2);\n            } else {\n              str = \'\\n\' + str.split(\'\\n\').map(function(line) {\n                return \'   \' + line;\n              }).join(\'\\n\');\n            }\n          }\n        } else {\n          str = stylize(\'[Circular]\', \'special\');\n        }\n      }\n      if (typeof name === \'undefined\') {\n        if (type === \'Array\' && key.match(/^\\d+$/)) {\n          return str;\n        }\n        name = JSON.stringify(\'\' + key);\n        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {\n          name = name.substr(1, name.length - 2);\n          name = stylize(name, \'name\');\n        } else {\n          name = name.replace(/\'/g, "\\\\\'")\n                     .replace(/\\\\"/g, \'"\')\n                     .replace(/(^"|"$)/g, "\'");\n          name = stylize(name, \'string\');\n        }\n      }\n\n      return name + \': \' + str;\n    });\n\n    seen.pop();\n\n    var numLinesEst = 0;\n    var length = output.reduce(function(prev, cur) {\n      numLinesEst++;\n      if (cur.indexOf(\'\\n\') >= 0) numLinesEst++;\n      return prev + cur.length + 1;\n    }, 0);\n\n    if (length > 50) {\n      output = braces[0] +\n               (base === \'\' ? \'\' : base + \'\\n \') +\n               \' \' +\n               output.join(\',\\n  \') +\n               \' \' +\n               braces[1];\n\n    } else {\n      output = braces[0] + base + \' \' + output.join(\', \') + \' \' + braces[1];\n    }\n\n    return output;\n  }\n  return format(obj, (typeof depth === \'undefined\' ? 2 : depth));\n};\n\n\nfunction isArray(ar) {\n  return ar instanceof Array ||\n         Array.isArray(ar) ||\n         (ar && ar !== Object.prototype && isArray(ar.__proto__));\n}\n\n\nfunction isRegExp(re) {\n  return re instanceof RegExp ||\n    (typeof re === \'object\' && Object.prototype.toString.call(re) === \'[object RegExp]\');\n}\n\n\nfunction isDate(d) {\n  if (d instanceof Date) return true;\n  if (typeof d !== \'object\') return false;\n  var properties = Date.prototype && Object_getOwnPropertyNames(Date.prototype);\n  var proto = d.__proto__ && Object_getOwnPropertyNames(d.__proto__);\n  return JSON.stringify(proto) === JSON.stringify(properties);\n}\n\nfunction pad(n) {\n  return n < 10 ? \'0\' + n.toString(10) : n.toString(10);\n}\n\nvar months = [\'Jan\', \'Feb\', \'Mar\', \'Apr\', \'May\', \'Jun\', \'Jul\', \'Aug\', \'Sep\',\n              \'Oct\', \'Nov\', \'Dec\'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(\':\');\n  return [d.getDate(), months[d.getMonth()], time].join(\' \');\n}\n\nexports.log = function (msg) {};\n\nexports.pump = null;\n\nvar Object_keys = Object.keys || function (obj) {\n    var res = [];\n    for (var key in obj) res.push(key);\n    return res;\n};\n\nvar Object_getOwnPropertyNames = Object.getOwnPropertyNames || function (obj) {\n    var res = [];\n    for (var key in obj) {\n        if (Object.hasOwnProperty.call(obj, key)) res.push(key);\n    }\n    return res;\n};\n\nvar Object_create = Object.create || function (prototype, properties) {\n    // from es5-shim\n    var object;\n    if (prototype === null) {\n        object = { \'__proto__\' : null };\n    }\n    else {\n        if (typeof prototype !== \'object\') {\n            throw new TypeError(\n                \'typeof prototype[\' + (typeof prototype) + \'] != \\\'object\\\'\'\n            );\n        }\n        var Type = function () {};\n        Type.prototype = prototype;\n        object = new Type();\n        object.__proto__ = prototype;\n    }\n    if (typeof properties !== \'undefined\' && Object.defineProperties) {\n        Object.defineProperties(object, properties);\n    }\n    return object;\n};\n\nexports.inherits = function(ctor, superCtor) {\n  ctor.super_ = superCtor;\n  ctor.prototype = Object_create(superCtor.prototype, {\n    constructor: {\n      value: ctor,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n};\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (typeof f !== \'string\') {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(exports.inspect(arguments[i]));\n    }\n    return objects.join(\' \');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === \'%%\') return \'%\';\n    if (i >= len) return x;\n    switch (x) {\n      case \'%s\': return String(args[i++]);\n      case \'%d\': return Number(args[i++]);\n      case \'%j\': return JSON.stringify(args[i++]);\n      default:\n        return x;\n    }\n  });\n  for(var x = args[i]; i < len; x = args[++i]){\n    if (x === null || typeof x !== \'object\') {\n      str += \' \' + x;\n    } else {\n      str += \' \' + exports.inspect(x);\n    }\n  }\n  return str;\n};\n\n},{"events":6}],5:[function(require,module,exports){\n(function (exports) {\n\t\'use strict\';\n\n\tvar lookup = \'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\';\n\n\tfunction b64ToByteArray(b64) {\n\t\tvar i, j, l, tmp, placeHolders, arr;\n\t\n\t\tif (b64.length % 4 > 0) {\n\t\t\tthrow \'Invalid string. Length must be a multiple of 4\';\n\t\t}\n\n\t\t// the number of equal signs (place holders)\n\t\t// if there are two placeholders, than the two characters before it\n\t\t// represent one byte\n\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t// this is just a cheap hack to not do indexOf twice\n\t\tplaceHolders = b64.indexOf(\'=\');\n\t\tplaceHolders = placeHolders > 0 ? b64.length - placeHolders : 0;\n\n\t\t// base64 is 4/3 + up to two characters of the original data\n\t\tarr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);\n\n\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length;\n\n\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);\n\t\t\tarr.push((tmp & 0xFF0000) >> 16);\n\t\t\tarr.push((tmp & 0xFF00) >> 8);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t}\n\n\t\tif (placeHolders === 2) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t} else if (placeHolders === 1) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);\n\t\t\tarr.push((tmp >> 8) & 0xFF);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t}\n\n\t\treturn arr;\n\t}\n\n\tfunction uint8ToBase64(uint8) {\n\t\tvar i,\n\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\toutput = "",\n\t\t\ttemp, length;\n\n\t\tfunction tripletToBase64 (num) {\n\t\t\treturn lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n\t\t};\n\n\t\t// go through the array every three bytes, we\'ll deal with trailing stuff later\n\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);\n\t\t\toutput += tripletToBase64(temp);\n\t\t}\n\n\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\tswitch (extraBytes) {\n\t\t\tcase 1:\n\t\t\t\ttemp = uint8[uint8.length - 1];\n\t\t\t\toutput += lookup[temp >> 2];\n\t\t\t\toutput += lookup[(temp << 4) & 0x3F];\n\t\t\t\toutput += \'==\';\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);\n\t\t\t\toutput += lookup[temp >> 10];\n\t\t\t\toutput += lookup[(temp >> 4) & 0x3F];\n\t\t\t\toutput += lookup[(temp << 2) & 0x3F];\n\t\t\t\toutput += \'=\';\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn output;\n\t}\n\n\tmodule.exports.toByteArray = b64ToByteArray;\n\tmodule.exports.fromByteArray = uint8ToBase64;\n}());\n\n},{}],7:[function(require,module,exports){\nexports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {\n  var e, m,\n      eLen = nBytes * 8 - mLen - 1,\n      eMax = (1 << eLen) - 1,\n      eBias = eMax >> 1,\n      nBits = -7,\n      i = isBE ? 0 : (nBytes - 1),\n      d = isBE ? 1 : -1,\n      s = buffer[offset + i];\n\n  i += d;\n\n  e = s & ((1 << (-nBits)) - 1);\n  s >>= (-nBits);\n  nBits += eLen;\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);\n\n  m = e & ((1 << (-nBits)) - 1);\n  e >>= (-nBits);\n  nBits += mLen;\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);\n\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity);\n  } else {\n    m = m + Math.pow(2, mLen);\n    e = e - eBias;\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n};\n\nexports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {\n  var e, m, c,\n      eLen = nBytes * 8 - mLen - 1,\n      eMax = (1 << eLen) - 1,\n      eBias = eMax >> 1,\n      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),\n      i = isBE ? (nBytes - 1) : 0,\n      d = isBE ? -1 : 1,\n      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;\n\n  value = Math.abs(value);\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0;\n    e = eMax;\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2);\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * Math.pow(2, 1 - eBias);\n    }\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n      e = 0;\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);\n\n  e = (e << mLen) | m;\n  eLen += mLen;\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);\n\n  buffer[offset + i - d] |= s * 128;\n};\n\n},{}],8:[function(require,module,exports){\n// shim for using process in browser\n\nvar process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== \'undefined\'\n    && window.setImmediate;\n    var canPost = typeof window !== \'undefined\'\n    && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    if (canPost) {\n        var queue = [];\n        window.addEventListener(\'message\', function (ev) {\n            if (ev.source === window && ev.data === \'process-tick\') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage(\'process-tick\', \'*\');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = \'browser\';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nprocess.binding = function (name) {\n    throw new Error(\'process.binding is not supported\');\n}\n\n// TODO(shtylman)\nprocess.cwd = function () { return \'/\' };\nprocess.chdir = function (dir) {\n    throw new Error(\'process.chdir is not supported\');\n};\n\n},{}],6:[function(require,module,exports){\n(function(process){if (!process.EventEmitter) process.EventEmitter = function () {};\n\nvar EventEmitter = exports.EventEmitter = process.EventEmitter;\nvar isArray = typeof Array.isArray === \'function\'\n    ? Array.isArray\n    : function (xs) {\n        return Object.prototype.toString.call(xs) === \'[object Array]\'\n    }\n;\nfunction indexOf (xs, x) {\n    if (xs.indexOf) return xs.indexOf(x);\n    for (var i = 0; i < xs.length; i++) {\n        if (x === xs[i]) return i;\n    }\n    return -1;\n}\n\n// By default EventEmitters will print a warning if more than\n// 10 listeners are added to it. This is a useful default which\n// helps finding memory leaks.\n//\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nvar defaultMaxListeners = 10;\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!this._events) this._events = {};\n  this._events.maxListeners = n;\n};\n\n\nEventEmitter.prototype.emit = function(type) {\n  // If there is no \'error\' event listener then throw.\n  if (type === \'error\') {\n    if (!this._events || !this._events.error ||\n        (isArray(this._events.error) && !this._events.error.length))\n    {\n      if (arguments[1] instanceof Error) {\n        throw arguments[1]; // Unhandled \'error\' event\n      } else {\n        throw new Error("Uncaught, unspecified \'error\' event.");\n      }\n      return false;\n    }\n  }\n\n  if (!this._events) return false;\n  var handler = this._events[type];\n  if (!handler) return false;\n\n  if (typeof handler == \'function\') {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        var args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n    return true;\n\n  } else if (isArray(handler)) {\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    var listeners = handler.slice();\n    for (var i = 0, l = listeners.length; i < l; i++) {\n      listeners[i].apply(this, args);\n    }\n    return true;\n\n  } else {\n    return false;\n  }\n};\n\n// EventEmitter is defined in src/node_events.cc\n// EventEmitter.prototype.emit() is also defined there.\nEventEmitter.prototype.addListener = function(type, listener) {\n  if (\'function\' !== typeof listener) {\n    throw new Error(\'addListener only takes instances of Function\');\n  }\n\n  if (!this._events) this._events = {};\n\n  // To avoid recursion in the case that type == "newListeners"! Before\n  // adding it to the listeners, first emit "newListeners".\n  this.emit(\'newListener\', type, listener);\n\n  if (!this._events[type]) {\n    // Optimize the case of one listener. Don\'t need the extra array object.\n    this._events[type] = listener;\n  } else if (isArray(this._events[type])) {\n\n    // Check for listener leak\n    if (!this._events[type].warned) {\n      var m;\n      if (this._events.maxListeners !== undefined) {\n        m = this._events.maxListeners;\n      } else {\n        m = defaultMaxListeners;\n      }\n\n      if (m && m > 0 && this._events[type].length > m) {\n        this._events[type].warned = true;\n        console.error(\'(node) warning: possible EventEmitter memory \' +\n                      \'leak detected. %d listeners added. \' +\n                      \'Use emitter.setMaxListeners() to increase limit.\',\n                      this._events[type].length);\n        console.trace();\n      }\n    }\n\n    // If we\'ve already got an array, just append.\n    this._events[type].push(listener);\n  } else {\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  var self = this;\n  self.on(type, function g() {\n    self.removeListener(type, g);\n    listener.apply(this, arguments);\n  });\n\n  return this;\n};\n\nEventEmitter.prototype.removeListener = function(type, listener) {\n  if (\'function\' !== typeof listener) {\n    throw new Error(\'removeListener only takes instances of Function\');\n  }\n\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (!this._events || !this._events[type]) return this;\n\n  var list = this._events[type];\n\n  if (isArray(list)) {\n    var i = indexOf(list, listener);\n    if (i < 0) return this;\n    list.splice(i, 1);\n    if (list.length == 0)\n      delete this._events[type];\n  } else if (this._events[type] === listener) {\n    delete this._events[type];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  if (arguments.length === 0) {\n    this._events = {};\n    return this;\n  }\n\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (type && this._events && this._events[type]) this._events[type] = null;\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  if (!this._events) this._events = {};\n  if (!this._events[type]) this._events[type] = [];\n  if (!isArray(this._events[type])) {\n    this._events[type] = [this._events[type]];\n  }\n  return this._events[type];\n};\n\n})(require("__browserify_process"))\n},{"__browserify_process":8}],4:[function(require,module,exports){\n(function(){function SlowBuffer (size) {\n    this.length = size;\n};\n\nvar assert = require(\'assert\');\n\nexports.INSPECT_MAX_BYTES = 50;\n\n\nfunction toHex(n) {\n  if (n < 16) return \'0\' + n.toString(16);\n  return n.toString(16);\n}\n\nfunction utf8ToBytes(str) {\n  var byteArray = [];\n  for (var i = 0; i < str.length; i++)\n    if (str.charCodeAt(i) <= 0x7F)\n      byteArray.push(str.charCodeAt(i));\n    else {\n      var h = encodeURIComponent(str.charAt(i)).substr(1).split(\'%\');\n      for (var j = 0; j < h.length; j++)\n        byteArray.push(parseInt(h[j], 16));\n    }\n\n  return byteArray;\n}\n\nfunction asciiToBytes(str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++ )\n    // Node\'s code seems to be doing this and not & 0x7F..\n    byteArray.push( str.charCodeAt(i) & 0xFF );\n\n  return byteArray;\n}\n\nfunction base64ToBytes(str) {\n  return require("base64-js").toByteArray(str);\n}\n\nSlowBuffer.byteLength = function (str, encoding) {\n  switch (encoding || "utf8") {\n    case \'hex\':\n      return str.length / 2;\n\n    case \'utf8\':\n    case \'utf-8\':\n      return utf8ToBytes(str).length;\n\n    case \'ascii\':\n      return str.length;\n\n    case \'base64\':\n      return base64ToBytes(str).length;\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n};\n\nfunction blitBuffer(src, dst, offset, length) {\n  var pos, i = 0;\n  while (i < length) {\n    if ((i+offset >= dst.length) || (i >= src.length))\n      break;\n\n    dst[i + offset] = src[i];\n    i++;\n  }\n  return i;\n}\n\nSlowBuffer.prototype.utf8Write = function (string, offset, length) {\n  var bytes, pos;\n  return SlowBuffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);\n};\n\nSlowBuffer.prototype.asciiWrite = function (string, offset, length) {\n  var bytes, pos;\n  return SlowBuffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);\n};\n\nSlowBuffer.prototype.base64Write = function (string, offset, length) {\n  var bytes, pos;\n  return SlowBuffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);\n};\n\nSlowBuffer.prototype.base64Slice = function (start, end) {\n  var bytes = Array.prototype.slice.apply(this, arguments)\n  return require("base64-js").fromByteArray(bytes);\n}\n\nfunction decodeUtf8Char(str) {\n  try {\n    return decodeURIComponent(str);\n  } catch (err) {\n    return String.fromCharCode(0xFFFD); // UTF 8 invalid char\n  }\n}\n\nSlowBuffer.prototype.utf8Slice = function () {\n  var bytes = Array.prototype.slice.apply(this, arguments);\n  var res = "";\n  var tmp = "";\n  var i = 0;\n  while (i < bytes.length) {\n    if (bytes[i] <= 0x7F) {\n      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);\n      tmp = "";\n    } else\n      tmp += "%" + bytes[i].toString(16);\n\n    i++;\n  }\n\n  return res + decodeUtf8Char(tmp);\n}\n\nSlowBuffer.prototype.asciiSlice = function () {\n  var bytes = Array.prototype.slice.apply(this, arguments);\n  var ret = "";\n  for (var i = 0; i < bytes.length; i++)\n    ret += String.fromCharCode(bytes[i]);\n  return ret;\n}\n\nSlowBuffer.prototype.inspect = function() {\n  var out = [],\n      len = this.length;\n  for (var i = 0; i < len; i++) {\n    out[i] = toHex(this[i]);\n    if (i == exports.INSPECT_MAX_BYTES) {\n      out[i + 1] = \'...\';\n      break;\n    }\n  }\n  return \'<SlowBuffer \' + out.join(\' \') + \'>\';\n};\n\n\nSlowBuffer.prototype.hexSlice = function(start, end) {\n  var len = this.length;\n\n  if (!start || start < 0) start = 0;\n  if (!end || end < 0 || end > len) end = len;\n\n  var out = \'\';\n  for (var i = start; i < end; i++) {\n    out += toHex(this[i]);\n  }\n  return out;\n};\n\n\nSlowBuffer.prototype.toString = function(encoding, start, end) {\n  encoding = String(encoding || \'utf8\').toLowerCase();\n  start = +start || 0;\n  if (typeof end == \'undefined\') end = this.length;\n\n  // Fastpath empty strings\n  if (+end == start) {\n    return \'\';\n  }\n\n  switch (encoding) {\n    case \'hex\':\n      return this.hexSlice(start, end);\n\n    case \'utf8\':\n    case \'utf-8\':\n      return this.utf8Slice(start, end);\n\n    case \'ascii\':\n      return this.asciiSlice(start, end);\n\n    case \'binary\':\n      return this.binarySlice(start, end);\n\n    case \'base64\':\n      return this.base64Slice(start, end);\n\n    case \'ucs2\':\n    case \'ucs-2\':\n      return this.ucs2Slice(start, end);\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n};\n\n\nSlowBuffer.prototype.hexWrite = function(string, offset, length) {\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length;\n  if (strLen % 2) {\n    throw new Error(\'Invalid hex string\');\n  }\n  if (length > strLen / 2) {\n    length = strLen / 2;\n  }\n  for (var i = 0; i < length; i++) {\n    var byte = parseInt(string.substr(i * 2, 2), 16);\n    if (isNaN(byte)) throw new Error(\'Invalid hex string\');\n    this[offset + i] = byte;\n  }\n  SlowBuffer._charsWritten = i * 2;\n  return i;\n};\n\n\nSlowBuffer.prototype.write = function(string, offset, length, encoding) {\n  // Support both (string, offset, length, encoding)\n  // and the legacy (string, encoding, offset, length)\n  if (isFinite(offset)) {\n    if (!isFinite(length)) {\n      encoding = length;\n      length = undefined;\n    }\n  } else {  // legacy\n    var swap = encoding;\n    encoding = offset;\n    offset = length;\n    length = swap;\n  }\n\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n  encoding = String(encoding || \'utf8\').toLowerCase();\n\n  switch (encoding) {\n    case \'hex\':\n      return this.hexWrite(string, offset, length);\n\n    case \'utf8\':\n    case \'utf-8\':\n      return this.utf8Write(string, offset, length);\n\n    case \'ascii\':\n      return this.asciiWrite(string, offset, length);\n\n    case \'binary\':\n      return this.binaryWrite(string, offset, length);\n\n    case \'base64\':\n      return this.base64Write(string, offset, length);\n\n    case \'ucs2\':\n    case \'ucs-2\':\n      return this.ucs2Write(string, offset, length);\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n};\n\n\n// slice(start, end)\nSlowBuffer.prototype.slice = function(start, end) {\n  if (end === undefined) end = this.length;\n\n  if (end > this.length) {\n    throw new Error(\'oob\');\n  }\n  if (start > end) {\n    throw new Error(\'oob\');\n  }\n\n  return new Buffer(this, end - start, +start);\n};\n\nSlowBuffer.prototype.copy = function(target, targetstart, sourcestart, sourceend) {\n  var temp = [];\n  for (var i=sourcestart; i<sourceend; i++) {\n    assert.ok(typeof this[i] !== \'undefined\', "copying undefined buffer bytes!");\n    temp.push(this[i]);\n  }\n\n  for (var i=targetstart; i<targetstart+temp.length; i++) {\n    target[i] = temp[i-targetstart];\n  }\n};\n\nfunction coerce(length) {\n  // Coerce length to a number (possibly NaN), round up\n  // in case it\'s fractional (e.g. 123.456) then do a\n  // double negate to coerce a NaN to 0. Easy, right?\n  length = ~~Math.ceil(+length);\n  return length < 0 ? 0 : length;\n}\n\n\n// Buffer\n\nfunction Buffer(subject, encoding, offset) {\n  if (!(this instanceof Buffer)) {\n    return new Buffer(subject, encoding, offset);\n  }\n\n  var type;\n\n  // Are we slicing?\n  if (typeof offset === \'number\') {\n    this.length = coerce(encoding);\n    this.parent = subject;\n    this.offset = offset;\n  } else {\n    // Find the length\n    switch (type = typeof subject) {\n      case \'number\':\n        this.length = coerce(subject);\n        break;\n\n      case \'string\':\n        this.length = Buffer.byteLength(subject, encoding);\n        break;\n\n      case \'object\': // Assume object is an array\n        this.length = coerce(subject.length);\n        break;\n\n      default:\n        throw new Error(\'First argument needs to be a number, \' +\n                        \'array or string.\');\n    }\n\n    if (this.length > Buffer.poolSize) {\n      // Big buffer, just alloc one.\n      this.parent = new SlowBuffer(this.length);\n      this.offset = 0;\n\n    } else {\n      // Small buffer.\n      if (!pool || pool.length - pool.used < this.length) allocPool();\n      this.parent = pool;\n      this.offset = pool.used;\n      pool.used += this.length;\n    }\n\n    // Treat array-ish objects as a byte array.\n    if (isArrayIsh(subject)) {\n      for (var i = 0; i < this.length; i++) {\n        this.parent[i + this.offset] = subject[i];\n      }\n    } else if (type == \'string\') {\n      // We are a string\n      this.length = this.write(subject, 0, encoding);\n    }\n  }\n\n}\n\nfunction isArrayIsh(subject) {\n  return Array.isArray(subject) || Buffer.isBuffer(subject) ||\n         subject && typeof subject === \'object\' &&\n         typeof subject.length === \'number\';\n}\n\nexports.SlowBuffer = SlowBuffer;\nexports.Buffer = Buffer;\n\nBuffer.poolSize = 8 * 1024;\nvar pool;\n\nfunction allocPool() {\n  pool = new SlowBuffer(Buffer.poolSize);\n  pool.used = 0;\n}\n\n\n// Static methods\nBuffer.isBuffer = function isBuffer(b) {\n  return b instanceof Buffer || b instanceof SlowBuffer;\n};\n\nBuffer.concat = function (list, totalLength) {\n  if (!Array.isArray(list)) {\n    throw new Error("Usage: Buffer.concat(list, [totalLength])\\n \\\n      list should be an Array.");\n  }\n\n  if (list.length === 0) {\n    return new Buffer(0);\n  } else if (list.length === 1) {\n    return list[0];\n  }\n\n  if (typeof totalLength !== \'number\') {\n    totalLength = 0;\n    for (var i = 0; i < list.length; i++) {\n      var buf = list[i];\n      totalLength += buf.length;\n    }\n  }\n\n  var buffer = new Buffer(totalLength);\n  var pos = 0;\n  for (var i = 0; i < list.length; i++) {\n    var buf = list[i];\n    buf.copy(buffer, pos);\n    pos += buf.length;\n  }\n  return buffer;\n};\n\n// Inspect\nBuffer.prototype.inspect = function inspect() {\n  var out = [],\n      len = this.length;\n\n  for (var i = 0; i < len; i++) {\n    out[i] = toHex(this.parent[i + this.offset]);\n    if (i == exports.INSPECT_MAX_BYTES) {\n      out[i + 1] = \'...\';\n      break;\n    }\n  }\n\n  return \'<Buffer \' + out.join(\' \') + \'>\';\n};\n\n\nBuffer.prototype.get = function get(i) {\n  if (i < 0 || i >= this.length) throw new Error(\'oob\');\n  return this.parent[this.offset + i];\n};\n\n\nBuffer.prototype.set = function set(i, v) {\n  if (i < 0 || i >= this.length) throw new Error(\'oob\');\n  return this.parent[this.offset + i] = v;\n};\n\n\n// write(string, offset = 0, length = buffer.length-offset, encoding = \'utf8\')\nBuffer.prototype.write = function(string, offset, length, encoding) {\n  // Support both (string, offset, length, encoding)\n  // and the legacy (string, encoding, offset, length)\n  if (isFinite(offset)) {\n    if (!isFinite(length)) {\n      encoding = length;\n      length = undefined;\n    }\n  } else {  // legacy\n    var swap = encoding;\n    encoding = offset;\n    offset = length;\n    length = swap;\n  }\n\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n  encoding = String(encoding || \'utf8\').toLowerCase();\n\n  var ret;\n  switch (encoding) {\n    case \'hex\':\n      ret = this.parent.hexWrite(string, this.offset + offset, length);\n      break;\n\n    case \'utf8\':\n    case \'utf-8\':\n      ret = this.parent.utf8Write(string, this.offset + offset, length);\n      break;\n\n    case \'ascii\':\n      ret = this.parent.asciiWrite(string, this.offset + offset, length);\n      break;\n\n    case \'binary\':\n      ret = this.parent.binaryWrite(string, this.offset + offset, length);\n      break;\n\n    case \'base64\':\n      // Warning: maxLength not taken into account in base64Write\n      ret = this.parent.base64Write(string, this.offset + offset, length);\n      break;\n\n    case \'ucs2\':\n    case \'ucs-2\':\n      ret = this.parent.ucs2Write(string, this.offset + offset, length);\n      break;\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n\n  Buffer._charsWritten = SlowBuffer._charsWritten;\n\n  return ret;\n};\n\n\n// toString(encoding, start=0, end=buffer.length)\nBuffer.prototype.toString = function(encoding, start, end) {\n  encoding = String(encoding || \'utf8\').toLowerCase();\n\n  if (typeof start == \'undefined\' || start < 0) {\n    start = 0;\n  } else if (start > this.length) {\n    start = this.length;\n  }\n\n  if (typeof end == \'undefined\' || end > this.length) {\n    end = this.length;\n  } else if (end < 0) {\n    end = 0;\n  }\n\n  start = start + this.offset;\n  end = end + this.offset;\n\n  switch (encoding) {\n    case \'hex\':\n      return this.parent.hexSlice(start, end);\n\n    case \'utf8\':\n    case \'utf-8\':\n      return this.parent.utf8Slice(start, end);\n\n    case \'ascii\':\n      return this.parent.asciiSlice(start, end);\n\n    case \'binary\':\n      return this.parent.binarySlice(start, end);\n\n    case \'base64\':\n      return this.parent.base64Slice(start, end);\n\n    case \'ucs2\':\n    case \'ucs-2\':\n      return this.parent.ucs2Slice(start, end);\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n};\n\n\n// byteLength\nBuffer.byteLength = SlowBuffer.byteLength;\n\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function fill(value, start, end) {\n  value || (value = 0);\n  start || (start = 0);\n  end || (end = this.length);\n\n  if (typeof value === \'string\') {\n    value = value.charCodeAt(0);\n  }\n  if (!(typeof value === \'number\') || isNaN(value)) {\n    throw new Error(\'value is not a number\');\n  }\n\n  if (end < start) throw new Error(\'end < start\');\n\n  // Fill 0 bytes; we\'re done\n  if (end === start) return 0;\n  if (this.length == 0) return 0;\n\n  if (start < 0 || start >= this.length) {\n    throw new Error(\'start out of bounds\');\n  }\n\n  if (end < 0 || end > this.length) {\n    throw new Error(\'end out of bounds\');\n  }\n\n  return this.parent.fill(value,\n                          start + this.offset,\n                          end + this.offset);\n};\n\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function(target, target_start, start, end) {\n  var source = this;\n  start || (start = 0);\n  end || (end = this.length);\n  target_start || (target_start = 0);\n\n  if (end < start) throw new Error(\'sourceEnd < sourceStart\');\n\n  // Copy 0 bytes; we\'re done\n  if (end === start) return 0;\n  if (target.length == 0 || source.length == 0) return 0;\n\n  if (target_start < 0 || target_start >= target.length) {\n    throw new Error(\'targetStart out of bounds\');\n  }\n\n  if (start < 0 || start >= source.length) {\n    throw new Error(\'sourceStart out of bounds\');\n  }\n\n  if (end < 0 || end > source.length) {\n    throw new Error(\'sourceEnd out of bounds\');\n  }\n\n  // Are we oob?\n  if (end > this.length) {\n    end = this.length;\n  }\n\n  if (target.length - target_start < end - start) {\n    end = target.length - target_start + start;\n  }\n\n  return this.parent.copy(target.parent,\n                          target_start + target.offset,\n                          start + this.offset,\n                          end + this.offset);\n};\n\n\n// slice(start, end)\nBuffer.prototype.slice = function(start, end) {\n  if (end === undefined) end = this.length;\n  if (end > this.length) throw new Error(\'oob\');\n  if (start > end) throw new Error(\'oob\');\n\n  return new Buffer(this.parent, end - start, +start + this.offset);\n};\n\n\n// Legacy methods for backwards compatibility.\n\nBuffer.prototype.utf8Slice = function(start, end) {\n  return this.toString(\'utf8\', start, end);\n};\n\nBuffer.prototype.binarySlice = function(start, end) {\n  return this.toString(\'binary\', start, end);\n};\n\nBuffer.prototype.asciiSlice = function(start, end) {\n  return this.toString(\'ascii\', start, end);\n};\n\nBuffer.prototype.utf8Write = function(string, offset) {\n  return this.write(string, offset, \'utf8\');\n};\n\nBuffer.prototype.binaryWrite = function(string, offset) {\n  return this.write(string, offset, \'binary\');\n};\n\nBuffer.prototype.asciiWrite = function(string, offset) {\n  return this.write(string, offset, \'ascii\');\n};\n\nBuffer.prototype.readUInt8 = function(offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  return buffer.parent[buffer.offset + offset];\n};\n\nfunction readUInt16(buffer, offset, isBigEndian, noAssert) {\n  var val = 0;\n\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 1 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  if (isBigEndian) {\n    val = buffer.parent[buffer.offset + offset] << 8;\n    val |= buffer.parent[buffer.offset + offset + 1];\n  } else {\n    val = buffer.parent[buffer.offset + offset];\n    val |= buffer.parent[buffer.offset + offset + 1] << 8;\n  }\n\n  return val;\n}\n\nBuffer.prototype.readUInt16LE = function(offset, noAssert) {\n  return readUInt16(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readUInt16BE = function(offset, noAssert) {\n  return readUInt16(this, offset, true, noAssert);\n};\n\nfunction readUInt32(buffer, offset, isBigEndian, noAssert) {\n  var val = 0;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  if (isBigEndian) {\n    val = buffer.parent[buffer.offset + offset + 1] << 16;\n    val |= buffer.parent[buffer.offset + offset + 2] << 8;\n    val |= buffer.parent[buffer.offset + offset + 3];\n    val = val + (buffer.parent[buffer.offset + offset] << 24 >>> 0);\n  } else {\n    val = buffer.parent[buffer.offset + offset + 2] << 16;\n    val |= buffer.parent[buffer.offset + offset + 1] << 8;\n    val |= buffer.parent[buffer.offset + offset];\n    val = val + (buffer.parent[buffer.offset + offset + 3] << 24 >>> 0);\n  }\n\n  return val;\n}\n\nBuffer.prototype.readUInt32LE = function(offset, noAssert) {\n  return readUInt32(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readUInt32BE = function(offset, noAssert) {\n  return readUInt32(this, offset, true, noAssert);\n};\n\n\n/*\n * Signed integer types, yay team! A reminder on how two\'s complement actually\n * works. The first bit is the signed bit, i.e. tells us whether or not the\n * number should be positive or negative. If the two\'s complement value is\n * positive, then we\'re done, as it\'s equivalent to the unsigned representation.\n *\n * Now if the number is positive, you\'re pretty much done, you can just leverage\n * the unsigned translations and return those. Unfortunately, negative numbers\n * aren\'t quite that straightforward.\n *\n * At first glance, one might be inclined to use the traditional formula to\n * translate binary numbers between the positive and negative values in two\'s\n * complement. (Though it doesn\'t quite work for the most negative value)\n * Mainly:\n *  - invert all the bits\n *  - add one to the result\n *\n * Of course, this doesn\'t quite work in Javascript. Take for example the value\n * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of\n * course, Javascript will do the following:\n *\n * > ~0xff80\n * -65409\n *\n * Whoh there, Javascript, that\'s not quite right. But wait, according to\n * Javascript that\'s perfectly correct. When Javascript ends up seeing the\n * constant 0xff80, it has no notion that it is actually a signed number. It\n * assumes that we\'ve input the unsigned value 0xff80. Thus, when it does the\n * binary negation, it casts it into a signed value, (positive 0xff80). Then\n * when you perform binary negation on that, it turns it into a negative number.\n *\n * Instead, we\'re going to have to use the following general formula, that works\n * in a rather Javascript friendly way. I\'m glad we don\'t support this kind of\n * weird numbering scheme in the kernel.\n *\n * (BIT-MAX - (unsigned)val + 1) * -1\n *\n * The astute observer, may think that this doesn\'t make sense for 8-bit numbers\n * (really it isn\'t necessary for them). However, when you get 16-bit numbers,\n * you do. Let\'s go back to our prior example and see how this will look:\n *\n * (0xffff - 0xff80 + 1) * -1\n * (0x007f + 1) * -1\n * (0x0080) * -1\n */\nBuffer.prototype.readInt8 = function(offset, noAssert) {\n  var buffer = this;\n  var neg;\n\n  if (!noAssert) {\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  neg = buffer.parent[buffer.offset + offset] & 0x80;\n  if (!neg) {\n    return (buffer.parent[buffer.offset + offset]);\n  }\n\n  return ((0xff - buffer.parent[buffer.offset + offset] + 1) * -1);\n};\n\nfunction readInt16(buffer, offset, isBigEndian, noAssert) {\n  var neg, val;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 1 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  val = readUInt16(buffer, offset, isBigEndian, noAssert);\n  neg = val & 0x8000;\n  if (!neg) {\n    return val;\n  }\n\n  return (0xffff - val + 1) * -1;\n}\n\nBuffer.prototype.readInt16LE = function(offset, noAssert) {\n  return readInt16(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readInt16BE = function(offset, noAssert) {\n  return readInt16(this, offset, true, noAssert);\n};\n\nfunction readInt32(buffer, offset, isBigEndian, noAssert) {\n  var neg, val;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  val = readUInt32(buffer, offset, isBigEndian, noAssert);\n  neg = val & 0x80000000;\n  if (!neg) {\n    return (val);\n  }\n\n  return (0xffffffff - val + 1) * -1;\n}\n\nBuffer.prototype.readInt32LE = function(offset, noAssert) {\n  return readInt32(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readInt32BE = function(offset, noAssert) {\n  return readInt32(this, offset, true, noAssert);\n};\n\nfunction readFloat(buffer, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  return require(\'./buffer_ieee754\').readIEEE754(buffer, offset, isBigEndian,\n      23, 4);\n}\n\nBuffer.prototype.readFloatLE = function(offset, noAssert) {\n  return readFloat(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readFloatBE = function(offset, noAssert) {\n  return readFloat(this, offset, true, noAssert);\n};\n\nfunction readDouble(buffer, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset + 7 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  return require(\'./buffer_ieee754\').readIEEE754(buffer, offset, isBigEndian,\n      52, 8);\n}\n\nBuffer.prototype.readDoubleLE = function(offset, noAssert) {\n  return readDouble(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readDoubleBE = function(offset, noAssert) {\n  return readDouble(this, offset, true, noAssert);\n};\n\n\n/*\n * We have to make sure that the value is a valid integer. This means that it is\n * non-negative. It has no fractional component and that it does not exceed the\n * maximum allowed value.\n *\n *      value           The number to check for validity\n *\n *      max             The maximum value\n */\nfunction verifuint(value, max) {\n  assert.ok(typeof (value) == \'number\',\n      \'cannot write a non-number as a number\');\n\n  assert.ok(value >= 0,\n      \'specified a negative value for writing an unsigned value\');\n\n  assert.ok(value <= max, \'value is larger than maximum value for type\');\n\n  assert.ok(Math.floor(value) === value, \'value has a fractional component\');\n}\n\nBuffer.prototype.writeUInt8 = function(value, offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset < buffer.length,\n        \'trying to write beyond buffer length\');\n\n    verifuint(value, 0xff);\n  }\n\n  buffer.parent[buffer.offset + offset] = value;\n};\n\nfunction writeUInt16(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 1 < buffer.length,\n        \'trying to write beyond buffer length\');\n\n    verifuint(value, 0xffff);\n  }\n\n  if (isBigEndian) {\n    buffer.parent[buffer.offset + offset] = (value & 0xff00) >>> 8;\n    buffer.parent[buffer.offset + offset + 1] = value & 0x00ff;\n  } else {\n    buffer.parent[buffer.offset + offset + 1] = (value & 0xff00) >>> 8;\n    buffer.parent[buffer.offset + offset] = value & 0x00ff;\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function(value, offset, noAssert) {\n  writeUInt16(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeUInt16BE = function(value, offset, noAssert) {\n  writeUInt16(this, value, offset, true, noAssert);\n};\n\nfunction writeUInt32(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'trying to write beyond buffer length\');\n\n    verifuint(value, 0xffffffff);\n  }\n\n  if (isBigEndian) {\n    buffer.parent[buffer.offset + offset] = (value >>> 24) & 0xff;\n    buffer.parent[buffer.offset + offset + 1] = (value >>> 16) & 0xff;\n    buffer.parent[buffer.offset + offset + 2] = (value >>> 8) & 0xff;\n    buffer.parent[buffer.offset + offset + 3] = value & 0xff;\n  } else {\n    buffer.parent[buffer.offset + offset + 3] = (value >>> 24) & 0xff;\n    buffer.parent[buffer.offset + offset + 2] = (value >>> 16) & 0xff;\n    buffer.parent[buffer.offset + offset + 1] = (value >>> 8) & 0xff;\n    buffer.parent[buffer.offset + offset] = value & 0xff;\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function(value, offset, noAssert) {\n  writeUInt32(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeUInt32BE = function(value, offset, noAssert) {\n  writeUInt32(this, value, offset, true, noAssert);\n};\n\n\n/*\n * We now move onto our friends in the signed number category. Unlike unsigned\n * numbers, we\'re going to have to worry a bit more about how we put values into\n * arrays. Since we are only worrying about signed 32-bit values, we\'re in\n * slightly better shape. Unfortunately, we really can\'t do our favorite binary\n * & in this system. It really seems to do the wrong thing. For example:\n *\n * > -32 & 0xff\n * 224\n *\n * What\'s happening above is really: 0xe0 & 0xff = 0xe0. However, the results of\n * this aren\'t treated as a signed number. Ultimately a bad thing.\n *\n * What we\'re going to want to do is basically create the unsigned equivalent of\n * our representation and pass that off to the wuint* functions. To do that\n * we\'re going to do the following:\n *\n *  - if the value is positive\n *      we can pass it directly off to the equivalent wuint\n *  - if the value is negative\n *      we do the following computation:\n *         mb + val + 1, where\n *         mb   is the maximum unsigned value in that byte size\n *         val  is the Javascript negative integer\n *\n *\n * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If\n * you do out the computations:\n *\n * 0xffff - 128 + 1\n * 0xffff - 127\n * 0xff80\n *\n * You can then encode this value as the signed version. This is really rather\n * hacky, but it should work and get the job done which is our goal here.\n */\n\n/*\n * A series of checks to make sure we actually have a signed 32-bit number\n */\nfunction verifsint(value, max, min) {\n  assert.ok(typeof (value) == \'number\',\n      \'cannot write a non-number as a number\');\n\n  assert.ok(value <= max, \'value larger than maximum allowed value\');\n\n  assert.ok(value >= min, \'value smaller than minimum allowed value\');\n\n  assert.ok(Math.floor(value) === value, \'value has a fractional component\');\n}\n\nfunction verifIEEE754(value, max, min) {\n  assert.ok(typeof (value) == \'number\',\n      \'cannot write a non-number as a number\');\n\n  assert.ok(value <= max, \'value larger than maximum allowed value\');\n\n  assert.ok(value >= min, \'value smaller than minimum allowed value\');\n}\n\nBuffer.prototype.writeInt8 = function(value, offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifsint(value, 0x7f, -0x80);\n  }\n\n  if (value >= 0) {\n    buffer.writeUInt8(value, offset, noAssert);\n  } else {\n    buffer.writeUInt8(0xff + value + 1, offset, noAssert);\n  }\n};\n\nfunction writeInt16(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 1 < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifsint(value, 0x7fff, -0x8000);\n  }\n\n  if (value >= 0) {\n    writeUInt16(buffer, value, offset, isBigEndian, noAssert);\n  } else {\n    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);\n  }\n}\n\nBuffer.prototype.writeInt16LE = function(value, offset, noAssert) {\n  writeInt16(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeInt16BE = function(value, offset, noAssert) {\n  writeInt16(this, value, offset, true, noAssert);\n};\n\nfunction writeInt32(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifsint(value, 0x7fffffff, -0x80000000);\n  }\n\n  if (value >= 0) {\n    writeUInt32(buffer, value, offset, isBigEndian, noAssert);\n  } else {\n    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);\n  }\n}\n\nBuffer.prototype.writeInt32LE = function(value, offset, noAssert) {\n  writeInt32(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeInt32BE = function(value, offset, noAssert) {\n  writeInt32(this, value, offset, true, noAssert);\n};\n\nfunction writeFloat(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);\n  }\n\n  require(\'./buffer_ieee754\').writeIEEE754(buffer, value, offset, isBigEndian,\n      23, 4);\n}\n\nBuffer.prototype.writeFloatLE = function(value, offset, noAssert) {\n  writeFloat(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeFloatBE = function(value, offset, noAssert) {\n  writeFloat(this, value, offset, true, noAssert);\n};\n\nfunction writeDouble(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 7 < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);\n  }\n\n  require(\'./buffer_ieee754\').writeIEEE754(buffer, value, offset, isBigEndian,\n      52, 8);\n}\n\nBuffer.prototype.writeDoubleLE = function(value, offset, noAssert) {\n  writeDouble(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeDoubleBE = function(value, offset, noAssert) {\n  writeDouble(this, value, offset, true, noAssert);\n};\n\nSlowBuffer.prototype.readUInt8 = Buffer.prototype.readUInt8;\nSlowBuffer.prototype.readUInt16LE = Buffer.prototype.readUInt16LE;\nSlowBuffer.prototype.readUInt16BE = Buffer.prototype.readUInt16BE;\nSlowBuffer.prototype.readUInt32LE = Buffer.prototype.readUInt32LE;\nSlowBuffer.prototype.readUInt32BE = Buffer.prototype.readUInt32BE;\nSlowBuffer.prototype.readInt8 = Buffer.prototype.readInt8;\nSlowBuffer.prototype.readInt16LE = Buffer.prototype.readInt16LE;\nSlowBuffer.prototype.readInt16BE = Buffer.prototype.readInt16BE;\nSlowBuffer.prototype.readInt32LE = Buffer.prototype.readInt32LE;\nSlowBuffer.prototype.readInt32BE = Buffer.prototype.readInt32BE;\nSlowBuffer.prototype.readFloatLE = Buffer.prototype.readFloatLE;\nSlowBuffer.prototype.readFloatBE = Buffer.prototype.readFloatBE;\nSlowBuffer.prototype.readDoubleLE = Buffer.prototype.readDoubleLE;\nSlowBuffer.prototype.readDoubleBE = Buffer.prototype.readDoubleBE;\nSlowBuffer.prototype.writeUInt8 = Buffer.prototype.writeUInt8;\nSlowBuffer.prototype.writeUInt16LE = Buffer.prototype.writeUInt16LE;\nSlowBuffer.prototype.writeUInt16BE = Buffer.prototype.writeUInt16BE;\nSlowBuffer.prototype.writeUInt32LE = Buffer.prototype.writeUInt32LE;\nSlowBuffer.prototype.writeUInt32BE = Buffer.prototype.writeUInt32BE;\nSlowBuffer.prototype.writeInt8 = Buffer.prototype.writeInt8;\nSlowBuffer.prototype.writeInt16LE = Buffer.prototype.writeInt16LE;\nSlowBuffer.prototype.writeInt16BE = Buffer.prototype.writeInt16BE;\nSlowBuffer.prototype.writeInt32LE = Buffer.prototype.writeInt32LE;\nSlowBuffer.prototype.writeInt32BE = Buffer.prototype.writeInt32BE;\nSlowBuffer.prototype.writeFloatLE = Buffer.prototype.writeFloatLE;\nSlowBuffer.prototype.writeFloatBE = Buffer.prototype.writeFloatBE;\nSlowBuffer.prototype.writeDoubleLE = Buffer.prototype.writeDoubleLE;\nSlowBuffer.prototype.writeDoubleBE = Buffer.prototype.writeDoubleBE;\n\n})()\n},{"assert":2,"./buffer_ieee754":7,"base64-js":9}],9:[function(require,module,exports){\n(function (exports) {\n\t\'use strict\';\n\n\tvar lookup = \'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\';\n\n\tfunction b64ToByteArray(b64) {\n\t\tvar i, j, l, tmp, placeHolders, arr;\n\t\n\t\tif (b64.length % 4 > 0) {\n\t\t\tthrow \'Invalid string. Length must be a multiple of 4\';\n\t\t}\n\n\t\t// the number of equal signs (place holders)\n\t\t// if there are two placeholders, than the two characters before it\n\t\t// represent one byte\n\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t// this is just a cheap hack to not do indexOf twice\n\t\tplaceHolders = b64.indexOf(\'=\');\n\t\tplaceHolders = placeHolders > 0 ? b64.length - placeHolders : 0;\n\n\t\t// base64 is 4/3 + up to two characters of the original data\n\t\tarr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);\n\n\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length;\n\n\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);\n\t\t\tarr.push((tmp & 0xFF0000) >> 16);\n\t\t\tarr.push((tmp & 0xFF00) >> 8);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t}\n\n\t\tif (placeHolders === 2) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t} else if (placeHolders === 1) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);\n\t\t\tarr.push((tmp >> 8) & 0xFF);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t}\n\n\t\treturn arr;\n\t}\n\n\tfunction uint8ToBase64(uint8) {\n\t\tvar i,\n\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\toutput = "",\n\t\t\ttemp, length;\n\n\t\tfunction tripletToBase64 (num) {\n\t\t\treturn lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n\t\t};\n\n\t\t// go through the array every three bytes, we\'ll deal with trailing stuff later\n\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);\n\t\t\toutput += tripletToBase64(temp);\n\t\t}\n\n\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\tswitch (extraBytes) {\n\t\t\tcase 1:\n\t\t\t\ttemp = uint8[uint8.length - 1];\n\t\t\t\toutput += lookup[temp >> 2];\n\t\t\t\toutput += lookup[(temp << 4) & 0x3F];\n\t\t\t\toutput += \'==\';\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);\n\t\t\t\toutput += lookup[temp >> 10];\n\t\t\t\toutput += lookup[(temp >> 4) & 0x3F];\n\t\t\t\toutput += lookup[(temp << 2) & 0x3F];\n\t\t\t\toutput += \'=\';\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn output;\n\t}\n\n\tmodule.exports.toByteArray = b64ToByteArray;\n\tmodule.exports.fromByteArray = uint8ToBase64;\n}());\n\n},{}]},{},[])\n;;module.exports=require("buffer-browserify")\n\n},{}],6:[function(require,module,exports){\n(function(Buffer){/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Wentao Shang\n * See COPYING for copyright and distribution information.\n */\n\n// Library namespace\nvar ndn = ndn || {};\n\nvar exports = ndn;\n\n\n// Factory method to create node.js compatible ndnbuf objects\nvar ndnbuf = function ndnbuf(data, format)\n{\n  var obj;\n\n  if (typeof data == \'number\')\n    obj = new Uint8Array(data);\n  else if (typeof data == \'string\') {\n    if (format == null || format == \'utf8\') {\n      var utf8 = ndnbuf.str2rstr_utf8(data);\n      obj = new Uint8Array(utf8.length);\n      for (var i = 0; i < utf8.length; i++)\n        obj[i] = utf8.charCodeAt(i);\n    }\n    else if (format == \'binary\') {\n      obj = new Uint8Array(data.length);\n      for (var i = 0; i < data.length; i++)\n        obj[i] = data.charCodeAt(i);\n    }\n    else if (format == \'hex\') {\n      obj = new Uint8Array(Math.floor(data.length / 2));\n      var i = 0;\n      data.replace(/(..)/g, function(ss) {\n        obj[i++] = parseInt(ss, 16);\n      });\n    }\n    else if (format == \'base64\') {\n      var hex = b64tohex(data);\n      obj = new Uint8Array(Math.floor(hex.length / 2));\n      var i = 0;\n      hex.replace(/(..)/g, function(ss) {\n        obj[i++] = parseInt(ss, 16);\n      });\n    }\n    else\n      throw new Error(\'Buffer: unknown encoding format \' + format);\n  }\n  else if (typeof data == \'object\' && (data instanceof Uint8Array || data instanceof ndnbuf)) {\n    // The second argument is a boolean for "copy", default true.\n    if (format == false)\n      obj = data.subarray(0);\n    else\n      obj = new Uint8Array(data);\n  }\n  else if (typeof data == \'object\' && data instanceof ArrayBuffer)\n    // Copy.\n    obj = new Uint8Array(data);\n  else if (typeof data == \'object\')\n    // Assume component is a byte array.  We can\'t check instanceof Array because\n    //   this doesn\'t work in JavaScript if the array comes from a different module.\n    obj = new Uint8Array(data);\n  else\n    throw new Error(\'Buffer: unknown data type.\');\n\n  try {\n    obj.__proto__ = ndnbuf.prototype;\n  } catch(ex) {\n    throw new Error("Buffer: Set obj.__proto__ exception: " + ex);\n  }\n\n  obj.__proto__.toString = function(encoding) {\n    if (encoding == null) {\n      var ret = "";\n      for (var i = 0; i < this.length; i++)\n        ret += String.fromCharCode(this[i]);\n      return ret;\n    }\n\n    var ret = "";\n    for (var i = 0; i < this.length; i++)\n      ret += (this[i] < 16 ? "0" : "") + this[i].toString(16);\n\n    if (encoding == \'hex\')\n      return ret;\n    else if (encoding == \'base64\')\n      return hex2b64(ret);\n    else\n      throw new Error(\'ndnbuf.toString: unknown encoding format \' + encoding);\n  };\n\n  obj.__proto__.slice = function(begin, end) {\n    if (end !== undefined)\n      return new ndnbuf(this.subarray(begin, end), false);\n    else\n      return new ndnbuf(this.subarray(begin), false);\n  };\n\n  obj.__proto__.copy = function(target, targetStart) {\n    if (targetStart !== undefined)\n      target.set(this, targetStart);\n    else\n      target.set(this);\n  };\n\n  return obj;\n};\n\nndnbuf.prototype = Uint8Array.prototype;\n\nndnbuf.concat = function(arrays)\n{\n  var totalLength = 0;\n  for (var i = 0; i < arrays.length; ++i)\n    totalLength += arrays[i].length;\n\n  var result = new ndnbuf(totalLength);\n  var offset = 0;\n  for (var i = 0; i < arrays.length; ++i) {\n    result.set(arrays[i], offset);\n    offset += arrays[i].length;\n  }\n  return result;\n};\n\nndnbuf.str2rstr_utf8 = function(input)\n{\n  var output = "";\n  var i = -1;\n  var x, y;\n\n  while (++i < input.length)\n  {\n    // Decode utf-16 surrogate pairs\n    x = input.charCodeAt(i);\n    y = i + 1 < input.length ? input.charCodeAt(i + 1) : 0;\n    if (0xD800 <= x && x <= 0xDBFF && 0xDC00 <= y && y <= 0xDFFF)\n    {\n      x = 0x10000 + ((x & 0x03FF) << 10) + (y & 0x03FF);\n      i++;\n    }\n\n    // Encode output as utf-8\n    if (x <= 0x7F)\n      output += String.fromCharCode(x);\n    else if (x <= 0x7FF)\n      output += String.fromCharCode(0xC0 | ((x >>> 6 ) & 0x1F),\n                                    0x80 | ( x         & 0x3F));\n    else if (x <= 0xFFFF)\n      output += String.fromCharCode(0xE0 | ((x >>> 12) & 0x0F),\n                                    0x80 | ((x >>> 6 ) & 0x3F),\n                                    0x80 | ( x         & 0x3F));\n    else if (x <= 0x1FFFFF)\n      output += String.fromCharCode(0xF0 | ((x >>> 18) & 0x07),\n                                    0x80 | ((x >>> 12) & 0x3F),\n                                    0x80 | ((x >>> 6 ) & 0x3F),\n                                    0x80 | ( x         & 0x3F));\n  }\n  return output;\n};\n\nexports.ndnbuf = ndnbuf\n\n// Factory method to create hasher objects\nndn.createHash = function(alg)\n{\n  if (alg != \'sha256\')\n    throw new Error(\'createHash: unsupported algorithm.\');\n\n  var obj = {};\n\n  obj.md = new KJUR.crypto.MessageDigest({alg: "sha256", prov: "cryptojs"});\n\n  obj.update = function(buf) {\n    this.md.updateHex(buf.toString(\'hex\'));\n  };\n\n  obj.digest = function() {\n    return new ndnbuf(this.md.digest(), \'hex\');\n  };\n\n  return obj;\n};\n\n// Factory method to create RSA signer objects\nndn.createSign = function(alg)\n{\n  if (alg != \'RSA-SHA256\')\n    throw new Error(\'createSign: unsupported algorithm.\');\n\n  var obj = {};\n\n  obj.arr = [];\n\n  obj.update = function(buf) {\n    this.arr.push(buf);\n  };\n\n  obj.sign = function(keypem) {\n    var rsa = new RSAKey();\n    rsa.readPrivateKeyFromPEMString(keypem);\n    var signer = new KJUR.crypto.Signature({alg: "SHA256withRSA", prov: "cryptojs/jsrsa"});\n    signer.initSign(rsa);\n    for (var i = 0; i < this.arr.length; ++i)\n      signer.updateHex(this.arr[i].toString(\'hex\'));\n\n    return new ndnbuf(signer.sign(), \'hex\');\n  };\n\n  return obj;\n};\n\n// Factory method to create RSA verifier objects\nndn.createVerify = function(alg)\n{\n  if (alg != \'RSA-SHA256\')\n    throw new Error(\'createSign: unsupported algorithm.\');\n\n  var obj = {};\n\n  obj.arr = [];\n\n  obj.update = function(buf) {\n    this.arr.push(buf);\n  };\n\n  var getSubjectPublicKeyPosFromHex = function(hPub) {\n    var a = ASN1HEX.getPosArrayOfChildren_AtObj(hPub, 0);\n    if (a.length != 2)\n      return -1;\n    var pBitString = a[1];\n    if (hPub.substring(pBitString, pBitString + 2) != \'03\')\n      return -1;\n    var pBitStringV = ASN1HEX.getStartPosOfV_AtObj(hPub, pBitString);\n    if (hPub.substring(pBitStringV, pBitStringV + 2) != \'00\')\n      return -1;\n    return pBitStringV + 2;\n  };\n\n  var readPublicDER = function(pub_der) {\n    var hex = pub_der.toString(\'hex\');\n    var p = getSubjectPublicKeyPosFromHex(hex);\n    var a = ASN1HEX.getPosArrayOfChildren_AtObj(hex, p);\n    if (a.length != 2)\n      return null;\n    var hN = ASN1HEX.getHexOfV_AtObj(hex, a[0]);\n    var hE = ASN1HEX.getHexOfV_AtObj(hex, a[1]);\n    var rsaKey = new RSAKey();\n    rsaKey.setPublic(hN, hE);\n    return rsaKey;\n  };\n\n  obj.verify = function(keypem, sig) {\n    var key = new ndn.Key();\n    key.fromPemString(keypem);\n\n    var rsa = readPublicDER(key.publicToDER());\n    var signer = new KJUR.crypto.Signature({alg: "SHA256withRSA", prov: "cryptojs/jsrsa"});\n    signer.initVerifyByPublicKey(rsa);\n    for (var i = 0; i < this.arr.length; i++)\n      signer.updateHex(this.arr[i].toString(\'hex\'));\n    var hSig = sig.toString(\'hex\');\n    return signer.verify(hSig);\n  };\n\n  return obj;\n};\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\n/**\n * The Log class holds the global static variable LOG.\n */\nvar Log = function Log()\n{\n}\n\nexports.Log = Log;\n\n/**\n * LOG is the level for logging debugging statements.  0 means no log messages.\n * @type Number\n */\nvar LOG = 0;\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class contains all NDNx tags\n */\n\n\nvar NDNProtocolDTags = {\n\n  /**\n   * Note if you add one of these, add it to the reverse string map as well.\n   * Emphasize getting the work done at compile time over trying to make something\n   * flexible and developer error-proof.\n   */\n\n   Any : 13,\n   Name : 14,\n   Component : 15,\n   Certificate : 16,\n   Collection : 17,\n   CompleteName : 18,\n   Content : 19,\n   SignedInfo : 20,\n   ContentDigest : 21,\n   ContentHash : 22,\n   Count : 24,\n   Header : 25,\n   Interest : 26,  /* 20090915 */\n   Key : 27,\n   KeyLocator : 28,\n   KeyName : 29,\n   Length : 30,\n   Link : 31,\n   LinkAuthenticator : 32,\n   NameComponentCount : 33,  /* DeprecatedInInterest */\n   RootDigest : 36,\n   Signature : 37,\n   Start : 38,\n   Timestamp : 39,\n   Type : 40,\n   Nonce : 41,\n   Scope : 42,\n   Exclude : 43,\n   Bloom : 44,\n   BloomSeed : 45,\n   AnswerOriginKind : 47,\n   InterestLifetime : 48,\n   Witness : 53,\n   SignatureBits : 54,\n   DigestAlgorithm : 55,\n   BlockSize : 56,\n   FreshnessSeconds : 58,\n   FinalBlockID : 59,\n   PublisherPublicKeyDigest : 60,\n   PublisherCertificateDigest : 61,\n   PublisherIssuerKeyDigest : 62,\n   PublisherIssuerCertificateDigest : 63,\n   Data : 64,  /* 20090915 */\n   WrappedKey : 65,\n   WrappingKeyIdentifier : 66,\n   WrapAlgorithm : 67,\n   KeyAlgorithm : 68,\n   Label : 69,\n   EncryptedKey : 70,\n   EncryptedNonceKey : 71,\n   WrappingKeyName : 72,\n   Action : 73,\n   FaceID : 74,\n   IPProto : 75,\n   Host : 76,\n   Port : 77,\n   MulticastInterface : 78,\n   ForwardingFlags : 79,\n   FaceInstance : 80,\n   ForwardingEntry : 81,\n   MulticastTTL : 82,\n   MinSuffixComponents : 83,\n   MaxSuffixComponents : 84,\n   ChildSelector : 85,\n   RepositoryInfo : 86,\n   Version : 87,\n   RepositoryVersion : 88,\n   GlobalPrefix : 89,\n   LocalName : 90,\n   Policy : 91,\n   Namespace : 92,\n   GlobalPrefixName : 93,\n   PolicyVersion : 94,\n   KeyValueSet : 95,\n   KeyValuePair : 96,\n   IntegerValue : 97,\n   DecimalValue : 98,\n   StringValue : 99,\n   BinaryValue : 100,\n   NameValue : 101,\n   Entry : 102,\n   ACL : 103,\n   ParameterizedName : 104,\n   Prefix : 105,\n   Suffix : 106,\n   Root : 107,\n   ProfileName : 108,\n   Parameters : 109,\n   InfoString : 110,\n  // 111 unallocated\n   StatusResponse : 112,\n   StatusCode : 113,\n   StatusText : 114,\n\n  // Sync protocol\n   SyncNode : 115,\n   SyncNodeKind : 116,\n   SyncNodeElement : 117,\n   SyncVersion : 118,\n   SyncNodeElements : 119,\n   SyncContentHash : 120,\n   SyncLeafCount : 121,\n   SyncTreeDepth : 122,\n   SyncByteCount : 123,\n   ConfigSlice : 124,\n   ConfigSliceList : 125,\n   ConfigSliceOp : 126,\n\n  // Remember to keep in sync with schema/tagnames.csvsdict\n   NDNProtocolDataUnit : 17702112,\n   NDNPROTOCOL_DATA_UNIT : "NDNProtocolDataUnit"\n};\n\nexports.NDNProtocolDTags = NDNProtocolDTags;\n\nvar NDNProtocolDTagsStrings = [\n  null, null, null, null, null, null, null, null, null, null, null,\n  null, null,\n  "Any", "Name", "Component", "Certificate", "Collection", "CompleteName",\n  "Content", "SignedInfo", "ContentDigest", "ContentHash", null, "Count", "Header",\n  "Interest", "Key", "KeyLocator", "KeyName", "Length", "Link", "LinkAuthenticator",\n  "NameComponentCount", null, null, "RootDigest", "Signature", "Start", "Timestamp", "Type",\n  "Nonce", "Scope", "Exclude", "Bloom", "BloomSeed", null, "AnswerOriginKind",\n  "InterestLifetime", null, null, null, null, "Witness", "SignatureBits", "DigestAlgorithm", "BlockSize",\n  null, "FreshnessSeconds", "FinalBlockID", "PublisherPublicKeyDigest", "PublisherCertificateDigest",\n  "PublisherIssuerKeyDigest", "PublisherIssuerCertificateDigest", "Data",\n  "WrappedKey", "WrappingKeyIdentifier", "WrapAlgorithm", "KeyAlgorithm", "Label",\n  "EncryptedKey", "EncryptedNonceKey", "WrappingKeyName", "Action", "FaceID", "IPProto",\n  "Host", "Port", "MulticastInterface", "ForwardingFlags", "FaceInstance",\n  "ForwardingEntry", "MulticastTTL", "MinSuffixComponents", "MaxSuffixComponents", "ChildSelector",\n  "RepositoryInfo", "Version", "RepositoryVersion", "GlobalPrefix", "LocalName",\n  "Policy", "Namespace", "GlobalPrefixName", "PolicyVersion", "KeyValueSet", "KeyValuePair",\n  "IntegerValue", "DecimalValue", "StringValue", "BinaryValue", "NameValue", "Entry",\n  "ACL", "ParameterizedName", "Prefix", "Suffix", "Root", "ProfileName", "Parameters",\n  "InfoString", null,\n    "StatusResponse", "StatusCode", "StatusText", "SyncNode", "SyncNodeKind", "SyncNodeElement",\n    "SyncVersion", "SyncNodeElements", "SyncContentHash", "SyncLeafCount", "SyncTreeDepth", "SyncByteCount",\n    "ConfigSlice", "ConfigSliceList", "ConfigSliceOp" ];\n\nexports.NDNProtocolDTagsStrings = NDNProtocolDTagsStrings;\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class represents NDNTime Objects\n */\n\n\n/**\n * @constructor\n */\nvar NDNTime = function NDNTime(input)\n{\n  this.NANOS_MAX = 999877929;\n\n  if (typeof input ==\'number\')\n    this.msec = input;\n  else {\n    if (LOG > 1) console.log(\'UNRECOGNIZED TYPE FOR TIME\');\n  }\n};\n\nexports.NDNTime = NDNTime;\n\nNDNTime.prototype.getJavascriptDate = function()\n{\n  var d = new Date();\n  d.setTime(this.msec);\n  return d\n};\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * This is the closure class for use in expressInterest to re express with exponential falloff.\n */\n\n\n/**\n * Create a new ExponentialReExpressClosure where upcall responds to UPCALL_INTEREST_TIMED_OUT\n *   by expressing the interest again with double the interestLifetime. If the interesLifetime goes\n *   over maxInterestLifetime, then call callerClosure.upcall with UPCALL_INTEREST_TIMED_OUT.\n * When upcall is not UPCALL_INTEREST_TIMED_OUT, just call callerClosure.upcall.\n * @constructor\n * @param {Closure} callerClosure\n * @param {Object} settings if not null, an associative array with the following defaults:\n * {\n *   maxInterestLifetime: 16000 // milliseconds\n * }\n */\nvar ExponentialReExpressClosure = function ExponentialReExpressClosure(callerClosure, settings)\n{\n  // Inherit from Closure.\n  Closure.call(this);\n\n  this.callerClosure = callerClosure;\n  settings = (settings || {});\n  this.maxInterestLifetime = (settings.maxInterestLifetime || 16000);\n};\n\nexports.ExponentialReExpressClosure = ExponentialReExpressClosure;\n\n/**\n * Wrap this.callerClosure to responds to UPCALL_INTEREST_TIMED_OUT\n *   by expressing the interest again as described in the constructor.\n */\nExponentialReExpressClosure.prototype.upcall = function(kind, upcallInfo)\n{\n  try {\n    if (kind == Closure.UPCALL_INTEREST_TIMED_OUT) {\n      var interestLifetime = upcallInfo.interest.interestLifetime;\n      if (interestLifetime == null)\n        return this.callerClosure.upcall(Closure.UPCALL_INTEREST_TIMED_OUT, upcallInfo);\n\n      var nextInterestLifetime = interestLifetime * 2;\n      if (nextInterestLifetime > this.maxInterestLifetime)\n        return this.callerClosure.upcall(Closure.UPCALL_INTEREST_TIMED_OUT, upcallInfo);\n\n      var nextInterest = upcallInfo.interest.clone();\n      nextInterest.interestLifetime = nextInterestLifetime;\n      // TODO: Use expressInterest with callbacks, not Closure.\n      upcallInfo.face.expressInterest(nextInterest.name, this, nextInterest);\n      return Closure.RESULT_OK;\n    }\n    else\n      return this.callerClosure.upcall(kind, upcallInfo);\n  } catch (ex) {\n    console.log("ExponentialReExpressClosure.upcall exception: " + ex);\n    return Closure.RESULT_ERR;\n  }\n};\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * Encapsulate a ndnbuf and support dynamic reallocation.\n */\n\n/**\n * Create a DynamicBuffer where this.array is a ndnbuf of size length.\n * The methods will update this.length.\n * To access the array, use this.array or call slice.\n * @constructor\n * @param {number} length the initial length of the array.  If null, use a default.\n */\nvar DynamicBuffer = function DynamicBuffer(length)\n{\n  if (!length)\n    length = 16;\n\n  this.array = new ndnbuf(length);\n  this.length = length;\n};\n\nexports.DynamicBuffer = DynamicBuffer;\n\n/**\n * Ensure that this.array has the length, reallocate and copy if necessary.\n * Update this.length which may be greater than length.\n */\nDynamicBuffer.prototype.ensureLength = function(length)\n{\n  if (this.array.length >= length)\n    return;\n\n  // See if double is enough.\n  var newLength = this.array.length * 2;\n  if (length > newLength)\n    // The needed length is much greater, so use it.\n    newLength = length;\n\n  var newArray = new ndnbuf(newLength);\n  this.array.copy(newArray);\n  this.array = newArray;\n  this.length = newLength;\n};\n\n/**\n * Copy the value to this.array at offset, reallocating if necessary.\n */\nDynamicBuffer.prototype.set = function(value, offset)\n{\n  this.ensureLength(value.length + offset);\n\n  if (typeof value == \'object\' && value instanceof ndnbuf)\n    value.copy(this.array, offset);\n  else\n    // Need to make value a ndnbuf to copy.\n    new ndnbuf(value).copy(this.array, offset);\n};\n\n/**\n * Return this.array.slice(begin, end);\n */\nDynamicBuffer.prototype.slice = function(begin, end)\n{\n  return this.array.slice(begin, end);\n};\n/**\n * This class contains utilities to help parse the data\n *\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Meki Cheraoui\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\n/**\n * A DataUtils has static methods for converting data.\n * @constructor\n */\nvar DataUtils = function DataUtils()\n{\n};\n\nexports.DataUtils = DataUtils;\n\n/*\n * NOTE THIS IS CURRENTLY NOT BEING USED\n *\n */\n\nDataUtils.keyStr = "ABCDEFGHIJKLMNOP" +\n                   "QRSTUVWXYZabcdef" +\n                   "ghijklmnopqrstuv" +\n                   "wxyz0123456789+/" +\n                   "=";\n\n/**\n * Raw String to Base 64\n */\nDataUtils.stringtoBase64 = function stringtoBase64(input)\n{\n   //input = escape(input);\n   var output = "";\n   var chr1, chr2, chr3 = "";\n   var enc1, enc2, enc3, enc4 = "";\n   var i = 0;\n\n   do {\n    chr1 = input.charCodeAt(i++);\n    chr2 = input.charCodeAt(i++);\n    chr3 = input.charCodeAt(i++);\n\n    enc1 = chr1 >> 2;\n    enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\n    enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\n    enc4 = chr3 & 63;\n\n    if (isNaN(chr2))\n       enc3 = enc4 = 64;\n    else if (isNaN(chr3))\n       enc4 = 64;\n\n    output = output +\n       DataUtils.keyStr.charAt(enc1) +\n       DataUtils.keyStr.charAt(enc2) +\n       DataUtils.keyStr.charAt(enc3) +\n       DataUtils.keyStr.charAt(enc4);\n    chr1 = chr2 = chr3 = "";\n    enc1 = enc2 = enc3 = enc4 = "";\n   } while (i < input.length);\n\n   return output;\n};\n\n/**\n * Base 64 to Raw String\n */\nDataUtils.base64toString = function base64toString(input)\n{\n  var output = "";\n  var chr1, chr2, chr3 = "";\n  var enc1, enc2, enc3, enc4 = "";\n  var i = 0;\n\n  // remove all characters that are not A-Z, a-z, 0-9, +, /, or =\n  var base64test = /[^A-Za-z0-9\\+\\/\\=]/g;\n  /* Test for invalid characters. */\n  if (base64test.exec(input)) {\n    alert("There were invalid base64 characters in the input text.\\n" +\n          "Valid base64 characters are A-Z, a-z, 0-9, \'+\', \'/\',and \'=\'\\n" +\n          "Expect errors in decoding.");\n  }\n\n  input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, "");\n\n  do {\n    enc1 = DataUtils.keyStr.indexOf(input.charAt(i++));\n    enc2 = DataUtils.keyStr.indexOf(input.charAt(i++));\n    enc3 = DataUtils.keyStr.indexOf(input.charAt(i++));\n    enc4 = DataUtils.keyStr.indexOf(input.charAt(i++));\n\n    chr1 = (enc1 << 2) | (enc2 >> 4);\n    chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);\n    chr3 = ((enc3 & 3) << 6) | enc4;\n\n    output = output + String.fromCharCode(chr1);\n\n    if (enc3 != 64)\n      output = output + String.fromCharCode(chr2);\n\n    if (enc4 != 64)\n      output = output + String.fromCharCode(chr3);\n\n    chr1 = chr2 = chr3 = "";\n    enc1 = enc2 = enc3 = enc4 = "";\n  } while (i < input.length);\n\n  return output;\n};\n\n/**\n * ndnbuf to Hex String\n */\nDataUtils.toHex = function(ndnbuf)\n{\n  return ndnbuf.toString(\'hex\');\n};\n\n/**\n * Raw string to hex string.\n */\nDataUtils.stringToHex = function(args)\n{\n  var ret = "";\n  for (var i = 0; i < args.length; ++i) {\n    var value = args.charCodeAt(i);\n    ret += (value < 16 ? "0" : "") + value.toString(16);\n  }\n  return ret;\n};\n\n/**\n * ndnbuf to raw string.\n */\nDataUtils.toString = function(ndnbuf)\n{\n  return ndnbuf.toString();\n};\n\n/**\n * Hex String to ndnbuf.\n */\nDataUtils.toNumbers = function(str)\n{\n  return new ndnbuf(str, \'hex\');\n};\n\n/**\n * Hex String to raw string.\n */\nDataUtils.hexToRawString = function(str)\n{\n  if (typeof str ==\'string\') {\n  var ret = "";\n  str.replace(/(..)/g, function(s) {\n    ret += String.fromCharCode(parseInt(s, 16));\n  });\n  return ret;\n  }\n};\n\n/**\n * Raw String to ndnbuf.\n */\nDataUtils.toNumbersFromString = function(str)\n{\n  return new ndnbuf(str, \'binary\');\n};\n\n/**\n * Encode str as utf8 and return as ndnbuf.\n */\nDataUtils.stringToUtf8Array = function(str)\n{\n  return new ndnbuf(str, \'utf8\');\n};\n\n/**\n * arrays is an array of ndnbuf. Return a new ndnbuf which is the concatenation of all.\n */\nDataUtils.concatArrays = function(arrays)\n{\n  return ndnbuf.concat(arrays);\n};\n\n// TODO: Take ndnbuf and use TextDecoder when available.\nDataUtils.decodeUtf8 = function(utftext)\n{\n  var string = "";\n  var i = 0;\n  var c = 0;\n    var c1 = 0;\n    var c2 = 0;\n\n  while (i < utftext.length) {\n    c = utftext.charCodeAt(i);\n\n    if (c < 128) {\n      string += String.fromCharCode(c);\n      i++;\n    }\n    else if (c > 191 && c < 224) {\n      c2 = utftext.charCodeAt(i + 1);\n      string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));\n      i += 2;\n    }\n    else {\n      c2 = utftext.charCodeAt(i+1);\n      var c3 = utftext.charCodeAt(i+2);\n      string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));\n      i += 3;\n    }\n  }\n\n  return string;\n};\n\n/**\n * Return true if a1 and a2 are the same length with equal elements.\n */\nDataUtils.arraysEqual = function(a1, a2)\n{\n  // A simple sanity check that it is an array.\n  if (!a1.slice)\n    throw new Error("DataUtils.arraysEqual: a1 is not an array");\n  if (!a2.slice)\n    throw new Error("DataUtils.arraysEqual: a2 is not an array");\n\n  if (a1.length != a2.length)\n    return false;\n\n  for (var i = 0; i < a1.length; ++i) {\n    if (a1[i] != a2[i])\n      return false;\n  }\n\n  return true;\n};\n\n/**\n * Convert the big endian ndnbuf to an unsigned int.\n * Don\'t check for overflow.\n */\nDataUtils.bigEndianToUnsignedInt = function(bytes)\n{\n  var result = 0;\n  for (var i = 0; i < bytes.length; ++i) {\n    result <<= 8;\n    result += bytes[i];\n  }\n  return result;\n};\n\n/**\n * Convert the int value to a new big endian ndnbuf and return.\n * If value is 0 or negative, return new ndnbuf(0).\n */\nDataUtils.nonNegativeIntToBigEndian = function(value)\n{\n  value = Math.round(value);\n  if (value <= 0)\n    return new ndnbuf(0);\n\n  // Assume value is not over 64 bits.\n  var size = 8;\n  var result = new ndnbuf(size);\n  var i = 0;\n  while (value != 0) {\n    ++i;\n    result[size - i] = value & 0xff;\n    value >>= 8;\n  }\n  return result.slice(size - i, size);\n};\n\n/**\n * Modify array to randomly shuffle the elements.\n */\nDataUtils.shuffle = function(array)\n{\n  for (var i = array.length - 1; i >= 1; --i) {\n    // j is from 0 to i.\n    var j = Math.floor(Math.random() * (i + 1));\n    var temp = array[i];\n    array[i] = array[j];\n    array[j] = temp;\n  }\n};\n/*\n * Date Format 1.2.3\n * (c) 2007-2009 Steven Levithan <stevenlevithan.com>\n * MIT license\n *\n * Includes enhancements by Scott Trenda <scott.trenda.net>\n * and Kris Kowal <cixar.com/~kris.kowal/>\n *\n * Accepts a date, a mask, or a date and a mask.\n * Returns a formatted version of the given date.\n * The date defaults to the current date/time.\n * The mask defaults to dateFormat.masks.default.\n */\n\nvar DateFormat = function()\n{\n  var  token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\\1?|[LloSZ]|"[^"]*"|\'[^\']*\'/g,\n    timezone = /\\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\\d{4})?)\\b/g,\n    timezoneClip = /[^-+\\dA-Z]/g,\n    pad = function(val, len) {\n      val = String(val);\n      len = len || 2;\n      while (val.length < len) val = "0" + val;\n      return val;\n    };\n\n  // Regexes and supporting functions are cached through closure\n  return function(date, mask, utc) {\n    var dF = dateFormat;\n\n    // You can\'t provide utc if you skip other args (use the "UTC:" mask prefix)\n    if (arguments.length == 1 && Object.prototype.toString.call(date) == "[object String]" && !/\\d/.test(date)) {\n      mask = date;\n      date = undefined;\n    }\n\n    // Passing date through Date applies Date.parse, if necessary\n    date = date ? new Date(date) : new Date;\n    if (isNaN(date)) throw SyntaxError("invalid date");\n\n    mask = String(dF.masks[mask] || mask || dF.masks["default"]);\n\n    // Allow setting the utc argument via the mask\n    if (mask.slice(0, 4) == "UTC:") {\n      mask = mask.slice(4);\n      utc = true;\n    }\n\n    var  _ = utc ? "getUTC" : "get",\n      d = date[_ + "Date"](),\n      D = date[_ + "Day"](),\n      m = date[_ + "Month"](),\n      y = date[_ + "FullYear"](),\n      H = date[_ + "Hours"](),\n      M = date[_ + "Minutes"](),\n      s = date[_ + "Seconds"](),\n      L = date[_ + "Milliseconds"](),\n      o = utc ? 0 : date.getTimezoneOffset(),\n      flags = {\n        d:    d,\n        dd:   pad(d),\n        ddd:  dF.i18n.dayNames[D],\n        dddd: dF.i18n.dayNames[D + 7],\n        m:    m + 1,\n        mm:   pad(m + 1),\n        mmm:  dF.i18n.monthNames[m],\n        mmmm: dF.i18n.monthNames[m + 12],\n        yy:   String(y).slice(2),\n        yyyy: y,\n        h:    H % 12 || 12,\n        hh:   pad(H % 12 || 12),\n        H:    H,\n        HH:   pad(H),\n        M:    M,\n        MM:   pad(M),\n        s:    s,\n        ss:   pad(s),\n        l:    pad(L, 3),\n        L:    pad(L > 99 ? Math.round(L / 10) : L),\n        t:    H < 12 ? "a"  : "p",\n        tt:   H < 12 ? "am" : "pm",\n        T:    H < 12 ? "A"  : "P",\n        TT:   H < 12 ? "AM" : "PM",\n        Z:    utc ? "UTC" : (String(date).match(timezone) || [""]).pop().replace(timezoneClip, ""),\n        o:    (o > 0 ? "-" : "+") + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),\n        S:    ["th", "st", "nd", "rd"][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10]\n      };\n\n    return mask.replace(token, function($0) {\n      return $0 in flags ? flags[$0] : $0.slice(1, $0.length - 1);\n    });\n  };\n}();\n\n// Some common format strings\nDateFormat.masks = {\n  "default":      "ddd mmm dd yyyy HH:MM:ss",\n  shortDate:      "m/d/yy",\n  mediumDate:     "mmm d, yyyy",\n  longDate:       "mmmm d, yyyy",\n  fullDate:       "dddd, mmmm d, yyyy",\n  shortTime:      "h:MM TT",\n  mediumTime:     "h:MM:ss TT",\n  longTime:       "h:MM:ss TT Z",\n  isoDate:        "yyyy-mm-dd",\n  isoTime:        "HH:MM:ss",\n  isoDateTime:    "yyyy-mm-dd\'T\'HH:MM:ss",\n  isoUtcDateTime: "UTC:yyyy-mm-dd\'T\'HH:MM:ss\'Z\'"\n};\n\n// Internationalization strings\nDateFormat.i18n = {\n  dayNames: [\n    "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat",\n    "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"\n  ],\n  monthNames: [\n    "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",\n    "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"\n  ]\n};\n\n// For convenience...\nDate.prototype.format = function(mask, utc) {\n  return dateFormat(this, mask, utc);\n};\n/**\n * This class is used to encode ndnb binary elements (blob, type/value pairs).\n *\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n */\n\n\nvar XML_EXT = 0x00;\n\nvar XML_TAG = 0x01;\n\nvar XML_DTAG = 0x02;\n\nvar XML_ATTR = 0x03;\n\nvar XML_DATTR = 0x04;\n\nvar XML_BLOB = 0x05;\n\nvar XML_UDATA = 0x06;\n\nvar XML_CLOSE = 0x0;\n\nvar XML_SUBTYPE_PROCESSING_INSTRUCTIONS = 16;\n\n\nvar XML_TT_BITS = 3;\nvar XML_TT_MASK = ((1 << XML_TT_BITS) - 1);\nvar XML_TT_VAL_BITS = XML_TT_BITS + 1;\nvar XML_TT_VAL_MASK = ((1 << (XML_TT_VAL_BITS)) - 1);\nvar XML_REG_VAL_BITS = 7;\nvar XML_REG_VAL_MASK = ((1 << XML_REG_VAL_BITS) - 1);\nvar XML_TT_NO_MORE = (1 << XML_REG_VAL_BITS); // 0x80\nvar BYTE_MASK = 0xFF;\nvar LONG_BYTES = 8;\nvar LONG_BITS = 64;\n\nvar bits_11 = 0x0000007FF;\nvar bits_18 = 0x00003FFFF;\nvar bits_32 = 0x0FFFFFFFF;\n\n/**\n * @constructor\n */\nvar BinaryXMLEncoder = function BinaryXMLEncoder(initiaLength)\n{\n  if (!initiaLength)\n    initiaLength = 16;\n\n  this.ostream = new DynamicBuffer(initiaLength);\n  this.offset = 0;\n  this.CODEC_NAME = "Binary";\n};\n\nexports.BinaryXMLEncoder = BinaryXMLEncoder;\n\n/**\n * Encode utf8Content as utf8 and write to the output ndnbuf as a UDATA.\n * @param {string} utf8Content The string to convert to utf8.\n */\nBinaryXMLEncoder.prototype.writeUString = function(utf8Content)\n{\n  this.encodeUString(utf8Content, XML_UDATA);\n};\n\nBinaryXMLEncoder.prototype.writeBlob = function(\n    /*Buffer*/ binaryContent)\n{\n  if (LOG >3) console.log(binaryContent);\n\n  this.encodeBlob(binaryContent, binaryContent.length);\n};\n\n/**\n * Write an element start header using DTAG with the tag to the output ndnbuf.\n * @param {number} tag The DTAG tag.\n */\nBinaryXMLEncoder.prototype.writeElementStartDTag = function(tag)\n{\n  this.encodeTypeAndVal(XML_DTAG, tag);\n};\n\n/**\n * @deprecated Use writeElementStartDTag.  Binary XML string tags and attributes are not used by any NDN encodings and\n * support is not maintained in the code base.\n */\nBinaryXMLEncoder.prototype.writeStartElement = function(\n  /*String*/ tag,\n  /*TreeMap<String,String>*/ attributes)\n{\n  /*Long*/ var dictionaryVal = tag; //stringToTag(tag);\n\n  if (null == dictionaryVal)\n    this.encodeUString(tag, XML_TAG);\n  else\n    this.encodeTypeAndVal(XML_DTAG, dictionaryVal);\n\n  if (null != attributes)\n    this.writeAttributes(attributes);\n};\n\n/**\n * Write an element close to the output ndnbuf.\n */\nBinaryXMLEncoder.prototype.writeElementClose = function()\n{\n  this.ostream.ensureLength(this.offset + 1);\n  this.ostream.array[this.offset] = XML_CLOSE;\n  this.offset += 1;\n};\n\n/**\n * @deprecated Use writeElementClose.\n */\nBinaryXMLEncoder.prototype.writeEndElement = function()\n{\n  this.writeElementClose();\n};\n\n/**\n * @deprecated Binary XML string tags and attributes are not used by any NDN encodings and support is not maintained in the code base.\n */\nBinaryXMLEncoder.prototype.writeAttributes = function(/*TreeMap<String,String>*/ attributes)\n{\n  if (null == attributes)\n    return;\n\n  // the keySet of a TreeMap is sorted.\n\n  for (var i = 0; i< attributes.length;i++) {\n    var strAttr = attributes[i].k;\n    var strValue = attributes[i].v;\n\n    var dictionaryAttr = stringToTag(strAttr);\n    if (null == dictionaryAttr)\n      // not in dictionary, encode as attr\n      // compressed format wants length of tag represented as length-1\n      // to save that extra bit, as tag cannot be 0 length.\n      // encodeUString knows to do that.\n      this.encodeUString(strAttr, XML_ATTR);\n    else\n      this.encodeTypeAndVal(XML_DATTR, dictionaryAttr);\n\n    // Write value\n    this.encodeUString(strValue);\n  }\n};\n\n//returns a string\nstringToTag = function(/*long*/ tagVal)\n{\n  if (tagVal >= 0 && tagVal < NDNProtocolDTagsStrings.length)\n    return NDNProtocolDTagsStrings[tagVal];\n  else if (tagVal == NDNProtocolDTags.NDNProtocolDataUnit)\n    return NDNProtocolDTags.NDNPROTOCOL_DATA_UNIT;\n\n  return null;\n};\n\n//returns a Long\ntagToString =  function(/*String*/ tagName)\n{\n  // the slow way, but right now we don\'t care.... want a static lookup for the forward direction\n  for (var i = 0; i < NDNProtocolDTagsStrings.length; ++i) {\n    if (null != NDNProtocolDTagsStrings[i] && NDNProtocolDTagsStrings[i] == tagName)\n      return i;\n  }\n\n  if (NDNProtocolDTags.NDNPROTOCOL_DATA_UNIT == tagName)\n    return NDNProtocolDTags.NDNProtocolDataUnit;\n\n  return null;\n};\n\n/**\n * Write an element start header using DTAG with the tag to the output ndnbuf, then the content as explained below,\n * then an element close.\n * @param {number} tag The DTAG tag.\n * @param {number|string|Buffer} content If contentis a number, convert it to a string and call writeUString.  If content is a string,\n * call writeUString.  Otherwise, call writeBlob.\n */\nBinaryXMLEncoder.prototype.writeDTagElement = function(tag, content)\n{\n  this.writeElementStartDTag(tag);\n\n  if (typeof content === \'number\')\n    this.writeUString(content.toString());\n  else if (typeof content === \'string\')\n    this.writeUString(content);\n  else\n    this.writeBlob(content);\n\n  this.writeElementClose();\n};\n\n/**\n * @deprecated Use writeDTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and\n * support is not maintained in the code base.\n * If Content is a string, then encode as utf8 and write UDATA.\n */\nBinaryXMLEncoder.prototype.writeElement = function(\n    //long\n    tag,\n    //byte[]\n    Content,\n    //TreeMap<String, String>\n    attributes)\n{\n  this.writeStartElement(tag, attributes);\n  // Will omit if 0-length\n\n  if (typeof Content === \'number\') {\n    if (LOG > 4) console.log(\'GOING TO WRITE THE NUMBER .charCodeAt(0) \' + Content.toString().charCodeAt(0));\n    if (LOG > 4) console.log(\'GOING TO WRITE THE NUMBER \' + Content.toString());\n    if (LOG > 4) console.log(\'type of number is \' + typeof Content.toString());\n\n    this.writeUString(Content.toString());\n  }\n  else if (typeof Content === \'string\') {\n    if (LOG > 4) console.log(\'GOING TO WRITE THE STRING  \' + Content);\n    if (LOG > 4) console.log(\'type of STRING is \' + typeof Content);\n\n    this.writeUString(Content);\n  }\n  else {\n    if (LOG > 4) console.log(\'GOING TO WRITE A BLOB  \' + Content);\n\n    this.writeBlob(Content);\n  }\n\n  this.writeElementClose();\n};\n\nvar TypeAndVal = function TypeAndVal(_type,_val)\n{\n  this.type = _type;\n  this.val = _val;\n};\n\nBinaryXMLEncoder.prototype.encodeTypeAndVal = function(\n    //int\n    type,\n    //long\n    val)\n{\n  if (LOG > 4) console.log(\'Encoding type \'+ type+ \' and value \'+ val);\n\n  if (LOG > 4) console.log(\'OFFSET IS \' + this.offset);\n\n  if (type > XML_UDATA || type < 0 || val < 0)\n    throw new Error("Tag and value must be positive, and tag valid.");\n\n  // Encode backwards. Calculate how many bytes we need:\n  var numEncodingBytes = this.numEncodingBytes(val);\n  this.ostream.ensureLength(this.offset + numEncodingBytes);\n\n  // Bottom 4 bits of val go in last byte with tag.\n  this.ostream.array[this.offset + numEncodingBytes - 1] =\n    //(byte)\n      (BYTE_MASK &\n          (((XML_TT_MASK & type) |\n           ((XML_TT_VAL_MASK & val) << XML_TT_BITS))) |\n           XML_TT_NO_MORE); // set top bit for last byte\n  val = val >>> XML_TT_VAL_BITS;\n\n  // Rest of val goes into preceding bytes, 7 bits per byte, top bit\n  // is "more" flag.\n  var i = this.offset + numEncodingBytes - 2;\n  while (0 != val && i >= this.offset) {\n    this.ostream.array[i] = //(byte)\n        (BYTE_MASK & (val & XML_REG_VAL_MASK)); // leave top bit unset\n    val = val >>> XML_REG_VAL_BITS;\n    --i;\n  }\n\n  if (val != 0)\n    throw new Error("This should not happen: miscalculated encoding");\n\n  this.offset+= numEncodingBytes;\n\n  return numEncodingBytes;\n};\n\n/**\n * Encode ustring as utf8.\n */\nBinaryXMLEncoder.prototype.encodeUString = function(\n    //String\n    ustring,\n    //byte\n    type)\n{\n  if (null == ustring)\n    return;\n  if (type == XML_TAG || type == XML_ATTR && ustring.length == 0)\n    return;\n\n  if (LOG > 3) console.log("The string to write is ");\n  if (LOG > 3) console.log(ustring);\n\n  var strBytes = DataUtils.stringToUtf8Array(ustring);\n\n  this.encodeTypeAndVal(type,\n            (((type == XML_TAG) || (type == XML_ATTR)) ?\n                (strBytes.length-1) :\n                strBytes.length));\n\n  if (LOG > 3) console.log("THE string to write is ");\n\n  if (LOG > 3) console.log(strBytes);\n\n  this.writeString(strBytes);\n  this.offset+= strBytes.length;\n};\n\n\nBinaryXMLEncoder.prototype.encodeBlob = function(\n    //Buffer\n    blob,\n    //int\n    length)\n{\n  if (null == blob)\n    return;\n\n  if (LOG > 4) console.log(\'LENGTH OF XML_BLOB IS \'+length);\n\n  this.encodeTypeAndVal(XML_BLOB, length);\n  this.writeBlobArray(blob);\n  this.offset += length;\n};\n\nvar ENCODING_LIMIT_1_BYTE = ((1 << (XML_TT_VAL_BITS)) - 1);\nvar ENCODING_LIMIT_2_BYTES = ((1 << (XML_TT_VAL_BITS + XML_REG_VAL_BITS)) - 1);\nvar ENCODING_LIMIT_3_BYTES = ((1 << (XML_TT_VAL_BITS + 2 * XML_REG_VAL_BITS)) - 1);\n\nBinaryXMLEncoder.prototype.numEncodingBytes = function(\n    //long\n    x)\n{\n  if (x <= ENCODING_LIMIT_1_BYTE) return (1);\n  if (x <= ENCODING_LIMIT_2_BYTES) return (2);\n  if (x <= ENCODING_LIMIT_3_BYTES) return (3);\n\n  var numbytes = 1;\n\n  // Last byte gives you XML_TT_VAL_BITS\n  // Remainder each give you XML_REG_VAL_BITS\n  x = x >>> XML_TT_VAL_BITS;\n  while (x != 0) {\n        numbytes++;\n    x = x >>> XML_REG_VAL_BITS;\n  }\n  return (numbytes);\n};\n\n/**\n * Write an element start header using DTAG with the tag to the output ndnbuf, then the dateTime\n   * as a big endian BLOB converted to 4096 ticks per second, then an element close.\n * @param {number} tag The DTAG tag.\n * @param {NDNTime} dateTime\n */\nBinaryXMLEncoder.prototype.writeDateTimeDTagElement = function(tag, dateTime)\n{\n  //parse to hex\n  var binarydate =  Math.round((dateTime.msec/1000) * 4096).toString(16)  ;\n  if (binarydate.length % 2 == 1)\n    binarydate = \'0\' + binarydate;\n\n  this.writeDTagElement(tag, DataUtils.toNumbers(binarydate));\n};\n\n/**\n * @deprecated Use writeDateTimeDTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and\n * support is not maintained in the code base.\n */\nBinaryXMLEncoder.prototype.writeDateTime = function(\n    //String\n    tag,\n    //NDNTime\n    dateTime)\n{\n  //parse to hex\n  var binarydate =  Math.round((dateTime.msec/1000) * 4096).toString(16)  ;\n  if (binarydate.length % 2 == 1)\n    binarydate = \'0\' + binarydate;\n\n  this.writeElement(tag, DataUtils.toNumbers(binarydate));\n};\n\n// This does not update this.offset.\nBinaryXMLEncoder.prototype.writeString = function(input)\n{\n  if (typeof input === \'string\') {\n    if (LOG > 4) console.log(\'GOING TO WRITE A STRING\');\n    if (LOG > 4) console.log(input);\n\n    this.ostream.ensureLength(this.offset + input.length);\n    for (var i = 0; i < input.length; i++) {\n      if (LOG > 4) console.log(\'input.charCodeAt(i)=\' + input.charCodeAt(i));\n      this.ostream.array[this.offset + i] = (input.charCodeAt(i));\n    }\n  }\n  else\n  {\n    if (LOG > 4) console.log(\'GOING TO WRITE A STRING IN BINARY FORM\');\n    if (LOG > 4) console.log(input);\n\n    this.writeBlobArray(input);\n  }\n};\n\nBinaryXMLEncoder.prototype.writeBlobArray = function(\n    //Buffer\n    blob)\n{\n  if (LOG > 4) console.log(\'GOING TO WRITE A BLOB\');\n\n  this.ostream.set(blob, this.offset);\n};\n\nBinaryXMLEncoder.prototype.getReducedOstream = function()\n{\n  return this.ostream.slice(0, this.offset);\n};\n/**\n * This class is used to decode ndnb binary elements (blob, type/value pairs).\n *\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n */\n\n\nvar XML_EXT = 0x00;\n\nvar XML_TAG = 0x01;\n\nvar XML_DTAG = 0x02;\n\nvar XML_ATTR = 0x03;\n\nvar XML_DATTR = 0x04;\n\nvar XML_BLOB = 0x05;\n\nvar XML_UDATA = 0x06;\n\nvar XML_CLOSE = 0x0;\n\nvar XML_SUBTYPE_PROCESSING_INSTRUCTIONS = 16;\n\n\nvar XML_TT_BITS = 3;\nvar XML_TT_MASK = ((1 << XML_TT_BITS) - 1);\nvar XML_TT_VAL_BITS = XML_TT_BITS + 1;\nvar XML_TT_VAL_MASK = ((1 << (XML_TT_VAL_BITS)) - 1);\nvar XML_REG_VAL_BITS = 7;\nvar XML_REG_VAL_MASK = ((1 << XML_REG_VAL_BITS) - 1);\nvar XML_TT_NO_MORE = (1 << XML_REG_VAL_BITS); // 0x80\nvar BYTE_MASK = 0xFF;\nvar LONG_BYTES = 8;\nvar LONG_BITS = 64;\n\nvar bits_11 = 0x0000007FF;\nvar bits_18 = 0x00003FFFF;\nvar bits_32 = 0x0FFFFFFFF;\n\n\n\n//returns a string\ntagToString = function(/*long*/ tagVal)\n{\n  if (tagVal >= 0 && tagVal < NDNProtocolDTagsStrings.length) {\n    return NDNProtocolDTagsStrings[tagVal];\n  }\n  else if (tagVal == NDNProtocolDTags.NDNProtocolDataUnit) {\n    return NDNProtocolDTags.NDNPROTOCOL_DATA_UNIT;\n  }\n\n  return null;\n};\n\n//returns a Long\nstringToTag =  function(/*String*/ tagName)\n{\n  // the slow way, but right now we don\'t care.... want a static lookup for the forward direction\n  for (var i=0; i < NDNProtocolDTagsStrings.length; ++i) {\n    if (null != NDNProtocolDTagsStrings[i] && NDNProtocolDTagsStrings[i] == tagName)\n      return i;\n  }\n  if (NDNProtocolDTags.NDNPROTOCOL_DATA_UNIT == tagName) {\n    return NDNProtocolDTags.NDNProtocolDataUnit;\n  }\n\n  return null;\n};\n\n/**\n * @constructor\n */\nvar BinaryXMLDecoder = function BinaryXMLDecoder(input)\n{\n  var MARK_LEN=512;\n  var DEBUG_MAX_LEN =  32768;\n\n  this.input = input;\n  this.offset = 0;\n  // peekDTag sets and checks this, and readElementStartDTag uses it to avoid reading again.\n  this.previouslyPeekedDTagStartOffset = -1;\n};\n\nexports.BinaryXMLDecoder = BinaryXMLDecoder;\n\n/**\n * Decode the header from the input starting at its position, expecting the type to be DTAG and the value to be expectedTag.\n   * Update the input\'s offset.\n * @param {number} expectedTag The expected value for DTAG.\n */\nBinaryXMLDecoder.prototype.readElementStartDTag = function(expectedTag)\n{\n  if (this.offset == this.previouslyPeekedDTagStartOffset) {\n    // peekDTag already decoded this DTag.\n    if (this.previouslyPeekedDTag != expectedTag)\n      throw new ContentDecodingException(new Error("Did not get the expected DTAG " + expectedTag + ", got " + this.previouslyPeekedDTag));\n\n    // Fast forward past the header.\n    this.offset = this.previouslyPeekedDTagEndOffset;\n  }\n  else {\n    var typeAndValue = this.decodeTypeAndVal();\n    if (typeAndValue == null || typeAndValue.type() != XML_DTAG)\n      throw new ContentDecodingException(new Error("Header type is not a DTAG"));\n\n    if (typeAndValue.val() != expectedTag)\n      throw new ContentDecodingException(new Error("Expected start element: " + expectedTag + " got: " + typeAndValue.val()));\n  }\n};\n\n/**\n * @deprecated Use readElementStartDTag. Binary XML string tags and attributes are not used by any NDN encodings and\n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.readStartElement = function(\n    //String\n    startTag,\n    //TreeMap<String, String>\n    attributes)\n{\n  //TypeAndVal\n  var tv = this.decodeTypeAndVal();\n\n  if (null == tv)\n    throw new ContentDecodingException(new Error("Expected start element: " + startTag + " got something not a tag."));\n\n  //String\n  var decodedTag = null;\n\n  if (tv.type() == XML_TAG) {\n    // Tag value represents length-1 as tags can never be empty.\n    var valval;\n\n    if (typeof tv.val() == \'string\')\n      valval = (parseInt(tv.val())) + 1;\n    else\n      valval = (tv.val())+ 1;\n\n    decodedTag = this.decodeUString(valval);\n  }\n  else if (tv.type() == XML_DTAG)\n    decodedTag = tv.val();\n\n  if (null ==  decodedTag || decodedTag != startTag) {\n    console.log(\'expecting \'+ startTag + \' but got \'+ decodedTag);\n    throw new ContentDecodingException(new Error("Expected start element: " + startTag + " got: " + decodedTag + "(" + tv.val() + ")"));\n  }\n\n  // DKS: does not read attributes out of stream if caller doesn\'t\n  // ask for them. Should possibly peek and skip over them regardless.\n  // TODO: fix this\n  if (null != attributes)\n    readAttributes(attributes);\n};\n\n/**\n * @deprecated Binary XML string tags and attributes are not used by any NDN encodings and support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.readAttributes = function(\n  // array of [attributeName, attributeValue]\n  attributes)\n{\n  if (null == attributes)\n    return;\n\n  try {\n    // Now need to get attributes.\n    //TypeAndVal\n    var nextTV = this.peekTypeAndVal();\n\n    while (null != nextTV && (XML_ATTR == nextTV.type() || XML_DATTR == nextTV.type())) {\n      // Decode this attribute. First, really read the type and value.\n      //this.TypeAndVal\n      var thisTV = this.decodeTypeAndVal();\n\n      //String\n      var attributeName = null;\n      if (XML_ATTR == thisTV.type()) {\n        // Tag value represents length-1 as attribute names cannot be empty.\n        var valval ;\n        if (typeof thisTV.val() == \'string\')\n          valval = (parseInt(thisTV.val())) + 1;\n        else\n          valval = (thisTV.val())+ 1;\n\n        attributeName = this.decodeUString(valval);\n      }\n      else if (XML_DATTR == thisTV.type()) {\n        // DKS TODO are attributes same or different dictionary?\n        attributeName = tagToString(thisTV.val());\n        if (null == attributeName)\n          throw new ContentDecodingException(new Error("Unknown DATTR value" + thisTV.val()));\n      }\n\n      // Attribute values are always UDATA\n      //String\n      var attributeValue = this.decodeUString();\n\n      attributes.push([attributeName, attributeValue]);\n      nextTV = this.peekTypeAndVal();\n    }\n  }\n  catch (e) {\n    throw new ContentDecodingException(new Error("readStartElement", e));\n  }\n};\n\n/**\n * @deprecated Use peekDTag.  Binary XML string tags and attributes are not used by any NDN encodings and\n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.peekStartElementAsString = function()\n{\n  //String\n  var decodedTag = null;\n  var previousOffset = this.offset;\n  try {\n    // Have to distinguish genuine errors from wrong tags. Could either use\n    // a special exception subtype, or redo the work here.\n    //this.TypeAndVal\n    var tv = this.decodeTypeAndVal();\n\n    if (null != tv) {\n      if (tv.type() == XML_TAG) {\n        // Tag value represents length-1 as tags can never be empty.\n        var valval ;\n        if (typeof tv.val() == \'string\')\n          valval = (parseInt(tv.val())) + 1;\n        else\n          valval = (tv.val())+ 1;\n\n        decodedTag = this.decodeUString(valval);\n      }\n      else if (tv.type() == XML_DTAG)\n        decodedTag = tagToString(tv.val());\n    } // else, not a type and val, probably an end element. rewind and return false.\n  }\n  catch (e) {\n  }\n  finally {\n    try {\n      this.offset = previousOffset;\n    }\n    catch (e) {\n      Log.logStackTrace(Log.FAC_ENCODING, Level.WARNING, e);\n      throw new ContentDecodingException(new Error("Cannot reset stream! " + e.getMessage(), e));\n    }\n  }\n\n  return decodedTag;\n};\n\n/**\n * Decode the header from the input starting at its position, and if it is a DTAG where the value is the expectedTag,\n * then set return true.  Do not update the input\'s offset.\n * @param {number} expectedTag The expected value for DTAG.\n * @returns {boolean} True if the tag is the expected tag, otherwise false.\n */\nBinaryXMLDecoder.prototype.peekDTag = function(expectedTag)\n{\n  if (this.offset == this.previouslyPeekedDTagStartOffset)\n    // We already decoded this DTag.\n    return this.previouslyPeekedDTag == expectedTag;\n  else {\n    // First check if it is an element close (which cannot be the expected tag).\n    if (this.input[this.offset] == XML_CLOSE)\n      return false;\n\n    var saveOffset = this.offset;\n    var typeAndValue = this.decodeTypeAndVal();\n    // readElementStartDTag will use this to fast forward.\n    this.previouslyPeekedDTagEndOffset = this.offset;\n    // Restore the position.\n    this.offset = saveOffset;\n\n    if (typeAndValue != null && typeAndValue.type() == XML_DTAG) {\n      this.previouslyPeekedDTagStartOffset = saveOffset;\n      this.previouslyPeekedDTag = typeAndValue.val();\n\n      return typeAndValue.val() == expectedTag;\n    }\n    else\n      return false;\n  }\n};\n\n/**\n * @deprecated Use peekDTag.  Binary XML string tags and attributes are not used by any NDN encodings and\n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.peekStartElement = function(\n    //String\n    startTag)\n{\n  //String\n  if (typeof startTag == \'string\') {\n    var decodedTag = this.peekStartElementAsString();\n\n    if (null !=  decodedTag && decodedTag == startTag)\n      return true;\n\n    return false;\n  }\n  else if (typeof startTag == \'number\') {\n    var decodedTag = this.peekStartElementAsLong();\n    if (null !=  decodedTag && decodedTag == startTag)\n      return true;\n\n    return false;\n  }\n  else\n    throw new ContentDecodingException(new Error("SHOULD BE STRING OR NUMBER"));\n};\n\n/**\n * @deprecated Use peekDTag.  Binary XML string tags and attributes are not used by any NDN encodings and\n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.peekStartElementAsLong = function()\n{\n  //Long\n  var decodedTag = null;\n  var previousOffset = this.offset;\n\n  try {\n    // Have to distinguish genuine errors from wrong tags. Could either use\n    // a special exception subtype, or redo the work here.\n    //this.TypeAndVal\n    var tv = this.decodeTypeAndVal();\n\n    if (null != tv) {\n      if (tv.type() == XML_TAG) {\n        if (tv.val() + 1 > DEBUG_MAX_LEN)\n          throw new ContentDecodingException(new Error("Decoding error: length " + tv.val()+1 + " longer than expected maximum length!"));\n\n        var valval;\n        if (typeof tv.val() == \'string\')\n          valval = (parseInt(tv.val())) + 1;\n        else\n          valval = (tv.val())+ 1;\n\n        // Tag value represents length-1 as tags can never be empty.\n        //String\n        var strTag = this.decodeUString(valval);\n\n        decodedTag = stringToTag(strTag);\n      }\n      else if (tv.type() == XML_DTAG)\n        decodedTag = tv.val();\n    } // else, not a type and val, probably an end element. rewind and return false.\n\n  }\n  catch (e) {\n  }\n  finally {\n    try {\n      //this.input.reset();\n      this.offset = previousOffset;\n    } catch (e) {\n      Log.logStackTrace(Log.FAC_ENCODING, Level.WARNING, e);\n      throw new Error("Cannot reset stream! " + e.getMessage(), e);\n    }\n  }\n\n  return decodedTag;\n};\n\n/**\n * Decode the header from the input starting its offset, expecting the type to be DTAG and the value to be expectedTag.\n * Then read one item of any type (presumably BLOB, UDATA, TAG or ATTR) and return a\n * ndnbuf. However, if allowNull is true, then the item may be absent.\n * Finally, read the element close.  Update the input\'s offset.\n * @param {number} expectedTag The expected value for DTAG.\n * @param {boolean} allowNull True if the binary item may be missing.\n * @returns {Buffer} A ndnbuf which is a slice on the data inside the input ndnbuf. However,\n * if allowNull is true and the binary data item is absent, then return null.\n */\nBinaryXMLDecoder.prototype.readBinaryDTagElement = function(expectedTag, allowNull)\n{\n  this.readElementStartDTag(expectedTag);\n  return this.readBlob(allowNull);\n};\n\n/**\n * @deprecated Use readBinaryDTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and\n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.readBinaryElement = function(\n    //long\n    startTag,\n    //TreeMap<String, String>\n    attributes,\n    //boolean\n    allowNull)\n{\n  this.readStartElement(startTag, attributes);\n  return this.readBlob(allowNull);\n};\n\n/**\n * Read one byte from the input starting at its offset, expecting it to be the element close.\n * Update the input\'s offset.\n */\nBinaryXMLDecoder.prototype.readElementClose = function()\n{\n  var next = this.input[this.offset++];\n  if (next != XML_CLOSE)\n    throw new ContentDecodingException(new Error("Expected end element, got: " + next));\n};\n\n/**\n * @deprecated Use readElementClose.\n */\nBinaryXMLDecoder.prototype.readEndElement = function()\n{\n  if (LOG > 4) console.log(\'this.offset is \'+this.offset);\n\n  var next = this.input[this.offset];\n\n  this.offset++;\n\n  if (LOG > 4) console.log(\'XML_CLOSE IS \'+XML_CLOSE);\n  if (LOG > 4) console.log(\'next is \'+next);\n\n  if (next != XML_CLOSE) {\n    console.log("Expected end element, got: " + next);\n    throw new ContentDecodingException(new Error("Expected end element, got: " + next));\n  }\n};\n\n//String\nBinaryXMLDecoder.prototype.readUString = function()\n{\n  //String\n  var ustring = this.decodeUString();\n  this.readElementClose();\n  return ustring;\n};\n\n/**\n * Read a blob as well as the end element. Returns a ndnbuf (or null for missing blob).\n * If the blob is missing and allowNull is false (default), throw an exception.  Otherwise,\n *   just read the end element and return null.\n */\nBinaryXMLDecoder.prototype.readBlob = function(allowNull)\n{\n  if (this.input[this.offset] == XML_CLOSE && allowNull) {\n    this.readElementClose();\n    return null;\n  }\n\n  var blob = this.decodeBlob();\n  this.readElementClose();\n  return blob;\n};\n\n/**\n * Decode the header from the input starting at its offset, expecting the type to be\n * DTAG and the value to be expectedTag.  Then read one item, parse it as an unsigned\n * big endian integer in 4096 ticks per second, and convert it to and NDNTime object.\n * Finally, read the element close.  Update the input\'s offset.\n * @param {number} expectedTag The expected value for DTAG.\n * @returns {NDNTime} The dateTime value.\n */\nBinaryXMLDecoder.prototype.readDateTimeDTagElement = function(expectedTag)\n{\n  var byteTimestamp = this.readBinaryDTagElement(expectedTag);\n  byteTimestamp = DataUtils.toHex(byteTimestamp);\n  byteTimestamp = parseInt(byteTimestamp, 16);\n\n  var lontimestamp = (byteTimestamp/ 4096) * 1000;\n\n  var timestamp = new NDNTime(lontimestamp);\n  if (null == timestamp)\n    throw new ContentDecodingException(new Error("Cannot parse timestamp: " + DataUtils.printHexBytes(byteTimestamp)));\n\n  return timestamp;\n};\n\n/**\n * @deprecated Use readDateTimeDTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and\n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.readDateTime = function(\n  //long\n  startTag)\n{\n  var byteTimestamp = this.readBinaryElement(startTag);\n  byteTimestamp = DataUtils.toHex(byteTimestamp);\n  byteTimestamp = parseInt(byteTimestamp, 16);\n\n  var lontimestamp = (byteTimestamp/ 4096) * 1000;\n\n  if (LOG > 4) console.log(\'DECODED DATE WITH VALUE\');\n  if (LOG > 4) console.log(lontimestamp);\n\n  //NDNTime\n  var timestamp = new NDNTime(lontimestamp);\n  if (null == timestamp)\n    throw new ContentDecodingException(new Error("Cannot parse timestamp: " + DataUtils.printHexBytes(byteTimestamp)));\n\n  return timestamp;\n};\n\nBinaryXMLDecoder.prototype.decodeTypeAndVal = function()\n{\n\n  /*int*/ var type = -1;\n  /*long*/ var val = 0;\n  /*boolean*/ var more = true;\n\n  do {\n    var next = this.input[this.offset ];\n    if (next == null)\n      // Quit the loop.\n      return null;\n\n    if (next < 0)\n      return null;\n\n    if (0 == next && 0 == val)\n      return null;\n\n    more = (0 == (next & XML_TT_NO_MORE));\n\n    if  (more) {\n      val = val << XML_REG_VAL_BITS;\n      val |= (next & XML_REG_VAL_MASK);\n    }\n    else {\n      type = next & XML_TT_MASK;\n      val = val << XML_TT_VAL_BITS;\n      val |= ((next >>> XML_TT_BITS) & XML_TT_VAL_MASK);\n    }\n\n    this.offset++;\n  } while (more);\n\n  if (LOG > 4) console.log(\'TYPE is \'+ type + \' VAL is \'+ val);\n\n  return new TypeAndVal(type, val);\n};\n\n//TypeAndVal\nBinaryXMLDecoder.prototype.peekTypeAndVal = function()\n{\n  //TypeAndVal\n  var tv = null;\n  var previousOffset = this.offset;\n\n  try {\n    tv = this.decodeTypeAndVal();\n  }\n  finally {\n    this.offset = previousOffset;\n  }\n\n  return tv;\n};\n\n//Buffer\nBinaryXMLDecoder.prototype.decodeBlob = function(\n    //int\n    blobLength)\n{\n  if (null == blobLength) {\n    //TypeAndVal\n    var tv = this.decodeTypeAndVal();\n\n    var valval ;\n    if (typeof tv.val() == \'string\')\n      valval = (parseInt(tv.val()));\n    else\n      valval = (tv.val());\n\n    return this.decodeBlob(valval);\n  }\n\n  //Buffer\n  var bytes = new ndnbuf(this.input.slice(this.offset, this.offset+ blobLength));\n  this.offset += blobLength;\n\n  return bytes;\n};\n\n//String\nBinaryXMLDecoder.prototype.decodeUString = function(\n    //int\n    byteLength)\n{\n  if (null == byteLength) {\n    var tempStreamPosition = this.offset;\n\n    //TypeAndVal\n    var tv = this.decodeTypeAndVal();\n\n    if (LOG > 4) console.log(\'TV is \'+tv);\n    if (LOG > 4) console.log(tv);\n\n    if (LOG > 4) console.log(\'Type of TV is \'+typeof tv);\n\n    // if we just have closers left, will get back null\n    if (null == tv || XML_UDATA != tv.type()) {\n      this.offset = tempStreamPosition;\n      return "";\n    }\n\n    return this.decodeUString(tv.val());\n  }\n  else {\n    //Buffer\n    var stringBytes = this.decodeBlob(byteLength);\n\n    // TODO: Should this parse as UTF8?\n    return DataUtils.toString(stringBytes);\n  }\n};\n\n//OBject containg a pair of type and value\nvar TypeAndVal = function TypeAndVal(_type,_val)\n{\n  this.t = _type;\n  this.v = _val;\n};\n\nTypeAndVal.prototype.type = function()\n{\n  return this.t;\n};\n\nTypeAndVal.prototype.val = function()\n{\n  return this.v;\n};\n\n/**\n * Decode the header from the input starting its offset, expecting the type to be DTAG and the value to be expectedTag.\n * Then read one UDATA item, parse it as a decimal integer and return the integer. Finally, read the element close.  Update the input\'s offset.\n * @param {number} expectedTag The expected value for DTAG.\n * @returns {number} The parsed integer.\n */\nBinaryXMLDecoder.prototype.readIntegerDTagElement = function(expectedTag)\n{\n  return parseInt(this.readUTF8DTagElement(expectedTag));\n};\n\n/**\n * @deprecated Use readIntegerDTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and\n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.readIntegerElement = function(\n  //String\n  startTag)\n{\n  //String\n  if (LOG > 4) console.log(\'READING INTEGER \'+ startTag);\n  if (LOG > 4) console.log(\'TYPE OF \'+ typeof startTag);\n\n  var strVal = this.readUTF8Element(startTag);\n\n  return parseInt(strVal);\n};\n\n/**\n * Decode the header from the input starting its offset, expecting the type to be DTAG and the value to be expectedTag.\n * Then read one UDATA item and return a string. Finally, read the element close.  Update the input\'s offset.\n * @param {number} expectedTag The expected value for DTAG.\n * @returns {string} The UDATA string.\n */\nBinaryXMLDecoder.prototype.readUTF8DTagElement = function(expectedTag)\n{\n  this.readElementStartDTag(expectedTag);\n  return this.readUString();;\n};\n\n/**\n * @deprecated Use readUTF8DTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and\n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.readUTF8Element = function(\n    //String\n    startTag,\n    //TreeMap<String, String>\n    attributes)\n{\n  //throws Error where name == "ContentDecodingException"\n\n  // can\'t use getElementText, can\'t get attributes\n  this.readStartElement(startTag, attributes);\n  //String\n  var strElementText = this.readUString();\n  return strElementText;\n};\n\n/**\n * Set the offset into the input, used for the next read.\n * @param {number} offset The new offset.\n */\nBinaryXMLDecoder.prototype.seek = function(offset)\n{\n  this.offset = offset;\n};\n\n/*\n * Call with: throw new ContentDecodingException(new Error("message")).\n */\nfunction ContentDecodingException(error)\n{\n  this.message = error.message;\n  // Copy lineNumber, etc. from where new Error was called.\n  for (var prop in error)\n      this[prop] = error[prop];\n}\nContentDecodingException.prototype = new Error();\nContentDecodingException.prototype.name = "ContentDecodingException";\n/**\n * This class uses BinaryXMLDecoder to follow the structure of a ndnb binary element to\n * determine its end.\n *\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\n\nvar XML_EXT = 0x00;\nvar XML_TAG = 0x01;\nvar XML_DTAG = 0x02;\nvar XML_ATTR = 0x03;\nvar XML_DATTR = 0x04;\nvar XML_BLOB = 0x05;\nvar XML_UDATA = 0x06;\nvar XML_CLOSE = 0x0;\n\nvar XML_SUBTYPE_PROCESSING_INSTRUCTIONS = 16;\n\nvar XML_TT_BITS = 3;\nvar XML_TT_MASK = ((1 << XML_TT_BITS) - 1);\nvar XML_TT_VAL_BITS = XML_TT_BITS + 1;\nvar XML_TT_VAL_MASK = ((1 << (XML_TT_VAL_BITS)) - 1);\nvar XML_REG_VAL_BITS = 7;\nvar XML_REG_VAL_MASK = ((1 << XML_REG_VAL_BITS) - 1);\nvar XML_TT_NO_MORE = (1 << XML_REG_VAL_BITS); // 0x80\n\n/**\n * @constructor\n */\nvar BinaryXMLStructureDecoder = function BinaryXMLDecoder()\n{\n  this.gotElementEnd = false;\n  this.offset = 0;\n  this.level = 0;\n  this.state = BinaryXMLStructureDecoder.READ_HEADER_OR_CLOSE;\n  this.headerLength = 0;\n  this.useHeaderBuffer = false;\n  this.headerBuffer = new DynamicBuffer(5);\n  this.nBytesToRead = 0;\n};\n\nexports.BinaryXMLStructureDecoder = BinaryXMLStructureDecoder;\n\nBinaryXMLStructureDecoder.READ_HEADER_OR_CLOSE = 0;\nBinaryXMLStructureDecoder.READ_BYTES = 1;\n\n/**\n * Continue scanning input starting from this.offset.  If found the end of the element\n *   which started at offset 0 then return true, else false.\n * If this returns false, you should read more into input and call again.\n * You have to pass in input each time because the array could be reallocated.\n * This throws an exception for badly formed ndnb.\n */\nBinaryXMLStructureDecoder.prototype.findElementEnd = function(\n  // ndnbuf\n  input)\n{\n  if (this.gotElementEnd)\n    // Someone is calling when we already got the end.\n    return true;\n\n  var decoder = new BinaryXMLDecoder(input);\n\n  while (true) {\n    if (this.offset >= input.length)\n      // All the cases assume we have some input.\n      return false;\n\n    switch (this.state) {\n      case BinaryXMLStructureDecoder.READ_HEADER_OR_CLOSE:\n        // First check for XML_CLOSE.\n        if (this.headerLength == 0 && input[this.offset] == XML_CLOSE) {\n          ++this.offset;\n          // Close the level.\n          --this.level;\n          if (this.level == 0) {\n            // Finished.\n            this.gotElementEnd = true;\n            return true;\n          }\n          if (this.level < 0)\n            throw new Error("BinaryXMLStructureDecoder: Unexpected close tag at offset " + (this.offset - 1));\n\n          // Get ready for the next header.\n          this.startHeader();\n          break;\n        }\n\n        var startingHeaderLength = this.headerLength;\n        while (true) {\n          if (this.offset >= input.length) {\n            // We can\'t get all of the header bytes from this input. Save in headerBuffer.\n            this.useHeaderBuffer = true;\n            var nNewBytes = this.headerLength - startingHeaderLength;\n            this.headerBuffer.set(input.slice(this.offset - nNewBytes, nNewBytes), startingHeaderLength);\n\n            return false;\n          }\n          var headerByte = input[this.offset++];\n          ++this.headerLength;\n          if (headerByte & XML_TT_NO_MORE)\n            // Break and read the header.\n            break;\n        }\n\n        var typeAndVal;\n        if (this.useHeaderBuffer) {\n          // Copy the remaining bytes into headerBuffer.\n          nNewBytes = this.headerLength - startingHeaderLength;\n          this.headerBuffer.set(input.slice(this.offset - nNewBytes, nNewBytes), startingHeaderLength);\n\n          typeAndVal = new BinaryXMLDecoder(this.headerBuffer.array).decodeTypeAndVal();\n        }\n        else {\n          // We didn\'t have to use the headerBuffer.\n          decoder.seek(this.offset - this.headerLength);\n          typeAndVal = decoder.decodeTypeAndVal();\n        }\n\n        if (typeAndVal == null)\n          throw new Error("BinaryXMLStructureDecoder: Can\'t read header starting at offset " +\n                          (this.offset - this.headerLength));\n\n        // Set the next state based on the type.\n        var type = typeAndVal.t;\n        if (type == XML_DATTR)\n          // We already consumed the item. READ_HEADER_OR_CLOSE again.\n          // ndnb has rules about what must follow an attribute, but we are just scanning.\n          this.startHeader();\n        else if (type == XML_DTAG || type == XML_EXT) {\n          // Start a new level and READ_HEADER_OR_CLOSE again.\n          ++this.level;\n          this.startHeader();\n        }\n        else if (type == XML_TAG || type == XML_ATTR) {\n          if (type == XML_TAG)\n            // Start a new level and read the tag.\n            ++this.level;\n          // Minimum tag or attribute length is 1.\n          this.nBytesToRead = typeAndVal.v + 1;\n          this.state = BinaryXMLStructureDecoder.READ_BYTES;\n          // ndnb has rules about what must follow an attribute, but we are just scanning.\n        }\n        else if (type == XML_BLOB || type == XML_UDATA) {\n          this.nBytesToRead = typeAndVal.v;\n          this.state = BinaryXMLStructureDecoder.READ_BYTES;\n        }\n        else\n          throw new Error("BinaryXMLStructureDecoder: Unrecognized header type " + type);\n        break;\n\n      case BinaryXMLStructureDecoder.READ_BYTES:\n        var nRemainingBytes = input.length - this.offset;\n        if (nRemainingBytes < this.nBytesToRead) {\n          // Need more.\n          this.offset += nRemainingBytes;\n          this.nBytesToRead -= nRemainingBytes;\n          return false;\n        }\n        // Got the bytes.  Read a new header or close.\n        this.offset += this.nBytesToRead;\n        this.startHeader();\n        break;\n\n      default:\n        // We don\'t expect this to happen.\n        throw new Error("BinaryXMLStructureDecoder: Unrecognized state " + this.state);\n    }\n  }\n};\n\n/**\n * Set the state to READ_HEADER_OR_CLOSE and set up to start reading the header\n */\nBinaryXMLStructureDecoder.prototype.startHeader = function()\n{\n  this.headerLength = 0;\n  this.useHeaderBuffer = false;\n  this.state = BinaryXMLStructureDecoder.READ_HEADER_OR_CLOSE;\n};\n\n/**\n *  Set the offset into the input, used for the next read.\n */\nBinaryXMLStructureDecoder.prototype.seek = function(offset)\n{\n  this.offset = offset;\n};\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * This class represents Interest Objects\n */\n\n/**\n * Create a WireFormat base class where the encode and decode methods throw an error. You should use a derived class like BinaryXmlWireFormat.\n * @constructor\n */\nvar WireFormat = function WireFormat() {\n};\n\nexports.WireFormat = WireFormat;\n\n/**\n * The override method in the derived class should encode the interest and return a ndnbuf.\n * @param {Interest} interest\n * @returns {Buffer}\n * @throws Error This always throws an "unimplemented" error. The derived class should override.\n */\nWireFormat.prototype.encodeInterest = function(interest)\n{\n  throw new Error("encodeInterest is unimplemented in the base WireFormat class.  You should use a derived class.");\n};\n\n/**\n * The override method in the derived class should decode the input and put the result in interest.\n * @param {Interest} interest\n * @param {Buffer} input\n * @throws Error This always throws an "unimplemented" error. The derived class should override.\n */\nWireFormat.prototype.decodeInterest = function(interest, input)\n{\n  throw new Error("decodeInterest is unimplemented in the base WireFormat class.  You should use a derived class.");\n};\n\n/**\n * The override method in the derived class should encode the data and return a ndnbuf.\n * @param {Data} data\n * @returns {Buffer}\n * @throws Error This always throws an "unimplemented" error. The derived class should override.\n */\nWireFormat.prototype.encodeData = function(data)\n{\n  throw new Error("encodeData is unimplemented in the base WireFormat class.  You should use a derived class.");\n};\n\n/**\n * The override method in the derived class should decode the input and put the result in data.\n * @param {Data} data\n * @param {Buffer} input\n * @throws Error This always throws an "unimplemented" error. The derived class should override.\n */\nWireFormat.prototype.decodeData = function(data, input)\n{\n  throw new Error("decodeData is unimplemented in the base WireFormat class.  You should use a derived class.");\n};\n\n\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\n\n/**\n * A BinaryXmlElementReader lets you call onReceivedData multiple times which uses a\n * BinaryXMLStructureDecoder to detect the end of a binary XML element and calls\n * elementListener.onReceivedElement(element) with the element.\n * This handles the case where a single call to onReceivedData may contain multiple elements.\n * @constructor\n * @param {{onReceivedElement:function}} elementListener\n */\nvar BinaryXmlElementReader = function BinaryXmlElementReader(elementListener)\n{\n  this.elementListener = elementListener;\n  this.dataParts = [];\n  this.structureDecoder = new BinaryXMLStructureDecoder();\n};\n\nexports.BinaryXmlElementReader = BinaryXmlElementReader;\n\nBinaryXmlElementReader.prototype.onReceivedData = function(/* ndnbuf */ data)\n{\n  // Process multiple objects in the data.\n  while (true) {\n    // Scan the input to check if a whole ndnb object has been read.\n    this.structureDecoder.seek(0);\n    if (this.structureDecoder.findElementEnd(data)) {\n      // Got the remainder of an object.  Report to the caller.\n      this.dataParts.push(data.slice(0, this.structureDecoder.offset));\n      var element = DataUtils.concatArrays(this.dataParts);\n      this.dataParts = [];\n      try {\n        this.elementListener.onReceivedElement(element);\n      } catch (ex) {\n          console.log("BinaryXmlElementReader: ignoring exception from onReceivedElement: " + ex);\n      }\n\n      // Need to read a new object.\n      data = data.slice(this.structureDecoder.offset, data.length);\n      this.structureDecoder = new BinaryXMLStructureDecoder();\n      if (data.length == 0)\n        // No more data in the packet.\n        return;\n\n      // else loop back to decode.\n    }\n    else {\n      // Save for a later call to concatArrays so that we only copy data once.\n      this.dataParts.push(data);\n      if (LOG > 3) console.log(\'Incomplete packet received. Length \' + data.length + \'. Wait for more input.\');\n        return;\n    }\n  }\n};\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\n/**\n * Create a context for getting the response from the name enumeration command, as neede by getComponents.\n * (To do name enumeration, call the static method NameEnumeration.getComponents.)\n * @param {Face} face The Face object for using expressInterest.\n * @param {function} onComponents The onComponents callback given to getComponents.\n */\nvar NameEnumeration = function NameEnumeration(face, onComponents)\n{\n  this.face = face;\n  this.onComponents = onComponents;\n  this.contentParts = [];\n\n  var self = this;\n  this.onData = function(interest, data) { self.processData(data); };\n  this.onTimeout = function(interest) { self.processTimeout(); };\n};\n\nexports.NameEnumeration = NameEnumeration;\n\n/**\n * Use the name enumeration protocol to get the child components of the name prefix.\n * @param {Face} face The Face object for using expressInterest.\n * @param {Name} name The name prefix for finding the child components.\n * @param {function} onComponents On getting the response, this calls onComponents(components) where\n * components is an array of ndnbuf name components.  If there is no response, this calls onComponents(null).\n */\nNameEnumeration.getComponents = function(face, prefix, onComponents)\n{\n  var command = new Name(prefix);\n  // Add %C1.E.be\n  command.add([0xc1, 0x2e, 0x45, 0x2e, 0x62, 0x65])\n\n  var enumeration = new NameEnumeration(face, onComponents);\n  face.expressInterest(command, enumeration.onData, enumeration.onTimeout);\n};\n\n\n\n\n\n\n\n\n\n/**\n * Create a closure for getting the response from the name enumeration command.\n * @param {Face} face The Face object for using expressInterest.\n * @param {function} onComponents The onComponents callback given to getComponents.\n */\nNameEnumeration.Closure = function NameEnumerationClosure(face, onComponents)\n{\n  // Inherit from Closure.\n  Closure.call(this);\n\n  this.face = face;\n  this.onComponents = onComponents;\n  this.contentParts = [];\n\n  var enumeration = new NameEnumeration(face, onComponents);\n  face.expressInterest(command, enumeration.onData, enumeration.onTimeout);\n};\n\n/**\n * Parse the response from the name enumeration command and call this.onComponents.\n * @param {Data} data\n */\nNameEnumeration.prototype.processData = function(data)\n{\n  try {\n    if (!NameEnumeration.endsWithSegmentNumber(data.name))\n      // We don\'t expect a name without a segment number.  Treat it as a bad packet.\n      this.onComponents(null);\n    else {\n      var segmentNumber = DataUtils.bigEndianToUnsignedInt\n          (data.name.get(data.name.size() - 1).getValue());\n\n      // Each time we get a segment, we put it in contentParts, so its length follows the segment numbers.\n      var expectedSegmentNumber = this.contentParts.length;\n      if (segmentNumber != expectedSegmentNumber)\n        // Try again to get the expected segment.  This also includes the case where the first segment is not segment 0.\n        this.face.expressInterest\n          (data.name.getPrefix(-1).addSegment(expectedSegmentNumber), this.onData, this.onTimeout);\n      else {\n        // Save the content and check if we are finished.\n        this.contentParts.push(data.content);\n\n        if (data.signedInfo != null && data.signedInfo.finalBlockID != null) {\n          var finalSegmentNumber = DataUtils.bigEndianToUnsignedInt(data.signedInfo.finalBlockID);\n          if (segmentNumber == finalSegmentNumber) {\n            // We are finished.  Parse and return the result.\n            this.onComponents(NameEnumeration.parseComponents(Buffer.concat(this.contentParts)));\n            return;\n          }\n        }\n\n        // Fetch the next segment.\n        this.face.expressInterest\n          (data.name.getPrefix(-1).addSegment(expectedSegmentNumber + 1), this.onData, this.onTimeout);\n      }\n    }\n  } catch (ex) {\n    console.log("NameEnumeration: ignoring exception: " + ex);\n  }\n};\n\n/**\n * Just call onComponents(null).\n */\nNameEnumeration.prototype.processTimeout = function()\n{\n  try {\n    this.onComponents(null);\n  } catch (ex) {\n    console.log("NameEnumeration: ignoring exception: " + ex);\n  }\n};\n\n/**\n * Parse the content as a name enumeration response and return an array of components.  This makes a copy of the component.\n * @param {Uint8Array} content The content to parse.\n * @returns {Array<Buffer>} The array of components.\n */\nNameEnumeration.parseComponents = function(content)\n{\n  var components = [];\n  var decoder = new BinaryXMLDecoder(content);\n\n  decoder.readElementStartDTag(NDNProtocolDTags.Collection);\n\n  while (decoder.peekDTag(NDNProtocolDTags.Link)) {\n    decoder.readElementStartDTag(NDNProtocolDTags.Link);\n    decoder.readElementStartDTag(NDNProtocolDTags.Name);\n\n    components.push(new ndnbuf(decoder.readBinaryDTagElement(NDNProtocolDTags.Component)));\n\n    decoder.readElementClose();\n    decoder.readElementClose();\n  }\n\n  decoder.readElementClose();\n  return components;\n};\n\n/**\n * Check if the last component in the name is a segment number.\n * TODO: Move to Name class.\n * @param {Name} name\n * @returns {Boolean} True if the name ends with a segment number, otherwise false.\n */\nNameEnumeration.endsWithSegmentNumber = function(name) {\n  return name.components != null && name.size() >= 1 &&\n         name.get(name.size() - 1).getValue().length >= 1 &&\n         name.get(name.size() - 1).getValue()[0] == 0;\n};\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Wentao Shang\n * See COPYING for copyright and distribution information.\n */\n\n/**\n * @constructor\n */\nvar WebSocketTransport = function WebSocketTransport()\n{\n  if (!WebSocket)\n    throw new Error("WebSocket support is not available on this platform.");\n\n  this.ws = null;\n  this.connectedHost = null; // Read by Face.\n  this.connectedPort = null; // Read by Face.\n  this.elementReader = null;\n  this.defaultGetHostAndPort = Face.makeShuffledGetHostAndPort\n    (["A.ws.ndn.ucla.edu", "B.ws.ndn.ucla.edu", "C.ws.ndn.ucla.edu", "D.ws.ndn.ucla.edu",\n      "E.ws.ndn.ucla.edu"],\n     9696);\n};\n\nexports.WebSocketTransport = WebSocketTransport;\n\n/**\n * Connect to the host and port in face.  This replaces a previous connection and sets connectedHost\n *   and connectedPort.  Once connected, call onopenCallback().\n * Listen on the port to read an entire binary XML encoded element and call\n *    face.onReceivedElement(element).\n */\nWebSocketTransport.prototype.connect = function(face, onopenCallback)\n{\n  if (this.ws != null)\n    delete this.ws;\n\n  this.ws = new WebSocket(\'ws://\' + face.host + \':\' + face.port);\n  if (LOG > 0) console.log(\'ws connection created.\');\n    this.connectedHost = face.host;\n    this.connectedPort = face.port;\n\n  this.ws.binaryType = "arraybuffer";\n\n  this.elementReader = new BinaryXmlElementReader(face);\n  var self = this;\n  this.ws.onmessage = function(ev) {\n    var result = ev.data;\n    //console.log(\'RecvHandle called.\');\n\n    if (result == null || result == undefined || result == "") {\n      console.log(\'INVALID ANSWER\');\n    }\n    else if (result instanceof ArrayBuffer) {\n      var bytearray = new ndnbuf(result);\n\n      if (LOG > 3) console.log(\'BINARY RESPONSE IS \' + bytearray.toString(\'hex\'));\n\n      try {\n        // Find the end of the binary XML element and call face.onReceivedElement.\n        self.elementReader.onReceivedData(bytearray);\n      } catch (ex) {\n        console.log("NDN.ws.onmessage exception: " + ex);\n        return;\n      }\n    }\n  }\n\n  this.ws.onopen = function(ev) {\n    if (LOG > 3) console.log(ev);\n    if (LOG > 3) console.log(\'ws.onopen: WebSocket connection opened.\');\n    if (LOG > 3) console.log(\'ws.onopen: ReadyState: \' + this.readyState);\n    // Face.registerPrefix will fetch the ndndid when needed.\n\n    onopenCallback();\n  }\n\n  this.ws.onerror = function(ev) {\n    console.log(\'ws.onerror: ReadyState: \' + this.readyState);\n    console.log(ev);\n    console.log(\'ws.onerror: WebSocket error: \' + ev.data);\n  }\n\n  this.ws.onclose = function(ev) {\n    console.log(\'ws.onclose: WebSocket connection closed.\');\n    self.ws = null;\n\n    // Close Face when WebSocket is closed\n    face.readyStatus = Face.CLOSED;\n    face.onclose();\n    //console.log("NDN.onclose event fired.");\n  }\n};\n\n/**\n * Send the Uint8Array data.\n */\nWebSocketTransport.prototype.send = function(data)\n{\n  if (this.ws != null) {\n    // If we directly use data.buffer to feed ws.send(),\n    // WebSocket may end up sending a packet with 10000 bytes of data.\n    // That is, WebSocket will flush the entire ndnbuf\n    // regardless of the offset of the Uint8Array. So we have to create\n    // a new Uint8Array ndnbuf with just the right size and copy the\n    // content from binaryInterest to the new ndnbuf.\n    //    ---Wentao\n    var bytearray = new Uint8Array(data.length);\n    bytearray.set(data);\n    this.ws.send(bytearray.buffer);\n    if (LOG > 3) console.log(\'ws.send() returned.\');\n  }\n  else\n    console.log(\'WebSocket connection is not established.\');\n};\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\n// The Face constructor uses TcpTransport by default which is not available in the browser, so override to WebSocketTransport.\nTcpTransport = WebSocketTransport;\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * Provide the callback closure for the async communication methods in the Face class.\n * This is a port of Closure.py from PyNDN, written by:\n * Derek Kulinski <takeda@takeda.tk>\n * Jeff Burke <jburke@ucla.edu>\n */\n\n/**\n * A subclass of Closure is passed to expressInterest and registerPrefix.\n * @deprecated You should use the forms of expressInterest and registerPrefix which use callbacks instead of Closure.\n * @constructor\n */\nvar Closure = function Closure()\n{\n  // I don\'t think storing Face\'s closure is needed\n  // and it creates a reference loop, as of now both\n  // of those variables are never set -- Derek\n  //\n  // Use instance variables to return data to callback\n  this.ndn_data = null;  // this holds the ndn_closure\n  this.ndn_data_dirty = false;\n};\n\nexports.Closure = Closure;\n\n// Upcall result\nClosure.RESULT_ERR               = -1; // upcall detected an error\nClosure.RESULT_OK                =  0; // normal upcall return\nClosure.RESULT_REEXPRESS         =  1; // reexpress the same interest again\nClosure.RESULT_INTEREST_CONSUMED =  2; // upcall claims to consume interest\nClosure.RESULT_VERIFY            =  3; // force an unverified result to be verified\nClosure.RESULT_FETCHKEY          =  4; // get the key in the key locator and re-call the interest\n                                       //   with the key available in the local storage\n\n// Upcall kind\nClosure.UPCALL_FINAL              = 0; // handler is about to be deregistered\nClosure.UPCALL_INTEREST           = 1; // incoming interest\nClosure.UPCALL_CONSUMED_INTEREST  = 2; // incoming interest, someone has answered\nClosure.UPCALL_CONTENT            = 3; // incoming verified content\nClosure.UPCALL_INTEREST_TIMED_OUT = 4; // interest timed out\nClosure.UPCALL_CONTENT_UNVERIFIED = 5; // content that has not been verified\nClosure.UPCALL_CONTENT_BAD        = 6; // verification failed\n\n/**\n * Override this in your subclass.\n * If you\'re getting strange errors in upcall()\n * check your code whether you\'re returning a value.\n */\nClosure.prototype.upcall = function(kind, upcallInfo)\n{\n  //dump(\'upcall \' + this + " " + kind + " " + upcallInfo + "\\n");\n  return Closure.RESULT_OK;\n};\n\n/**\n * An UpcallInfo is passed to Closure.upcall.\n * @constructor\n */\nvar UpcallInfo = function UpcallInfo(face, interest, matchedComps, data)\n{\n  this.face = face;  // Face object (not used)\n  this.ndn = face;   // deprecated\n  this.interest = interest;  // Interest object\n  this.matchedComps = matchedComps;  // int\n  this.data = data;  // Data\n  this.contentObject = data; // deprecated.  Include for backward compatibility.\n};\n\nUpcallInfo.prototype.toString = function()\n{\n  var ret = "face = " + this.face;\n  ret += "\\nInterest = " + this.interest;\n  ret += "\\nmatchedComps = " + this.matchedComps;\n  ret += "\\nData: " + this.data;\n  return ret;\n};\n\nexports.UpcallInfo = UpcallInfo;\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class represents PublisherPublicKeyDigest Objects\n */\n\n\n/**\n * @constructor\n */\nvar PublisherPublicKeyDigest = function PublisherPublicKeyDigest(pkd)\n{\n this.PUBLISHER_ID_LEN = 512/8;\n this.publisherPublicKeyDigest = pkd;\n};\n\nexports.PublisherPublicKeyDigest = PublisherPublicKeyDigest;\n\nPublisherPublicKeyDigest.prototype.from_ndnb = function(decoder)\n{\n  this.publisherPublicKeyDigest = decoder.readBinaryDTagElement(this.getElementLabel());\n\n  if (LOG > 4) console.log(\'Publisher public key digest is \' + this.publisherPublicKeyDigest);\n\n  if (null == this.publisherPublicKeyDigest)\n    throw new Error("Cannot parse publisher key digest.");\n\n  //TODO check if the length of the PublisherPublicKeyDigest is correct (Security reason)\n\n  if (this.publisherPublicKeyDigest.length != this.PUBLISHER_ID_LEN) {\n    if (LOG > 0)\n      console.log(\'LENGTH OF PUBLISHER ID IS WRONG! Expected \' + this.PUBLISHER_ID_LEN + ", got " + this.publisherPublicKeyDigest.length);\n\n    //this.publisherPublicKeyDigest = new PublisherPublicKeyDigest(this.PublisherPublicKeyDigest).PublisherKeyDigest;\n  }\n};\n\nPublisherPublicKeyDigest.prototype.to_ndnb= function(encoder)\n{\n  //TODO Check that the ByteArray for the key is present\n  if (!this.validate())\n    throw new Error("Cannot encode : field values missing.");\n\n  if (LOG > 3) console.log(\'PUBLISHER KEY DIGEST IS\'+this.publisherPublicKeyDigest);\n  encoder.writeDTagElement(this.getElementLabel(), this.publisherPublicKeyDigest);\n};\n\nPublisherPublicKeyDigest.prototype.getElementLabel = function() { return NDNProtocolDTags.PublisherPublicKeyDigest; };\n\nPublisherPublicKeyDigest.prototype.validate = function()\n{\n    return null != this.publisherPublicKeyDigest;\n};\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class represents Publisher and PublisherType Objects\n */\n\n/**\n * @constructor\n */\nvar PublisherType = function PublisherType(tag)\n{\n  this.KEY = NDNProtocolDTags.PublisherPublicKeyDigest;\n  this.CERTIFICATE = NDNProtocolDTags.PublisherCertificateDigest;\n  this.ISSUER_KEY = NDNProtocolDTags.PublisherIssuerKeyDigest;\n  this.ISSUER_CERTIFICATE = NDNProtocolDTags.PublisherIssuerCertificateDigest;\n\n  this.Tag = tag;\n};\n\n/**\n * @constructor\n */\nvar PublisherID = function PublisherID()\n{\n  this.PUBLISHER_ID_DIGEST_ALGORITHM = "SHA-256";\n  this.PUBLISHER_ID_LEN = 256/8;\n\n  //TODO, implement publisherID creation and key creation\n\n  //TODO implement generatePublicKeyDigest\n  this.publisherID =null;//= generatePublicKeyDigest(key);//ByteArray\n\n  //TODO implement generate key\n  //CryptoUtil.generateKeyID(PUBLISHER_ID_DIGEST_ALGORITHM, key);\n  this.publisherType = null;//isIssuer ? PublisherType.ISSUER_KEY : PublisherType.KEY;//publisher Type\n};\n\nexports.PublisherID = PublisherID;\n\nPublisherID.prototype.from_ndnb = function(decoder)\n{\n  // We have a choice here of one of 4 binary element types.\n  var nextTag = PublisherID.peekAndGetNextDTag(decoder);\n\n  this.publisherType = new PublisherType(nextTag);\n\n  if (nextTag < 0)\n    throw new Error("Invalid publisher ID, got unexpected type");\n\n  this.publisherID = decoder.readBinaryDTagElement(nextTag);\n  if (null == this.publisherID)\n    throw new ContentDecodingException(new Error("Cannot parse publisher ID of type : " + nextTag + "."));\n};\n\nPublisherID.prototype.to_ndnb = function(encoder)\n{\n  if (!this.validate())\n    throw new Error("Cannot encode " + this.getClass().getName() + ": field values missing.");\n\n  encoder.writeDTagElement(this.getElementLabel(), this.publisherID);\n};\n\n/**\n * Peek the next DTag in the decoder and return it if it is a PublisherID DTag.\n * @param {BinaryXMLDecoder} decoder The BinaryXMLDecoder with the input to decode.\n * @returns {number} The PublisherID DTag or -1 if it is not one of them.\n */\nPublisherID.peekAndGetNextDTag = function(decoder)\n{\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherPublicKeyDigest))\n    return             NDNProtocolDTags.PublisherPublicKeyDigest;\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherCertificateDigest))\n    return             NDNProtocolDTags.PublisherCertificateDigest;\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherIssuerKeyDigest))\n    return             NDNProtocolDTags.PublisherIssuerKeyDigest;\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherIssuerCertificateDigest))\n    return             NDNProtocolDTags.PublisherIssuerCertificateDigest;\n\n  return -1;\n};\n\nPublisherID.peek = function(/* XMLDecoder */ decoder)\n{\n  return PublisherID.peekAndGetNextDTag(decoder) >= 0;\n};\n\nPublisherID.prototype.getElementLabel = function()\n{\n  return this.publisherType.Tag;\n};\n\nPublisherID.prototype.validate = function()\n{\n  return null != id() && null != type();\n};\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Meki Cheraoui, Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * This class represents a Name as an array of components where each is a byte array.\n */\n\n/**\n * Create a new Name from components.\n *\n * @constructor\n * @param {string|Name|Array<string|Array<number>|ArrayBuffer|Buffer|Name>} components if a string, parse it as a URI.  If a Name, add a deep copy of its components.\n * Otherwise it is an array of components which are appended according to Name.append, so\n * convert each and store it as an array of ndnbuf.  If a component is a string, encode as utf8.\n */\nvar Name = function Name(components)\n{\n  if (typeof components == \'string\') {\n    if (LOG > 3) console.log(\'Content Name String \' + components);\n    this.components = Name.createNameArray(components);\n  }\n  else if (typeof components === \'object\') {\n    this.components = [];\n    if (components instanceof Name)\n      this.append(components);\n    else {\n      for (var i = 0; i < components.length; ++i)\n        this.append(components[i]);\n    }\n  }\n  else if (components== null)\n    this.components =[];\n  else\n    if (LOG > 1) console.log("NO CONTENT NAME GIVEN");\n};\n\nexports.Name = Name;\n\n/**\n *\n * @constructor\n * Create a new Name.Component with a copy of the given value.\n * @param {Name.Component|String|Array<number>|ArrayBuffer|Buffer} value If the value is a string, encode it as utf8 (but don\'t unescape).\n */\nName.Component = function NameComponent(value)\n{\n  if (typeof value == \'string\')\n    this.value = DataUtils.stringToUtf8Array(value);\n  else if (typeof value == \'object\' && value instanceof Name.Component)\n    this.value = new ndnbuf(value.value);\n  else if (typeof value == \'object\' && value instanceof ndnbuf)\n    this.value = new ndnbuf(value);\n  else if (typeof value == \'object\' && typeof ArrayBuffer != \'undefined\' &&  value instanceof ArrayBuffer) {\n    // Make a copy.  Don\'t use ArrayBuffer.slice since it isn\'t always supported.\n    this.value = new ndnbuf(new ArrayBuffer(value.byteLength));\n    this.value.set(new ndnbuf(value));\n  }\n  else if (typeof value == \'object\')\n    // Assume value is a byte array.  We can\'t check instanceof Array because\n    //   this doesn\'t work in JavaScript if the array comes from a different module.\n    this.value = new ndnbuf(value);\n  else\n    throw new Error("Name.Component constructor: Invalid type");\n}\n\n/**\n * Get the component value.\n * @returns {Buffer} The component value.\n */\nName.Component.prototype.getValue = function()\n{\n  return this.value;\n}\n\n/**\n * Convert this component value to a string by escaping characters according to the NDN URI Scheme.\n * This also adds "..." to a value with zero or more ".".\n * @returns {string} The escaped string.\n */\nName.Component.prototype.toEscapedString = function()\n{\n  return Name.toEscapedString(this.value);\n}\n\n/**\n * @deprecated Use toUri.\n */\nName.prototype.getName = function()\n{\n  return this.toUri();\n};\n\n/** Parse uri as a URI and return an array of ndnbuf components.\n */\nName.createNameArray = function(uri)\n{\n  uri = uri.trim();\n  if (uri.length <= 0)\n    return [];\n\n  var iColon = uri.indexOf(\':\');\n  if (iColon >= 0) {\n    // Make sure the colon came before a \'/\'.\n    var iFirstSlash = uri.indexOf(\'/\');\n    if (iFirstSlash < 0 || iColon < iFirstSlash)\n      // Omit the leading protocol such as ndn:\n      uri = uri.substr(iColon + 1, uri.length - iColon - 1).trim();\n  }\n\n  if (uri[0] == \'/\') {\n    if (uri.length >= 2 && uri[1] == \'/\') {\n      // Strip the authority following "//".\n      var iAfterAuthority = uri.indexOf(\'/\', 2);\n      if (iAfterAuthority < 0)\n        // Unusual case: there was only an authority.\n        return [];\n      else\n        uri = uri.substr(iAfterAuthority + 1, uri.length - iAfterAuthority - 1).trim();\n    }\n    else\n      uri = uri.substr(1, uri.length - 1).trim();\n  }\n\n  var array = uri.split(\'/\');\n\n  // Unescape the components.\n  for (var i = 0; i < array.length; ++i) {\n    var value = Name.fromEscapedString(array[i]);\n\n    if (value == null) {\n      // Ignore the illegal componenent.  This also gets rid of a trailing \'/\'.\n      array.splice(i, 1);\n      --i;\n      continue;\n    }\n    else\n      array[i] = new Name.Component(value);\n  }\n\n  return array;\n};\n\nName.prototype.from_ndnb = function(/*XMLDecoder*/ decoder)\n{\n  decoder.readElementStartDTag(this.getElementLabel());\n\n  this.components = [];\n\n  while (decoder.peekDTag(NDNProtocolDTags.Component))\n    this.append(decoder.readBinaryDTagElement(NDNProtocolDTags.Component));\n\n  decoder.readElementClose();\n};\n\nName.prototype.to_ndnb = function(/*XMLEncoder*/ encoder)\n{\n  if (this.components == null)\n    throw new Error("CANNOT ENCODE EMPTY CONTENT NAME");\n\n  encoder.writeElementStartDTag(this.getElementLabel());\n  var count = this.size();\n  for (var i=0; i < count; i++)\n    encoder.writeDTagElement(NDNProtocolDTags.Component, this.components[i].getValue());\n\n  encoder.writeElementClose();\n};\n\nName.prototype.getElementLabel = function()\n{\n  return NDNProtocolDTags.Name;\n};\n\n/**\n * Convert the component to a ndnbuf and append to this Name.\n * Return this Name object to allow chaining calls to add.\n * @param {Name.Component|String|Array<number>|ArrayBuffer|Buffer|Name} component If a component is a string, encode as utf8 (but don\'t unescape).\n * @returns {Name}\n */\nName.prototype.append = function(component)\n{\n  if (typeof component == \'object\' && component instanceof Name) {\n    var components;\n    if (component == this)\n      // special case, when we need to create a copy\n      components = this.components.slice(0, this.components.length);\n    else\n      components = component.components;\n\n    for (var i = 0; i < components.length; ++i)\n      this.components.push(new Name.Component(components[i]));\n  }\n  else\n    // Just use the Name.Component constructor.\n    this.components.push(new Name.Component(component));\n\n  return this;\n};\n\n/**\n * @deprecated Use append.\n */\nName.prototype.add = function(component)\n{\n  return this.append(component);\n};\n\n/**\n * Return the escaped name string according to "NDNx URI Scheme".\n * @returns {String}\n */\nName.prototype.toUri = function()\n{\n  if (this.size() == 0)\n    return "/";\n\n  var result = "";\n\n  for (var i = 0; i < this.size(); ++i)\n    result += "/"+ Name.toEscapedString(this.components[i].getValue());\n\n  return result;\n};\n\n/**\n * @deprecated Use toUri.\n */\nName.prototype.to_uri = function()\n{\n  return this.toUri();\n};\n\n/**\n * Append a component that represents a segment number\n *\n * This component has a special format handling:\n * - if number is zero, then %00 is added\n * - if number is between 1 and 255, %00%01 .. %00%FF is added\n * - ...\n * @param {number} number the segment number (integer is expected)\n * @returns {Name}\n */\nName.prototype.appendSegment = function(number)\n{\n  var segmentNumberBigEndian = DataUtils.nonNegativeIntToBigEndian(number);\n  // Put a 0 byte in front.\n  var segmentNumberComponent = new ndnbuf(segmentNumberBigEndian.length + 1);\n  segmentNumberComponent[0] = 0;\n  segmentNumberBigEndian.copy(segmentNumberComponent, 1);\n\n  this.components.push(new Name.Component(segmentNumberComponent));\n  return this;\n};\n\n/**\n * @deprecated Use appendSegment.\n */\nName.prototype.addSegment = function(number)\n{\n  return this.appendSegment(number);\n};\n\n/**\n * Get a new name, constructed as a subset of components.\n * @param {number} iStartComponent The index if the first component to get.\n * @param {number} (optional) nComponents The number of components starting at iStartComponent.  If omitted,\n * return components starting at iStartComponent until the end of the name.\n * @returns {Name} A new name.\n */\nName.prototype.getSubName = function(iStartComponent, nComponents)\n{\n  if (nComponents == undefined)\n    nComponents = this.components.length - iStartComponent;\n\n  var result = new Name();\n\n  var iEnd = iStartComponent + nComponents;\n  for (var i = iStartComponent; i < iEnd && i < this.components.length; ++i)\n    result.components.push(this.components[i]);\n\n  return result;\n};\n\n/**\n * Return a new Name with the first nComponents components of this Name.\n * @param {number} nComponents The number of prefix components.  If nComponents is -N then return the prefix up\n * to name.size() - N. For example getPrefix(-1) returns the name without the final component.\n * @returns {Name} A new name.\n */\nName.prototype.getPrefix = function(nComponents)\n{\n  if (nComponents < 0)\n    return this.getSubName(0, this.components.length + nComponents);\n  else\n    return this.getSubName(0, nComponents);\n};\n\n/**\n * @brief Get prefix of the name, containing less minusComponents right components\n * @param minusComponents number of components to cut from the back\n */\nName.prototype.cut = function(minusComponents)\n{\n  return new Name(this.components.slice(0, this.components.length - minusComponents));\n};\n\n/**\n * Return the number of name components.\n * @returns {number}\n */\nName.prototype.size = function()\n{\n  return this.components.length;\n};\n\n/**\n * Return a new Name.Component of the component at the given index.  To get just the component value, use get(i).getValue().\n * @param {Number} i The index of the component, starting from 0.  However, if i is negative, return the component\n * at size() - (-i).\n * @returns {Name.Component}\n */\nName.prototype.get = function(i)\n{\n  if (i >= 0) {\n    if (i >= this.components.length)\n      throw new Error("Name.get: Index is out of bounds");\n\n    return new Name.Component(this.components[i]);\n  }\n  else {\n    // Negative index.\n    if (i < -this.components.length)\n      throw new Error("Name.get: Index is out of bounds");\n\n    return new Name.Component(this.components[this.components.length - (-i)]);\n  }\n};\n\n/**\n * @deprecated Use size().\n */\nName.prototype.getComponentCount = function()\n{\n  return this.components.length;\n};\n\n/**\n * @deprecated To get just the component value, use get(i).getValue().\n */\nName.prototype.getComponent = function(i)\n{\n  return new ndnbuf(this.components[i].getValue());\n};\n\n/**\n * The "file name" in a name is the last component that isn\'t blank and doesn\'t start with one of the\n *   special marker octets (for version, etc.).  Return the index in this.components of\n *   the file name, or -1 if not found.\n */\nName.prototype.indexOfFileName = function()\n{\n  for (var i = this.size() - 1; i >= 0; --i) {\n    var component = this.components[i].getValue();\n    if (component.length <= 0)\n      continue;\n\n    if (component[0] == 0 || component[0] == 0xC0 || component[0] == 0xC1 ||\n        (component[0] >= 0xF5 && component[0] <= 0xFF))\n      continue;\n\n    return i;\n  }\n\n  return -1;\n};\n\n/**\n * Return true if this Name has the same components as name.\n */\nName.prototype.equals = function(name)\n{\n  if (this.components.length != name.components.length)\n    return false;\n\n  // Start from the last component because they are more likely to differ.\n  for (var i = this.components.length - 1; i >= 0; --i) {\n    if (!DataUtils.arraysEqual(this.components[i].getValue(), name.components[i].getValue()))\n      return false;\n  }\n\n  return true;\n};\n\n/**\n * @deprecated Use equals.\n */\nName.prototype.equalsName = function(name)\n{\n  return this.equals(name);\n};\n\n/**\n * Find the last component in name that has a ContentDigest and return the digest value as ndnbuf,\n *   or null if not found.  See Name.getComponentContentDigestValue.\n */\nName.prototype.getContentDigestValue = function()\n{\n  for (var i = this.size() - 1; i >= 0; --i) {\n    var digestValue = Name.getComponentContentDigestValue(this.components[i]);\n    if (digestValue != null)\n      return digestValue;\n  }\n\n  return null;\n};\n\n/**\n * If component is a ContentDigest, return the digest value as a ndnbuf slice (don\'t modify!).\n * If not a ContentDigest, return null.\n * A ContentDigest component is Name.ContentDigestPrefix + 32 bytes + Name.ContentDigestSuffix.\n */\nName.getComponentContentDigestValue = function(component)\n{\n  if (typeof component == \'object\' && component instanceof Name.Component)\n    component = component.getValue();\n\n  var digestComponentLength = Name.ContentDigestPrefix.length + 32 + Name.ContentDigestSuffix.length;\n  // Check for the correct length and equal ContentDigestPrefix and ContentDigestSuffix.\n  if (component.length == digestComponentLength &&\n      DataUtils.arraysEqual(component.slice(0, Name.ContentDigestPrefix.length),\n                            Name.ContentDigestPrefix) &&\n      DataUtils.arraysEqual(component.slice\n         (component.length - Name.ContentDigestSuffix.length, component.length),\n                            Name.ContentDigestSuffix))\n   return component.slice(Name.ContentDigestPrefix.length, Name.ContentDigestPrefix.length + 32);\n else\n   return null;\n};\n\n// Meta GUID "%C1.M.G%C1" + ContentDigest with a 32 byte BLOB.\nName.ContentDigestPrefix = new ndnbuf([0xc1, 0x2e, 0x4d, 0x2e, 0x47, 0xc1, 0x01, 0xaa, 0x02, 0x85]);\nName.ContentDigestSuffix = new ndnbuf([0x00]);\n\n\n/**\n * Return value as an escaped string according to "NDNx URI Scheme".\n * We can\'t use encodeURIComponent because that doesn\'t encode all the characters we want to.\n * @param {Buffer|Name.Component} component The value or Name.Component to escape.\n * @returns {string} The escaped string.\n */\nName.toEscapedString = function(value)\n{\n  if (typeof value == \'object\' && value instanceof Name.Component)\n    value = value.getValue();\n\n  var result = "";\n  var gotNonDot = false;\n  for (var i = 0; i < value.length; ++i) {\n    if (value[i] != 0x2e) {\n      gotNonDot = true;\n      break;\n    }\n  }\n  if (!gotNonDot) {\n    // Special case for component of zero or more periods.  Add 3 periods.\n    result = "...";\n    for (var i = 0; i < value.length; ++i)\n      result += ".";\n  }\n  else {\n    for (var i = 0; i < value.length; ++i) {\n      var x = value[i];\n      // Check for 0-9, A-Z, a-z, (+), (-), (.), (_)\n      if (x >= 0x30 && x <= 0x39 || x >= 0x41 && x <= 0x5a ||\n          x >= 0x61 && x <= 0x7a || x == 0x2b || x == 0x2d ||\n          x == 0x2e || x == 0x5f)\n        result += String.fromCharCode(x);\n      else\n        result += "%" + (x < 16 ? "0" : "") + x.toString(16).toUpperCase();\n    }\n  }\n  return result;\n};\n\n/**\n * Return a ndnbuf byte array by decoding the escapedString according to "NDNx URI Scheme".\n * If escapedString is "", "." or ".." then return null, which means to skip the component in the name.\n * @param {string} escapedString The escaped string to decode.\n * @returns {Buffer} The byte array, or null which means to skip the component in the name.\n */\nName.fromEscapedString = function(escapedString)\n{\n  var value = unescape(escapedString.trim());\n\n  if (value.match(/[^.]/) == null) {\n    // Special case for value of only periods.\n    if (value.length <= 2)\n      // Zero, one or two periods is illegal.  Ignore this componenent to be\n      //   consistent with the C implementation.\n      return null;\n    else\n      // Remove 3 periods.\n      return DataUtils.toNumbersFromString(value.substr(3, value.length - 3));\n  }\n  else\n    return DataUtils.toNumbersFromString(value);\n};\n\n/**\n * Return true if the N components of this name are the same as the first N components of the given name.\n * @param {Name} name The name to check.\n * @returns {Boolean} true if this matches the given name.  This always returns true if this name is empty.\n */\nName.prototype.match = function(name)\n{\n  var i_name = this.components;\n  var o_name = name.components;\n\n  // This name is longer than the name we are checking it against.\n  if (i_name.length > o_name.length)\n    return false;\n\n  // Check if at least one of given components doesn\'t match.\n  for (var i = 0; i < i_name.length; ++i) {\n    if (!DataUtils.arraysEqual(i_name[i].getValue(), o_name[i].getValue()))\n      return false;\n  }\n\n  return true;\n};\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n */\n\n\n/**\n * @constructor\n */\nvar KeyManager = function KeyManager()\n{\n  this.certificate =\n  "MIIBmzCCAQQCCQC32FyQa61S7jANBgkqhkiG9w0BAQUFADASMRAwDgYDVQQDEwd" +\n  "heGVsY2R2MB4XDTEyMDQyODIzNDQzN1oXDTEyMDUyODIzNDQzN1owEjEQMA4GA1" +\n  "UEAxMHYXhlbGNkdjCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA4X0wp9goq" +\n  "xuECxdULcr2IHr9Ih4Iaypg0Wy39URIup8/CLzQmdsh3RYqd55hqonu5VTTpH3i" +\n  "MLx6xZDVJAZ8OJi7pvXcQ2C4Re2kjL2c8SanI0RfDhlS1zJadfr1VhRPmpivcYa" +\n  "wJ4aFuOLAi+qHFxtN7lhcGCgpW1OV60oXd58CAwEAATANBgkqhkiG9w0BAQUFAA" +\n  "OBgQDLOrA1fXzSrpftUB5Ro6DigX1Bjkf7F5Bkd69hSVp+jYeJFBBlsILQAfSxU" +\n  "ZPQtD+2Yc3iCmSYNyxqu9PcufDRJlnvB7PG29+L3y9lR37tetzUV9eTscJ7rdp8" +\n  "Wt6AzpW32IJ/54yKNfP7S6ZIoIG+LP6EIxq6s8K1MXRt8uBJKw==";\n\n  // Public Key\n    this.publicKey =\n  "-----BEGIN PUBLIC KEY-----\\n" +\n  "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDhfTCn2CirG4QLF1QtyvYgev0i\\n" +\n  "HghrKmDRbLf1REi6nz8IvNCZ2yHdFip3nmGqie7lVNOkfeIwvHrFkNUkBnw4mLum\\n" +\n  "9dxDYLhF7aSMvZzxJqcjRF8OGVLXMlp1+vVWFE+amK9xhrAnhoW44sCL6ocXG03u\\n" +\n  "WFwYKClbU5XrShd3nwIDAQAB\\n" +\n  "-----END PUBLIC KEY-----";\n  // Private Key\n    this.privateKey =\n  "-----BEGIN RSA PRIVATE KEY-----\\n" +\n  "MIICXQIBAAKBgQDhfTCn2CirG4QLF1QtyvYgev0iHghrKmDRbLf1REi6nz8IvNCZ\\n" +\n  "2yHdFip3nmGqie7lVNOkfeIwvHrFkNUkBnw4mLum9dxDYLhF7aSMvZzxJqcjRF8O\\n" +\n  "GVLXMlp1+vVWFE+amK9xhrAnhoW44sCL6ocXG03uWFwYKClbU5XrShd3nwIDAQAB\\n" +\n  "AoGAGkv6T6jC3WmhFZYL6CdCWvlc6gysmKrhjarrLTxgavtFY6R5g2ft5BXAsCCV\\n" +\n  "bUkWxkIFSKqxpVNl0gKZCNGEzPDN6mHJOQI/h0rlxNIHAuGfoAbCzALnqmyZivhJ\\n" +\n  "APGijAyKuU9tczsst5+Kpn+bn7ehzHQuj7iwJonS5WbojqECQQD851K8TpW2GrRi\\n" +\n  "zNgG4dx6orZxAaon/Jnl8lS7soXhllQty7qG+oDfzznmdMsiznCqEABzHUUKOVGE\\n" +\n  "9RWPN3aRAkEA5D/w9N55d0ibnChFJlc8cUAoaqH+w+U3oQP2Lb6AZHJpLptN4y4b\\n" +\n  "/uf5d4wYU5/i/gC7SSBH3wFhh9bjRLUDLwJAVOx8vN0Kqt7myfKNbCo19jxjVSlA\\n" +\n  "8TKCn1Oznl/BU1I+rC4oUaEW25DjmX6IpAR8kq7S59ThVSCQPjxqY/A08QJBAIRa\\n" +\n  "F2zGPITQk3r/VumemCvLWiRK/yG0noc9dtibqHOWbCtcXtOm/xDWjq+lis2i3ssO\\n" +\n  "vYrvrv0/HcDY+Dv1An0CQQCLJtMsfSg4kvG/FRY5UMhtMuwo8ovYcMXt4Xv/LWaM\\n" +\n  "hndD67b2UGawQCRqr5ghRTABWdDD/HuuMBjrkPsX0861\\n" +\n  "-----END RSA PRIVATE KEY-----";\n\n  this.key = null;\n};\n\n/**\n * Return a Key object for the keys in this KeyManager.  This creates the Key on the first\n * call and returns a cached copy after that.\n * @returns {Key}\n */\nKeyManager.prototype.getKey = function()\n{\n  if (this.key === null) {\n    this.key = new Key();\n    this.key.fromPemString(this.publicKey, this.privateKey);\n  }\n\n  return this.key;\n}\n\nvar globalKeyManager = globalKeyManager || new KeyManager();\nndn.globalKeyManager = globalKeyManager\nexports.globalKeyManager = globalKeyManager;\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class represents Data Objects\n */\n\n\n/**\n * Create a new Data with the optional values.\n *\n * @constructor\n * @param {Name} name\n * @param {SignedInfo} signedInfo\n * @param {Buffer} content\n */\nvar Data = function Data(name, signedInfo, content)\n{\n  if (typeof name == \'string\')\n    this.name = new Name(name);\n  else\n    //TODO Check the class of name\n    this.name = name;\n\n  this.signedInfo = signedInfo;\n\n  if (typeof content == \'string\')\n    this.content = DataUtils.toNumbersFromString(content);\n  else\n    this.content = content;\n\n  this.signature = new Signature();\n\n  this.startSIG = null;\n  this.endSIG = null;\n\n  this.endContent = null;\n\n  this.rawSignatureData = null;\n};\n\nexports.Data = Data;\n\nData.prototype.sign = function()\n{\n  var n1 = this.encodeObject(this.name);\n  var n2 = this.encodeObject(this.signedInfo);\n  var n3 = this.encodeContent();\n\n  var rsa = ndn.createSign(\'RSA-SHA256\');\n  rsa.update(n1);\n  rsa.update(n2);\n  rsa.update(n3);\n\n  var sig = new ndnbuf(rsa.sign(ndn.globalKeyManager.privateKey));\n\n  this.signature.signature = sig;\n};\n\nData.prototype.verify = function(/*Key*/ key)\n{\n  if (key == null || key.publicKeyPem == null)\n    throw new Error(\'Cannot verify Data without a public key.\');\n\n  var verifier = ndn.createVerify(\'RSA-SHA256\');\n  verifier.update(this.rawSignatureData);\n  return verifier.verify(key.publicKeyPem, this.signature.signature);\n};\n\nData.prototype.encodeObject = function encodeObject(obj)\n{\n  var enc = new BinaryXMLEncoder();\n  obj.to_ndnb(enc);\n  var num = enc.getReducedOstream();\n\n  return num;\n};\n\nData.prototype.encodeContent = function encodeContent()\n{\n  var enc = new BinaryXMLEncoder();\n  enc.writeDTagElement(NDNProtocolDTags.Content, this.content);\n  var num = enc.getReducedOstream();\n\n  return num;\n};\n\nData.prototype.saveRawData = function(bytes)\n{\n  var sigBits = bytes.slice(this.startSIG, this.endSIG);\n  this.rawSignatureData = new ndnbuf(sigBits);\n};\n\nData.prototype.getElementLabel = function() { return NDNProtocolDTags.Data; };\n\n/**\n * Create a new Signature with the optional values.\n * @constructor\n */\nvar Signature = function Signature(witness, signature, digestAlgorithm)\n{\n  this.witness = witness;\n  this.signature = signature;\n  this.digestAlgorithm = digestAlgorithm\n};\n\nexports.Signature = Signature;\n\nSignature.prototype.from_ndnb = function(decoder)\n{\n  decoder.readElementStartDTag(this.getElementLabel());\n\n  if (LOG > 4) console.log(\'STARTED DECODING SIGNATURE\');\n\n  if (decoder.peekDTag(NDNProtocolDTags.DigestAlgorithm)) {\n    if (LOG > 4) console.log(\'DIGIEST ALGORITHM FOUND\');\n    this.digestAlgorithm = decoder.readUTF8DTagElement(NDNProtocolDTags.DigestAlgorithm);\n  }\n  if (decoder.peekDTag(NDNProtocolDTags.Witness)) {\n    if (LOG > 4) console.log(\'WITNESS FOUND\');\n    this.witness = decoder.readBinaryDTagElement(NDNProtocolDTags.Witness);\n  }\n\n  //FORCE TO READ A SIGNATURE\n\n  if (LOG > 4) console.log(\'SIGNATURE FOUND\');\n  this.signature = decoder.readBinaryDTagElement(NDNProtocolDTags.SignatureBits);\n\n  decoder.readElementClose();\n};\n\nSignature.prototype.to_ndnb = function(encoder)\n{\n  if (!this.validate())\n    throw new Error("Cannot encode: field values missing.");\n\n  encoder.writeElementStartDTag(this.getElementLabel());\n\n  if (null != this.digestAlgorithm && !this.digestAlgorithm.equals(NDNDigestHelper.DEFAULT_DIGEST_ALGORITHM))\n    encoder.writeDTagElement(NDNProtocolDTags.DigestAlgorithm, OIDLookup.getDigestOID(this.DigestAlgorithm));\n\n  if (null != this.witness)\n    // needs to handle null witness\n    encoder.writeDTagElement(NDNProtocolDTags.Witness, this.witness);\n\n  encoder.writeDTagElement(NDNProtocolDTags.SignatureBits, this.signature);\n\n  encoder.writeElementClose();\n};\n\nSignature.prototype.getElementLabel = function() { return NDNProtocolDTags.Signature; };\n\nSignature.prototype.validate = function()\n{\n  return null != this.signature;\n};\n\nvar ContentType = {DATA:0, ENCR:1, GONE:2, KEY:3, LINK:4, NACK:5};\nvar ContentTypeValue = {0:0x0C04C0, 1:0x10D091,2:0x18E344,3:0x28463F,4:0x2C834A,5:0x34008A};\nvar ContentTypeValueReverse = {0x0C04C0:0, 0x10D091:1,0x18E344:2,0x28463F:3,0x2C834A:4,0x34008A:5};\n\nexports.ContentType = ContentType;\n\n/**\n * Create a new SignedInfo with the optional values.\n * @constructor\n */\nvar SignedInfo = function SignedInfo(publisher, timestamp, type, locator, freshnessSeconds, finalBlockID)\n{\n  this.publisher = publisher; //publisherPublicKeyDigest\n  this.timestamp=timestamp; // NDN Time\n  this.type=type; // ContentType\n  this.locator =locator;//KeyLocator\n  this.freshnessSeconds =freshnessSeconds; // Integer\n  this.finalBlockID=finalBlockID; //byte array\n\n  this.setFields();\n};\n\nexports.SignedInfo = SignedInfo;\n\nSignedInfo.prototype.setFields = function()\n{\n  var key = ndn.globalKeyManager.getKey();\n  this.publisher = new PublisherPublicKeyDigest(key.getKeyID());\n\n  var d = new Date();\n\n  var time = d.getTime();\n\n  this.timestamp = new NDNTime(time);\n\n  if (LOG > 4) console.log(\'TIME msec is\');\n\n  if (LOG > 4) console.log(this.timestamp.msec);\n\n  //DATA\n  this.type = 0;//0x0C04C0;//ContentTypeValue[ContentType.DATA];\n\n  if (LOG > 4) console.log(\'PUBLIC KEY TO WRITE TO DATA PACKET IS \');\n  if (LOG > 4) console.log(key.publicToDER().toString(\'hex\'));\n\n  this.locator = new KeyLocator(key.publicToDER(), KeyLocatorType.KEY);\n  //this.locator = new KeyLocator(DataUtils.toNumbersFromString(stringCertificate)  ,KeyLocatorType.CERTIFICATE);\n};\n\nSignedInfo.prototype.from_ndnb = function(decoder)\n{\n  decoder.readElementStartDTag(this.getElementLabel());\n\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherPublicKeyDigest)) {\n    if (LOG > 4) console.log(\'DECODING PUBLISHER KEY\');\n    this.publisher = new PublisherPublicKeyDigest();\n    this.publisher.from_ndnb(decoder);\n  }\n\n  if (decoder.peekDTag(NDNProtocolDTags.Timestamp)) {\n    if (LOG > 4) console.log(\'DECODING TIMESTAMP\');\n    this.timestamp = decoder.readDateTimeDTagElement(NDNProtocolDTags.Timestamp);\n  }\n\n  if (decoder.peekDTag(NDNProtocolDTags.Type)) {\n    var binType = decoder.readBinaryDTagElement(NDNProtocolDTags.Type);\n\n    if (LOG > 4) console.log(\'Binary Type of of Signed Info is \'+binType);\n\n    this.type = binType;\n\n    //TODO Implement type of Key Reading\n    if (null == this.type)\n      throw new Error("Cannot parse signedInfo type: bytes.");\n  }\n  else\n    this.type = ContentType.DATA; // default\n\n  if (decoder.peekDTag(NDNProtocolDTags.FreshnessSeconds)) {\n    this.freshnessSeconds = decoder.readIntegerDTagElement(NDNProtocolDTags.FreshnessSeconds);\n    if (LOG > 4) console.log(\'FRESHNESS IN SECONDS IS \'+ this.freshnessSeconds);\n  }\n\n  if (decoder.peekDTag(NDNProtocolDTags.FinalBlockID)) {\n    if (LOG > 4) console.log(\'DECODING FINAL BLOCKID\');\n    this.finalBlockID = decoder.readBinaryDTagElement(NDNProtocolDTags.FinalBlockID);\n  }\n\n  if (decoder.peekDTag(NDNProtocolDTags.KeyLocator)) {\n    if (LOG > 4) console.log(\'DECODING KEY LOCATOR\');\n    this.locator = new KeyLocator();\n    this.locator.from_ndnb(decoder);\n  }\n\n  decoder.readElementClose();\n};\n\nSignedInfo.prototype.to_ndnb = function(encoder)  {\n  if (!this.validate())\n    throw new Error("Cannot encode : field values missing.");\n\n  encoder.writeElementStartDTag(this.getElementLabel());\n\n  if (null != this.publisher) {\n    if (LOG > 3) console.log(\'ENCODING PUBLISHER KEY\' + this.publisher.publisherPublicKeyDigest);\n    this.publisher.to_ndnb(encoder);\n  }\n\n  if (null != this.timestamp)\n    encoder.writeDateTimeDTagElement(NDNProtocolDTags.Timestamp, this.timestamp);\n\n  if (null != this.type && this.type != 0)\n    encoder.writeDTagElement(NDNProtocolDTags.type, this.type);\n\n  if (null != this.freshnessSeconds)\n    encoder.writeDTagElement(NDNProtocolDTags.FreshnessSeconds, this.freshnessSeconds);\n\n  if (null != this.finalBlockID)\n    encoder.writeDTagElement(NDNProtocolDTags.FinalBlockID, this.finalBlockID);\n\n  if (null != this.locator)\n    this.locator.to_ndnb(encoder);\n\n  encoder.writeElementClose();\n};\n\nSignedInfo.prototype.valueToType = function()\n{\n  return null;\n};\n\nSignedInfo.prototype.getElementLabel = function() {\n  return NDNProtocolDTags.SignedInfo;\n};\n\nSignedInfo.prototype.validate = function()\n{\n  // We don\'t do partial matches any more, even though encoder/decoder\n  // is still pretty generous.\n  if (null ==this.publisher || null==this.timestamp ||null== this.locator)\n    return false;\n  return true;\n};\n\n/**\n * @deprecated Use BinaryXmlWireFormat.decodeData.\n */\nData.prototype.from_ndnb = function(/*XMLDecoder*/ decoder)\n{\n  BinaryXmlWireFormat.decodeData(this, decoder);\n};\n\n/**\n * @deprecated Use BinaryXmlWireFormat.encodeData.\n */\nData.prototype.to_ndnb = function(/*XMLEncoder*/ encoder)\n{\n  BinaryXmlWireFormat.encodeData(this, encoder);\n};\n\n/**\n * Encode this Data for a particular wire format.\n * @param {WireFormat} wireFormat if null, use BinaryXmlWireFormat.\n * @returns {Buffer}\n */\nData.prototype.encode = function(wireFormat)\n{\n  wireFormat = (wireFormat || BinaryXmlWireFormat.instance);\n  return wireFormat.encodeData(this);\n};\n\n/**\n * Decode the input using a particular wire format and update this Data.\n * @param {Buffer} input\n * @param {WireFormat} wireFormat if null, use BinaryXmlWireFormat.\n */\nData.prototype.decode = function(input, wireFormat)\n{\n  wireFormat = (wireFormat || BinaryXmlWireFormat.instance);\n  wireFormat.decodeData(this, input);\n};\n\n/**\n * @deprecated Use new Data.\n */\nvar ContentObject = function ContentObject(name, signedInfo, content)\n{\n  // Call the base constructor.\n  Data.call(this, name, signedInfo, content);\n}\n\nContentObject.prototype = new Data();\n\nexports.ContentObject = ContentObject;\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class represents Interest Objects\n */\n\n\n/**\n * Create a new Interest with the optional values.\n *\n * @constructor\n * @param {Name|Interest} nameOrInterest If this is an Interest, copy values from the interest and ignore the\n * other arguments.  Otherwise this is the optional name for the new Interest.\n * @param {number} minSuffixComponents\n * @param {number} maxSuffixComponents\n * @param {Buffer} publisherPublicKeyDigest\n * @param {Exclude} exclude\n * @param {number} childSelector\n * @param {number} answerOriginKind\n * @param {number} scope\n * @param {number} interestLifetimeMilliseconds in milliseconds\n * @param {Buffer} nonce\n */\nvar Interest = function Interest\n   (nameOrInterest, minSuffixComponents, maxSuffixComponents, publisherPublicKeyDigest, exclude,\n    childSelector, answerOriginKind, scope, interestLifetimeMilliseconds, nonce)\n{\n  if (typeof nameOrInterest == \'object\' && nameOrInterest instanceof Interest) {\n    // Special case: this is a copy constructor.  Ignore all but the first argument.\n    var interest = nameOrInterest;\n    if (interest.name)\n      // Copy the name.\n      this.name = new Name(interest.name);\n    this.maxSuffixComponents = interest.maxSuffixComponents;\n    this.minSuffixComponents = interest.minSuffixComponents;\n\n    this.publisherPublicKeyDigest = interest.publisherPublicKeyDigest;\n    this.exclude = interest.exclude;\n    this.childSelector = interest.childSelector;\n    this.answerOriginKind = interest.answerOriginKind;\n    this.scope = interest.scope;\n    this.interestLifetime = interest.interestLifetime;\n    if (interest.nonce)\n      // Copy.\n      this.nonce = new ndnbuf(interest.nonce);\n  }\n  else {\n    this.name = nameOrInterest;\n    this.maxSuffixComponents = maxSuffixComponents;\n    this.minSuffixComponents = minSuffixComponents;\n\n    this.publisherPublicKeyDigest = publisherPublicKeyDigest;\n    this.exclude = exclude;\n    this.childSelector = childSelector;\n    this.answerOriginKind = answerOriginKind;\n    this.scope = scope;\n    this.interestLifetime = interestLifetimeMilliseconds;\n    if (nonce)\n      // Copy and make sure it is a ndnbuf.\n      this.nonce = new ndnbuf(nonce);\n  }\n};\n\nexports.Interest = Interest;\n\nInterest.RECURSIVE_POSTFIX = "*";\n\nInterest.CHILD_SELECTOR_LEFT = 0;\nInterest.CHILD_SELECTOR_RIGHT = 1;\n\nInterest.ANSWER_NO_CONTENT_STORE = 0;\nInterest.ANSWER_CONTENT_STORE = 1;\nInterest.ANSWER_GENERATED = 2;\nInterest.ANSWER_STALE = 4;    // Stale answer OK\nInterest.MARK_STALE = 16;    // Must have scope 0.  Michael calls this a "hack"\n\nInterest.DEFAULT_ANSWER_ORIGIN_KIND = Interest.ANSWER_CONTENT_STORE | Interest.ANSWER_GENERATED;\n\n/**\n * Return true if this.name.match(name) and the name conforms to the interest selectors.\n * @param {Name} name\n * @returns {boolean}\n */\nInterest.prototype.matchesName = function(/*Name*/ name)\n{\n  if (!this.name.match(name))\n    return false;\n\n  if (this.minSuffixComponents != null &&\n      // Add 1 for the implicit digest.\n      !(name.size() + 1 - this.name.size() >= this.minSuffixComponents))\n    return false;\n  if (this.maxSuffixComponents != null &&\n      // Add 1 for the implicit digest.\n      !(name.size() + 1 - this.name.size() <= this.maxSuffixComponents))\n    return false;\n  if (this.exclude != null && name.size() > this.name.size() &&\n      this.exclude.matches(name.components[this.name.size()]))\n    return false;\n\n  return true;\n};\n\n/**\n * @deprecated Use matchesName.\n */\nInterest.prototype.matches_name = function(/*Name*/ name)\n{\n  return this.matchesName(name);\n};\n\n/**\n * Return a new Interest with the same fields as this Interest.\n * Note: This does NOT make a deep clone of the name, exclue or other objects.\n */\nInterest.prototype.clone = function()\n{\n  return new Interest\n     (this.name, this.minSuffixComponents, this.maxSuffixComponents,\n      this.publisherPublicKeyDigest, this.exclude, this.childSelector, this.answerOriginKind,\n      this.scope, this.interestLifetime, this.nonce);\n};\n\nInterest.prototype.setMinSuffixComponents = function(value)\n{\n  this.minSuffixComponents = value;\n}\n\nInterest.prototype.setMaxSuffixComponents = function(value)\n{\n  this.maxSuffixComponents = value;\n}\n\nInterest.prototype.setChildSelector = function(value)\n{\n  this.childSelector = value;\n}\n\nInterest.prototype.setAnswerOriginKind = function(value)\n{\n  this.answerOriginKind = value;\n}\n\nInterest.prototype.setScope = function(value)\n{\n  this.scope = value;\n}\n\nInterest.prototype.setInterestLifetimeMilliseconds = function(value)\n{\n  this.interestLifetime = value;\n}\n\nInterest.prototype.setNonce = function(value)\n{\n  if (value)\n    // Copy and make sure it is a ndnbuf.\n    this.nonce = new ndnbuf(value);\n  else\n    this.nonce = null;\n}\n\n/**\n * Create a new Exclude.\n * @constructor\n * @param {Array<Name.Component|Buffer|Exclude.ANY>} values (optional) An array where each element is either a Name.Component, ndnbuf component or Exclude.ANY.\n */\nvar Exclude = function Exclude(values)\n{\n  this.values = [];\n\n  if (values) {\n    for (var i = 0; i < values.length; ++i) {\n      if (values[i] == Exclude.ANY)\n        this.appendAny();\n      else\n        this.appendComponent(values[i]);\n    }\n  }\n};\n\nexports.Exclude = Exclude;\n\nExclude.ANY = "*";\n\n/**\n * Append an Exclude.ANY element.\n * @returns This Exclude so that you can chain calls to append.\n */\nExclude.prototype.appendAny = function()\n{\n  this.values.push(Exclude.ANY);\n  return this;\n}\n\n/**\n * Append a component entry, copying from component.\n * @param {Name.Component|Buffer} component\n * @returns This Exclude so that you can chain calls to append.\n */\nExclude.prototype.appendComponent = function(component)\n{\n  this.values.push(new Name.Component(component));\n  return this;\n}\n\nExclude.prototype.from_ndnb = function(/*XMLDecoder*/ decoder)\n{\n  decoder.readElementStartDTag(NDNProtocolDTags.Exclude);\n\n  while (true) {\n    if (decoder.peekDTag(NDNProtocolDTags.Component))\n      this.appendComponent(decoder.readBinaryDTagElement(NDNProtocolDTags.Component));\n    else if (decoder.peekDTag(NDNProtocolDTags.Any)) {\n      decoder.readElementStartDTag(NDNProtocolDTags.Any);\n      decoder.readElementClose();\n      this.appendAny();\n    }\n    else if (decoder.peekDTag(NDNProtocolDTags.Bloom)) {\n      // Skip the Bloom and treat it as Any.\n      decoder.readBinaryDTagElement(NDNProtocolDTags.Bloom);\n      this.appendAny();\n    }\n    else\n      break;\n  }\n\n  decoder.readElementClose();\n};\n\nExclude.prototype.to_ndnb = function(/*XMLEncoder*/ encoder)\n{\n  if (this.values == null || this.values.length == 0)\n    return;\n\n  encoder.writeElementStartDTag(NDNProtocolDTags.Exclude);\n\n  // TODO: Do we want to order the components (except for ANY)?\n  for (var i = 0; i < this.values.length; ++i) {\n    if (this.values[i] == Exclude.ANY) {\n      encoder.writeElementStartDTag(NDNProtocolDTags.Any);\n      encoder.writeElementClose();\n    }\n    else\n      encoder.writeDTagElement(NDNProtocolDTags.Component, this.values[i].getValue());\n  }\n\n  encoder.writeElementClose();\n};\n\n/**\n * Return a string with elements separated by "," and Exclude.ANY shown as "*".\n */\nExclude.prototype.toUri = function()\n{\n  if (this.values == null || this.values.length == 0)\n    return "";\n\n  var result = "";\n  for (var i = 0; i < this.values.length; ++i) {\n    if (i > 0)\n      result += ",";\n\n    if (this.values[i] == Exclude.ANY)\n      result += "*";\n    else\n      result += Name.toEscapedString(this.values[i].getValue());\n  }\n  return result;\n};\n\n/**\n * Return true if the component matches any of the exclude criteria.\n */\nExclude.prototype.matches = function(/*Buffer*/ component)\n{\n  if (typeof component == \'object\' && component instanceof Name.Component)\n    component = component.getValue();\n\n  for (var i = 0; i < this.values.length; ++i) {\n    if (this.values[i] == Exclude.ANY) {\n      var lowerBound = null;\n      if (i > 0)\n        lowerBound = this.values[i - 1];\n\n      // Find the upper bound, possibly skipping over multiple ANY in a row.\n      var iUpperBound;\n      var upperBound = null;\n      for (iUpperBound = i + 1; iUpperBound < this.values.length; ++iUpperBound) {\n        if (this.values[iUpperBound] != Exclude.ANY) {\n          upperBound = this.values[iUpperBound];\n          break;\n        }\n      }\n\n      // If lowerBound != null, we already checked component equals lowerBound on the last pass.\n      // If upperBound != null, we will check component equals upperBound on the next pass.\n      if (upperBound != null) {\n        if (lowerBound != null) {\n          if (Exclude.compareComponents(component, lowerBound) > 0 &&\n              Exclude.compareComponents(component, upperBound) < 0)\n            return true;\n        }\n        else {\n          if (Exclude.compareComponents(component, upperBound) < 0)\n            return true;\n        }\n\n        // Make i equal iUpperBound on the next pass.\n        i = iUpperBound - 1;\n      }\n      else {\n        if (lowerBound != null) {\n            if (Exclude.compareComponents(component, lowerBound) > 0)\n              return true;\n        }\n        else\n          // this.values has only ANY.\n          return true;\n      }\n    }\n    else {\n      if (DataUtils.arraysEqual(component, this.values[i].getValue()))\n        return true;\n    }\n  }\n\n  return false;\n};\n\n/**\n * Return -1 if component1 is less than component2, 1 if greater or 0 if equal.\n * A component is less if it is shorter, otherwise if equal length do a byte comparison.\n */\nExclude.compareComponents = function(component1, component2)\n{\n  if (typeof component1 == \'object\' && component1 instanceof Name.Component)\n    component1 = component1.getValue();\n  if (typeof component2 == \'object\' && component2 instanceof Name.Component)\n    component2 = component2.getValue();\n\n  if (component1.length < component2.length)\n    return -1;\n  if (component1.length > component2.length)\n    return 1;\n\n  for (var i = 0; i < component1.length; ++i) {\n    if (component1[i] < component2[i])\n      return -1;\n    if (component1[i] > component2[i])\n      return 1;\n  }\n\n  return 0;\n};\n\n/**\n * @deprecated Use BinaryXmlWireFormat.decodeInterest.\n */\nInterest.prototype.from_ndnb = function(/*XMLDecoder*/ decoder)\n{\n  BinaryXmlWireFormat.decodeInterest(this, decoder);\n};\n\n/**\n * @deprecated Use BinaryXmlWireFormat.encodeInterest.\n */\nInterest.prototype.to_ndnb = function(/*XMLEncoder*/ encoder)\n{\n  BinaryXmlWireFormat.encodeInterest(this, encoder);\n};\n\n/**\n * Encode this Interest for a particular wire format.\n * @param {WireFormat} wireFormat if null, use BinaryXmlWireFormat.\n * @returns {Buffer}\n */\nInterest.prototype.encode = function(wireFormat)\n{\n  wireFormat = (wireFormat || BinaryXmlWireFormat.instance);\n  return wireFormat.encodeInterest(this);\n};\n\n/**\n * Decode the input using a particular wire format and update this Interest.\n * @param {Buffer} input\n * @param {WireFormat} wireFormat if null, use BinaryXmlWireFormat.\n */\nInterest.prototype.decode = function(input, wireFormat)\n{\n  wireFormat = (wireFormat || BinaryXmlWireFormat.instance);\n  wireFormat.decodeInterest(this, input);\n};\n\n/**\n * Encode the name according to the "NDN URI Scheme".  If there are interest selectors, append "?" and\n * added the selectors as a query string.  For example "/test/name?ndn.ChildSelector=1".\n * @returns {string} The URI string.\n */\nInterest.prototype.toUri = function()\n{\n  var selectors = "";\n\n  if (this.minSuffixComponents != null)\n    selectors += "&ndn.MinSuffixComponents=" + this.minSuffixComponents;\n  if (this.maxSuffixComponents != null)\n    selectors += "&ndn.MaxSuffixComponents=" + this.maxSuffixComponents;\n  if (this.childSelector != null)\n    selectors += "&ndn.ChildSelector=" + this.childSelector;\n  if (this.answerOriginKind != null)\n    selectors += "&ndn.AnswerOriginKind=" + this.answerOriginKind;\n  if (this.scope != null)\n    selectors += "&ndn.Scope=" + this.scope;\n  if (this.interestLifetime != null)\n    selectors += "&ndn.InterestLifetime=" + this.interestLifetime;\n  if (this.publisherPublicKeyDigest != null)\n    selectors += "&ndn.PublisherPublicKeyDigest=" + Name.toEscapedString(this.publisherPublicKeyDigest.publisherPublicKeyDigest);\n  if (this.nonce != null)\n    selectors += "&ndn.Nonce=" + Name.toEscapedString(this.nonce);\n  if (this.exclude != null)\n    selectors += "&ndn.Exclude=" + this.exclude.toUri();\n\n  var result = this.name.toUri();\n  if (selectors != "")\n    // Replace the first & with ?.\n    result += "?" + selectors.substr(1);\n\n  return result;\n};\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class represents Key Objects\n */\n\n/**\n * @constructor\n */\n/**\n * Key\n */\nvar Key = function Key()\n{\n  this.publicKeyDer = null;     // ndnbuf\n  this.publicKeyDigest = null;  // ndnbuf\n  this.publicKeyPem = null;     // String\n  this.privateKeyPem = null;    // String\n};\n\nexports.Key = Key;\n\n/**\n * Helper functions to read Key fields\n * TODO: generateRSA()\n */\n\nKey.prototype.publicToDER = function()\n{\n  return this.publicKeyDer;  // ndnbuf\n};\n\nKey.prototype.privateToDER = function()\n{\n  // Remove the \'-----XXX-----\' from the beginning and the end of the key\n  // and also remove any \\n in the key string\n  var lines = this.privateKeyPem.split(\'\\n\');\n  priKey = "";\n  for (var i = 1; i < lines.length - 1; i++)\n    priKey += lines[i];\n\n  return new ndnbuf(priKey, \'base64\');\n};\n\nKey.prototype.publicToPEM = function()\n{\n  return this.publicKeyPem;\n};\n\nKey.prototype.privateToPEM = function()\n{\n  return this.privateKeyPem;\n};\n\nKey.prototype.getKeyID = function()\n{\n  return this.publicKeyDigest;\n};\n\nexports.Key = Key;\n\nKey.prototype.readDerPublicKey = function(/*Buffer*/pub_der)\n{\n  if (LOG > 4) console.log("Encode DER public key:\\n" + pub_der.toString(\'hex\'));\n\n  this.publicKeyDer = pub_der;\n\n  var hash = ndn.createHash(\'sha256\');\n  hash.update(this.publicKeyDer);\n  this.publicKeyDigest = new ndnbuf(hash.digest());\n\n  var keyStr = pub_der.toString(\'base64\');\n  var keyPem = "-----BEGIN PUBLIC KEY-----\\n";\n  for (var i = 0; i < keyStr.length; i += 64)\n  keyPem += (keyStr.substr(i, 64) + "\\n");\n  keyPem += "-----END PUBLIC KEY-----";\n  this.publicKeyPem = keyPem;\n\n  if (LOG > 4) console.log("Convert public key to PEM format:\\n" + this.publicKeyPem);\n};\n\n/**\n * Load RSA key pair from PEM-encoded strings.\n * Will throw an Error if both \'pub\' and \'pri\' are null.\n */\nKey.prototype.fromPemString = function(pub, pri)\n{\n  if (pub == null && pri == null)\n    throw new Error(\'Cannot create Key object if both public and private PEM string is empty.\');\n\n  // Read public key\n  if (pub != null) {\n    this.publicKeyPem = pub;\n    if (LOG > 4) console.log("Key.publicKeyPem: \\n" + this.publicKeyPem);\n\n    // Remove the \'-----XXX-----\' from the beginning and the end of the public key\n    // and also remove any \\n in the public key string\n    var lines = pub.split(\'\\n\');\n    pub = "";\n    for (var i = 1; i < lines.length - 1; i++)\n      pub += lines[i];\n    this.publicKeyDer = new ndnbuf(pub, \'base64\');\n    if (LOG > 4) console.log("Key.publicKeyDer: \\n" + this.publicKeyDer.toString(\'hex\'));\n\n    var hash = ndn.createHash(\'sha256\');\n    hash.update(this.publicKeyDer);\n    this.publicKeyDigest = new ndnbuf(hash.digest());\n    if (LOG > 4) console.log("Key.publicKeyDigest: \\n" + this.publicKeyDigest.toString(\'hex\'));\n  }\n\n  // Read private key\n  if (pri != null) {\n    this.privateKeyPem = pri;\n    if (LOG > 4) console.log("Key.privateKeyPem: \\n" + this.privateKeyPem);\n  }\n};\n\nKey.prototype.fromPem = Key.prototype.fromPemString;\n\n/**\n * Static method that create a Key object.\n * Parameter \'obj\' is a JSON object that has two properties:\n *   pub: the PEM string for the public key\n *   pri: the PEM string for the private key\n * Will throw an Error if both obj.pub and obj.pri are null.\n */\nKey.createFromPEM = function(obj)\n{\n    var key = new Key();\n    key.fromPemString(obj.pub, obj.pri);\n    return key;\n};\n\n/**\n * KeyLocator\n */\nvar KeyLocatorType = {\n  KEY:1,\n  CERTIFICATE:2,\n  KEYNAME:3\n};\n\nexports.KeyLocatorType = KeyLocatorType;\n\n/**\n * @constructor\n */\nvar KeyLocator = function KeyLocator(input,type)\n{\n  this.type = type;\n\n  if (type == KeyLocatorType.KEYNAME) {\n    if (LOG > 3) console.log(\'KeyLocator: SET KEYNAME\');\n    this.keyName = input;\n  }\n  else if (type == KeyLocatorType.KEY) {\n    if (LOG > 3) console.log(\'KeyLocator: SET KEY\');\n    this.publicKey = input;\n  }\n  else if (type == KeyLocatorType.CERTIFICATE) {\n    if (LOG > 3) console.log(\'KeyLocator: SET CERTIFICATE\');\n    this.certificate = input;\n  }\n};\n\nexports.KeyLocator = KeyLocator;\n\nKeyLocator.prototype.from_ndnb = function(decoder) {\n\n  decoder.readElementStartDTag(this.getElementLabel());\n\n  if (decoder.peekDTag(NDNProtocolDTags.Key))\n  {\n    try {\n      var encodedKey = decoder.readBinaryDTagElement(NDNProtocolDTags.Key);\n      // This is a DER-encoded SubjectPublicKeyInfo.\n\n      //TODO FIX THIS, This should create a Key Object instead of keeping bytes\n\n      this.publicKey =   encodedKey;//CryptoUtil.getPublicKey(encodedKey);\n      this.type = KeyLocatorType.KEY;\n\n      if (LOG > 4) console.log(\'PUBLIC KEY FOUND: \'+ this.publicKey);\n    }\n    catch (e) {\n      throw new Error("Cannot parse key: ", e);\n    }\n\n    if (null == this.publicKey)\n      throw new Error("Cannot parse key: ");\n  }\n  else if (decoder.peekDTag(NDNProtocolDTags.Certificate)) {\n    try {\n      var encodedCert = decoder.readBinaryDTagElement(NDNProtocolDTags.Certificate);\n\n      /*\n       * Certificates not yet working\n       */\n\n      this.certificate = encodedCert;\n      this.type = KeyLocatorType.CERTIFICATE;\n\n      if (LOG > 4) console.log(\'CERTIFICATE FOUND: \'+ this.certificate);\n    }\n    catch (e) {\n      throw new Error("Cannot decode certificate: " +  e);\n    }\n    if (null == this.certificate)\n      throw new Error("Cannot parse certificate! ");\n  } else  {\n    this.type = KeyLocatorType.KEYNAME;\n\n    this.keyName = new KeyName();\n    this.keyName.from_ndnb(decoder);\n  }\n  decoder.readElementClose();\n};\n\nKeyLocator.prototype.to_ndnb = function(encoder)\n{\n  if (LOG > 4) console.log(\'type is is \' + this.type);\n  //TODO Check if Name is missing\n  if (!this.validate())\n    throw new Error("Cannot encode " + this.getClass().getName() + ": field values missing.");\n\n  //TODO FIX THIS TOO\n  encoder.writeElementStartDTag(this.getElementLabel());\n\n  if (this.type == KeyLocatorType.KEY) {\n    if (LOG > 5) console.log(\'About to encode a public key\' +this.publicKey);\n    encoder.writeDTagElement(NDNProtocolDTags.Key, this.publicKey);\n  }\n  else if (this.type == KeyLocatorType.CERTIFICATE) {\n    try {\n      encoder.writeDTagElement(NDNProtocolDTags.Certificate, this.certificate);\n    }\n    catch (e) {\n      throw new Error("CertificateEncodingException attempting to write key locator: " + e);\n    }\n  }\n  else if (this.type == KeyLocatorType.KEYNAME)\n    this.keyName.to_ndnb(encoder);\n\n  encoder.writeElementClose();\n};\n\nKeyLocator.prototype.getElementLabel = function()\n{\n  return NDNProtocolDTags.KeyLocator;\n};\n\nKeyLocator.prototype.validate = function()\n{\n  return null != this.keyName || null != this.publicKey || null != this.certificate;\n};\n\n/**\n * KeyName is only used by KeyLocator.\n * @constructor\n */\nvar KeyName = function KeyName()\n{\n  this.contentName = this.contentName;  //contentName\n  this.publisherID = this.publisherID;  //publisherID\n};\n\nexports.KeyName = KeyName;\n\nKeyName.prototype.from_ndnb = function(decoder)\n{\n  decoder.readElementStartDTag(this.getElementLabel());\n\n  this.contentName = new Name();\n  this.contentName.from_ndnb(decoder);\n\n  if (LOG > 4) console.log(\'KEY NAME FOUND: \');\n\n  if (PublisherID.peek(decoder)) {\n    this.publisherID = new PublisherID();\n    this.publisherID.from_ndnb(decoder);\n  }\n\n  decoder.readElementClose();\n};\n\nKeyName.prototype.to_ndnb = function(encoder)\n{\n  if (!this.validate())\n    throw new Error("Cannot encode : field values missing.");\n\n  encoder.writeElementStartDTag(this.getElementLabel());\n\n  this.contentName.to_ndnb(encoder);\n  if (null != this.publisherID)\n    this.publisherID.to_ndnb(encoder);\n\n  encoder.writeElementClose();\n};\n\nKeyName.prototype.getElementLabel = function() { return NDNProtocolDTags.KeyName; };\n\nKeyName.prototype.validate = function()\n{\n    // DKS -- do we do recursive validation?\n    // null signedInfo ok\n    return (null != this.contentName);\n};\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class represents Face Instances\n */\n\n\n/**\n * @constructor\n */\nvar FaceInstance  = function FaceInstance(action, publisherPublicKeyDigest, faceID, ipProto, host, port, multicastInterface,\n    multicastTTL, freshnessSeconds)\n{\n  this.action = action;\n  this.publisherPublicKeyDigest = publisherPublicKeyDigest;\n  this.faceID = faceID;\n  this.ipProto = ipProto;\n  this.host = host;\n  this.Port = port;\n  this.multicastInterface =multicastInterface;\n  this.multicastTTL =multicastTTL;\n  this.freshnessSeconds = freshnessSeconds;\n};\n\nexports.FaceInstance = FaceInstance;\n\nFaceInstance.NetworkProtocol = { TCP:6, UDP:17};\n\n/**\n * Used by NetworkObject to decode the object from a network stream.\n */\nFaceInstance.prototype.from_ndnb = function(\n  //XMLDecoder\n  decoder)\n{\n  decoder.readElementStartDTag(this.getElementLabel());\n\n  if (decoder.peekDTag(NDNProtocolDTags.Action))\n    this.action = decoder.readUTF8DTagElement(NDNProtocolDTags.Action);\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherPublicKeyDigest)) {\n    this.publisherPublicKeyDigest = new PublisherPublicKeyDigest();\n    this.publisherPublicKeyDigest.from_ndnb(decoder);\n  }\n  if (decoder.peekDTag(NDNProtocolDTags.FaceID))\n    this.faceID = decoder.readIntegerDTagElement(NDNProtocolDTags.FaceID);\n  if (decoder.peekDTag(NDNProtocolDTags.IPProto)) {\n    //int\n    var pI = decoder.readIntegerDTagElement(NDNProtocolDTags.IPProto);\n\n    this.ipProto = null;\n\n    if (FaceInstance.NetworkProtocol.TCP == pI)\n      this.ipProto = FaceInstance.NetworkProtocol.TCP;\n    else if (FaceInstance.NetworkProtocol.UDP == pI)\n      this.ipProto = FaceInstance.NetworkProtocol.UDP;\n    else\n      throw new Error("FaceInstance.decoder.  Invalid NDNProtocolDTags.IPProto field: " + pI);\n  }\n\n  if (decoder.peekDTag(NDNProtocolDTags.Host))\n    this.host = decoder.readUTF8DTagElement(NDNProtocolDTags.Host);\n  if (decoder.peekDTag(NDNProtocolDTags.Port))\n    this.Port = decoder.readIntegerDTagElement(NDNProtocolDTags.Port);\n  if (decoder.peekDTag(NDNProtocolDTags.MulticastInterface))\n    this.multicastInterface = decoder.readUTF8DTagElement(NDNProtocolDTags.MulticastInterface);\n  if (decoder.peekDTag(NDNProtocolDTags.MulticastTTL))\n    this.multicastTTL = decoder.readIntegerDTagElement(NDNProtocolDTags.MulticastTTL);\n  if (decoder.peekDTag(NDNProtocolDTags.FreshnessSeconds))\n    this.freshnessSeconds = decoder.readIntegerDTagElement(NDNProtocolDTags.FreshnessSeconds);\n\n  decoder.readElementClose();\n};\n\n/**\n * Used by NetworkObject to encode the object to a network stream.\n */\nFaceInstance.prototype.to_ndnb = function(\n  //XMLEncoder\n  encoder)\n{\n  encoder.writeElementStartDTag(this.getElementLabel());\n\n  if (null != this.action && this.action.length != 0)\n    encoder.writeDTagElement(NDNProtocolDTags.Action, this.action);\n  if (null != this.publisherPublicKeyDigest)\n    this.publisherPublicKeyDigest.to_ndnb(encoder);\n  if (null != this.faceID)\n    encoder.writeDTagElement(NDNProtocolDTags.FaceID, this.faceID);\n  if (null != this.ipProto)\n    encoder.writeDTagElement(NDNProtocolDTags.IPProto, this.ipProto);\n  if (null != this.host && this.host.length != 0)\n    encoder.writeDTagElement(NDNProtocolDTags.Host, this.host);\n  if (null != this.Port)\n    encoder.writeDTagElement(NDNProtocolDTags.Port, this.Port);\n  if (null != this.multicastInterface && this.multicastInterface.length != 0)\n    encoder.writeDTagElement(NDNProtocolDTags.MulticastInterface, this.multicastInterface);\n  if (null !=  this.multicastTTL)\n    encoder.writeDTagElement(NDNProtocolDTags.MulticastTTL, this.multicastTTL);\n  if (null != this.freshnessSeconds)\n    encoder.writeDTagElement(NDNProtocolDTags.FreshnessSeconds, this.freshnessSeconds);\n\n  encoder.writeElementClose();\n};\n\nFaceInstance.prototype.getElementLabel = function()\n{\n  return NDNProtocolDTags.FaceInstance;\n};\n\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class represents Forwarding Entries\n */\n\n\n/**\n * Create a new ForwardingEntry with the optional arguments.\n * @constructor\n * @param {String} action\n * @param {Name} prefixName\n * @param {PublisherPublicKeyDigest} ndndId\n * @param {number} faceID\n * @param {number} flags\n * @param {number} lifetime in seconds\n */\nvar ForwardingEntry = function ForwardingEntry(action, prefixName, ndndId, faceID, flags, lifetime)\n{\n  this.action = action;\n  this.prefixName = prefixName;\n  this.ndndID = ndndId;\n  this.faceID = faceID;\n  this.flags = flags;\n  this.lifetime = lifetime;\n};\n\nexports.ForwardingEntry = ForwardingEntry;\n\nForwardingEntry.ACTIVE         = 1;\nForwardingEntry.CHILD_INHERIT  = 2;\nForwardingEntry.ADVERTISE      = 4;\nForwardingEntry.LAST           = 8;\nForwardingEntry.CAPTURE       = 16;\nForwardingEntry.LOCAL         = 32;\nForwardingEntry.TAP           = 64;\nForwardingEntry.CAPTURE_OK   = 128;\n\nForwardingEntry.prototype.from_ndnb = function(\n  //XMLDecoder\n  decoder)\n  //throws ContentDecodingException\n{\n  decoder.readElementStartDTag(this.getElementLabel());\n  if (decoder.peekDTag(NDNProtocolDTags.Action))\n    this.action = decoder.readUTF8DTagElement(NDNProtocolDTags.Action);\n  if (decoder.peekDTag(NDNProtocolDTags.Name)) {\n    this.prefixName = new Name();\n    this.prefixName.from_ndnb(decoder) ;\n  }\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherPublicKeyDigest)) {\n    this.NdndId = new PublisherPublicKeyDigest();\n    this.NdndId.from_ndnb(decoder);\n  }\n  if (decoder.peekDTag(NDNProtocolDTags.FaceID))\n    this.faceID = decoder.readIntegerDTagElement(NDNProtocolDTags.FaceID);\n  if (decoder.peekDTag(NDNProtocolDTags.ForwardingFlags))\n    this.flags = decoder.readIntegerDTagElement(NDNProtocolDTags.ForwardingFlags);\n  if (decoder.peekDTag(NDNProtocolDTags.FreshnessSeconds))\n    this.lifetime = decoder.readIntegerDTagElement(NDNProtocolDTags.FreshnessSeconds);\n\n  decoder.readElementClose();\n};\n\nForwardingEntry.prototype.to_ndnb = function(\n  //XMLEncoder\n  encoder)\n{\n  encoder.writeElementStartDTag(this.getElementLabel());\n  if (null != this.action && this.action.length != 0)\n    encoder.writeDTagElement(NDNProtocolDTags.Action, this.action);\n  if (null != this.prefixName)\n    this.prefixName.to_ndnb(encoder);\n  if (null != this.NdndId)\n    this.NdndId.to_ndnb(encoder);\n  if (null != this.faceID)\n    encoder.writeDTagElement(NDNProtocolDTags.FaceID, this.faceID);\n  if (null != this.flags)\n    encoder.writeDTagElement(NDNProtocolDTags.ForwardingFlags, this.flags);\n  if (null != this.lifetime)\n    encoder.writeDTagElement(NDNProtocolDTags.FreshnessSeconds, this.lifetime);\n\n  encoder.writeElementClose();\n};\n\nForwardingEntry.prototype.getElementLabel = function() { return NDNProtocolDTags.ForwardingEntry; }\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\n\n/**\n * A ForwardingFlags object holds the flags which specify how the forwarding daemon should forward an interest for\n * a registered prefix.  We use a separate ForwardingFlags object to retain future compatibility if the daemon forwarding\n * bits are changed, amended or deprecated.\n * Create a new ForwardingFlags with "active" and "childInherit" set and all other flags cleared.\n */\nvar ForwardingFlags = function ForwardingFlags()\n{\n  this.active = true;\n  this.childInherit = true;\n  this.advertise = false;\n  this.last = false;\n  this.capture = false;\n  this.local = false;\n  this.tap = false;\n  this.captureOk = false;\n}\n\nexports.ForwardingFlags = ForwardingFlags;\n\n/**\n * Get an integer with the bits set according to the flags as used by the ForwardingEntry message.\n * @returns {number} An integer with the bits set.\n */\nForwardingFlags.prototype.getForwardingEntryFlags = function()\n{\n  var result = 0;\n\n  if (this.active)\n    result |= ForwardingEntry.ACTIVE;\n  if (this.childInherit)\n    result |= ForwardingEntry.CHILD_INHERIT;\n  if (this.advertise)\n    result |= ForwardingEntry.ADVERTISE;\n  if (this.last)\n    result |= ForwardingEntry.LAST;\n  if (this.capture)\n    result |= ForwardingEntry.CAPTURE;\n  if (this.local)\n    result |= ForwardingEntry.LOCAL;\n  if (this.tap)\n    result |= ForwardingEntry.TAP;\n  if (this.captureOk)\n    result |= ForwardingEntry.CAPTURE_OK;\n\n  return result;\n};\n\n/**\n * Set the flags according to the bits in forwardingEntryFlags as used by the ForwardingEntry message.\n * @param {number} forwardingEntryFlags An integer with the bits set.\n */\nForwardingFlags.prototype.setForwardingEntryFlags = function(forwardingEntryFlags)\n{\n  this.active = ((forwardingEntryFlags & ForwardingEntry.ACTIVE) != 0);\n  this.childInherit = ((forwardingEntryFlags & ForwardingEntry.CHILD_INHERIT) != 0);\n  this.advertise = ((forwardingEntryFlags & ForwardingEntry.ADVERTISE) != 0);\n  this.last = ((forwardingEntryFlags & ForwardingEntry.LAST) != 0);\n  this.capture = ((forwardingEntryFlags & ForwardingEntry.CAPTURE) != 0);\n  this.local = ((forwardingEntryFlags & ForwardingEntry.LOCAL) != 0);\n  this.tap = ((forwardingEntryFlags & ForwardingEntry.TAP) != 0);\n  this.captureOk = ((forwardingEntryFlags & ForwardingEntry.CAPTURE_OK) != 0);\n};\n\n/**\n * Get the value of the "active" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getActive = function() { return this.active; };\n\n/**\n * Get the value of the "childInherit" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getChildInherit = function() { return this.childInherit; };\n\n/**\n * Get the value of the "advertise" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getAdvertise = function() { return this.advertise; };\n\n/**\n * Get the value of the "last" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getLast = function() { return this.last; };\n\n/**\n * Get the value of the "capture" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getCapture = function() { return this.capture; };\n\n/**\n * Get the value of the "local" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getLocal = function() { return this.local; };\n\n/**\n * Get the value of the "tap" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getTap = function() { return this.tap; };\n\n/**\n * Get the value of the "captureOk" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getCaptureOk = function() { return this.captureOk; };\n\n/**\n * Set the value of the "active" flag\n * @param {number} value true to set the flag, false to clear it.\n */\nForwardingFlags.prototype.setActive = function(value) { this.active = value; };\n\n/**\n * Set the value of the "childInherit" flag\n * @param {number} value true to set the flag, false to clear it.\n */\nForwardingFlags.prototype.setChildInherit = function(value) { this.childInherit = value; };\n\n/**\n * Set the value of the "advertise" flag\n * @param {number} value true to set the flag, false to clear it.\n */\nForwardingFlags.prototype.setAdvertise = function(value) { this.advertise = value; };\n\n/**\n * Set the value of the "last" flag\n * @param {number} value true to set the flag, false to clear it.\n */\nForwardingFlags.prototype.setLast = function(value) { this.last = value; };\n\n/**\n * Set the value of the "capture" flag\n * @param {number} value true to set the flag, false to clear it.\n */\nForwardingFlags.prototype.setCapture = function(value) { this.capture = value; };\n\n/**\n * Set the value of the "local" flag\n * @param {number} value true to set the flag, false to clear it.\n */\nForwardingFlags.prototype.setLocal = function(value) { this.local = value; };\n\n/**\n * Set the value of the "tap" flag\n * @param {number} value true to set the flag, false to clear it.\n */\nForwardingFlags.prototype.setTap = function(value) { this.tap = value; };\n\n/**\n * Set the value of the "captureOk" flag\n * @param {number} value true to set the flag, false to clear it.\n */\nForwardingFlags.prototype.setCaptureOk = function(value) { this.captureOk = value; };\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\n/**\n * A BinaryXmlWireFormat implements the WireFormat interface for encoding and decoding in binary XML.\n * @constructor\n */\nvar BinaryXmlWireFormat = function BinaryXmlWireFormat()\n{\n  // Inherit from WireFormat.\n  WireFormat.call(this);\n};\n\nexports.BinaryXmlWireFormat = BinaryXmlWireFormat;\n\n// Default object.\nBinaryXmlWireFormat.instance = new BinaryXmlWireFormat();\n\n/**\n * Encode the interest and return a ndnbuf.\n * @param {Interest} interest\n * @returns {Buffer}\n */\nBinaryXmlWireFormat.prototype.encodeInterest = function(interest)\n{\n  var encoder = new BinaryXMLEncoder();\n  BinaryXmlWireFormat.encodeInterest(interest, encoder);\n  return encoder.getReducedOstream();\n};\n\n/**\n * Decode the input and put the result in interest.\n * @param {Interest} interest\n * @param {Buffer} input\n */\nBinaryXmlWireFormat.prototype.decodeInterest = function(interest, input)\n{\n  var decoder = new BinaryXMLDecoder(input);\n  BinaryXmlWireFormat.decodeInterest(interest, decoder);\n};\n\n/**\n * Encode the data and return a ndnbuf.\n * @param {Data} data\n * @returns {Buffer}\n */\nBinaryXmlWireFormat.prototype.encodeData = function(data)\n{\n  var encoder = new BinaryXMLEncoder(1500);\n  BinaryXmlWireFormat.encodeData(data, encoder);\n  return encoder.getReducedOstream();\n};\n\n/**\n * @deprecated Use encodeData(data).\n */\nBinaryXmlWireFormat.prototype.encodeContentObject = function(data)\n{\n  return this.encodeData(data);\n}\n\n/**\n * Decode the input and put the result in data.\n * @param {Data} data\n * @param {Buffer} input\n */\nBinaryXmlWireFormat.prototype.decodeData = function(data, input)\n{\n  var decoder = new BinaryXMLDecoder(input);\n  BinaryXmlWireFormat.decodeData(data, decoder);\n};\n\n/**\n * @deprecated Use decodeData(data, input).\n */\nBinaryXmlWireFormat.prototype.decodeContentObject = function(data, input)\n{\n  this.decodeData(data, input);\n}\n\n/**\n * Encode the interest by calling the operations on the encoder.\n * @param {Interest} interest\n * @param {BinaryXMLEncoder} encoder\n */\nBinaryXmlWireFormat.encodeInterest = function(interest, encoder)\n{\n  encoder.writeElementStartDTag(NDNProtocolDTags.Interest);\n\n  interest.name.to_ndnb(encoder);\n\n  if (null != interest.minSuffixComponents)\n    encoder.writeDTagElement(NDNProtocolDTags.MinSuffixComponents, interest.minSuffixComponents);\n\n  if (null != interest.maxSuffixComponents)\n    encoder.writeDTagElement(NDNProtocolDTags.MaxSuffixComponents, interest.maxSuffixComponents);\n\n  if (null != interest.publisherPublicKeyDigest)\n    interest.publisherPublicKeyDigest.to_ndnb(encoder);\n\n  if (null != interest.exclude)\n    interest.exclude.to_ndnb(encoder);\n\n  if (null != interest.childSelector)\n    encoder.writeDTagElement(NDNProtocolDTags.ChildSelector, interest.childSelector);\n\n  if (interest.DEFAULT_ANSWER_ORIGIN_KIND != interest.answerOriginKind && interest.answerOriginKind!=null)\n    encoder.writeDTagElement(NDNProtocolDTags.AnswerOriginKind, interest.answerOriginKind);\n\n  if (null != interest.scope)\n    encoder.writeDTagElement(NDNProtocolDTags.Scope, interest.scope);\n\n  if (null != interest.interestLifetime)\n    encoder.writeDTagElement(NDNProtocolDTags.InterestLifetime,\n                DataUtils.nonNegativeIntToBigEndian((interest.interestLifetime / 1000.0) * 4096));\n\n  if (null != interest.nonce)\n    encoder.writeDTagElement(NDNProtocolDTags.Nonce, interest.nonce);\n\n  encoder.writeElementClose();\n};\n\n\n/**\n * Use the decoder to place the result in interest.\n * @param {Interest} interest\n * @param {BinaryXMLDecoder} decoder\n */\nBinaryXmlWireFormat.decodeInterest = function(interest, decoder)\n{\n  decoder.readElementStartDTag(NDNProtocolDTags.Interest);\n\n  interest.name = new Name();\n  interest.name.from_ndnb(decoder);\n\n  if (decoder.peekDTag(NDNProtocolDTags.MinSuffixComponents))\n    interest.minSuffixComponents = decoder.readIntegerDTagElement(NDNProtocolDTags.MinSuffixComponents);\n  else\n    interest.minSuffixComponents = null;\n\n  if (decoder.peekDTag(NDNProtocolDTags.MaxSuffixComponents))\n    interest.maxSuffixComponents = decoder.readIntegerDTagElement(NDNProtocolDTags.MaxSuffixComponents);\n  else\n    interest.maxSuffixComponents = null;\n\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherPublicKeyDigest)) {\n    interest.publisherPublicKeyDigest = new PublisherPublicKeyDigest();\n    interest.publisherPublicKeyDigest.from_ndnb(decoder);\n  }\n  else\n    interest.publisherPublicKeyDigest = null;\n\n  if (decoder.peekDTag(NDNProtocolDTags.Exclude)) {\n    interest.exclude = new Exclude();\n    interest.exclude.from_ndnb(decoder);\n  }\n  else\n    interest.exclude = null;\n\n  if (decoder.peekDTag(NDNProtocolDTags.ChildSelector))\n    interest.childSelector = decoder.readIntegerDTagElement(NDNProtocolDTags.ChildSelector);\n  else\n    interest.childSelector = null;\n\n  if (decoder.peekDTag(NDNProtocolDTags.AnswerOriginKind))\n    interest.answerOriginKind = decoder.readIntegerDTagElement(NDNProtocolDTags.AnswerOriginKind);\n  else\n    interest.answerOriginKind = null;\n\n  if (decoder.peekDTag(NDNProtocolDTags.Scope))\n    interest.scope = decoder.readIntegerDTagElement(NDNProtocolDTags.Scope);\n  else\n    interest.scope = null;\n\n  if (decoder.peekDTag(NDNProtocolDTags.InterestLifetime))\n    interest.interestLifetime = 1000.0 * DataUtils.bigEndianToUnsignedInt\n               (decoder.readBinaryDTagElement(NDNProtocolDTags.InterestLifetime)) / 4096;\n  else\n    interest.interestLifetime = null;\n\n  if (decoder.peekDTag(NDNProtocolDTags.Nonce))\n    interest.nonce = decoder.readBinaryDTagElement(NDNProtocolDTags.Nonce);\n  else\n    interest.nonce = null;\n\n  decoder.readElementClose();\n};\n\n/**\n * Encode the data by calling the operations on the encoder.\n * @param {Data} data\n * @param {BinaryXMLEncoder} encoder\n */\nBinaryXmlWireFormat.encodeData = function(data, encoder)\n{\n  //TODO verify name, SignedInfo and Signature is present\n  encoder.writeElementStartDTag(data.getElementLabel());\n\n  if (null != data.signature)\n    data.signature.to_ndnb(encoder);\n\n  data.startSIG = encoder.offset;\n\n  if (null != data.name)\n    data.name.to_ndnb(encoder);\n\n  if (null != data.signedInfo)\n    data.signedInfo.to_ndnb(encoder);\n\n  encoder.writeDTagElement(NDNProtocolDTags.Content, data.content);\n\n  data.endSIG = encoder.offset;\n\n  encoder.writeElementClose();\n\n  data.saveRawData(encoder.ostream);\n};\n\n/**\n * Use the decoder to place the result in data.\n * @param {Data} data\n * @param {BinaryXMLDecoder} decoder\n */\nBinaryXmlWireFormat.decodeData = function(data, decoder)\n{\n  // TODO VALIDATE THAT ALL FIELDS EXCEPT SIGNATURE ARE PRESENT\n  decoder.readElementStartDTag(data.getElementLabel());\n\n  if (decoder.peekDTag(NDNProtocolDTags.Signature)) {\n    data.signature = new Signature();\n    data.signature.from_ndnb(decoder);\n  }\n  else\n    data.signature = null;\n\n  data.startSIG = decoder.offset;\n\n  data.name = new Name();\n  data.name.from_ndnb(decoder);\n\n  if (decoder.peekDTag(NDNProtocolDTags.SignedInfo)) {\n    data.signedInfo = new SignedInfo();\n    data.signedInfo.from_ndnb(decoder);\n  }\n  else\n    data.signedInfo = null;\n\n  data.content = decoder.readBinaryDTagElement(NDNProtocolDTags.Content, true);\n\n  data.endSIG = decoder.offset;\n\n  decoder.readElementClose();\n\n  data.saveRawData(decoder.input);\n};\n/**\n * This file contains utilities to help encode and decode NDN objects.\n * Copyright (C) 2013 Regents of the University of California.\n * author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n */\n\n/**\n * An EncodingUtils has static methods for encoding data.\n * @constructor\n */\nvar EncodingUtils = function EncodingUtils()\n{\n};\n\nexports.EncodingUtils = EncodingUtils;\n\nEncodingUtils.encodeToHexInterest = function(interest)\n{\n  return DataUtils.toHex(interest.encode());\n};\n\nEncodingUtils.encodeToHexData = function(data)\n{\n  return DataUtils.toHex(data.encode());\n};\n\n/**\n * @deprecated Use EncodingUtils.encodeToHexData(data).\n */\nEncodingUtils.encodeToHexContentObject = function(data)\n{\n  return EncodingUtils.encodeToHexData(data);\n}\n\nEncodingUtils.encodeForwardingEntry = function(data)\n{\n  var enc = new BinaryXMLEncoder();\n  data.to_ndnb(enc);\n  var bytes = enc.getReducedOstream();\n\n  return bytes;\n};\n\nEncodingUtils.decodeHexFaceInstance = function(result)\n{\n  var numbers = DataUtils.toNumbers(result);\n  var decoder = new BinaryXMLDecoder(numbers);\n\n  if (LOG > 3) console.log(\'DECODING HEX FACE INSTANCE  \\n\'+numbers);\n\n  var faceInstance = new FaceInstance();\n  faceInstance.from_ndnb(decoder);\n\n  return faceInstance;\n};\n\nEncodingUtils.decodeHexInterest = function(input)\n{\n  var interest = new Interest();\n  interest.decode(DataUtils.toNumbers(input));\n  return interest;\n};\n\nEncodingUtils.decodeHexData = function(input)\n{\n  var data = new Data();\n  data.decode(DataUtils.toNumbers(input));\n  return data;\n};\n\n/**\n * @deprecated Use EncodingUtils.decodeHexData(input).\n */\nEncodingUtils.decodeHexContentObject = function(input)\n{\n  return EncodingUtils.decodeHexData(input);\n}\n\nEncodingUtils.decodeHexForwardingEntry = function(result)\n{\n  var numbers = DataUtils.toNumbers(result);\n  var decoder = new BinaryXMLDecoder(numbers);\n\n  if (LOG > 3) console.log(\'DECODED HEX FORWARDING ENTRY \\n\'+numbers);\n\n  var forwardingEntry = new ForwardingEntry();\n  forwardingEntry.from_ndnb(decoder);\n  return forwardingEntry;\n};\n\n/**\n * Decode the ndnbuf array which holds SubjectPublicKeyInfo and return an RSAKey.\n */\nEncodingUtils.decodeSubjectPublicKeyInfo = function(array)\n{\n  var hex = DataUtils.toHex(array).toLowerCase();\n  var a = _x509_getPublicKeyHexArrayFromCertHex(hex, _x509_getSubjectPublicKeyPosFromCertHex(hex, 0));\n  var rsaKey = new RSAKey();\n  rsaKey.setPublic(a[0], a[1]);\n  return rsaKey;\n}\n\n/**\n * Return a user friendly HTML string with the contents of data.\n * This also outputs to console.log.\n */\nEncodingUtils.dataToHtml = function(/* Data */ data)\n{\n  var output ="";\n\n  if (data == -1)\n    output+= "NO CONTENT FOUND"\n  else if (data == -2)\n    output+= "CONTENT NAME IS EMPTY"\n  else {\n    if (data.name != null && data.name.components != null) {\n      output+= "NAME: " + data.name.toUri();\n\n      output+= "<br />";\n      output+= "<br />";\n    }\n    if (data.content != null) {\n      output += "CONTENT(ASCII): "+ DataUtils.toString(data.content);\n\n      output+= "<br />";\n      output+= "<br />";\n    }\n    if (data.content != null) {\n      output += "CONTENT(hex): "+ DataUtils.toHex(data.content);\n\n      output+= "<br />";\n      output+= "<br />";\n    }\n    if (data.signature != null && data.signature.digestAlgorithm != null) {\n      output += "DigestAlgorithm (hex): "+ DataUtils.toHex(data.signature.digestAlgorithm);\n\n      output+= "<br />";\n      output+= "<br />";\n    }\n    if (data.signature != null && data.signature.witness != null) {\n      output += "Witness (hex): "+ DataUtils.toHex(data.signature.witness);\n\n      output+= "<br />";\n      output+= "<br />";\n    }\n    if (data.signature != null && data.signature.signature != null) {\n      output += "Signature(hex): "+ DataUtils.toHex(data.signature.signature);\n\n      output+= "<br />";\n      output+= "<br />";\n    }\n    if (data.signedInfo != null && data.signedInfo.publisher != null && data.signedInfo.publisher.publisherPublicKeyDigest != null) {\n      output += "Publisher Public Key Digest(hex): "+ DataUtils.toHex(data.signedInfo.publisher.publisherPublicKeyDigest);\n\n      output+= "<br />";\n      output+= "<br />";\n    }\n    if (data.signedInfo != null && data.signedInfo.timestamp != null) {\n      var d = new Date();\n      d.setTime(data.signedInfo.timestamp.msec);\n\n      var bytes = [217, 185, 12, 225, 217, 185, 12, 225];\n\n      output += "TimeStamp: "+d;\n      output+= "<br />";\n      output += "TimeStamp(number): "+ data.signedInfo.timestamp.msec;\n\n      output+= "<br />";\n    }\n    if (data.signedInfo != null && data.signedInfo.finalBlockID != null) {\n      output += "FinalBlockID: "+ DataUtils.toHex(data.signedInfo.finalBlockID);\n      output+= "<br />";\n    }\n    if (data.signedInfo != null && data.signedInfo.locator != null && data.signedInfo.locator.type) {\n      output += "keyLocator: ";\n      if (data.signedInfo.locator.type == KeyLocatorType.KEY)\n        output += "Key: " + DataUtils.toHex(data.signedInfo.locator.publicKey).toLowerCase() + "<br />";\n      else if (data.signedInfo.locator.type == KeyLocatorType.CERTIFICATE)\n        output += "Certificate: " + DataUtils.toHex(data.signedInfo.locator.certificate).toLowerCase() + "<br />";\n      else if (data.signedInfo.locator.type == KeyLocatorType.KEYNAME)\n        output += "KeyName: " + data.signedInfo.locator.keyName.contentName.to_uri() + "<br />";\n      else\n        output += "[unrecognized ndn_KeyLocatorType " + data.signedInfo.locator.type + "]<br />";\n    }\n    if (data.signedInfo!= null && data.signedInfo.locator!= null && data.signedInfo.locator.publicKey!= null) {\n      var publickeyHex = DataUtils.toHex(data.signedInfo.locator.publicKey).toLowerCase();\n      var publickeyString = DataUtils.toString(data.signedInfo.locator.publicKey);\n      var signature = DataUtils.toHex(data.signature.signature).toLowerCase();\n      var input = DataUtils.toString(data.rawSignatureData);\n\n      var witHex = "";\n      if (data.signature.witness != null)\n        witHex = DataUtils.toHex(data.signature.witness);\n\n      // Already showed data.signedInfo.locator.publicKey above.\n      output+= "<br />";\n\n      if (LOG > 2) console.log(" ContentName + SignedInfo + Content = "+input);\n      if (LOG > 2) console.log(" PublicKeyHex = "+publickeyHex);\n      if (LOG > 2) console.log(" PublicKeyString = "+publickeyString);\n\n      if (LOG > 2) console.log(" Signature "+signature);\n      if (LOG > 2) console.log(" Witness "+witHex);\n\n      if (LOG > 2) console.log(" Signature NOW IS");\n\n      if (LOG > 2) console.log(data.signature.signature);\n\n      var rsakey = new Key();\n      rsakey.readDerPublicKey(data.signedInfo.locator.publicKey);\n\n      var result = data.verify(rsakey);\n      if (result)\n      output += \'SIGNATURE VALID\';\n      else\n      output += \'SIGNATURE INVALID\';\n\n      output+= "<br />";\n      output+= "<br />";\n    }\n  }\n\n  return output;\n};\n\n/**\n * @deprecated Use return EncodingUtils.dataToHtml(data).\n */\nEncodingUtils.contentObjectToHtml = function(data)\n{\n  return EncodingUtils.dataToHtml(data);\n}\n\n//\n// Deprecated: For the browser, define these in the global scope.  Applications should access as member of EncodingUtils.\n//\n\nvar encodeToHexInterest = function(interest) { return EncodingUtils.encodeToHexInterest(interest); }\nvar encodeToHexContentObject = function(data) { return EncodingUtils.encodeToHexData(data); }\nvar encodeForwardingEntry = function(data) { return EncodingUtils.encodeForwardingEntry(data); }\nvar decodeHexFaceInstance = function(input) { return EncodingUtils.decodeHexFaceInstance(input); }\nvar decodeHexInterest = function(input) { return EncodingUtils.decodeHexInterest(input); }\nvar decodeHexContentObject = function(input) { return EncodingUtils.decodeHexData(input); }\nvar decodeHexForwardingEntry = function(input) { return EncodingUtils.decodeHexForwardingEntry(input); }\nvar decodeSubjectPublicKeyInfo = function(input) { return EncodingUtils.decodeSubjectPublicKeyInfo(input); }\nvar contentObjectToHtml = function(data) { return EncodingUtils.dataToHtml(data); }\n\n/**\n * @deprecated Use interest.encode().\n */\nfunction encodeToBinaryInterest(interest) { return interest.encode(); }\n/**\n * @deprecated Use data.encode().\n */\nfunction encodeToBinaryContentObject(data) { return data.encode(); }\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Meki Cherkaoui, Jeff Thompson <jefft0@remap.ucla.edu>, Wentao Shang\n * See COPYING for copyright and distribution information.\n * This class represents the top-level object for communicating with an NDN host.\n */\n\n/**\n * Create a new Face with the given settings.\n * This throws an exception if Face.supported is false.\n * @constructor\n * @param {Object} settings if not null, an associative array with the following defaults:\n * {\n *   getTransport: function() { return new WebSocketTransport(); }, // If in the browser.\n *              OR function() { return new TcpTransport(); },       // If in Node.js.\n *   getHostAndPort: transport.defaultGetHostAndPort, // a function, on each call it returns a new { host: host, port: port } or null if there are no more hosts.\n *   host: null, // If null, use getHostAndPort when connecting.\n *   port: 9696, // If in the browser.\n *      OR 6363, // If in Node.js.\n *   onopen: function() { if (LOG > 3) console.log("NDN connection established."); },\n *   onclose: function() { if (LOG > 3) console.log("NDN connection closed."); },\n *   verify: false // If false, don\'t verify and call upcall with Closure.UPCALL_CONTENT_UNVERIFIED.\n * }\n */\nvar Face = function Face(settings)\n{\n  if (!Face.supported)\n    throw new Error("The necessary JavaScript support is not available on this platform.");\n\n  settings = (settings || {});\n  // For the browser, browserify-tcp-transport.js replaces TcpTransport with WebSocketTransport.\n  var getTransport = (settings.getTransport || function() { return new TcpTransport(); });\n  this.transport = getTransport();\n  this.getHostAndPort = (settings.getHostAndPort || this.transport.defaultGetHostAndPort);\n  this.host = (settings.host !== undefined ? settings.host : null);\n  this.port = (settings.port || (typeof WebSocketTransport != \'undefined\' ? 9696 : 6363));\n  this.readyStatus = Face.UNOPEN;\n  this.verify = (settings.verify !== undefined ? settings.verify : false);\n  // Event handler\n  this.onopen = (settings.onopen || function() { if (LOG > 3) console.log("Face connection established."); });\n  this.onclose = (settings.onclose || function() { if (LOG > 3) console.log("Face connection closed."); });\n  this.ndndid = null;\n};\n\nexports.Face = Face;\n\nFace.UNOPEN = 0;  // created but not opened yet\nFace.OPENED = 1;  // connection to ndnd opened\nFace.CLOSED = 2;  // connection to ndnd closed\n\n/**\n * Return true if necessary JavaScript support is available, else log an error and return false.\n */\nFace.getSupported = function()\n{\n  try {\n    var dummy = new ndnbuf(1).slice(0, 1);\n  }\n  catch (ex) {\n    console.log("NDN not available: ndnbuf not supported. " + ex);\n    return false;\n  }\n\n  return true;\n};\n\nFace.supported = Face.getSupported();\n\nFace.ndndIdFetcher = new Name(\'/%C1.M.S.localhost/%C1.M.SRV/ndnd/KEY\');\n\nFace.prototype.createRoute = function(host, port)\n{\n  this.host=host;\n  this.port=port;\n};\n\nFace.KeyStore = new Array();\n\nvar KeyStoreEntry = function KeyStoreEntry(name, rsa, time)\n{\n  this.keyName = name;  // KeyName\n  this.rsaKey = rsa;    // RSA key\n  this.timeStamp = time;  // Time Stamp\n};\n\nFace.addKeyEntry = function(/* KeyStoreEntry */ keyEntry)\n{\n  var result = Face.getKeyByName(keyEntry.keyName);\n  if (result == null)\n    Face.KeyStore.push(keyEntry);\n  else\n    result = keyEntry;\n};\n\nFace.getKeyByName = function(/* KeyName */ name)\n{\n  var result = null;\n\n  for (var i = 0; i < Face.KeyStore.length; i++) {\n    if (Face.KeyStore[i].keyName.contentName.match(name.contentName)) {\n      if (result == null || Face.KeyStore[i].keyName.contentName.components.length > result.keyName.contentName.components.length)\n        result = Face.KeyStore[i];\n    }\n  }\n\n  return result;\n};\n\nFace.prototype.close = function()\n{\n  if (this.readyStatus != Face.OPENED)\n    throw new Error(\'Cannot close because Face connection is not opened.\');\n\n  this.readyStatus = Face.CLOSED;\n  this.transport.close();\n};\n\n// For fetching data\nFace.PITTable = new Array();\n\n/**\n * @constructor\n */\nvar PITEntry = function PITEntry(interest, closure)\n{\n  this.interest = interest;  // Interest\n  this.closure = closure;    // Closure\n  this.timerID = -1;  // Timer ID\n};\n\n/**\n * Return the entry from Face.PITTable where the name conforms to the interest selectors, and\n * the interest name is the longest that matches name.\n */\nFace.getEntryForExpressedInterest = function(/*Name*/ name)\n{\n  var result = null;\n\n  for (var i = 0; i < Face.PITTable.length; i++) {\n    if (Face.PITTable[i].interest.matchesName(name)) {\n      if (result == null || Face.PITTable[i].interest.name.components.length > result.interest.name.components.length)\n        result = Face.PITTable[i];\n    }\n  }\n\n  return result;\n};\n\n// For publishing data\nFace.registeredPrefixTable = new Array();\n\n/**\n * @constructor\n */\nvar RegisteredPrefix = function RegisteredPrefix(prefix, closure)\n{\n  this.prefix = prefix;        // String\n  this.closure = closure;  // Closure\n};\n\n/**\n * Find the first entry from Face.registeredPrefixTable where the entry prefix is the longest that matches name.\n * @param {Name} name The name to find the PrefixEntry for (from the incoming interest packet).\n * @returns {object} The entry from Face.registeredPrefixTable, or 0 if not found.\n */\nfunction getEntryForRegisteredPrefix(name)\n{\n  var iResult = -1;\n\n  for (var i = 0; i < Face.registeredPrefixTable.length; i++) {\n    if (LOG > 3) console.log("Registered prefix " + i + ": checking if " + Face.registeredPrefixTable[i].prefix + " matches " + name);\n    if (Face.registeredPrefixTable[i].prefix.match(name)) {\n      if (iResult < 0 ||\n          Face.registeredPrefixTable[i].prefix.size() > Face.registeredPrefixTable[iResult].prefix.size())\n        // Update to the longer match.\n        iResult = i;\n    }\n  }\n\n  if (iResult >= 0)\n    return Face.registeredPrefixTable[iResult];\n  else\n    return null;\n}\n\n/**\n * Return a function that selects a host at random from hostList and returns { host: host, port: port }.\n * If no more hosts remain, return null.\n */\nFace.makeShuffledGetHostAndPort = function(hostList, port)\n{\n  // Make a copy.\n  hostList = hostList.slice(0, hostList.length);\n  DataUtils.shuffle(hostList);\n\n  return function() {\n    if (hostList.length == 0)\n      return null;\n\n    return { host: hostList.splice(0, 1)[0], port: port };\n  };\n};\n\n/**\n * Send the interest through the transport, read the entire response and call onData.\n * If the interest times out according to interest lifetime, call onTimeout (if not omitted).\n * There are two forms of expressInterest.  The first form takes the exact interest (including lifetime):\n * expressInterest(interest, onData [, onTimeout]).  The second form creates the interest from\n * a name and optional interest template:\n * expressInterest(name [, template], onData [, onTimeout]).\n * This also supports the deprecated form expressInterest(name, closure [, template]), but you should use the other forms.\n * @param {Interest} interest The Interest to send which includes the interest lifetime for the timeout.\n * @param {function} onData When a matching data packet is received, this calls onData(interest, data) where:\n *   interest is the interest given to expressInterest,\n *   data is the received Data object.\n * @param {function} onTimeout (optional) If the interest times out according to the interest lifetime,\n *   this calls onTimeout(interest) where:\n *   interest is the interest given to expressInterest.\n * @param {Name} name The Name for the interest. (only used for the second form of expressInterest).\n * @param {Interest} template (optional) If not omitted, copy the interest selectors from this Interest.\n * If omitted, use a default interest lifetime. (only used for the second form of expressInterest).\n */\nFace.prototype.expressInterest = function(interestOrName, arg2, arg3, arg4)\n{\n  // There are several overloaded versions of expressInterest, each shown inline below.\n\n  // expressInterest(Name name, Closure closure);                      // deprecated\n  // expressInterest(Name name, Closure closure,   Interest template); // deprecated\n  if (arg2 && arg2.upcall && typeof arg2.upcall == \'function\') {\n    // Assume arg2 is the deprecated use with Closure.\n    if (arg3)\n      this.expressInterestWithClosure(interestOrName, arg2, arg3);\n    else\n      this.expressInterestWithClosure(interestOrName, arg2);\n    return;\n  }\n\n  var interest;\n  var onData;\n  var onTimeout;\n  // expressInterest(Interest interest, function onData);\n  // expressInterest(Interest interest, function onData, function onTimeout);\n  if (typeof interestOrName == \'object\' && interestOrName instanceof Interest) {\n    // Just use a copy of the interest.\n    interest = new Interest(interestOrName);\n    onData = arg2;\n    onTimeout = (arg3 ? arg3 : function() {});\n  }\n  else {\n    // The first argument is a name. Make the interest from the name and possible template.\n    interest = new Interest(interestOrName);\n    // expressInterest(Name name, Interest template, function onData);\n    // expressInterest(Name name, Interest template, function onData, function onTimeout);\n    if (arg2 && typeof arg2 == \'object\' && arg2 instanceof Interest) {\n      var template = arg2;\n      interest.minSuffixComponents = template.minSuffixComponents;\n      interest.maxSuffixComponents = template.maxSuffixComponents;\n      interest.publisherPublicKeyDigest = template.publisherPublicKeyDigest;\n      interest.exclude = template.exclude;\n      interest.childSelector = template.childSelector;\n      interest.answerOriginKind = template.answerOriginKind;\n      interest.scope = template.scope;\n      interest.interestLifetime = template.interestLifetime;\n\n      onData = arg3;\n      onTimeout = (arg4 ? arg4 : function() {});\n    }\n    // expressInterest(Name name, function onData);\n    // expressInterest(Name name, function onData,   function onTimeout);\n    else {\n      interest.interestLifetime = 4000;   // default interest timeout value in milliseconds.\n      onData = arg2;\n      onTimeout = (arg3 ? arg3 : function() {});\n    }\n  }\n\n  // Make a Closure from the callbacks so we can use expressInterestWithClosure.\n  // TODO: Convert the PIT to use callbacks, not a closure.\n  this.expressInterestWithClosure(interest, new Face.CallbackClosure(onData, onTimeout), interest);\n}\n\nFace.CallbackClosure = function FaceCallbackClosure(onData, onTimeout, onInterest, prefix, transport) {\n  // Inherit from Closure.\n  Closure.call(this);\n\n  this.onData = onData;\n  this.onTimeout = onTimeout;\n  this.onInterest = onInterest;\n  this.prefix = prefix;\n  this.transport = transport;\n};\n\nFace.CallbackClosure.prototype.upcall = function(kind, upcallInfo) {\n  if (kind == Closure.UPCALL_CONTENT || kind == Closure.UPCALL_CONTENT_UNVERIFIED)\n    this.onData(upcallInfo.interest, upcallInfo.data);\n  else if (kind == Closure.UPCALL_INTEREST_TIMED_OUT)\n    this.onTimeout(upcallInfo.interest);\n  else if (kind == Closure.UPCALL_INTEREST)\n    // Note: We never return INTEREST_CONSUMED because onInterest will send the result to the transport.\n    this.onInterest(this.prefix, upcallInfo.interest, this.transport)\n\n  return Closure.RESULT_OK;\n};\n\n/**\n * A private method to encode name as an Interest and send the it to host:port, read the entire response and call\n * closure.upcall(Closure.UPCALL_CONTENT (or Closure.UPCALL_CONTENT_UNVERIFIED),\n *                 new UpcallInfo(this, interest, 0, data)).\n * @deprecated Use expressInterest with callback functions, not Closure.\n * @param {Name} name Encode name as an Interest using the template (if supplied).\n * @param {Closure} closure\n * @param {Interest} template If not null, use its attributes.\n */\nFace.prototype.expressInterestWithClosure = function(name, closure, template)\n{\n  var interest = new Interest(name);\n  if (template != null) {\n    interest.minSuffixComponents = template.minSuffixComponents;\n    interest.maxSuffixComponents = template.maxSuffixComponents;\n    interest.publisherPublicKeyDigest = template.publisherPublicKeyDigest;\n    interest.exclude = template.exclude;\n    interest.childSelector = template.childSelector;\n    interest.answerOriginKind = template.answerOriginKind;\n    interest.scope = template.scope;\n    interest.interestLifetime = template.interestLifetime;\n  }\n  else\n    interest.interestLifetime = 4000;   // default interest timeout value in milliseconds.\n\n  if (this.host == null || this.port == null) {\n    if (this.getHostAndPort == null)\n      console.log(\'ERROR: host OR port NOT SET\');\n    else {\n      var thisNDN = this;\n      this.connectAndExecute(function() { thisNDN.reconnectAndExpressInterest(interest, closure); });\n    }\n  }\n  else\n    this.reconnectAndExpressInterest(interest, closure);\n};\n\n/**\n * If the host and port are different than the ones in this.transport, then call\n *   this.transport.connect to change the connection (or connect for the first time).\n * Then call expressInterestHelper.\n */\nFace.prototype.reconnectAndExpressInterest = function(interest, closure)\n{\n  if (this.transport.connectedHost != this.host || this.transport.connectedPort != this.port) {\n    var thisNDN = this;\n    this.transport.connect(thisNDN, function() { thisNDN.expressInterestHelper(interest, closure); });\n    this.readyStatus = Face.OPENED;\n  }\n  else\n    this.expressInterestHelper(interest, closure);\n};\n\n/**\n * Do the work of reconnectAndExpressInterest once we know we are connected.  Set the PITTable and call\n *   this.transport.send to send the interest.\n */\nFace.prototype.expressInterestHelper = function(interest, closure)\n{\n  var binaryInterest = interest.encode();\n  var thisNDN = this;\n  //TODO: check local content store first\n  if (closure != null) {\n    var pitEntry = new PITEntry(interest, closure);\n    // TODO: This needs to be a single thread-safe transaction on a global object.\n    Face.PITTable.push(pitEntry);\n    closure.pitEntry = pitEntry;\n\n    // Set interest timer.\n    var timeoutMilliseconds = (interest.interestLifetime || 4000);\n    var timeoutCallback = function() {\n      if (LOG > 1) console.log("Interest time out: " + interest.name.toUri());\n\n      // Remove PIT entry from Face.PITTable, even if we add it again later to re-express\n      //   the interest because we don\'t want to match it in the mean time.\n      // TODO: Make this a thread-safe operation on the global PITTable.\n      var index = Face.PITTable.indexOf(pitEntry);\n      if (index >= 0)\n        Face.PITTable.splice(index, 1);\n\n      // Raise closure callback\n      if (closure.upcall(Closure.UPCALL_INTEREST_TIMED_OUT, new UpcallInfo(thisNDN, interest, 0, null)) == Closure.RESULT_REEXPRESS) {\n        if (LOG > 1) console.log("Re-express interest: " + interest.name.toUri());\n        pitEntry.timerID = setTimeout(timeoutCallback, timeoutMilliseconds);\n        Face.PITTable.push(pitEntry);\n        thisNDN.transport.send(binaryInterest);\n      }\n    };\n\n    pitEntry.timerID = setTimeout(timeoutCallback, timeoutMilliseconds);\n  }\n\n  this.transport.send(binaryInterest);\n};\n\n/**\n * Register prefix with the connected NDN hub and call onInterest when a matching interest is received.\n * This uses the form:\n * registerPrefix(name, onInterest, onRegisterFailed [, flags]).\n * This also supports the deprecated form registerPrefix(name, closure [, intFlags]), but you should use the main form.\n * @param {Name} prefix The Name prefix.\n * @param {function} onInterest When an interest is received which matches the name prefix, this calls\n * onInterest(prefix, interest, transport) where:\n *   prefix is the prefix given to registerPrefix.\n *   interest is the received interest.\n *   transport The Transport with the connection which received the interest. You must encode a signed Data packet and send it using transport.send().\n * @param {function} onRegisterFailed If failed to retrieve the connected hub\'s ID or failed to register the prefix,\n * this calls onRegisterFailed(prefix) where:\n *   prefix is the prefix given to registerPrefix.\n * @param {ForwardingFlags} flags (optional) The flags for finer control of which interests are forward to the application.\n * If omitted, use the default flags defined by the default ForwardingFlags constructor.\n */\nFace.prototype.registerPrefix = function(prefix, arg2, arg3, arg4)\n{\n  // There are several overloaded versions of registerPrefix, each shown inline below.\n\n  // registerPrefix(Name prefix, Closure closure);            // deprecated\n  // registerPrefix(Name prefix, Closure closure, int flags); // deprecated\n  if (arg2 && arg2.upcall && typeof arg2.upcall == \'function\') {\n    // Assume arg2 is the deprecated use with Closure.\n    if (arg3)\n      this.registerPrefixWithClosure(prefix, arg2, arg3);\n    else\n      this.registerPrefixWithClosure(prefix, arg2);\n    return;\n  }\n\n  // registerPrefix(Name prefix, function onInterest, function onRegisterFailed);\n  // registerPrefix(Name prefix, function onInterest, function onRegisterFailed, ForwardingFlags flags);\n  var onInterest = arg2;\n  var onRegisterFailed = (arg3 ? arg3 : function() {});\n  var intFlags = (arg4 ? arg4.getForwardingEntryFlags() : new ForwardingFlags().getForwardingEntryFlags());\n  this.registerPrefixWithClosure(prefix, new Face.CallbackClosure(null, null, onInterest, prefix, this.transport),\n                                 intFlags, onRegisterFailed);\n}\n\n/**\n * A private method to register the prefix with the host, receive the data and call\n * closure.upcall(Closure.UPCALL_INTEREST, new UpcallInfo(this, interest, 0, null)).\n * @deprecated Use registerPrefix with callback functions, not Closure.\n * @param {Name} prefix\n * @param {Closure} closure\n * @param {number} intFlags\n * @param {function} (optional) If called from the non-deprecated registerPrefix, call onRegisterFailed(prefix)\n * if registration fails.\n */\nFace.prototype.registerPrefixWithClosure = function(prefix, closure, intFlags, onRegisterFailed)\n{\n  intFlags = intFlags | 3;\n  var thisNDN = this;\n  var onConnected = function() {\n    if (thisNDN.ndndid == null) {\n      // Fetch ndndid first, then register.\n      var interest = new Interest(Face.ndndIdFetcher);\n      interest.interestLifetime = 4000; // milliseconds\n      if (LOG > 3) console.log(\'Expressing interest for ndndid from ndnd.\');\n      thisNDN.reconnectAndExpressInterest\n        (interest, new Face.FetchNdndidClosure(thisNDN, prefix, closure, intFlags, onRegisterFailed));\n    }\n    else\n      thisNDN.registerPrefixHelper(prefix, closure, intFlags);\n  };\n\n  if (this.host == null || this.port == null) {\n    if (this.getHostAndPort == null)\n      console.log(\'ERROR: host OR port NOT SET\');\n    else\n      this.connectAndExecute(onConnected);\n  }\n  else\n    onConnected();\n};\n\n/**\n * This is a closure to receive the Data for Face.ndndIdFetcher and call\n *   registerPrefixHelper(prefix, callerClosure, flags).\n */\nFace.FetchNdndidClosure = function FetchNdndidClosure(face, prefix, callerClosure, flags, onRegisterFailed)\n{\n  // Inherit from Closure.\n  Closure.call(this);\n\n  this.face = face;\n  this.prefix = prefix;\n  this.callerClosure = callerClosure;\n  this.flags = flags;\n  this.onRegisterFailed = onRegisterFailed;\n};\n\nFace.FetchNdndidClosure.prototype.upcall = function(kind, upcallInfo)\n{\n  if (kind == Closure.UPCALL_INTEREST_TIMED_OUT) {\n    console.log("Timeout while requesting the ndndid.  Cannot registerPrefix for " + this.prefix.toUri() + " .");\n    if (this.onRegisterFailed)\n      this.onRegisterFailed(this.prefix);\n    return Closure.RESULT_OK;\n  }\n  if (!(kind == Closure.UPCALL_CONTENT ||\n        kind == Closure.UPCALL_CONTENT_UNVERIFIED))\n    // The upcall is not for us.  Don\'t expect this to happen.\n    return Closure.RESULT_ERR;\n\n  var data = upcallInfo.data;\n  if (!data.signedInfo || !data.signedInfo.publisher || !data.signedInfo.publisher.publisherPublicKeyDigest) {\n    console.log\n      ("Data doesn\'t have a publisherPublicKeyDigest. Cannot set ndndid and registerPrefix for "\n       + this.prefix.toUri() + " .");\n    if (this.onRegisterFailed)\n      this.onRegisterFailed(this.prefix);\n  }\n  else {\n    if (LOG > 3) console.log(\'Got ndndid from ndnd.\');\n    this.face.ndndid = data.signedInfo.publisher.publisherPublicKeyDigest;\n    if (LOG > 3) console.log(this.face.ndndid);\n    this.face.registerPrefixHelper(this.prefix, this.callerClosure, this.flags);\n  }\n\n  return Closure.RESULT_OK;\n};\n\n/**\n * Do the work of registerPrefix once we know we are connected with a ndndid.\n */\nFace.prototype.registerPrefixHelper = function(prefix, closure, flags)\n{\n  var fe = new ForwardingEntry(\'selfreg\', prefix, null, null, flags, 2147483647);\n\n  var encoder = new BinaryXMLEncoder();\n  fe.to_ndnb(encoder);\n  var bytes = encoder.getReducedOstream();\n\n  var si = new SignedInfo();\n  si.setFields();\n\n  var data = new Data(new Name(), si, bytes);\n  data.sign();\n  var coBinary = data.encode();;\n\n  var nodename = this.ndndid;\n  var interestName = new Name([\'ndnx\', nodename, \'selfreg\', coBinary]);\n\n  var interest = new Interest(interestName);\n  interest.scope = 1;\n  if (LOG > 3) console.log(\'Send Interest registration packet.\');\n\n  Face.registeredPrefixTable.push(new RegisteredPrefix(prefix, closure));\n\n  this.transport.send(interest.encode());\n};\n\n/**\n * This is called when an entire binary XML element is received, such as a Data or Interest.\n * Look up in the PITTable and call the closure callback.\n */\nFace.prototype.onReceivedElement = function(element)\n{\n  if (LOG > 3) console.log(\'Complete element received. Length \' + element.length + \'. Start decoding.\');\n  var decoder = new BinaryXMLDecoder(element);\n  // Dispatch according to packet type\n  if (decoder.peekDTag(NDNProtocolDTags.Interest)) {  // Interest packet\n    if (LOG > 3) console.log(\'Interest packet received.\');\n\n    var interest = new Interest();\n    interest.from_ndnb(decoder);\n    if (LOG > 3) console.log(interest);\n    if (LOG > 3) console.log(interest.name.toUri());\n\n    var entry = getEntryForRegisteredPrefix(interest.name);\n    if (entry != null) {\n      if (LOG > 3) console.log("Found registered prefix for " + interest.name.toUri());\n      var info = new UpcallInfo(this, interest, 0, null);\n      var ret = entry.closure.upcall(Closure.UPCALL_INTEREST, info);\n      if (ret == Closure.RESULT_INTEREST_CONSUMED && info.data != null)\n        this.transport.send(info.data.encode());\n    }\n  }\n  else if (decoder.peekDTag(NDNProtocolDTags.Data)) {  // Content packet\n    if (LOG > 3) console.log(\'Data packet received.\');\n\n    var data = new Data();\n    data.from_ndnb(decoder);\n\n    var pitEntry = Face.getEntryForExpressedInterest(data.name);\n    if (pitEntry != null) {\n      // Cancel interest timer\n      clearTimeout(pitEntry.timerID);\n\n      // Remove PIT entry from Face.PITTable\n      var index = Face.PITTable.indexOf(pitEntry);\n      if (index >= 0)\n        Face.PITTable.splice(index, 1);\n\n      var currentClosure = pitEntry.closure;\n\n      if (this.verify == false) {\n        // Pass content up without verifying the signature\n        currentClosure.upcall(Closure.UPCALL_CONTENT_UNVERIFIED, new UpcallInfo(this, pitEntry.interest, 0, data));\n        return;\n      }\n\n      // Key verification\n\n      // Recursive key fetching & verification closure\n      var KeyFetchClosure = function KeyFetchClosure(content, closure, key, sig, wit) {\n        this.data = content;  // unverified data packet object\n        this.closure = closure;  // closure corresponding to the data\n        this.keyName = key;  // name of current key to be fetched\n\n        Closure.call(this);\n      };\n\n      var thisNDN = this;\n      KeyFetchClosure.prototype.upcall = function(kind, upcallInfo) {\n        if (kind == Closure.UPCALL_INTEREST_TIMED_OUT) {\n          console.log("In KeyFetchClosure.upcall: interest time out.");\n          console.log(this.keyName.contentName.toUri());\n        }\n        else if (kind == Closure.UPCALL_CONTENT) {\n          var rsakey = new Key();\n          rsakey.readDerPublicKey(upcallInfo.data.content);\n          var verified = data.verify(rsakey);\n\n          var flag = (verified == true) ? Closure.UPCALL_CONTENT : Closure.UPCALL_CONTENT_BAD;\n          this.closure.upcall(flag, new UpcallInfo(thisNDN, null, 0, this.data));\n\n          // Store key in cache\n          var keyEntry = new KeyStoreEntry(keylocator.keyName, rsakey, new Date().getTime());\n          Face.addKeyEntry(keyEntry);\n        }\n        else if (kind == Closure.UPCALL_CONTENT_BAD)\n          console.log("In KeyFetchClosure.upcall: signature verification failed");\n      };\n\n      if (data.signedInfo && data.signedInfo.locator && data.signature) {\n        if (LOG > 3) console.log("Key verification...");\n        var sigHex = DataUtils.toHex(data.signature.signature).toLowerCase();\n\n        var wit = null;\n        if (data.signature.witness != null)\n            //SWT: deprecate support for Witness decoding and Merkle hash tree verification\n            currentClosure.upcall(Closure.UPCALL_CONTENT_BAD, new UpcallInfo(this, pitEntry.interest, 0, data));\n\n        var keylocator = data.signedInfo.locator;\n        if (keylocator.type == KeyLocatorType.KEYNAME) {\n          if (LOG > 3) console.log("KeyLocator contains KEYNAME");\n\n          if (keylocator.keyName.contentName.match(data.name)) {\n            if (LOG > 3) console.log("Content is key itself");\n\n            var rsakey = new Key();\n            rsakey.readDerPublicKey(data.content);\n            var verified = data.verify(rsakey);\n            var flag = (verified == true) ? Closure.UPCALL_CONTENT : Closure.UPCALL_CONTENT_BAD;\n\n            currentClosure.upcall(flag, new UpcallInfo(this, pitEntry.interest, 0, data));\n\n            // SWT: We don\'t need to store key here since the same key will be stored again in the closure.\n          }\n          else {\n            // Check local key store\n            var keyEntry = Face.getKeyByName(keylocator.keyName);\n            if (keyEntry) {\n              // Key found, verify now\n              if (LOG > 3) console.log("Local key cache hit");\n              var rsakey = keyEntry.rsaKey;\n              var verified = data.verify(rsakey);\n              var flag = (verified == true) ? Closure.UPCALL_CONTENT : Closure.UPCALL_CONTENT_BAD;\n\n              // Raise callback\n              currentClosure.upcall(flag, new UpcallInfo(this, pitEntry.interest, 0, data));\n            }\n            else {\n              // Not found, fetch now\n              if (LOG > 3) console.log("Fetch key according to keylocator");\n              var nextClosure = new KeyFetchClosure(data, currentClosure, keylocator.keyName, sigHex, wit);\n              // TODO: Use expressInterest with callbacks, not Closure.\n              this.expressInterest(keylocator.keyName.contentName.getPrefix(4), nextClosure);\n            }\n          }\n        }\n        else if (keylocator.type == KeyLocatorType.KEY) {\n          if (LOG > 3) console.log("Keylocator contains KEY");\n\n          var rsakey = new Key();\n          rsakey.readDerPublicKey(keylocator.publicKey);\n          var verified = data.verify(rsakey);\n\n          var flag = (verified == true) ? Closure.UPCALL_CONTENT : Closure.UPCALL_CONTENT_BAD;\n          // Raise callback\n          currentClosure.upcall(Closure.UPCALL_CONTENT, new UpcallInfo(this, pitEntry.interest, 0, data));\n\n          // Since KeyLocator does not contain key name for this key,\n          // we have no way to store it as a key entry in KeyStore.\n        }\n        else {\n          var cert = keylocator.certificate;\n          console.log("KeyLocator contains CERT");\n          console.log(cert);\n          // TODO: verify certificate\n        }\n      }\n    }\n  }\n  else\n    console.log(\'Incoming packet is not Interest or Data. Discard now.\');\n};\n\n/**\n * Assume this.getHostAndPort is not null.  This is called when this.host is null or its host\n *   is not alive.  Get a host and port, connect, then execute onConnected().\n */\nFace.prototype.connectAndExecute = function(onConnected)\n{\n  var hostAndPort = this.getHostAndPort();\n  if (hostAndPort == null) {\n    console.log(\'ERROR: No more hosts from getHostAndPort\');\n    this.host = null;\n    return;\n  }\n\n  if (hostAndPort.host == this.host && hostAndPort.port == this.port) {\n    console.log(\'ERROR: The host returned by getHostAndPort is not alive: \' + this.host + ":" + this.port);\n    return;\n  }\n\n  this.host = hostAndPort.host;\n  this.port = hostAndPort.port;\n  if (LOG>0) console.log("connectAndExecute: trying host from getHostAndPort: " + this.host);\n\n  // Fetch any content.\n  var interest = new Interest(new Name("/"));\n  interest.interestLifetime = 4000; // milliseconds\n\n  var thisNDN = this;\n  var timerID = setTimeout(function() {\n    if (LOG>0) console.log("connectAndExecute: timeout waiting for host " + thisNDN.host);\n      // Try again.\n      thisNDN.connectAndExecute(onConnected);\n  }, 3000);\n\n  this.reconnectAndExpressInterest(interest, new Face.ConnectClosure(this, onConnected, timerID));\n};\n\n/**\n * This is called by the Transport when the connection is closed by the remote host.\n */\nFace.prototype.closeByTransport = function()\n{\n  this.readyStatus = Face.CLOSED;\n  this.onclose();\n};\n\nFace.ConnectClosure = function ConnectClosure(face, onConnected, timerID)\n{\n  // Inherit from Closure.\n  Closure.call(this);\n\n  this.face = face;\n  this.onConnected = onConnected;\n  this.timerID = timerID;\n};\n\nFace.ConnectClosure.prototype.upcall = function(kind, upcallInfo)\n{\n  if (!(kind == Closure.UPCALL_CONTENT ||\n        kind == Closure.UPCALL_CONTENT_UNVERIFIED))\n    // The upcall is not for us.\n    return Closure.RESULT_ERR;\n\n  // The host is alive, so cancel the timeout and continue with onConnected().\n  clearTimeout(this.timerID);\n\n    // Call Face.onopen after success\n  this.face.readyStatus = Face.OPENED;\n  this.face.onopen();\n\n  if (LOG>0) console.log("connectAndExecute: connected to host " + this.face.host);\n  this.onConnected();\n\n  return Closure.RESULT_OK;\n};\n\n/**\n * @deprecated Use new Face.\n */\nvar NDN = function NDN(settings)\n{\n  // Call the base constructor.\n  Face.call(this, settings);\n}\n\n// Use dummy functions so that the Face constructor will not try to set its own defaults.\nNDN.prototype = new Face({ getTransport: function(){}, getHostAndPort: function(){} });\n\nexports.NDN = NDN;\n\nNDN.supported = Face.supported;\nNDN.UNOPEN = Face.UNOPEN;\nNDN.OPENED = Face.OPENED;\nNDN.CLOSED = Face.CLOSED;\n\n\nmodule.exports = exports/*\nCryptoJS v3.1.2\ncode.google.com/p/crypto-js\n(c) 2009-2013 by Jeff Mott. All rights reserved.\ncode.google.com/p/crypto-js/wiki/License\n*/\n/**\n * CryptoJS core components.\n */\nvar CryptoJS = CryptoJS || (function (Math, undefined) {\n    /**\n     * CryptoJS namespace.\n     */\n    var C = {};\n\n    /**\n     * Library namespace.\n     */\n    var C_lib = C.lib = {};\n\n    /**\n     * Base object for prototypal inheritance.\n     */\n    var Base = C_lib.Base = (function () {\n        function F() {}\n\n        return {\n            /**\n             * Creates a new object that inherits from this object.\n             *\n             * @param {Object} overrides Properties to copy into the new object.\n             *\n             * @return {Object} The new object.\n             *\n             * @static\n             *\n             * @example\n             *\n             *     var MyType = CryptoJS.lib.Base.extend({\n             *         field: \'value\',\n             *\n             *         method: function () {\n             *         }\n             *     });\n             */\n            extend: function (overrides) {\n                // Spawn\n                F.prototype = this;\n                var subtype = new F();\n\n                // Augment\n                if (overrides) {\n                    subtype.mixIn(overrides);\n                }\n\n                // Create default initializer\n                if (!subtype.hasOwnProperty(\'init\')) {\n                    subtype.init = function () {\n                        subtype.$super.init.apply(this, arguments);\n                    };\n                }\n\n                // Initializer\'s prototype is the subtype object\n                subtype.init.prototype = subtype;\n\n                // Reference supertype\n                subtype.$super = this;\n\n                return subtype;\n            },\n\n            /**\n             * Extends this object and runs the init method.\n             * Arguments to create() will be passed to init().\n             *\n             * @return {Object} The new object.\n             *\n             * @static\n             *\n             * @example\n             *\n             *     var instance = MyType.create();\n             */\n            create: function () {\n                var instance = this.extend();\n                instance.init.apply(instance, arguments);\n\n                return instance;\n            },\n\n            /**\n             * Initializes a newly created object.\n             * Override this method to add some logic when your objects are created.\n             *\n             * @example\n             *\n             *     var MyType = CryptoJS.lib.Base.extend({\n             *         init: function () {\n             *             // ...\n             *         }\n             *     });\n             */\n            init: function () {\n            },\n\n            /**\n             * Copies properties into this object.\n             *\n             * @param {Object} properties The properties to mix in.\n             *\n             * @example\n             *\n             *     MyType.mixIn({\n             *         field: \'value\'\n             *     });\n             */\n            mixIn: function (properties) {\n                for (var propertyName in properties) {\n                    if (properties.hasOwnProperty(propertyName)) {\n                        this[propertyName] = properties[propertyName];\n                    }\n                }\n\n                // IE won\'t copy toString using the loop above\n                if (properties.hasOwnProperty(\'toString\')) {\n                    this.toString = properties.toString;\n                }\n            },\n\n            /**\n             * Creates a copy of this object.\n             *\n             * @return {Object} The clone.\n             *\n             * @example\n             *\n             *     var clone = instance.clone();\n             */\n            clone: function () {\n                return this.init.prototype.extend(this);\n            }\n        };\n    }());\n\n    /**\n     * An array of 32-bit words.\n     *\n     * @property {Array} words The array of 32-bit words.\n     * @property {number} sigBytes The number of significant bytes in this word array.\n     */\n    var WordArray = C_lib.WordArray = Base.extend({\n        /**\n         * Initializes a newly created word array.\n         *\n         * @param {Array} words (Optional) An array of 32-bit words.\n         * @param {number} sigBytes (Optional) The number of significant bytes in the words.\n         *\n         * @example\n         *\n         *     var wordArray = CryptoJS.lib.WordArray.create();\n         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);\n         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);\n         */\n        init: function (words, sigBytes) {\n            words = this.words = words || [];\n\n            if (sigBytes != undefined) {\n                this.sigBytes = sigBytes;\n            } else {\n                this.sigBytes = words.length * 4;\n            }\n        },\n\n        /**\n         * Converts this word array to a string.\n         *\n         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex\n         *\n         * @return {string} The stringified word array.\n         *\n         * @example\n         *\n         *     var string = wordArray + \'\';\n         *     var string = wordArray.toString();\n         *     var string = wordArray.toString(CryptoJS.enc.Utf8);\n         */\n        toString: function (encoder) {\n            return (encoder || Hex).stringify(this);\n        },\n\n        /**\n         * Concatenates a word array to this word array.\n         *\n         * @param {WordArray} wordArray The word array to append.\n         *\n         * @return {WordArray} This word array.\n         *\n         * @example\n         *\n         *     wordArray1.concat(wordArray2);\n         */\n        concat: function (wordArray) {\n            // Shortcuts\n            var thisWords = this.words;\n            var thatWords = wordArray.words;\n            var thisSigBytes = this.sigBytes;\n            var thatSigBytes = wordArray.sigBytes;\n\n            // Clamp excess bits\n            this.clamp();\n\n            // Concat\n            if (thisSigBytes % 4) {\n                // Copy one byte at a time\n                for (var i = 0; i < thatSigBytes; i++) {\n                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);\n                }\n            } else if (thatWords.length > 0xffff) {\n                // Copy one word at a time\n                for (var i = 0; i < thatSigBytes; i += 4) {\n                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];\n                }\n            } else {\n                // Copy all words at once\n                thisWords.push.apply(thisWords, thatWords);\n            }\n            this.sigBytes += thatSigBytes;\n\n            // Chainable\n            return this;\n        },\n\n        /**\n         * Removes insignificant bits.\n         *\n         * @example\n         *\n         *     wordArray.clamp();\n         */\n        clamp: function () {\n            // Shortcuts\n            var words = this.words;\n            var sigBytes = this.sigBytes;\n\n            // Clamp\n            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);\n            words.length = Math.ceil(sigBytes / 4);\n        },\n\n        /**\n         * Creates a copy of this word array.\n         *\n         * @return {WordArray} The clone.\n         *\n         * @example\n         *\n         *     var clone = wordArray.clone();\n         */\n        clone: function () {\n            var clone = Base.clone.call(this);\n            clone.words = this.words.slice(0);\n\n            return clone;\n        },\n\n        /**\n         * Creates a word array filled with random bytes.\n         *\n         * @param {number} nBytes The number of random bytes to generate.\n         *\n         * @return {WordArray} The random word array.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var wordArray = CryptoJS.lib.WordArray.random(16);\n         */\n        random: function (nBytes) {\n            var words = [];\n            for (var i = 0; i < nBytes; i += 4) {\n                words.push((Math.random() * 0x100000000) | 0);\n            }\n\n            return new WordArray.init(words, nBytes);\n        }\n    });\n\n    /**\n     * Encoder namespace.\n     */\n    var C_enc = C.enc = {};\n\n    /**\n     * Hex encoding strategy.\n     */\n    var Hex = C_enc.Hex = {\n        /**\n         * Converts a word array to a hex string.\n         *\n         * @param {WordArray} wordArray The word array.\n         *\n         * @return {string} The hex string.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);\n         */\n        stringify: function (wordArray) {\n            // Shortcuts\n            var words = wordArray.words;\n            var sigBytes = wordArray.sigBytes;\n\n            // Convert\n            var hexChars = [];\n            for (var i = 0; i < sigBytes; i++) {\n                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n                hexChars.push((bite >>> 4).toString(16));\n                hexChars.push((bite & 0x0f).toString(16));\n            }\n\n            return hexChars.join(\'\');\n        },\n\n        /**\n         * Converts a hex string to a word array.\n         *\n         * @param {string} hexStr The hex string.\n         *\n         * @return {WordArray} The word array.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);\n         */\n        parse: function (hexStr) {\n            // Shortcut\n            var hexStrLength = hexStr.length;\n\n            // Convert\n            var words = [];\n            for (var i = 0; i < hexStrLength; i += 2) {\n                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);\n            }\n\n            return new WordArray.init(words, hexStrLength / 2);\n        }\n    };\n\n    /**\n     * Latin1 encoding strategy.\n     */\n    var Latin1 = C_enc.Latin1 = {\n        /**\n         * Converts a word array to a Latin1 string.\n         *\n         * @param {WordArray} wordArray The word array.\n         *\n         * @return {string} The Latin1 string.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);\n         */\n        stringify: function (wordArray) {\n            // Shortcuts\n            var words = wordArray.words;\n            var sigBytes = wordArray.sigBytes;\n\n            // Convert\n            var latin1Chars = [];\n            for (var i = 0; i < sigBytes; i++) {\n                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n                latin1Chars.push(String.fromCharCode(bite));\n            }\n\n            return latin1Chars.join(\'\');\n        },\n\n        /**\n         * Converts a Latin1 string to a word array.\n         *\n         * @param {string} latin1Str The Latin1 string.\n         *\n         * @return {WordArray} The word array.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);\n         */\n        parse: function (latin1Str) {\n            // Shortcut\n            var latin1StrLength = latin1Str.length;\n\n            // Convert\n            var words = [];\n            for (var i = 0; i < latin1StrLength; i++) {\n                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);\n            }\n\n            return new WordArray.init(words, latin1StrLength);\n        }\n    };\n\n    /**\n     * UTF-8 encoding strategy.\n     */\n    var Utf8 = C_enc.Utf8 = {\n        /**\n         * Converts a word array to a UTF-8 string.\n         *\n         * @param {WordArray} wordArray The word array.\n         *\n         * @return {string} The UTF-8 string.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);\n         */\n        stringify: function (wordArray) {\n            try {\n                return decodeURIComponent(escape(Latin1.stringify(wordArray)));\n            } catch (e) {\n                throw new Error(\'Malformed UTF-8 data\');\n            }\n        },\n\n        /**\n         * Converts a UTF-8 string to a word array.\n         *\n         * @param {string} utf8Str The UTF-8 string.\n         *\n         * @return {WordArray} The word array.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);\n         */\n        parse: function (utf8Str) {\n            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\n        }\n    };\n\n    /**\n     * Abstract buffered block algorithm template.\n     *\n     * The property blockSize must be implemented in a concrete subtype.\n     *\n     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0\n     */\n    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({\n        /**\n         * Resets this block algorithm\'s data buffer to its initial state.\n         *\n         * @example\n         *\n         *     bufferedBlockAlgorithm.reset();\n         */\n        reset: function () {\n            // Initial values\n            this._data = new WordArray.init();\n            this._nDataBytes = 0;\n        },\n\n        /**\n         * Adds new data to this block algorithm\'s buffer.\n         *\n         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.\n         *\n         * @example\n         *\n         *     bufferedBlockAlgorithm._append(\'data\');\n         *     bufferedBlockAlgorithm._append(wordArray);\n         */\n        _append: function (data) {\n            // Convert string to WordArray, else assume WordArray already\n            if (typeof data == \'string\') {\n                data = Utf8.parse(data);\n            }\n\n            // Append\n            this._data.concat(data);\n            this._nDataBytes += data.sigBytes;\n        },\n\n        /**\n         * Processes available data blocks.\n         *\n         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.\n         *\n         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.\n         *\n         * @return {WordArray} The processed data.\n         *\n         * @example\n         *\n         *     var processedData = bufferedBlockAlgorithm._process();\n         *     var processedData = bufferedBlockAlgorithm._process(!!\'flush\');\n         */\n        _process: function (doFlush) {\n            // Shortcuts\n            var data = this._data;\n            var dataWords = data.words;\n            var dataSigBytes = data.sigBytes;\n            var blockSize = this.blockSize;\n            var blockSizeBytes = blockSize * 4;\n\n            // Count blocks ready\n            var nBlocksReady = dataSigBytes / blockSizeBytes;\n            if (doFlush) {\n                // Round up to include partial blocks\n                nBlocksReady = Math.ceil(nBlocksReady);\n            } else {\n                // Round down to include only full blocks,\n                // less the number of blocks that must remain in the buffer\n                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n            }\n\n            // Count words ready\n            var nWordsReady = nBlocksReady * blockSize;\n\n            // Count bytes ready\n            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);\n\n            // Process blocks\n            if (nWordsReady) {\n                for (var offset = 0; offset < nWordsReady; offset += blockSize) {\n                    // Perform concrete-algorithm logic\n                    this._doProcessBlock(dataWords, offset);\n                }\n\n                // Remove processed words\n                var processedWords = dataWords.splice(0, nWordsReady);\n                data.sigBytes -= nBytesReady;\n            }\n\n            // Return processed words\n            return new WordArray.init(processedWords, nBytesReady);\n        },\n\n        /**\n         * Creates a copy of this object.\n         *\n         * @return {Object} The clone.\n         *\n         * @example\n         *\n         *     var clone = bufferedBlockAlgorithm.clone();\n         */\n        clone: function () {\n            var clone = Base.clone.call(this);\n            clone._data = this._data.clone();\n\n            return clone;\n        },\n\n        _minBufferSize: 0\n    });\n\n    /**\n     * Abstract hasher template.\n     *\n     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)\n     */\n    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({\n        /**\n         * Configuration options.\n         */\n        cfg: Base.extend(),\n\n        /**\n         * Initializes a newly created hasher.\n         *\n         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.\n         *\n         * @example\n         *\n         *     var hasher = CryptoJS.algo.SHA256.create();\n         */\n        init: function (cfg) {\n            // Apply config defaults\n            this.cfg = this.cfg.extend(cfg);\n\n            // Set initial values\n            this.reset();\n        },\n\n        /**\n         * Resets this hasher to its initial state.\n         *\n         * @example\n         *\n         *     hasher.reset();\n         */\n        reset: function () {\n            // Reset data buffer\n            BufferedBlockAlgorithm.reset.call(this);\n\n            // Perform concrete-hasher logic\n            this._doReset();\n        },\n\n        /**\n         * Updates this hasher with a message.\n         *\n         * @param {WordArray|string} messageUpdate The message to append.\n         *\n         * @return {Hasher} This hasher.\n         *\n         * @example\n         *\n         *     hasher.update(\'message\');\n         *     hasher.update(wordArray);\n         */\n        update: function (messageUpdate) {\n            // Append\n            this._append(messageUpdate);\n\n            // Update the hash\n            this._process();\n\n            // Chainable\n            return this;\n        },\n\n        /**\n         * Finalizes the hash computation.\n         * Note that the finalize operation is effectively a destructive, read-once operation.\n         *\n         * @param {WordArray|string} messageUpdate (Optional) A final message update.\n         *\n         * @return {WordArray} The hash.\n         *\n         * @example\n         *\n         *     var hash = hasher.finalize();\n         *     var hash = hasher.finalize(\'message\');\n         *     var hash = hasher.finalize(wordArray);\n         */\n        finalize: function (messageUpdate) {\n            // Final message update\n            if (messageUpdate) {\n                this._append(messageUpdate);\n            }\n\n            // Perform concrete-hasher logic\n            var hash = this._doFinalize();\n\n            return hash;\n        },\n\n        blockSize: 512/32,\n\n        /**\n         * Creates a shortcut function to a hasher\'s object interface.\n         *\n         * @param {Hasher} hasher The hasher to create a helper for.\n         *\n         * @return {Function} The shortcut function.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);\n         */\n        _createHelper: function (hasher) {\n            return function (message, cfg) {\n                return new hasher.init(cfg).finalize(message);\n            };\n        },\n\n        /**\n         * Creates a shortcut function to the HMAC\'s object interface.\n         *\n         * @param {Hasher} hasher The hasher to use in this HMAC helper.\n         *\n         * @return {Function} The shortcut function.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);\n         */\n        _createHmacHelper: function (hasher) {\n            return function (message, key) {\n                return new C_algo.HMAC.init(hasher, key).finalize(message);\n            };\n        }\n    });\n\n    /**\n     * Algorithm namespace.\n     */\n    var C_algo = C.algo = {};\n\n    return C;\n}(Math));\n/*\nCryptoJS v3.1.2\ncode.google.com/p/crypto-js\n(c) 2009-2013 by Jeff Mott. All rights reserved.\ncode.google.com/p/crypto-js/wiki/License\n*/\n(function (Math) {\n    // Shortcuts\n    var C = CryptoJS;\n    var C_lib = C.lib;\n    var WordArray = C_lib.WordArray;\n    var Hasher = C_lib.Hasher;\n    var C_algo = C.algo;\n\n    // Initialization and round constants tables\n    var H = [];\n    var K = [];\n\n    // Compute constants\n    (function () {\n        function isPrime(n) {\n            var sqrtN = Math.sqrt(n);\n            for (var factor = 2; factor <= sqrtN; factor++) {\n                if (!(n % factor)) {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        function getFractionalBits(n) {\n            return ((n - (n | 0)) * 0x100000000) | 0;\n        }\n\n        var n = 2;\n        var nPrime = 0;\n        while (nPrime < 64) {\n            if (isPrime(n)) {\n                if (nPrime < 8) {\n                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));\n                }\n                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));\n\n                nPrime++;\n            }\n\n            n++;\n        }\n    }());\n\n    // Reusable object\n    var W = [];\n\n    /**\n     * SHA-256 hash algorithm.\n     */\n    var SHA256 = C_algo.SHA256 = Hasher.extend({\n        _doReset: function () {\n            this._hash = new WordArray.init(H.slice(0));\n        },\n\n        _doProcessBlock: function (M, offset) {\n            // Shortcut\n            var H = this._hash.words;\n\n            // Working variables\n            var a = H[0];\n            var b = H[1];\n            var c = H[2];\n            var d = H[3];\n            var e = H[4];\n            var f = H[5];\n            var g = H[6];\n            var h = H[7];\n\n            // Computation\n            for (var i = 0; i < 64; i++) {\n                if (i < 16) {\n                    W[i] = M[offset + i] | 0;\n                } else {\n                    var gamma0x = W[i - 15];\n                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^\n                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^\n                                   (gamma0x >>> 3);\n\n                    var gamma1x = W[i - 2];\n                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^\n                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^\n                                   (gamma1x >>> 10);\n\n                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];\n                }\n\n                var ch  = (e & f) ^ (~e & g);\n                var maj = (a & b) ^ (a & c) ^ (b & c);\n\n                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));\n                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));\n\n                var t1 = h + sigma1 + ch + K[i] + W[i];\n                var t2 = sigma0 + maj;\n\n                h = g;\n                g = f;\n                f = e;\n                e = (d + t1) | 0;\n                d = c;\n                c = b;\n                b = a;\n                a = (t1 + t2) | 0;\n            }\n\n            // Intermediate hash value\n            H[0] = (H[0] + a) | 0;\n            H[1] = (H[1] + b) | 0;\n            H[2] = (H[2] + c) | 0;\n            H[3] = (H[3] + d) | 0;\n            H[4] = (H[4] + e) | 0;\n            H[5] = (H[5] + f) | 0;\n            H[6] = (H[6] + g) | 0;\n            H[7] = (H[7] + h) | 0;\n        },\n\n        _doFinalize: function () {\n            // Shortcuts\n            var data = this._data;\n            var dataWords = data.words;\n\n            var nBitsTotal = this._nDataBytes * 8;\n            var nBitsLeft = data.sigBytes * 8;\n\n            // Add padding\n            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);\n            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;\n            data.sigBytes = dataWords.length * 4;\n\n            // Hash final blocks\n            this._process();\n\n            // Return final computed hash\n            return this._hash;\n        },\n\n        clone: function () {\n            var clone = Hasher.clone.call(this);\n            clone._hash = this._hash.clone();\n\n            return clone;\n        }\n    });\n\n    /**\n     * Shortcut function to the hasher\'s object interface.\n     *\n     * @param {WordArray|string} message The message to hash.\n     *\n     * @return {WordArray} The hash.\n     *\n     * @static\n     *\n     * @example\n     *\n     *     var hash = CryptoJS.SHA256(\'message\');\n     *     var hash = CryptoJS.SHA256(wordArray);\n     */\n    C.SHA256 = Hasher._createHelper(SHA256);\n\n    /**\n     * Shortcut function to the HMAC\'s object interface.\n     *\n     * @param {WordArray|string} message The message to hash.\n     * @param {WordArray|string} key The secret key.\n     *\n     * @return {WordArray} The HMAC.\n     *\n     * @static\n     *\n     * @example\n     *\n     *     var hmac = CryptoJS.HmacSHA256(message, key);\n     */\n    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);\n}(Math));\nvar b64map="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";\nvar b64pad="=";\n\nfunction hex2b64(h) {\n  var i;\n  var c;\n  var ret = "";\n  for(i = 0; i+3 <= h.length; i+=3) {\n    c = parseInt(h.substring(i,i+3),16);\n    ret += b64map.charAt(c >> 6) + b64map.charAt(c & 63);\n  }\n  if(i+1 == h.length) {\n    c = parseInt(h.substring(i,i+1),16);\n    ret += b64map.charAt(c << 2);\n  }\n  else if(i+2 == h.length) {\n    c = parseInt(h.substring(i,i+2),16);\n    ret += b64map.charAt(c >> 2) + b64map.charAt((c & 3) << 4);\n  }\n  if (b64pad) while((ret.length & 3) > 0) ret += b64pad;\n  return ret;\n}\n\n// convert a base64 string to hex\nfunction b64tohex(s) {\n  var ret = ""\n  var i;\n  var k = 0; // b64 state, 0-3\n  var slop;\n  for(i = 0; i < s.length; ++i) {\n    if(s.charAt(i) == b64pad) break;\n    v = b64map.indexOf(s.charAt(i));\n    if(v < 0) continue;\n    if(k == 0) {\n      ret += int2char(v >> 2);\n      slop = v & 3;\n      k = 1;\n    }\n    else if(k == 1) {\n      ret += int2char((slop << 2) | (v >> 4));\n      slop = v & 0xf;\n      k = 2;\n    }\n    else if(k == 2) {\n      ret += int2char(slop);\n      ret += int2char(v >> 2);\n      slop = v & 3;\n      k = 3;\n    }\n    else {\n      ret += int2char((slop << 2) | (v >> 4));\n      ret += int2char(v & 0xf);\n      k = 0;\n    }\n  }\n  if(k == 1)\n    ret += int2char(slop << 2);\n  return ret;\n}\n\n// convert a base64 string to a byte/number array\nfunction b64toBA(s) {\n  //piggyback on b64tohex for now, optimize later\n  var h = b64tohex(s);\n  var i;\n  var a = new Array();\n  for(i = 0; 2*i < h.length; ++i) {\n    a[i] = parseInt(h.substring(2*i,2*i+2),16);\n  }\n  return a;\n}\n// Depends on jsbn.js and rng.js\n\n// Version 1.1: support utf-8 encoding in pkcs1pad2\n\n// convert a (hex) string to a bignum object\nfunction parseBigInt(str,r) {\n  return new BigInteger(str,r);\n}\n\nfunction linebrk(s,n) {\n  var ret = "";\n  var i = 0;\n  while(i + n < s.length) {\n    ret += s.substring(i,i+n) + "\\n";\n    i += n;\n  }\n  return ret + s.substring(i,s.length);\n}\n\nfunction byte2Hex(b) {\n  if(b < 0x10)\n    return "0" + b.toString(16);\n  else\n    return b.toString(16);\n}\n\n// PKCS#1 (type 2, random) pad input string s to n bytes, and return a bigint\nfunction pkcs1pad2(s,n) {\n  if(n < s.length + 11) { // TODO: fix for utf-8\n    alert("Message too long for RSA");\n    return null;\n  }\n  var ba = new Array();\n  var i = s.length - 1;\n  while(i >= 0 && n > 0) {\n    var c = s.charCodeAt(i--);\n    if(c < 128) { // encode using utf-8\n      ba[--n] = c;\n    }\n    else if((c > 127) && (c < 2048)) {\n      ba[--n] = (c & 63) | 128;\n      ba[--n] = (c >> 6) | 192;\n    }\n    else {\n      ba[--n] = (c & 63) | 128;\n      ba[--n] = ((c >> 6) & 63) | 128;\n      ba[--n] = (c >> 12) | 224;\n    }\n  }\n  ba[--n] = 0;\n  var rng = new SecureRandom();\n  var x = new Array();\n  while(n > 2) { // random non-zero pad\n    x[0] = 0;\n    while(x[0] == 0) rng.nextBytes(x);\n    ba[--n] = x[0];\n  }\n  ba[--n] = 2;\n  ba[--n] = 0;\n  return new BigInteger(ba);\n}\n\n// PKCS#1 (OAEP) mask generation function\nfunction oaep_mgf1_arr(seed, len, hash)\n{\n    var mask = \'\', i = 0;\n\n    while (mask.length < len)\n    {\n        mask += hash(String.fromCharCode.apply(String, seed.concat([\n                (i & 0xff000000) >> 24,\n                (i & 0x00ff0000) >> 16,\n                (i & 0x0000ff00) >> 8,\n                i & 0x000000ff])));\n        i += 1;\n    }\n\n    return mask;\n}\n\nvar SHA1_SIZE = 20;\n\n// PKCS#1 (OAEP) pad input string s to n bytes, and return a bigint\nfunction oaep_pad(s, n, hash)\n{\n    if (s.length + 2 * SHA1_SIZE + 2 > n)\n    {\n        throw "Message too long for RSA";\n    }\n\n    var PS = \'\', i;\n\n    for (i = 0; i < n - s.length - 2 * SHA1_SIZE - 2; i += 1)\n    {\n        PS += \'\\x00\';\n    }\n\n    var DB = rstr_sha1(\'\') + PS + \'\\x01\' + s;\n    var seed = new Array(SHA1_SIZE);\n    new SecureRandom().nextBytes(seed);\n\n    var dbMask = oaep_mgf1_arr(seed, DB.length, hash || rstr_sha1);\n    var maskedDB = [];\n\n    for (i = 0; i < DB.length; i += 1)\n    {\n        maskedDB[i] = DB.charCodeAt(i) ^ dbMask.charCodeAt(i);\n    }\n\n    var seedMask = oaep_mgf1_arr(maskedDB, seed.length, rstr_sha1);\n    var maskedSeed = [0];\n\n    for (i = 0; i < seed.length; i += 1)\n    {\n        maskedSeed[i + 1] = seed[i] ^ seedMask.charCodeAt(i);\n    }\n\n    return new BigInteger(maskedSeed.concat(maskedDB));\n}\n\n// "empty" RSA key constructor\nfunction RSAKey() {\n  this.n = null;\n  this.e = 0;\n  this.d = null;\n  this.p = null;\n  this.q = null;\n  this.dmp1 = null;\n  this.dmq1 = null;\n  this.coeff = null;\n}\n\n// Set the public key fields N and e from hex strings\nfunction RSASetPublic(N,E) {\n  if (typeof N !== "string")\n  {\n    this.n = N;\n    this.e = E;\n  }\n  else if(N != null && E != null && N.length > 0 && E.length > 0) {\n    this.n = parseBigInt(N,16);\n    this.e = parseInt(E,16);\n  }\n  else\n    alert("Invalid RSA public key");\n}\n\n// Perform raw public operation on "x": return x^e (mod n)\nfunction RSADoPublic(x) {\n  return x.modPowInt(this.e, this.n);\n}\n\n// Return the PKCS#1 RSA encryption of "text" as an even-length hex string\nfunction RSAEncrypt(text) {\n  var m = pkcs1pad2(text,(this.n.bitLength()+7)>>3);\n  if(m == null) return null;\n  var c = this.doPublic(m);\n  if(c == null) return null;\n  var h = c.toString(16);\n  if((h.length & 1) == 0) return h; else return "0" + h;\n}\n\n// Return the PKCS#1 OAEP RSA encryption of "text" as an even-length hex string\nfunction RSAEncryptOAEP(text, hash) {\n  var m = oaep_pad(text, (this.n.bitLength()+7)>>3, hash);\n  if(m == null) return null;\n  var c = this.doPublic(m);\n  if(c == null) return null;\n  var h = c.toString(16);\n  if((h.length & 1) == 0) return h; else return "0" + h;\n}\n\n// Return the PKCS#1 RSA encryption of "text" as a Base64-encoded string\n//function RSAEncryptB64(text) {\n//  var h = this.encrypt(text);\n//  if(h) return hex2b64(h); else return null;\n//}\n\n// protected\nRSAKey.prototype.doPublic = RSADoPublic;\n\n// public\nRSAKey.prototype.setPublic = RSASetPublic;\nRSAKey.prototype.encrypt = RSAEncrypt;\nRSAKey.prototype.encryptOAEP = RSAEncryptOAEP;\n//RSAKey.prototype.encrypt_b64 = RSAEncryptB64;\n// Depends on rsa.js and jsbn2.js\n\n// Version 1.1: support utf-8 decoding in pkcs1unpad2\n\n// Undo PKCS#1 (type 2, random) padding and, if valid, return the plaintext\nfunction pkcs1unpad2(d,n) {\n  var b = d.toByteArray();\n  var i = 0;\n  while(i < b.length && b[i] == 0) ++i;\n  if(b.length-i != n-1 || b[i] != 2)\n    return null;\n  ++i;\n  while(b[i] != 0)\n    if(++i >= b.length) return null;\n  var ret = "";\n  while(++i < b.length) {\n    var c = b[i] & 255;\n    if(c < 128) { // utf-8 decode\n      ret += String.fromCharCode(c);\n    }\n    else if((c > 191) && (c < 224)) {\n      ret += String.fromCharCode(((c & 31) << 6) | (b[i+1] & 63));\n      ++i;\n    }\n    else {\n      ret += String.fromCharCode(((c & 15) << 12) | ((b[i+1] & 63) << 6) | (b[i+2] & 63));\n      i += 2;\n    }\n  }\n  return ret;\n}\n\n// PKCS#1 (OAEP) mask generation function\nfunction oaep_mgf1_str(seed, len, hash)\n{\n    var mask = \'\', i = 0;\n\n    while (mask.length < len)\n    {\n        mask += hash(seed + String.fromCharCode.apply(String, [\n                (i & 0xff000000) >> 24,\n                (i & 0x00ff0000) >> 16,\n                (i & 0x0000ff00) >> 8,\n                i & 0x000000ff]));\n        i += 1;\n    }\n\n    return mask;\n}\n\nvar SHA1_SIZE = 20;\n\n// Undo PKCS#1 (OAEP) padding and, if valid, return the plaintext\nfunction oaep_unpad(d, n, hash)\n{\n    d = d.toByteArray();\n\n    var i;\n\n    for (i = 0; i < d.length; i += 1)\n    {\n        d[i] &= 0xff;\n    }\n\n    while (d.length < n)\n    {\n        d.unshift(0);\n    }\n\n    d = String.fromCharCode.apply(String, d);\n\n    if (d.length < 2 * SHA1_SIZE + 2)\n    {\n        throw "Cipher too short";\n    }\n\n    var maskedSeed = d.substr(1, SHA1_SIZE)\n    var maskedDB = d.substr(SHA1_SIZE + 1);\n\n    var seedMask = oaep_mgf1_str(maskedDB, SHA1_SIZE, hash || rstr_sha1);\n    var seed = [], i;\n\n    for (i = 0; i < maskedSeed.length; i += 1)\n    {\n        seed[i] = maskedSeed.charCodeAt(i) ^ seedMask.charCodeAt(i);\n    }\n\n    var dbMask = oaep_mgf1_str(String.fromCharCode.apply(String, seed),\n                           d.length - SHA1_SIZE, rstr_sha1);\n\n    var DB = [];\n\n    for (i = 0; i < maskedDB.length; i += 1)\n    {\n        DB[i] = maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i);\n    }\n\n    DB = String.fromCharCode.apply(String, DB);\n\n    if (DB.substr(0, SHA1_SIZE) !== rstr_sha1(\'\'))\n    {\n        throw "Hash mismatch";\n    }\n\n    DB = DB.substr(SHA1_SIZE);\n\n    var first_one = DB.indexOf(\'\\x01\');\n    var last_zero = (first_one != -1) ? DB.substr(0, first_one).lastIndexOf(\'\\x00\') : -1;\n\n    if (last_zero + 1 != first_one)\n    {\n        throw "Malformed data";\n    }\n\n    return DB.substr(first_one + 1);\n}\n\n// Set the private key fields N, e, and d from hex strings\nfunction RSASetPrivate(N,E,D) {\n  if (typeof N !== "string")\n  {\n    this.n = N;\n    this.e = E;\n    this.d = D;\n  }\n  else if(N != null && E != null && N.length > 0 && E.length > 0) {\n    this.n = parseBigInt(N,16);\n    this.e = parseInt(E,16);\n    this.d = parseBigInt(D,16);\n  }\n  else\n    alert("Invalid RSA private key");\n}\n\n// Set the private key fields N, e, d and CRT params from hex strings\nfunction RSASetPrivateEx(N,E,D,P,Q,DP,DQ,C) {\n  //alert("RSASetPrivateEx called");\n  if (N == null) throw "RSASetPrivateEx N == null";\n  if (E == null) throw "RSASetPrivateEx E == null";\n  if (N.length == 0) throw "RSASetPrivateEx N.length == 0";\n  if (E.length == 0) throw "RSASetPrivateEx E.length == 0";\n\n  if (N != null && E != null && N.length > 0 && E.length > 0) {\n    this.n = parseBigInt(N,16);\n    this.e = parseInt(E,16);\n    this.d = parseBigInt(D,16);\n    this.p = parseBigInt(P,16);\n    this.q = parseBigInt(Q,16);\n    this.dmp1 = parseBigInt(DP,16);\n    this.dmq1 = parseBigInt(DQ,16);\n    this.coeff = parseBigInt(C,16);\n  } else {\n    alert("Invalid RSA private key in RSASetPrivateEx");\n  }\n}\n\n// Generate a new random private key B bits long, using public expt E\nfunction RSAGenerate(B,E) {\n  var rng = new SecureRandom();\n  var qs = B>>1;\n  this.e = parseInt(E,16);\n  var ee = new BigInteger(E,16);\n  for(;;) {\n    for(;;) {\n      this.p = new BigInteger(B-qs,1,rng);\n      if(this.p.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) == 0 && this.p.isProbablePrime(10)) break;\n    }\n    for(;;) {\n      this.q = new BigInteger(qs,1,rng);\n      if(this.q.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) == 0 && this.q.isProbablePrime(10)) break;\n    }\n    if(this.p.compareTo(this.q) <= 0) {\n      var t = this.p;\n      this.p = this.q;\n      this.q = t;\n    }\n    var p1 = this.p.subtract(BigInteger.ONE);\t// p1 = p - 1\n    var q1 = this.q.subtract(BigInteger.ONE);\t// q1 = q - 1\n    var phi = p1.multiply(q1);\n    if(phi.gcd(ee).compareTo(BigInteger.ONE) == 0) {\n      this.n = this.p.multiply(this.q);\t// this.n = p * q\n      this.d = ee.modInverse(phi);\t// this.d =\n      this.dmp1 = this.d.mod(p1);\t// this.dmp1 = d mod (p - 1)\n      this.dmq1 = this.d.mod(q1);\t// this.dmq1 = d mod (q - 1)\n      this.coeff = this.q.modInverse(this.p);\t// this.coeff = (q ^ -1) mod p\n      break;\n    }\n  }\n}\n\n// Perform raw private operation on "x": return x^d (mod n)\nfunction RSADoPrivate(x) {\n  if(this.p == null || this.q == null)\n    return x.modPow(this.d, this.n);\n\n  // TODO: re-calculate any missing CRT params\n  var xp = x.mod(this.p).modPow(this.dmp1, this.p); // xp=cp?\n  var xq = x.mod(this.q).modPow(this.dmq1, this.q); // xq=cq?\n\n  while(xp.compareTo(xq) < 0)\n    xp = xp.add(this.p);\n  // NOTE:\n  // xp.subtract(xq) => cp -cq\n  // xp.subtract(xq).multiply(this.coeff).mod(this.p) => (cp - cq) * u mod p = h\n  // xp.subtract(xq).multiply(this.coeff).mod(this.p).multiply(this.q).add(xq) => cq + (h * q) = M\n  return xp.subtract(xq).multiply(this.coeff).mod(this.p).multiply(this.q).add(xq);\n}\n\n// Return the PKCS#1 RSA decryption of "ctext".\n// "ctext" is an even-length hex string and the output is a plain string.\nfunction RSADecrypt(ctext) {\n  var c = parseBigInt(ctext, 16);\n  var m = this.doPrivate(c);\n  if(m == null) return null;\n  return pkcs1unpad2(m, (this.n.bitLength()+7)>>3);\n}\n\n// Return the PKCS#1 OAEP RSA decryption of "ctext".\n// "ctext" is an even-length hex string and the output is a plain string.\nfunction RSADecryptOAEP(ctext, hash) {\n  var c = parseBigInt(ctext, 16);\n  var m = this.doPrivate(c);\n  if(m == null) return null;\n  return oaep_unpad(m, (this.n.bitLength()+7)>>3, hash);\n}\n\n// Return the PKCS#1 RSA decryption of "ctext".\n// "ctext" is a Base64-encoded string and the output is a plain string.\n//function RSAB64Decrypt(ctext) {\n//  var h = b64tohex(ctext);\n//  if(h) return this.decrypt(h); else return null;\n//}\n\n// protected\nRSAKey.prototype.doPrivate = RSADoPrivate;\n\n// public\nRSAKey.prototype.setPrivate = RSASetPrivate;\nRSAKey.prototype.setPrivateEx = RSASetPrivateEx;\nRSAKey.prototype.generate = RSAGenerate;\nRSAKey.prototype.decrypt = RSADecrypt;\nRSAKey.prototype.decryptOAEP = RSADecryptOAEP;\n//RSAKey.prototype.b64_decrypt = RSAB64Decrypt;\n/*! crypto-1.0.4.js (c) 2013 Kenji Urushima | kjur.github.com/jsrsasign/license\n */\n/*\n * crypto.js - Cryptographic Algorithm Provider class\n *\n * Copyright (c) 2013 Kenji Urushima (kenji.urushima@gmail.com)\n *\n * This software is licensed under the terms of the MIT License.\n * http://kjur.github.com/jsrsasign/license\n *\n * The above copyright and license notice shall be\n * included in all copies or substantial portions of the Software.\n */\n\n/**\n * @fileOverview\n * @name crypto-1.0.js\n * @author Kenji Urushima kenji.urushima@gmail.com\n * @version 1.0.4 (2013-Mar-28)\n * @since 2.2\n * @license <a href="http://kjur.github.io/jsrsasign/license/">MIT License</a>\n */\n\n/**\n * kjur\'s class library name space\n * @name KJUR\n * @namespace kjur\'s class library name space\n */\nif (typeof KJUR == "undefined" || !KJUR) KJUR = {};\n/**\n * kjur\'s cryptographic algorithm provider library name space\n * <p>\n * This namespace privides following crytpgrahic classes.\n * <ul>\n * <li>{@link KJUR.crypto.MessageDigest} - Java JCE(cryptograhic extension) style MessageDigest class</li>\n * <li>{@link KJUR.crypto.Signature} - Java JCE(cryptograhic extension) style Signature class</li>\n * <li>{@link KJUR.crypto.Util} - cryptographic utility functions and properties</li>\n * </ul>\n * NOTE: Please ignore method summary and document of this namespace. This caused by a bug of jsdoc2.\n * </p>\n * @name KJUR.crypto\n * @namespace\n */\nif (typeof KJUR.crypto == "undefined" || !KJUR.crypto) KJUR.crypto = {};\n\n/**\n * static object for cryptographic function utilities\n * @name KJUR.crypto.Util\n * @class static object for cryptographic function utilities\n * @property {Array} DIGESTINFOHEAD PKCS#1 DigestInfo heading hexadecimal bytes for each hash algorithms\n * @description\n */\nKJUR.crypto.Util = new function() {\n    this.DIGESTINFOHEAD = {\n\t\'sha1\':      "3021300906052b0e03021a05000414",\n        \'sha224\':    "302d300d06096086480165030402040500041c",\n\t\'sha256\':    "3031300d060960864801650304020105000420",\n\t\'sha384\':    "3041300d060960864801650304020205000430",\n\t\'sha512\':    "3051300d060960864801650304020305000440",\n\t\'md2\':       "3020300c06082a864886f70d020205000410",\n\t\'md5\':       "3020300c06082a864886f70d020505000410",\n\t\'ripemd160\': "3021300906052b2403020105000414"\n    };\n\n    /**\n     * get hexadecimal DigestInfo\n     * @name getDigestInfoHex\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} hHash hexadecimal hash value\n     * @param {String} alg hash algorithm name (ex. \'sha1\')\n     * @return {String} hexadecimal string DigestInfo ASN.1 structure\n     */\n    this.getDigestInfoHex = function(hHash, alg) {\n\tif (typeof this.DIGESTINFOHEAD[alg] == "undefined")\n\t    throw "alg not supported in Util.DIGESTINFOHEAD: " + alg;\n\treturn this.DIGESTINFOHEAD[alg] + hHash;\n    };\n\n    /**\n     * get PKCS#1 padded hexadecimal DigestInfo\n     * @name getPaddedDigestInfoHex\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} hHash hexadecimal hash value\n     * @param {String} alg hash algorithm name (ex. \'sha1\')\n     * @param {Integer} keySize key bit length (ex. 1024)\n     * @return {String} hexadecimal string of PKCS#1 padded DigestInfo\n     */\n    this.getPaddedDigestInfoHex = function(hHash, alg, keySize) {\n\tvar hDigestInfo = this.getDigestInfoHex(hHash, alg);\n\tvar pmStrLen = keySize / 4; // minimum PM length\n\n\tif (hDigestInfo.length + 22 > pmStrLen) // len(0001+ff(*8)+00+hDigestInfo)=22\n\t    throw "key is too short for SigAlg: keylen=" + keySize + "," + alg;\n\n\tvar hHead = "0001";\n\tvar hTail = "00" + hDigestInfo;\n\tvar hMid = "";\n\tvar fLen = pmStrLen - hHead.length - hTail.length;\n\tfor (var i = 0; i < fLen; i += 2) {\n\t    hMid += "ff";\n\t}\n\tvar hPaddedMessage = hHead + hMid + hTail;\n\treturn hPaddedMessage;\n    };\n\n    /**\n     * get hexadecimal SHA1 hash of string\n     * @name sha1\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} s input string to be hashed\n     * @return {String} hexadecimal string of hash value\n     * @since 1.0.3\n     */\n    this.sha1 = function(s) {\n        var md = new KJUR.crypto.MessageDigest({\'alg\':\'sha1\', \'prov\':\'cryptojs\'});\n        return md.digestString(s);\n    };\n\n    /**\n     * get hexadecimal SHA256 hash of string\n     * @name sha256\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} s input string to be hashed\n     * @return {String} hexadecimal string of hash value\n     * @since 1.0.3\n     */\n    this.sha256 = function(s) {\n        var md = new KJUR.crypto.MessageDigest({\'alg\':\'sha256\', \'prov\':\'cryptojs\'});\n        return md.digestString(s);\n    };\n\n    /**\n     * get hexadecimal SHA512 hash of string\n     * @name sha512\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} s input string to be hashed\n     * @return {String} hexadecimal string of hash value\n     * @since 1.0.3\n     */\n    this.sha512 = function(s) {\n        var md = new KJUR.crypto.MessageDigest({\'alg\':\'sha512\', \'prov\':\'cryptojs\'});\n        return md.digestString(s);\n    };\n\n    /**\n     * get hexadecimal MD5 hash of string\n     * @name md5\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} s input string to be hashed\n     * @return {String} hexadecimal string of hash value\n     * @since 1.0.3\n     */\n    this.md5 = function(s) {\n        var md = new KJUR.crypto.MessageDigest({\'alg\':\'md5\', \'prov\':\'cryptojs\'});\n        return md.digestString(s);\n    };\n\n    /**\n     * get hexadecimal RIPEMD160 hash of string\n     * @name ripemd160\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} s input string to be hashed\n     * @return {String} hexadecimal string of hash value\n     * @since 1.0.3\n     */\n    this.ripemd160 = function(s) {\n        var md = new KJUR.crypto.MessageDigest({\'alg\':\'ripemd160\', \'prov\':\'cryptojs\'});\n        return md.digestString(s);\n    };\n};\n\n/**\n * MessageDigest class which is very similar to java.security.MessageDigest class\n * @name KJUR.crypto.MessageDigest\n * @class MessageDigest class which is very similar to java.security.MessageDigest class\n * @param {Array} params parameters for constructor\n * @description\n * <br/>\n * Currently this supports following algorithm and providers combination:\n * <ul>\n * <li>md5 - cryptojs</li>\n * <li>sha1 - cryptojs</li>\n * <li>sha224 - cryptojs</li>\n * <li>sha256 - cryptojs</li>\n * <li>sha384 - cryptojs</li>\n * <li>sha512 - cryptojs</li>\n * <li>ripemd160 - cryptojs</li>\n * <li>sha256 - sjcl (NEW from crypto.js 1.0.4)</li>\n * </ul>\n * @example\n * // CryptoJS provider sample\n * &lt;script src="http://crypto-js.googlecode.com/svn/tags/3.1.2/build/components/core.js"&gt;&lt;/script&gt;\n * &lt;script src="http://crypto-js.googlecode.com/svn/tags/3.1.2/build/components/sha1.js"&gt;&lt;/script&gt;\n * &lt;script src="crypto-1.0.js"&gt;&lt;/script&gt;\n * var md = new KJUR.crypto.MessageDigest({alg: "sha1", prov: "cryptojs"});\n * md.updateString(\'aaa\')\n * var mdHex = md.digest()\n *\n * // SJCL(Stanford JavaScript Crypto Library) provider sample\n * &lt;script src="http://bitwiseshiftleft.github.io/sjcl/sjcl.js"&gt;&lt;/script&gt;\n * &lt;script src="crypto-1.0.js"&gt;&lt;/script&gt;\n * var md = new KJUR.crypto.MessageDigest({alg: "sha256", prov: "sjcl"}); // sjcl supports sha256 only\n * md.updateString(\'aaa\')\n * var mdHex = md.digest()\n */\nKJUR.crypto.MessageDigest = function(params) {\n    var md = null;\n    var algName = null;\n    var provName = null;\n    var _CryptoJSMdName = {\n\t\'md5\': \'CryptoJS.algo.MD5\',\n\t\'sha1\': \'CryptoJS.algo.SHA1\',\n\t\'sha224\': \'CryptoJS.algo.SHA224\',\n\t\'sha256\': \'CryptoJS.algo.SHA256\',\n\t\'sha384\': \'CryptoJS.algo.SHA384\',\n\t\'sha512\': \'CryptoJS.algo.SHA512\',\n\t\'ripemd160\': \'CryptoJS.algo.RIPEMD160\'\n    };\n\n    /**\n     * set hash algorithm and provider\n     * @name setAlgAndProvider\n     * @memberOf KJUR.crypto.MessageDigest\n     * @function\n     * @param {String} alg hash algorithm name\n     * @param {String} prov provider name\n     * @description\n     * @example\n     * // for SHA1\n     * md.setAlgAndProvider(\'sha1\', \'cryptojs\');\n     * // for RIPEMD160\n     * md.setAlgAndProvider(\'ripemd160\', \'cryptojs\');\n     */\n    this.setAlgAndProvider = function(alg, prov) {\n\tif (\':md5:sha1:sha224:sha256:sha384:sha512:ripemd160:\'.indexOf(alg) != -1 &&\n\t    prov == \'cryptojs\') {\n\t    try {\n\t\tthis.md = eval(_CryptoJSMdName[alg]).create();\n\t    } catch (ex) {\n\t\tthrow "setAlgAndProvider hash alg set fail alg=" + alg + "/" + ex;\n\t    }\n\t    this.updateString = function(str) {\n\t\tthis.md.update(str);\n\t    };\n\t    this.updateHex = function(hex) {\n\t\tvar wHex = CryptoJS.enc.Hex.parse(hex);\n\t\tthis.md.update(wHex);\n\t    };\n\t    this.digest = function() {\n\t\tvar hash = this.md.finalize();\n\t\treturn hash.toString(CryptoJS.enc.Hex);\n\t    };\n\t    this.digestString = function(str) {\n\t\tthis.updateString(str);\n\t\treturn this.digest();\n\t    };\n\t    this.digestHex = function(hex) {\n\t\tthis.updateHex(hex);\n\t\treturn this.digest();\n\t    };\n\t}\n\tif (\':sha256:\'.indexOf(alg) != -1 &&\n\t    prov == \'sjcl\') {\n\t    try {\n\t\tthis.md = new sjcl.hash.sha256();\n\t    } catch (ex) {\n\t\tthrow "setAlgAndProvider hash alg set fail alg=" + alg + "/" + ex;\n\t    }\n\t    this.updateString = function(str) {\n\t\tthis.md.update(str);\n\t    };\n\t    this.updateHex = function(hex) {\n\t\tvar baHex = sjcl.codec.hex.toBits(hex);\n\t\tthis.md.update(baHex);\n\t    };\n\t    this.digest = function() {\n\t\tvar hash = this.md.finalize();\n\t\treturn sjcl.codec.hex.fromBits(hash);\n\t    };\n\t    this.digestString = function(str) {\n\t\tthis.updateString(str);\n\t\treturn this.digest();\n\t    };\n\t    this.digestHex = function(hex) {\n\t\tthis.updateHex(hex);\n\t\treturn this.digest();\n\t    };\n\t}\n    };\n\n    /**\n     * update digest by specified string\n     * @name updateString\n     * @memberOf KJUR.crypto.MessageDigest\n     * @function\n     * @param {String} str string to update\n     * @description\n     * @example\n     * md.updateString(\'New York\');\n     */\n    this.updateString = function(str) {\n\tthrow "updateString(str) not supported for this alg/prov: " + this.algName + "/" + this.provName;\n    };\n\n    /**\n     * update digest by specified hexadecimal string\n     * @name updateHex\n     * @memberOf KJUR.crypto.MessageDigest\n     * @function\n     * @param {String} hex hexadecimal string to update\n     * @description\n     * @example\n     * md.updateHex(\'0afe36\');\n     */\n    this.updateHex = function(hex) {\n\tthrow "updateHex(hex) not supported for this alg/prov: " + this.algName + "/" + this.provName;\n    };\n\n    /**\n     * completes hash calculation and returns hash result\n     * @name digest\n     * @memberOf KJUR.crypto.MessageDigest\n     * @function\n     * @description\n     * @example\n     * md.digest()\n     */\n    this.digest = function() {\n\tthrow "digest() not supported for this alg/prov: " + this.algName + "/" + this.provName;\n    };\n\n    /**\n     * performs final update on the digest using string, then completes the digest computation\n     * @name digestString\n     * @memberOf KJUR.crypto.MessageDigest\n     * @function\n     * @param {String} str string to final update\n     * @description\n     * @example\n     * md.digestString(\'aaa\')\n     */\n    this.digestString = function(str) {\n\tthrow "digestString(str) not supported for this alg/prov: " + this.algName + "/" + this.provName;\n    };\n\n    /**\n     * performs final update on the digest using hexadecimal string, then completes the digest computation\n     * @name digestHex\n     * @memberOf KJUR.crypto.MessageDigest\n     * @function\n     * @param {String} hex hexadecimal string to final update\n     * @description\n     * @example\n     * md.digestHex(\'0f2abd\')\n     */\n    this.digestHex = function(hex) {\n\tthrow "digestHex(hex) not supported for this alg/prov: " + this.algName + "/" + this.provName;\n    };\n\n    if (typeof params != "undefined") {\n\tif (typeof params[\'alg\'] != "undefined") {\n\t    this.algName = params[\'alg\'];\n\t    this.provName = params[\'prov\'];\n\t    this.setAlgAndProvider(params[\'alg\'], params[\'prov\']);\n\t}\n    }\n};\n\n\n/**\n * Signature class which is very similar to java.security.Signature class\n * @name KJUR.crypto.Signature\n * @class Signature class which is very similar to java.security.Signature class\n * @param {Array} params parameters for constructor\n * @property {String} state Current state of this signature object whether \'SIGN\', \'VERIFY\' or null\n * @description\n * <br/>\n * As for params of constructor\'s argument, it can be specify following attributes:\n * <ul>\n * <li>alg - signature algorithm name (ex. {MD5,SHA1,SHA224,SHA256,SHA384,SHA512,RIPEMD160}withRSA)</li>\n * <li>provider - currently \'cryptojs/jsrsa\' only</li>\n * <li>prvkeypem - PEM string of signer\'s private key. If this specified, no need to call initSign(prvKey).</li>\n * </ul>\n * <h4>SUPPORTED ALGORITHMS AND PROVIDERS</h4>\n * Signature class supports {MD5,SHA1,SHA224,SHA256,SHA384,SHA512,RIPEMD160}\n * withRSA algorithm in \'cryptojs/jsrsa\' provider.\n * <h4>EXAMPLES</h4>\n * @example\n * // signature generation\n * var sig = new KJUR.crypto.Signature({"alg": "SHA1withRSA", "prov": "cryptojs/jsrsa"});\n * sig.initSign(prvKey);\n * sig.updateString(\'aaa\');\n * var hSigVal = sig.sign();\n *\n * // signature validation\n * var sig2 = new KJUR.crypto.Signature({"alg": "SHA1withRSA", "prov": "cryptojs/jsrsa"});\n * sig2.initVerifyByCertificatePEM(cert)\n * sig.updateString(\'aaa\');\n * var isValid = sig2.verify(hSigVal);\n */\nKJUR.crypto.Signature = function(params) {\n    var prvKey = null; // RSAKey for signing\n    var pubKey = null; // RSAKey for verifying\n\n    var md = null; // KJUR.crypto.MessageDigest object\n    var sig = null;\n    var algName = null;\n    var provName = null;\n    var algProvName = null;\n    var mdAlgName = null;\n    var pubkeyAlgName = null;\n    var state = null;\n\n    var sHashHex = null; // hex hash value for hex\n    var hDigestInfo = null;\n    var hPaddedDigestInfo = null;\n    var hSign = null;\n\n    this._setAlgNames = function() {\n\tif (this.algName.match(/^(.+)with(.+)$/)) {\n\t    this.mdAlgName = RegExp.$1.toLowerCase();\n\t    this.pubkeyAlgName = RegExp.$2.toLowerCase();\n\t}\n    };\n\n    this._zeroPaddingOfSignature = function(hex, bitLength) {\n\tvar s = "";\n\tvar nZero = bitLength / 4 - hex.length;\n\tfor (var i = 0; i < nZero; i++) {\n\t    s = s + "0";\n\t}\n\treturn s + hex;\n    };\n\n    /**\n     * set signature algorithm and provider\n     * @name setAlgAndProvider\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {String} alg signature algorithm name\n     * @param {String} prov provider name\n     * @description\n     * @example\n     * md.setAlgAndProvider(\'SHA1withRSA\', \'cryptojs/jsrsa\');\n     */\n    this.setAlgAndProvider = function(alg, prov) {\n\tthis._setAlgNames();\n\tif (prov != \'cryptojs/jsrsa\')\n\t    throw "provider not supported: " + prov;\n\n\tif (\':md5:sha1:sha224:sha256:sha384:sha512:ripemd160:\'.indexOf(this.mdAlgName) != -1) {\n\t    try {\n\t\tthis.md = new KJUR.crypto.MessageDigest({\'alg\':this.mdAlgName,\'prov\':\'cryptojs\'});\n\t    } catch (ex) {\n\t\tthrow "setAlgAndProvider hash alg set fail alg=" + this.mdAlgName + "/" + ex;\n\t    }\n\n\t    this.initSign = function(prvKey) {\n\t\tthis.prvKey = prvKey;\n\t\tthis.state = "SIGN";\n\t    };\n\n\t    this.initVerifyByPublicKey = function(rsaPubKey) {\n\t\tthis.pubKey = rsaPubKey;\n\t\tthis.state = "VERIFY";\n\t    };\n\n\t    this.initVerifyByCertificatePEM = function(certPEM) {\n\t\tvar x509 = new X509();\n\t\tx509.readCertPEM(certPEM);\n\t\tthis.pubKey = x509.subjectPublicKeyRSA;\n\t\tthis.state = "VERIFY";\n\t    };\n\n\t    this.updateString = function(str) {\n\t\tthis.md.updateString(str);\n\t    };\n\t    this.updateHex = function(hex) {\n\t\tthis.md.updateHex(hex);\n\t    };\n\t    this.sign = function() {\n                var util = KJUR.crypto.Util;\n\t\tvar keyLen = this.prvKey.n.bitLength();\n\t\tthis.sHashHex = this.md.digest();\n\t\tthis.hDigestInfo = util.getDigestInfoHex(this.sHashHex, this.mdAlgName);\n\t\tthis.hPaddedDigestInfo =\n                    util.getPaddedDigestInfoHex(this.sHashHex, this.mdAlgName, keyLen);\n\n\t\tvar biPaddedDigestInfo = parseBigInt(this.hPaddedDigestInfo, 16);\n\t\tthis.hoge = biPaddedDigestInfo.toString(16);\n\n\t\tvar biSign = this.prvKey.doPrivate(biPaddedDigestInfo);\n\t\tthis.hSign = this._zeroPaddingOfSignature(biSign.toString(16), keyLen);\n\t\treturn this.hSign;\n\t    };\n\t    this.signString = function(str) {\n\t\tthis.updateString(str);\n\t\tthis.sign();\n\t    };\n\t    this.signHex = function(hex) {\n\t\tthis.updateHex(hex);\n\t\tthis.sign();\n\t    };\n\t    this.verify = function(hSigVal) {\n                var util = KJUR.crypto.Util;\n\t\tvar keyLen = this.pubKey.n.bitLength();\n\t\tthis.sHashHex = this.md.digest();\n\n\t\tvar biSigVal = parseBigInt(hSigVal, 16);\n\t\tvar biPaddedDigestInfo = this.pubKey.doPublic(biSigVal);\n\t\tthis.hPaddedDigestInfo = biPaddedDigestInfo.toString(16);\n                var s = this.hPaddedDigestInfo;\n                s = s.replace(/^1ff+00/, \'\');\n\n\t\tvar hDIHEAD = KJUR.crypto.Util.DIGESTINFOHEAD[this.mdAlgName];\n                if (s.indexOf(hDIHEAD) != 0) {\n\t\t    return false;\n\t\t}\n\t\tvar hHashFromDI = s.substr(hDIHEAD.length);\n\t\t//alert(hHashFromDI + "\\n" + this.sHashHex);\n\t\treturn (hHashFromDI == this.sHashHex);\n\t    };\n\t}\n    };\n\n    /**\n     * Initialize this object for verifying with a public key\n     * @name initVerifyByPublicKey\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {RSAKey} rsaPubKey RSAKey object of public key\n     * @since 1.0.2\n     * @description\n     * @example\n     * sig.initVerifyByPublicKey(prvKey)\n     */\n    this.initVerifyByPublicKey = function(rsaPubKey) {\n\tthrow "initVerifyByPublicKey(rsaPubKeyy) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * Initialize this object for verifying with a certficate\n     * @name initVerifyByCertificatePEM\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {String} certPEM PEM formatted string of certificate\n     * @since 1.0.2\n     * @description\n     * @example\n     * sig.initVerifyByCertificatePEM(certPEM)\n     */\n    this.initVerifyByCertificatePEM = function(certPEM) {\n\tthrow "initVerifyByCertificatePEM(certPEM) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * Initialize this object for signing\n     * @name initSign\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {RSAKey} prvKey RSAKey object of private key\n     * @description\n     * @example\n     * sig.initSign(prvKey)\n     */\n    this.initSign = function(prvKey) {\n\tthrow "initSign(prvKey) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * Updates the data to be signed or verified by a string\n     * @name updateString\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {String} str string to use for the update\n     * @description\n     * @example\n     * sig.updateString(\'aaa\')\n     */\n    this.updateString = function(str) {\n\tthrow "updateString(str) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * Updates the data to be signed or verified by a hexadecimal string\n     * @name updateHex\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {String} hex hexadecimal string to use for the update\n     * @description\n     * @example\n     * sig.updateHex(\'1f2f3f\')\n     */\n    this.updateHex = function(hex) {\n\tthrow "updateHex(hex) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * Returns the signature bytes of all data updates as a hexadecimal string\n     * @name sign\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @return the signature bytes as a hexadecimal string\n     * @description\n     * @example\n     * var hSigValue = sig.sign()\n     */\n    this.sign = function() {\n\tthrow "sign() not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * performs final update on the sign using string, then returns the signature bytes of all data updates as a hexadecimal string\n     * @name signString\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {String} str string to final update\n     * @return the signature bytes of a hexadecimal string\n     * @description\n     * @example\n     * var hSigValue = sig.signString(\'aaa\')\n     */\n    this.signString = function(str) {\n\tthrow "digestString(str) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * performs final update on the sign using hexadecimal string, then returns the signature bytes of all data updates as a hexadecimal string\n     * @name signHex\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {String} hex hexadecimal string to final update\n     * @return the signature bytes of a hexadecimal string\n     * @description\n     * @example\n     * var hSigValue = sig.signHex(\'1fdc33\')\n     */\n    this.signHex = function(hex) {\n\tthrow "digestHex(hex) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * verifies the passed-in signature.\n     * @name verify\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {String} str string to final update\n     * @return {Boolean} true if the signature was verified, otherwise false\n     * @description\n     * @example\n     * var isValid = sig.verify(\'1fbcefdca4823a7(snip)\')\n     */\n    this.verify = function(hSigVal) {\n\tthrow "verify(hSigVal) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    if (typeof params != "undefined") {\n\tif (typeof params[\'alg\'] != "undefined") {\n\t    this.algName = params[\'alg\'];\n\t    this.provName = params[\'prov\'];\n\t    this.algProvName = params[\'alg\'] + ":" + params[\'prov\'];\n\t    this.setAlgAndProvider(params[\'alg\'], params[\'prov\']);\n\t    this._setAlgNames();\n\t}\n\tif (typeof params[\'prvkeypem\'] != "undefined") {\n\t    if (typeof params[\'prvkeypas\'] != "undefined") {\n\t\tthrow "both prvkeypem and prvkeypas parameters not supported";\n\t    } else {\n\t\ttry {\n\t\t    var prvKey = new RSAKey();\n\t\t    prvKey.readPrivateKeyFromPEMString(params[\'prvkeypem\']);\n\t\t    this.initSign(prvKey);\n\t\t} catch (ex) {\n\t\t    throw "fatal error to load pem private key: " + ex;\n\t\t}\n\t    }\n\t}\n    }\n};\n\n/*! rsapem-1.1.js (c) 2012 Kenji Urushima | kjur.github.com/jsrsasign/license\n */\n//\n// rsa-pem.js - adding function for reading/writing PKCS#1 PEM private key\n//              to RSAKey class.\n//\n// version: 1.1.1 (2013-Apr-12)\n//\n// Copyright (c) 2010-2013 Kenji Urushima (kenji.urushima@gmail.com)\n//\n// This software is licensed under the terms of the MIT License.\n// http://kjur.github.com/jsrsasign/license/\n//\n// The above copyright and license notice shall be\n// included in all copies or substantial portions of the Software.\n//\n//\n// Depends on:\n//\n//\n//\n// _RSApem_pemToBase64(sPEM)\n//\n//   removing PEM header, PEM footer and space characters including\n//   new lines from PEM formatted RSA private key string.\n//\n\n/**\n * @fileOverview\n * @name rsapem-1.1.js\n * @author Kenji Urushima kenji.urushima@gmail.com\n * @version 1.1\n * @license <a href="http://kjur.github.io/jsrsasign/license/">MIT License</a>\n */\nfunction _rsapem_pemToBase64(sPEMPrivateKey) {\n  var s = sPEMPrivateKey;\n  s = s.replace("-----BEGIN RSA PRIVATE KEY-----", "");\n  s = s.replace("-----END RSA PRIVATE KEY-----", "");\n  s = s.replace(/[ \\n]+/g, "");\n  return s;\n}\n\nfunction _rsapem_getPosArrayOfChildrenFromHex(hPrivateKey) {\n  var a = new Array();\n  var v1 = ASN1HEX.getStartPosOfV_AtObj(hPrivateKey, 0);\n  var n1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, v1);\n  var e1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, n1);\n  var d1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, e1);\n  var p1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, d1);\n  var q1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, p1);\n  var dp1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, q1);\n  var dq1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, dp1);\n  var co1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, dq1);\n  a.push(v1, n1, e1, d1, p1, q1, dp1, dq1, co1);\n  return a;\n}\n\nfunction _rsapem_getHexValueArrayOfChildrenFromHex(hPrivateKey) {\n  var posArray = _rsapem_getPosArrayOfChildrenFromHex(hPrivateKey);\n  var v =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[0]);\n  var n =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[1]);\n  var e =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[2]);\n  var d =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[3]);\n  var p =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[4]);\n  var q =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[5]);\n  var dp = ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[6]);\n  var dq = ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[7]);\n  var co = ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[8]);\n  var a = new Array();\n  a.push(v, n, e, d, p, q, dp, dq, co);\n  return a;\n}\n\n/**\n * read RSA private key from a ASN.1 hexadecimal string\n * @name readPrivateKeyFromASN1HexString\n * @memberOf RSAKey#\n * @function\n * @param {String} keyHex ASN.1 hexadecimal string of PKCS#1 private key.\n * @since 1.1.1\n */\nfunction _rsapem_readPrivateKeyFromASN1HexString(keyHex) {\n  var a = _rsapem_getHexValueArrayOfChildrenFromHex(keyHex);\n  this.setPrivateEx(a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);\n}\n\n/**\n * read PKCS#1 private key from a string\n * @name readPrivateKeyFromPEMString\n * @memberOf RSAKey#\n * @function\n * @param {String} keyPEM string of PKCS#1 private key.\n */\nfunction _rsapem_readPrivateKeyFromPEMString(keyPEM) {\n  var keyB64 = _rsapem_pemToBase64(keyPEM);\n  var keyHex = b64tohex(keyB64) // depends base64.js\n  var a = _rsapem_getHexValueArrayOfChildrenFromHex(keyHex);\n  this.setPrivateEx(a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);\n}\n\nRSAKey.prototype.readPrivateKeyFromPEMString = _rsapem_readPrivateKeyFromPEMString;\nRSAKey.prototype.readPrivateKeyFromASN1HexString = _rsapem_readPrivateKeyFromASN1HexString;\n/*! rsasign-1.2.2.js (c) 2012 Kenji Urushima | kjur.github.com/jsrsasign/license\n */\n//\n// rsa-sign.js - adding signing functions to RSAKey class.\n//\n//\n// version: 1.2.2 (13 May 2013)\n//\n// Copyright (c) 2010-2013 Kenji Urushima (kenji.urushima@gmail.com)\n//\n// This software is licensed under the terms of the MIT License.\n// http://kjur.github.com/jsrsasign/license/\n//\n// The above copyright and license notice shall be\n// included in all copies or substantial portions of the Software.\n\n//\n// Depends on:\n//   function sha1.hex(s) of sha1.js\n//   jsbn.js\n//   jsbn2.js\n//   rsa.js\n//   rsa2.js\n//\n\n// keysize / pmstrlen\n//  512 /  128\n// 1024 /  256\n// 2048 /  512\n// 4096 / 1024\n\n/**\n * @fileOverview\n * @name rsasign-1.2.js\n * @author Kenji Urushima kenji.urushima@gmail.com\n * @version 1.2.2\n * @license <a href="http://kjur.github.io/jsrsasign/license/">MIT License</a>\n */\n\n/**\n * @property {Dictionary} _RSASIGN_DIHEAD\n * @description Array of head part of hexadecimal DigestInfo value for hash algorithms.\n * You can add any DigestInfo hash algorith for signing.\n * See PKCS#1 v2.1 spec (p38).\n */\nvar _RSASIGN_DIHEAD = [];\n_RSASIGN_DIHEAD[\'sha1\'] =      "3021300906052b0e03021a05000414";\n_RSASIGN_DIHEAD[\'sha256\'] =    "3031300d060960864801650304020105000420";\n_RSASIGN_DIHEAD[\'sha384\'] =    "3041300d060960864801650304020205000430";\n_RSASIGN_DIHEAD[\'sha512\'] =    "3051300d060960864801650304020305000440";\n_RSASIGN_DIHEAD[\'md2\'] =       "3020300c06082a864886f70d020205000410";\n_RSASIGN_DIHEAD[\'md5\'] =       "3020300c06082a864886f70d020505000410";\n_RSASIGN_DIHEAD[\'ripemd160\'] = "3021300906052b2403020105000414";\n\n/**\n * @property {Dictionary} _RSASIGN_HASHHEXFUNC\n * @description Array of functions which calculate hash and returns it as hexadecimal.\n * You can add any hash algorithm implementations.\n */\nvar _RSASIGN_HASHHEXFUNC = [];\n_RSASIGN_HASHHEXFUNC[\'sha1\'] =      function(s){return KJUR.crypto.Util.sha1(s);};\n_RSASIGN_HASHHEXFUNC[\'sha256\'] =    function(s){return KJUR.crypto.Util.sha256(s);}\n_RSASIGN_HASHHEXFUNC[\'sha512\'] =    function(s){return KJUR.crypto.Util.sha512(s);}\n_RSASIGN_HASHHEXFUNC[\'md5\'] =       function(s){return KJUR.crypto.Util.md5(s);};\n_RSASIGN_HASHHEXFUNC[\'ripemd160\'] = function(s){return KJUR.crypto.Util.ripemd160(s);};\n\n//_RSASIGN_HASHHEXFUNC[\'sha1\'] =   function(s){return sha1.hex(s);}   // http://user1.matsumoto.ne.jp/~goma/js/hash.html\n//_RSASIGN_HASHHEXFUNC[\'sha256\'] = function(s){return sha256.hex;}    // http://user1.matsumoto.ne.jp/~goma/js/hash.html\n\nvar _RE_HEXDECONLY = new RegExp("");\n_RE_HEXDECONLY.compile("[^0-9a-f]", "gi");\n\n// ========================================================================\n// Signature Generation\n// ========================================================================\n\nfunction _rsasign_getHexPaddedDigestInfoForString(s, keySize, hashAlg) {\n    var pmStrLen = keySize / 4;\n    var hashFunc = _RSASIGN_HASHHEXFUNC[hashAlg];\n    var sHashHex = hashFunc(s);\n\n    var sHead = "0001";\n    var sTail = "00" + _RSASIGN_DIHEAD[hashAlg] + sHashHex;\n    var sMid = "";\n    var fLen = pmStrLen - sHead.length - sTail.length;\n    for (var i = 0; i < fLen; i += 2) {\n\tsMid += "ff";\n    }\n    sPaddedMessageHex = sHead + sMid + sTail;\n    return sPaddedMessageHex;\n}\n\nfunction _zeroPaddingOfSignature(hex, bitLength) {\n    var s = "";\n    var nZero = bitLength / 4 - hex.length;\n    for (var i = 0; i < nZero; i++) {\n\ts = s + "0";\n    }\n    return s + hex;\n}\n\n/**\n * sign for a message string with RSA private key.<br/>\n * @name signString\n * @memberOf RSAKey#\n * @function\n * @param {String} s message string to be signed.\n * @param {String} hashAlg hash algorithm name for signing.<br/>\n * @return returns hexadecimal string of signature value.\n */\nfunction _rsasign_signString(s, hashAlg) {\n    //alert("this.n.bitLength() = " + this.n.bitLength());\n    var hPM = _rsasign_getHexPaddedDigestInfoForString(s, this.n.bitLength(), hashAlg);\n    var biPaddedMessage = parseBigInt(hPM, 16);\n    var biSign = this.doPrivate(biPaddedMessage);\n    var hexSign = biSign.toString(16);\n    return _zeroPaddingOfSignature(hexSign, this.n.bitLength());\n}\n\nfunction _rsasign_signStringWithSHA1(s) {\n    return _rsasign_signString.call(this, s, \'sha1\');\n}\n\nfunction _rsasign_signStringWithSHA256(s) {\n    return _rsasign_signString.call(this, s, \'sha256\');\n}\n\n// PKCS#1 (PSS) mask generation function\nfunction pss_mgf1_str(seed, len, hash) {\n    var mask = \'\', i = 0;\n\n    while (mask.length < len) {\n        mask += hash(seed + String.fromCharCode.apply(String, [\n                (i & 0xff000000) >> 24,\n                (i & 0x00ff0000) >> 16,\n                (i & 0x0000ff00) >> 8,\n                i & 0x000000ff]));\n        i += 1;\n    }\n\n    return mask;\n}\n\n/**\n * sign for a message string with RSA private key by PKCS#1 PSS signing.<br/>\n * @name signStringPSS\n * @memberOf RSAKey#\n * @function\n * @param {String} s message string to be signed.\n * @param {String} hashAlg hash algorithm name for signing.<br/>\n * @return returns hexadecimal string of signature value.\n */\nfunction _rsasign_signStringPSS(s, hashAlg, sLen) {\n    var hashFunc = _RSASIGN_HASHRAWFUNC[hashAlg];\n    var mHash = hashFunc(s);\n    var hLen = mHash.length;\n    var emBits = this.n.bitLength() - 1;\n    var emLen = Math.ceil(emBits / 8);\n    var i;\n\n    if (sLen === -1) {\n        sLen = hLen; // same has hash length\n    } else if ((sLen === -2) || (sLen === undefined)) {\n        sLen = emLen - hLen - 2; // maximum\n    } else if (sLen < -2) {\n        throw "invalid salt length";\n    }\n\n    if (emLen < (hLen + sLen + 2)) {\n        throw "data too long";\n    }\n\n    var salt = \'\';\n\n    if (sLen > 0) {\n        salt = new Array(sLen);\n        new SecureRandom().nextBytes(salt);\n        salt = String.fromCharCode.apply(String, salt);\n    }\n\n    var H = hashFunc(\'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\' + mHash + salt);\n    var PS = [];\n\n    for (i = 0; i < emLen - sLen - hLen - 2; i += 1) {\n        PS[i] = 0x00;\n    }\n\n    var DB = String.fromCharCode.apply(String, PS) + \'\\x01\' + salt;\n    var dbMask = pss_mgf1_str(H, DB.length, hashFunc);\n    var maskedDB = [];\n\n    for (i = 0; i < DB.length; i += 1) {\n        maskedDB[i] = DB.charCodeAt(i) ^ dbMask.charCodeAt(i);\n    }\n\n    var mask = (0xff00 >> (8 * emLen - emBits)) & 0xff;\n    maskedDB[0] &= ~mask;\n\n    for (i = 0; i < hLen; i++) {\n        maskedDB.push(H.charCodeAt(i));\n    }\n\n    maskedDB.push(0xbc);\n\n    return _zeroPaddingOfSignature(\n            this.doPrivate(new BigInteger(maskedDB)).toString(16),\n            this.n.bitLength());\n}\n\n// ========================================================================\n// Signature Verification\n// ========================================================================\n\nfunction _rsasign_getDecryptSignatureBI(biSig, hN, hE) {\n    var rsa = new RSAKey();\n    rsa.setPublic(hN, hE);\n    var biDecryptedSig = rsa.doPublic(biSig);\n    return biDecryptedSig;\n}\n\nfunction _rsasign_getHexDigestInfoFromSig(biSig, hN, hE) {\n    var biDecryptedSig = _rsasign_getDecryptSignatureBI(biSig, hN, hE);\n    var hDigestInfo = biDecryptedSig.toString(16).replace(/^1f+00/, \'\');\n    return hDigestInfo;\n}\n\nfunction _rsasign_getAlgNameAndHashFromHexDisgestInfo(hDigestInfo) {\n    for (var algName in _RSASIGN_DIHEAD) {\n\tvar head = _RSASIGN_DIHEAD[algName];\n\tvar len = head.length;\n\tif (hDigestInfo.substring(0, len) == head) {\n\t    var a = [algName, hDigestInfo.substring(len)];\n\t    return a;\n\t}\n    }\n    return [];\n}\n\nfunction _rsasign_verifySignatureWithArgs(sMsg, biSig, hN, hE) {\n    var hDigestInfo = _rsasign_getHexDigestInfoFromSig(biSig, hN, hE);\n    var digestInfoAry = _rsasign_getAlgNameAndHashFromHexDisgestInfo(hDigestInfo);\n    if (digestInfoAry.length == 0) return false;\n    var algName = digestInfoAry[0];\n    var diHashValue = digestInfoAry[1];\n    var ff = _RSASIGN_HASHHEXFUNC[algName];\n    var msgHashValue = ff(sMsg);\n    return (diHashValue == msgHashValue);\n}\n\nfunction _rsasign_verifyHexSignatureForMessage(hSig, sMsg) {\n    var biSig = parseBigInt(hSig, 16);\n    var result = _rsasign_verifySignatureWithArgs(sMsg, biSig,\n\t\t\t\t\t\t  this.n.toString(16),\n\t\t\t\t\t\t  this.e.toString(16));\n    return result;\n}\n\n/**\n * verifies a sigature for a message string with RSA public key.<br/>\n * @name verifyString\n * @memberOf RSAKey#\n * @function\n * @param {String} sMsg message string to be verified.\n * @param {String} hSig hexadecimal string of siganture.<br/>\n *                 non-hexadecimal charactors including new lines will be ignored.\n * @return returns 1 if valid, otherwise 0\n */\nfunction _rsasign_verifyString(sMsg, hSig) {\n    hSig = hSig.replace(_RE_HEXDECONLY, \'\');\n    if (hSig.length != this.n.bitLength() / 4) return 0;\n    hSig = hSig.replace(/[ \\n]+/g, "");\n    var biSig = parseBigInt(hSig, 16);\n    var biDecryptedSig = this.doPublic(biSig);\n    var hDigestInfo = biDecryptedSig.toString(16).replace(/^1f+00/, \'\');\n    var digestInfoAry = _rsasign_getAlgNameAndHashFromHexDisgestInfo(hDigestInfo);\n\n    if (digestInfoAry.length == 0) return false;\n    var algName = digestInfoAry[0];\n    var diHashValue = digestInfoAry[1];\n    var ff = _RSASIGN_HASHHEXFUNC[algName];\n    var msgHashValue = ff(sMsg);\n    return (diHashValue == msgHashValue);\n}\n\n/**\n * verifies a sigature for a message string with RSA public key by PKCS#1 PSS sign.<br/>\n * @name verifyStringPSS\n * @memberOf RSAKey#\n * @function\n * @param {String} sMsg message string to be verified.\n * @param {String} hSig hexadecimal string of siganture.<br/>\n *                 non-hexadecimal charactors including new lines will be ignored.\n * @return returns 1 if valid, otherwise 0\n */\nfunction _rsasign_verifyStringPSS(sMsg, hSig, hashAlg, sLen) {\n    if (hSig.length !== this.n.bitLength() / 4) {\n        return false;\n    }\n\n    var hashFunc = _RSASIGN_HASHRAWFUNC[hashAlg];\n    var mHash = hashFunc(sMsg);\n    var hLen = mHash.length;\n    var emBits = this.n.bitLength() - 1;\n    var emLen = Math.ceil(emBits / 8);\n    var i;\n\n    if (sLen === -1) {\n        sLen = hLen; // same has hash length\n    } else if ((sLen === -2) || (sLen === undefined)) {\n        sLen = emLen - hLen - 2; // maximum\n    } else if (sLen < -2) {\n        throw "invalid salt length";\n    }\n\n    if (emLen < (hLen + sLen + 2)) {\n        throw "data too long";\n    }\n\n    var em = this.doPublic(parseBigInt(hSig, 16)).toByteArray();\n\n    for (i = 0; i < em.length; i += 1) {\n        em[i] &= 0xff;\n    }\n\n    while (em.length < emLen) {\n        em.unshift(0);\n    }\n\n    if (em[emLen -1] !== 0xbc) {\n        throw "encoded message does not end in 0xbc";\n    }\n\n    em = String.fromCharCode.apply(String, em);\n\n    var maskedDB = em.substr(0, emLen - hLen - 1);\n    var H = em.substr(maskedDB.length, hLen);\n\n    var mask = (0xff00 >> (8 * emLen - emBits)) & 0xff;\n\n    if ((maskedDB.charCodeAt(0) & mask) !== 0) {\n        throw "bits beyond keysize not zero";\n    }\n\n    var dbMask = pss_mgf1_str(H, maskedDB.length, hashFunc);\n    var DB = [];\n\n    for (i = 0; i < maskedDB.length; i += 1) {\n        DB[i] = maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i);\n    }\n\n    DB[0] &= ~mask;\n\n    var checkLen = emLen - hLen - sLen - 2;\n\n    for (i = 0; i < checkLen; i += 1) {\n        if (DB[i] !== 0x00) {\n            throw "leftmost octets not zero";\n        }\n    }\n\n    if (DB[checkLen] !== 0x01) {\n        throw "0x01 marker not found";\n    }\n\n    return H === hashFunc(\'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\' + mHash +\n                          String.fromCharCode.apply(String, DB.slice(-sLen)));\n}\n\nRSAKey.prototype.signString = _rsasign_signString;\nRSAKey.prototype.signStringWithSHA1 = _rsasign_signStringWithSHA1;\nRSAKey.prototype.signStringWithSHA256 = _rsasign_signStringWithSHA256;\nRSAKey.prototype.sign = _rsasign_signString;\nRSAKey.prototype.signWithSHA1 = _rsasign_signStringWithSHA1;\nRSAKey.prototype.signWithSHA256 = _rsasign_signStringWithSHA256;\nRSAKey.prototype.signStringPSS = _rsasign_signStringPSS;\nRSAKey.prototype.signPSS = _rsasign_signStringPSS;\nRSAKey.SALT_LEN_HLEN = -1;\nRSAKey.SALT_LEN_MAX = -2;\n\nRSAKey.prototype.verifyString = _rsasign_verifyString;\nRSAKey.prototype.verifyHexSignatureForMessage = _rsasign_verifyHexSignatureForMessage;\nRSAKey.prototype.verify = _rsasign_verifyString;\nRSAKey.prototype.verifyHexSignatureForByteArrayMessage = _rsasign_verifyHexSignatureForMessage;\nRSAKey.prototype.verifyStringPSS = _rsasign_verifyStringPSS;\nRSAKey.prototype.verifyPSS = _rsasign_verifyStringPSS;\nRSAKey.SALT_LEN_RECOVER = -2;\n\n/**\n * @name RSAKey\n * @class key of RSA public key algorithm\n * @description Tom Wu\'s RSA Key class and extension\n */\n/*! asn1hex-1.1.js (c) 2012 Kenji Urushima | kjur.github.com/jsrsasign/license\n */\n//\n// asn1hex.js - Hexadecimal represented ASN.1 string library\n//\n// version: 1.1 (09-May-2012)\n//\n// Copyright (c) 2010-2012 Kenji Urushima (kenji.urushima@gmail.com)\n//\n// This software is licensed under the terms of the MIT License.\n// http://kjur.github.com/jsrsasign/license/\n//\n// The above copyright and license notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// Depends on:\n//\n\n// MEMO:\n//   f(\'3082025b02...\', 2) ... 82025b ... 3bytes\n//   f(\'020100\', 2) ... 01 ... 1byte\n//   f(\'0203001...\', 2) ... 03 ... 1byte\n//   f(\'02818003...\', 2) ... 8180 ... 2bytes\n//   f(\'3080....0000\', 2) ... 80 ... -1\n//\n//   Requirements:\n//   - ASN.1 type octet length MUST be 1.\n//     (i.e. ASN.1 primitives like SET, SEQUENCE, INTEGER, OCTETSTRING ...)\n//   -\n\n/**\n * @fileOverview\n * @name asn1hex-1.1.js\n * @author Kenji Urushima kenji.urushima@gmail.com\n * @version 1.1\n * @license <a href="http://kjur.github.io/jsrsasign/license/">MIT License</a>\n */\n\n/**\n * get byte length for ASN.1 L(length) bytes\n * @name getByteLengthOfL_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} pos string index\n * @return byte length for ASN.1 L(length) bytes\n */\nfunction _asnhex_getByteLengthOfL_AtObj(s, pos) {\n  if (s.substring(pos + 2, pos + 3) != \'8\') return 1;\n  var i = parseInt(s.substring(pos + 3, pos + 4));\n  if (i == 0) return -1; \t\t// length octet \'80\' indefinite length\n  if (0 < i && i < 10) return i + 1;\t// including \'8?\' octet;\n  return -2;\t\t\t\t// malformed format\n}\n\n\n/**\n * get hexadecimal string for ASN.1 L(length) bytes\n * @name getHexOfL_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} pos string index\n * @return {String} hexadecimal string for ASN.1 L(length) bytes\n */\nfunction _asnhex_getHexOfL_AtObj(s, pos) {\n  var len = _asnhex_getByteLengthOfL_AtObj(s, pos);\n  if (len < 1) return \'\';\n  return s.substring(pos + 2, pos + 2 + len * 2);\n}\n\n//\n//   getting ASN.1 length value at the position \'idx\' of\n//   hexa decimal string \'s\'.\n//\n//   f(\'3082025b02...\', 0) ... 82025b ... ???\n//   f(\'020100\', 0) ... 01 ... 1\n//   f(\'0203001...\', 0) ... 03 ... 3\n//   f(\'02818003...\', 0) ... 8180 ... 128\n/**\n * get integer value of ASN.1 length for ASN.1 data\n * @name getIntOfL_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} pos string index\n * @return ASN.1 L(length) integer value\n */\nfunction _asnhex_getIntOfL_AtObj(s, pos) {\n  var hLength = _asnhex_getHexOfL_AtObj(s, pos);\n  if (hLength == \'\') return -1;\n  var bi;\n  if (parseInt(hLength.substring(0, 1)) < 8) {\n     bi = parseBigInt(hLength, 16);\n  } else {\n     bi = parseBigInt(hLength.substring(2), 16);\n  }\n  return bi.intValue();\n}\n\n/**\n * get ASN.1 value starting string position for ASN.1 object refered by index \'idx\'.\n * @name getStartPosOfV_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} pos string index\n */\nfunction _asnhex_getStartPosOfV_AtObj(s, pos) {\n  var l_len = _asnhex_getByteLengthOfL_AtObj(s, pos);\n  if (l_len < 0) return l_len;\n  return pos + (l_len + 1) * 2;\n}\n\n/**\n * get hexadecimal string of ASN.1 V(value)\n * @name getHexOfV_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} pos string index\n * @return {String} hexadecimal string of ASN.1 value.\n */\nfunction _asnhex_getHexOfV_AtObj(s, pos) {\n  var pos1 = _asnhex_getStartPosOfV_AtObj(s, pos);\n  var len = _asnhex_getIntOfL_AtObj(s, pos);\n  return s.substring(pos1, pos1 + len * 2);\n}\n\n/**\n * get hexadecimal string of ASN.1 TLV at\n * @name getHexOfTLV_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} pos string index\n * @return {String} hexadecimal string of ASN.1 TLV.\n * @since 1.1\n */\nfunction _asnhex_getHexOfTLV_AtObj(s, pos) {\n  var hT = s.substr(pos, 2);\n  var hL = _asnhex_getHexOfL_AtObj(s, pos);\n  var hV = _asnhex_getHexOfV_AtObj(s, pos);\n  return hT + hL + hV;\n}\n\n/**\n * get next sibling starting index for ASN.1 object string\n * @name getPosOfNextSibling_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} pos string index\n * @return next sibling starting index for ASN.1 object string\n */\nfunction _asnhex_getPosOfNextSibling_AtObj(s, pos) {\n  var pos1 = _asnhex_getStartPosOfV_AtObj(s, pos);\n  var len = _asnhex_getIntOfL_AtObj(s, pos);\n  return pos1 + len * 2;\n}\n\n/**\n * get array of indexes of child ASN.1 objects\n * @name getPosArrayOfChildren_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} start string index of ASN.1 object\n * @return {Array of Number} array of indexes for childen of ASN.1 objects\n */\nfunction _asnhex_getPosArrayOfChildren_AtObj(h, pos) {\n  var a = new Array();\n  var p0 = _asnhex_getStartPosOfV_AtObj(h, pos);\n  a.push(p0);\n\n  var len = _asnhex_getIntOfL_AtObj(h, pos);\n  var p = p0;\n  var k = 0;\n  while (1) {\n    var pNext = _asnhex_getPosOfNextSibling_AtObj(h, p);\n    if (pNext == null || (pNext - p0  >= (len * 2))) break;\n    if (k >= 200) break;\n\n    a.push(pNext);\n    p = pNext;\n\n    k++;\n  }\n\n  return a;\n}\n\n/**\n * get string index of nth child object of ASN.1 object refered by h, idx\n * @name getNthChildIndex_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} h hexadecimal string of ASN.1 DER encoded data\n * @param {Number} idx start string index of ASN.1 object\n * @param {Number} nth for child\n * @return {Number} string index of nth child.\n * @since 1.1\n */\nfunction _asnhex_getNthChildIndex_AtObj(h, idx, nth) {\n  var a = _asnhex_getPosArrayOfChildren_AtObj(h, idx);\n  return a[nth];\n}\n\n// ========== decendant methods ==============================\n\n/**\n * get string index of nth child object of ASN.1 object refered by h, idx\n * @name getDecendantIndexByNthList\n * @memberOf ASN1HEX\n * @function\n * @param {String} h hexadecimal string of ASN.1 DER encoded data\n * @param {Number} currentIndex start string index of ASN.1 object\n * @param {Array of Number} nthList array list of nth\n * @return {Number} string index refered by nthList\n * @since 1.1\n */\nfunction _asnhex_getDecendantIndexByNthList(h, currentIndex, nthList) {\n  if (nthList.length == 0) {\n    return currentIndex;\n  }\n  var firstNth = nthList.shift();\n  var a = _asnhex_getPosArrayOfChildren_AtObj(h, currentIndex);\n  return _asnhex_getDecendantIndexByNthList(h, a[firstNth], nthList);\n}\n\n/**\n * get hexadecimal string of ASN.1 TLV refered by current index and nth index list.\n * @name getDecendantHexTLVByNthList\n * @memberOf ASN1HEX\n * @function\n * @param {String} h hexadecimal string of ASN.1 DER encoded data\n * @param {Number} currentIndex start string index of ASN.1 object\n * @param {Array of Number} nthList array list of nth\n * @return {Number} hexadecimal string of ASN.1 TLV refered by nthList\n * @since 1.1\n */\nfunction _asnhex_getDecendantHexTLVByNthList(h, currentIndex, nthList) {\n  var idx = _asnhex_getDecendantIndexByNthList(h, currentIndex, nthList);\n  return _asnhex_getHexOfTLV_AtObj(h, idx);\n}\n\n/**\n * get hexadecimal string of ASN.1 V refered by current index and nth index list.\n * @name getDecendantHexVByNthList\n * @memberOf ASN1HEX\n * @function\n * @param {String} h hexadecimal string of ASN.1 DER encoded data\n * @param {Number} currentIndex start string index of ASN.1 object\n * @param {Array of Number} nthList array list of nth\n * @return {Number} hexadecimal string of ASN.1 V refered by nthList\n * @since 1.1\n */\nfunction _asnhex_getDecendantHexVByNthList(h, currentIndex, nthList) {\n  var idx = _asnhex_getDecendantIndexByNthList(h, currentIndex, nthList);\n  return _asnhex_getHexOfV_AtObj(h, idx);\n}\n\n// ========== class definition ==============================\n\n/**\n * ASN.1 DER encoded hexadecimal string utility class\n * @class ASN.1 DER encoded hexadecimal string utility class\n * @author Kenji Urushima\n * @version 1.1 (09 May 2012)\n * @see <a href="http://kjur.github.com/jsrsasigns/">\'jwrsasign\'(RSA Sign JavaScript Library) home page http://kjur.github.com/jsrsasign/</a>\n * @since 1.1\n */\nfunction ASN1HEX() {\n  return ASN1HEX;\n}\n\nASN1HEX.getByteLengthOfL_AtObj = _asnhex_getByteLengthOfL_AtObj;\nASN1HEX.getHexOfL_AtObj = _asnhex_getHexOfL_AtObj;\nASN1HEX.getIntOfL_AtObj = _asnhex_getIntOfL_AtObj;\nASN1HEX.getStartPosOfV_AtObj = _asnhex_getStartPosOfV_AtObj;\nASN1HEX.getHexOfV_AtObj = _asnhex_getHexOfV_AtObj;\nASN1HEX.getHexOfTLV_AtObj = _asnhex_getHexOfTLV_AtObj;\nASN1HEX.getPosOfNextSibling_AtObj = _asnhex_getPosOfNextSibling_AtObj;\nASN1HEX.getPosArrayOfChildren_AtObj = _asnhex_getPosArrayOfChildren_AtObj;\nASN1HEX.getNthChildIndex_AtObj = _asnhex_getNthChildIndex_AtObj;\nASN1HEX.getDecendantIndexByNthList = _asnhex_getDecendantIndexByNthList;\nASN1HEX.getDecendantHexVByNthList = _asnhex_getDecendantHexVByNthList;\nASN1HEX.getDecendantHexTLVByNthList = _asnhex_getDecendantHexTLVByNthList;\n/*! x509-1.1.js (c) 2012 Kenji Urushima | kjur.github.com/jsrsasign/license\n */\n//\n// x509.js - X509 class to read subject public key from certificate.\n//\n// version: 1.1 (10-May-2012)\n//\n// Copyright (c) 2010-2012 Kenji Urushima (kenji.urushima@gmail.com)\n//\n// This software is licensed under the terms of the MIT License.\n// http://kjur.github.com/jsrsasign/license\n//\n// The above copyright and license notice shall be\n// included in all copies or substantial portions of the Software.\n//\n\n// Depends:\n//   base64.js\n//   rsa.js\n//   asn1hex.js\n\n/**\n * @fileOverview\n * @name x509-1.1.js\n * @author Kenji Urushima kenji.urushima@gmail.com\n * @version 1.1\n * @license <a href="http://kjur.github.io/jsrsasign/license/">MIT License</a>\n */\n\nfunction _x509_pemToBase64(sCertPEM) {\n  var s = sCertPEM;\n  s = s.replace("-----BEGIN CERTIFICATE-----", "");\n  s = s.replace("-----END CERTIFICATE-----", "");\n  s = s.replace(/[ \\n]+/g, "");\n  return s;\n}\n\nfunction _x509_pemToHex(sCertPEM) {\n  var b64Cert = _x509_pemToBase64(sCertPEM);\n  var hCert = b64tohex(b64Cert);\n  return hCert;\n}\n\nfunction _x509_getHexTbsCertificateFromCert(hCert) {\n  var pTbsCert = ASN1HEX.getStartPosOfV_AtObj(hCert, 0);\n  return pTbsCert;\n}\n\n// NOTE: privateKeyUsagePeriod field of X509v2 not supported.\n// NOTE: v1 and v3 supported\nfunction _x509_getSubjectPublicKeyInfoPosFromCertHex(hCert) {\n  var pTbsCert = ASN1HEX.getStartPosOfV_AtObj(hCert, 0);\n  var a = ASN1HEX.getPosArrayOfChildren_AtObj(hCert, pTbsCert);\n  if (a.length < 1) return -1;\n  if (hCert.substring(a[0], a[0] + 10) == "a003020102") { // v3\n    if (a.length < 6) return -1;\n    return a[6];\n  } else {\n    if (a.length < 5) return -1;\n    return a[5];\n  }\n}\n\n// NOTE: Without BITSTRING encapsulation.\nfunction _x509_getSubjectPublicKeyPosFromCertHex(hCert) {\n  var pInfo = _x509_getSubjectPublicKeyInfoPosFromCertHex(hCert);\n  if (pInfo == -1) return -1;\n  var a = ASN1HEX.getPosArrayOfChildren_AtObj(hCert, pInfo);\n  if (a.length != 2) return -1;\n  var pBitString = a[1];\n  if (hCert.substring(pBitString, pBitString + 2) != \'03\') return -1;\n  var pBitStringV = ASN1HEX.getStartPosOfV_AtObj(hCert, pBitString);\n\n  if (hCert.substring(pBitStringV, pBitStringV + 2) != \'00\') return -1;\n  return pBitStringV + 2;\n}\n\nfunction _x509_getPublicKeyHexArrayFromCertHex(hCert) {\n  var p = _x509_getSubjectPublicKeyPosFromCertHex(hCert);\n  var a = ASN1HEX.getPosArrayOfChildren_AtObj(hCert, p);\n  if (a.length != 2) return [];\n  var hN = ASN1HEX.getHexOfV_AtObj(hCert, a[0]);\n  var hE = ASN1HEX.getHexOfV_AtObj(hCert, a[1]);\n  if (hN != null && hE != null) {\n    return [hN, hE];\n  } else {\n    return [];\n  }\n}\n\nfunction _x509_getPublicKeyHexArrayFromCertPEM(sCertPEM) {\n  var hCert = _x509_pemToHex(sCertPEM);\n  var a = _x509_getPublicKeyHexArrayFromCertHex(hCert);\n  return a;\n}\n\n// ===== get basic fields from hex =====================================\n/**\n * get hexadecimal string of serialNumber field of certificate.<br/>\n * @name getSerialNumberHex\n * @memberOf X509#\n * @function\n */\nfunction _x509_getSerialNumberHex() {\n  return ASN1HEX.getDecendantHexVByNthList(this.hex, 0, [0, 1]);\n}\n\n/**\n * get hexadecimal string of issuer field of certificate.<br/>\n * @name getIssuerHex\n * @memberOf X509#\n * @function\n */\nfunction _x509_getIssuerHex() {\n  return ASN1HEX.getDecendantHexTLVByNthList(this.hex, 0, [0, 3]);\n}\n\n/**\n * get string of issuer field of certificate.<br/>\n * @name getIssuerString\n * @memberOf X509#\n * @function\n */\nfunction _x509_getIssuerString() {\n  return _x509_hex2dn(ASN1HEX.getDecendantHexTLVByNthList(this.hex, 0, [0, 3]));\n}\n\n/**\n * get hexadecimal string of subject field of certificate.<br/>\n * @name getSubjectHex\n * @memberOf X509#\n * @function\n */\nfunction _x509_getSubjectHex() {\n  return ASN1HEX.getDecendantHexTLVByNthList(this.hex, 0, [0, 5]);\n}\n\n/**\n * get string of subject field of certificate.<br/>\n * @name getSubjectString\n * @memberOf X509#\n * @function\n */\nfunction _x509_getSubjectString() {\n  return _x509_hex2dn(ASN1HEX.getDecendantHexTLVByNthList(this.hex, 0, [0, 5]));\n}\n\n/**\n * get notBefore field string of certificate.<br/>\n * @name getNotBefore\n * @memberOf X509#\n * @function\n */\nfunction _x509_getNotBefore() {\n  var s = ASN1HEX.getDecendantHexVByNthList(this.hex, 0, [0, 4, 0]);\n  s = s.replace(/(..)/g, "%$1");\n  s = decodeURIComponent(s);\n  return s;\n}\n\n/**\n * get notAfter field string of certificate.<br/>\n * @name getNotAfter\n * @memberOf X509#\n * @function\n */\nfunction _x509_getNotAfter() {\n  var s = ASN1HEX.getDecendantHexVByNthList(this.hex, 0, [0, 4, 1]);\n  s = s.replace(/(..)/g, "%$1");\n  s = decodeURIComponent(s);\n  return s;\n}\n\n// ===== read certificate =====================================\n\n_x509_DN_ATTRHEX = {\n    "0603550406": "C",\n    "060355040a": "O",\n    "060355040b": "OU",\n    "0603550403": "CN",\n    "0603550405": "SN",\n    "0603550408": "ST",\n    "0603550407": "L" };\n\nfunction _x509_hex2dn(hDN) {\n  var s = "";\n  var a = ASN1HEX.getPosArrayOfChildren_AtObj(hDN, 0);\n  for (var i = 0; i < a.length; i++) {\n    var hRDN = ASN1HEX.getHexOfTLV_AtObj(hDN, a[i]);\n    s = s + "/" + _x509_hex2rdn(hRDN);\n  }\n  return s;\n}\n\nfunction _x509_hex2rdn(hRDN) {\n    var hType = ASN1HEX.getDecendantHexTLVByNthList(hRDN, 0, [0, 0]);\n    var hValue = ASN1HEX.getDecendantHexVByNthList(hRDN, 0, [0, 1]);\n    var type = "";\n    try { type = _x509_DN_ATTRHEX[hType]; } catch (ex) { type = hType; }\n    hValue = hValue.replace(/(..)/g, "%$1");\n    var value = decodeURIComponent(hValue);\n    return type + "=" + value;\n}\n\n// ===== read certificate =====================================\n\n\n/**\n * read PEM formatted X.509 certificate from string.<br/>\n * @name readCertPEM\n * @memberOf X509#\n * @function\n * @param {String} sCertPEM string for PEM formatted X.509 certificate\n */\nfunction _x509_readCertPEM(sCertPEM) {\n  var hCert = _x509_pemToHex(sCertPEM);\n  var a = _x509_getPublicKeyHexArrayFromCertHex(hCert);\n  var rsa = new RSAKey();\n  rsa.setPublic(a[0], a[1]);\n  this.subjectPublicKeyRSA = rsa;\n  this.subjectPublicKeyRSA_hN = a[0];\n  this.subjectPublicKeyRSA_hE = a[1];\n  this.hex = hCert;\n}\n\nfunction _x509_readCertPEMWithoutRSAInit(sCertPEM) {\n  var hCert = _x509_pemToHex(sCertPEM);\n  var a = _x509_getPublicKeyHexArrayFromCertHex(hCert);\n  this.subjectPublicKeyRSA.setPublic(a[0], a[1]);\n  this.subjectPublicKeyRSA_hN = a[0];\n  this.subjectPublicKeyRSA_hE = a[1];\n  this.hex = hCert;\n}\n\n/**\n * X.509 certificate class.<br/>\n * @class X.509 certificate class\n * @property {RSAKey} subjectPublicKeyRSA Tom Wu\'s RSAKey object\n * @property {String} subjectPublicKeyRSA_hN hexadecimal string for modulus of RSA public key\n * @property {String} subjectPublicKeyRSA_hE hexadecimal string for public exponent of RSA public key\n * @property {String} hex hexacedimal string for X.509 certificate.\n * @author Kenji Urushima\n * @version 1.0.1 (08 May 2012)\n * @see <a href="http://kjur.github.com/jsrsasigns/">\'jwrsasign\'(RSA Sign JavaScript Library) home page http://kjur.github.com/jsrsasign/</a>\n */\nfunction X509() {\n  this.subjectPublicKeyRSA = null;\n  this.subjectPublicKeyRSA_hN = null;\n  this.subjectPublicKeyRSA_hE = null;\n  this.hex = null;\n}\n\nX509.prototype.readCertPEM = _x509_readCertPEM;\nX509.prototype.readCertPEMWithoutRSAInit = _x509_readCertPEMWithoutRSAInit;\nX509.prototype.getSerialNumberHex = _x509_getSerialNumberHex;\nX509.prototype.getIssuerHex = _x509_getIssuerHex;\nX509.prototype.getSubjectHex = _x509_getSubjectHex;\nX509.prototype.getIssuerString = _x509_getIssuerString;\nX509.prototype.getSubjectString = _x509_getSubjectString;\nX509.prototype.getNotBefore = _x509_getNotBefore;\nX509.prototype.getNotAfter = _x509_getNotAfter;\n\n// Copyright (c) 2005  Tom Wu\n// All Rights Reserved.\n// See "LICENSE" for details.\n\n// Basic JavaScript BN library - subset useful for RSA encryption.\n\n// Bits per digit\nvar dbits;\n\n// JavaScript engine analysis\nvar canary = 0xdeadbeefcafe;\nvar j_lm = ((canary&0xffffff)==0xefcafe);\n\n// (public) Constructor\nfunction BigInteger(a,b,c) {\n  if(a != null)\n    if("number" == typeof a) this.fromNumber(a,b,c);\n    else if(b == null && "string" != typeof a) this.fromString(a,256);\n    else this.fromString(a,b);\n}\n\n// return new, unset BigInteger\nfunction nbi() { return new BigInteger(null); }\n\n// am: Compute w_j += (x*this_i), propagate carries,\n// c is initial carry, returns final carry.\n// c < 3*dvalue, x < 2*dvalue, this_i < dvalue\n// We need to select the fastest one that works in this environment.\n\n// am1: use a single mult and divide to get the high bits,\n// max digit bits should be 26 because\n// max internal value = 2*dvalue^2-2*dvalue (< 2^53)\nfunction am1(i,x,w,j,c,n) {\n  while(--n >= 0) {\n    var v = x*this[i++]+w[j]+c;\n    c = Math.floor(v/0x4000000);\n    w[j++] = v&0x3ffffff;\n  }\n  return c;\n}\n// am2 avoids a big mult-and-extract completely.\n// Max digit bits should be <= 30 because we do bitwise ops\n// on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)\nfunction am2(i,x,w,j,c,n) {\n  var xl = x&0x7fff, xh = x>>15;\n  while(--n >= 0) {\n    var l = this[i]&0x7fff;\n    var h = this[i++]>>15;\n    var m = xh*l+h*xl;\n    l = xl*l+((m&0x7fff)<<15)+w[j]+(c&0x3fffffff);\n    c = (l>>>30)+(m>>>15)+xh*h+(c>>>30);\n    w[j++] = l&0x3fffffff;\n  }\n  return c;\n}\n// Alternately, set max digit bits to 28 since some\n// browsers slow down when dealing with 32-bit numbers.\nfunction am3(i,x,w,j,c,n) {\n  var xl = x&0x3fff, xh = x>>14;\n  while(--n >= 0) {\n    var l = this[i]&0x3fff;\n    var h = this[i++]>>14;\n    var m = xh*l+h*xl;\n    l = xl*l+((m&0x3fff)<<14)+w[j]+c;\n    c = (l>>28)+(m>>14)+xh*h;\n    w[j++] = l&0xfffffff;\n  }\n  return c;\n}\nif(j_lm && (navigator.appName == "Microsoft Internet Explorer")) {\n  BigInteger.prototype.am = am2;\n  dbits = 30;\n}\nelse if(j_lm && (navigator.appName != "Netscape")) {\n  BigInteger.prototype.am = am1;\n  dbits = 26;\n}\nelse { // Mozilla/Netscape seems to prefer am3\n  BigInteger.prototype.am = am3;\n  dbits = 28;\n}\n\nBigInteger.prototype.DB = dbits;\nBigInteger.prototype.DM = ((1<<dbits)-1);\nBigInteger.prototype.DV = (1<<dbits);\n\nvar BI_FP = 52;\nBigInteger.prototype.FV = Math.pow(2,BI_FP);\nBigInteger.prototype.F1 = BI_FP-dbits;\nBigInteger.prototype.F2 = 2*dbits-BI_FP;\n\n// Digit conversions\nvar BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";\nvar BI_RC = new Array();\nvar rr,vv;\nrr = "0".charCodeAt(0);\nfor(vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;\nrr = "a".charCodeAt(0);\nfor(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\nrr = "A".charCodeAt(0);\nfor(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n\nfunction int2char(n) { return BI_RM.charAt(n); }\nfunction intAt(s,i) {\n  var c = BI_RC[s.charCodeAt(i)];\n  return (c==null)?-1:c;\n}\n\n// (protected) copy this to r\nfunction bnpCopyTo(r) {\n  for(var i = this.t-1; i >= 0; --i) r[i] = this[i];\n  r.t = this.t;\n  r.s = this.s;\n}\n\n// (protected) set from integer value x, -DV <= x < DV\nfunction bnpFromInt(x) {\n  this.t = 1;\n  this.s = (x<0)?-1:0;\n  if(x > 0) this[0] = x;\n  else if(x < -1) this[0] = x+DV;\n  else this.t = 0;\n}\n\n// return bigint initialized to value\nfunction nbv(i) { var r = nbi(); r.fromInt(i); return r; }\n\n// (protected) set from string and radix\nfunction bnpFromString(s,b) {\n  var k;\n  if(b == 16) k = 4;\n  else if(b == 8) k = 3;\n  else if(b == 256) k = 8; // byte array\n  else if(b == 2) k = 1;\n  else if(b == 32) k = 5;\n  else if(b == 4) k = 2;\n  else { this.fromRadix(s,b); return; }\n  this.t = 0;\n  this.s = 0;\n  var i = s.length, mi = false, sh = 0;\n  while(--i >= 0) {\n    var x = (k==8)?s[i]&0xff:intAt(s,i);\n    if(x < 0) {\n      if(s.charAt(i) == "-") mi = true;\n      continue;\n    }\n    mi = false;\n    if(sh == 0)\n      this[this.t++] = x;\n    else if(sh+k > this.DB) {\n      this[this.t-1] |= (x&((1<<(this.DB-sh))-1))<<sh;\n      this[this.t++] = (x>>(this.DB-sh));\n    }\n    else\n      this[this.t-1] |= x<<sh;\n    sh += k;\n    if(sh >= this.DB) sh -= this.DB;\n  }\n  if(k == 8 && (s[0]&0x80) != 0) {\n    this.s = -1;\n    if(sh > 0) this[this.t-1] |= ((1<<(this.DB-sh))-1)<<sh;\n  }\n  this.clamp();\n  if(mi) BigInteger.ZERO.subTo(this,this);\n}\n\n// (protected) clamp off excess high words\nfunction bnpClamp() {\n  var c = this.s&this.DM;\n  while(this.t > 0 && this[this.t-1] == c) --this.t;\n}\n\n// (public) return string representation in given radix\nfunction bnToString(b) {\n  if(this.s < 0) return "-"+this.negate().toString(b);\n  var k;\n  if(b == 16) k = 4;\n  else if(b == 8) k = 3;\n  else if(b == 2) k = 1;\n  else if(b == 32) k = 5;\n  else if(b == 4) k = 2;\n  else return this.toRadix(b);\n  var km = (1<<k)-1, d, m = false, r = "", i = this.t;\n  var p = this.DB-(i*this.DB)%k;\n  if(i-- > 0) {\n    if(p < this.DB && (d = this[i]>>p) > 0) { m = true; r = int2char(d); }\n    while(i >= 0) {\n      if(p < k) {\n        d = (this[i]&((1<<p)-1))<<(k-p);\n        d |= this[--i]>>(p+=this.DB-k);\n      }\n      else {\n        d = (this[i]>>(p-=k))&km;\n        if(p <= 0) { p += this.DB; --i; }\n      }\n      if(d > 0) m = true;\n      if(m) r += int2char(d);\n    }\n  }\n  return m?r:"0";\n}\n\n// (public) -this\nfunction bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; }\n\n// (public) |this|\nfunction bnAbs() { return (this.s<0)?this.negate():this; }\n\n// (public) return + if this > a, - if this < a, 0 if equal\nfunction bnCompareTo(a) {\n  var r = this.s-a.s;\n  if(r != 0) return r;\n  var i = this.t;\n  r = i-a.t;\n  if(r != 0) return (this.s<0)?-r:r;\n  while(--i >= 0) if((r=this[i]-a[i]) != 0) return r;\n  return 0;\n}\n\n// returns bit length of the integer x\nfunction nbits(x) {\n  var r = 1, t;\n  if((t=x>>>16) != 0) { x = t; r += 16; }\n  if((t=x>>8) != 0) { x = t; r += 8; }\n  if((t=x>>4) != 0) { x = t; r += 4; }\n  if((t=x>>2) != 0) { x = t; r += 2; }\n  if((t=x>>1) != 0) { x = t; r += 1; }\n  return r;\n}\n\n// (public) return the number of bits in "this"\nfunction bnBitLength() {\n  if(this.t <= 0) return 0;\n  return this.DB*(this.t-1)+nbits(this[this.t-1]^(this.s&this.DM));\n}\n\n// (protected) r = this << n*DB\nfunction bnpDLShiftTo(n,r) {\n  var i;\n  for(i = this.t-1; i >= 0; --i) r[i+n] = this[i];\n  for(i = n-1; i >= 0; --i) r[i] = 0;\n  r.t = this.t+n;\n  r.s = this.s;\n}\n\n// (protected) r = this >> n*DB\nfunction bnpDRShiftTo(n,r) {\n  for(var i = n; i < this.t; ++i) r[i-n] = this[i];\n  r.t = Math.max(this.t-n,0);\n  r.s = this.s;\n}\n\n// (protected) r = this << n\nfunction bnpLShiftTo(n,r) {\n  var bs = n%this.DB;\n  var cbs = this.DB-bs;\n  var bm = (1<<cbs)-1;\n  var ds = Math.floor(n/this.DB), c = (this.s<<bs)&this.DM, i;\n  for(i = this.t-1; i >= 0; --i) {\n    r[i+ds+1] = (this[i]>>cbs)|c;\n    c = (this[i]&bm)<<bs;\n  }\n  for(i = ds-1; i >= 0; --i) r[i] = 0;\n  r[ds] = c;\n  r.t = this.t+ds+1;\n  r.s = this.s;\n  r.clamp();\n}\n\n// (protected) r = this >> n\nfunction bnpRShiftTo(n,r) {\n  r.s = this.s;\n  var ds = Math.floor(n/this.DB);\n  if(ds >= this.t) { r.t = 0; return; }\n  var bs = n%this.DB;\n  var cbs = this.DB-bs;\n  var bm = (1<<bs)-1;\n  r[0] = this[ds]>>bs;\n  for(var i = ds+1; i < this.t; ++i) {\n    r[i-ds-1] |= (this[i]&bm)<<cbs;\n    r[i-ds] = this[i]>>bs;\n  }\n  if(bs > 0) r[this.t-ds-1] |= (this.s&bm)<<cbs;\n  r.t = this.t-ds;\n  r.clamp();\n}\n\n// (protected) r = this - a\nfunction bnpSubTo(a,r) {\n  var i = 0, c = 0, m = Math.min(a.t,this.t);\n  while(i < m) {\n    c += this[i]-a[i];\n    r[i++] = c&this.DM;\n    c >>= this.DB;\n  }\n  if(a.t < this.t) {\n    c -= a.s;\n    while(i < this.t) {\n      c += this[i];\n      r[i++] = c&this.DM;\n      c >>= this.DB;\n    }\n    c += this.s;\n  }\n  else {\n    c += this.s;\n    while(i < a.t) {\n      c -= a[i];\n      r[i++] = c&this.DM;\n      c >>= this.DB;\n    }\n    c -= a.s;\n  }\n  r.s = (c<0)?-1:0;\n  if(c < -1) r[i++] = this.DV+c;\n  else if(c > 0) r[i++] = c;\n  r.t = i;\n  r.clamp();\n}\n\n// (protected) r = this * a, r != this,a (HAC 14.12)\n// "this" should be the larger one if appropriate.\nfunction bnpMultiplyTo(a,r) {\n  var x = this.abs(), y = a.abs();\n  var i = x.t;\n  r.t = i+y.t;\n  while(--i >= 0) r[i] = 0;\n  for(i = 0; i < y.t; ++i) r[i+x.t] = x.am(0,y[i],r,i,0,x.t);\n  r.s = 0;\n  r.clamp();\n  if(this.s != a.s) BigInteger.ZERO.subTo(r,r);\n}\n\n// (protected) r = this^2, r != this (HAC 14.16)\nfunction bnpSquareTo(r) {\n  var x = this.abs();\n  var i = r.t = 2*x.t;\n  while(--i >= 0) r[i] = 0;\n  for(i = 0; i < x.t-1; ++i) {\n    var c = x.am(i,x[i],r,2*i,0,1);\n    if((r[i+x.t]+=x.am(i+1,2*x[i],r,2*i+1,c,x.t-i-1)) >= x.DV) {\n      r[i+x.t] -= x.DV;\n      r[i+x.t+1] = 1;\n    }\n  }\n  if(r.t > 0) r[r.t-1] += x.am(i,x[i],r,2*i,0,1);\n  r.s = 0;\n  r.clamp();\n}\n\n// (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)\n// r != q, this != m.  q or r may be null.\nfunction bnpDivRemTo(m,q,r) {\n  var pm = m.abs();\n  if(pm.t <= 0) return;\n  var pt = this.abs();\n  if(pt.t < pm.t) {\n    if(q != null) q.fromInt(0);\n    if(r != null) this.copyTo(r);\n    return;\n  }\n  if(r == null) r = nbi();\n  var y = nbi(), ts = this.s, ms = m.s;\n  var nsh = this.DB-nbits(pm[pm.t-1]);\t// normalize modulus\n  if(nsh > 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); }\n  else { pm.copyTo(y); pt.copyTo(r); }\n  var ys = y.t;\n  var y0 = y[ys-1];\n  if(y0 == 0) return;\n  var yt = y0*(1<<this.F1)+((ys>1)?y[ys-2]>>this.F2:0);\n  var d1 = this.FV/yt, d2 = (1<<this.F1)/yt, e = 1<<this.F2;\n  var i = r.t, j = i-ys, t = (q==null)?nbi():q;\n  y.dlShiftTo(j,t);\n  if(r.compareTo(t) >= 0) {\n    r[r.t++] = 1;\n    r.subTo(t,r);\n  }\n  BigInteger.ONE.dlShiftTo(ys,t);\n  t.subTo(y,y);\t// "negative" y so we can replace sub with am later\n  while(y.t < ys) y[y.t++] = 0;\n  while(--j >= 0) {\n    // Estimate quotient digit\n    var qd = (r[--i]==y0)?this.DM:Math.floor(r[i]*d1+(r[i-1]+e)*d2);\n    if((r[i]+=y.am(0,qd,r,j,0,ys)) < qd) {\t// Try it out\n      y.dlShiftTo(j,t);\n      r.subTo(t,r);\n      while(r[i] < --qd) r.subTo(t,r);\n    }\n  }\n  if(q != null) {\n    r.drShiftTo(ys,q);\n    if(ts != ms) BigInteger.ZERO.subTo(q,q);\n  }\n  r.t = ys;\n  r.clamp();\n  if(nsh > 0) r.rShiftTo(nsh,r);\t// Denormalize remainder\n  if(ts < 0) BigInteger.ZERO.subTo(r,r);\n}\n\n// (public) this mod a\nfunction bnMod(a) {\n  var r = nbi();\n  this.abs().divRemTo(a,null,r);\n  if(this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r,r);\n  return r;\n}\n\n// Modular reduction using "classic" algorithm\nfunction Classic(m) { this.m = m; }\nfunction cConvert(x) {\n  if(x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);\n  else return x;\n}\nfunction cRevert(x) { return x; }\nfunction cReduce(x) { x.divRemTo(this.m,null,x); }\nfunction cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\nfunction cSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\nClassic.prototype.convert = cConvert;\nClassic.prototype.revert = cRevert;\nClassic.prototype.reduce = cReduce;\nClassic.prototype.mulTo = cMulTo;\nClassic.prototype.sqrTo = cSqrTo;\n\n// (protected) return "-1/this % 2^DB"; useful for Mont. reduction\n// justification:\n//         xy == 1 (mod m)\n//         xy =  1+km\n//   xy(2-xy) = (1+km)(1-km)\n// x[y(2-xy)] = 1-k^2m^2\n// x[y(2-xy)] == 1 (mod m^2)\n// if y is 1/x mod m, then y(2-xy) is 1/x mod m^2\n// should reduce x and y(2-xy) by m^2 at each step to keep size bounded.\n// JS multiply "overflows" differently from C/C++, so care is needed here.\nfunction bnpInvDigit() {\n  if(this.t < 1) return 0;\n  var x = this[0];\n  if((x&1) == 0) return 0;\n  var y = x&3;\t\t// y == 1/x mod 2^2\n  y = (y*(2-(x&0xf)*y))&0xf;\t// y == 1/x mod 2^4\n  y = (y*(2-(x&0xff)*y))&0xff;\t// y == 1/x mod 2^8\n  y = (y*(2-(((x&0xffff)*y)&0xffff)))&0xffff;\t// y == 1/x mod 2^16\n  // last step - calculate inverse mod DV directly;\n  // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints\n  y = (y*(2-x*y%this.DV))%this.DV;\t\t// y == 1/x mod 2^dbits\n  // we really want the negative inverse, and -DV < y < DV\n  return (y>0)?this.DV-y:-y;\n}\n\n// Montgomery reduction\nfunction Montgomery(m) {\n  this.m = m;\n  this.mp = m.invDigit();\n  this.mpl = this.mp&0x7fff;\n  this.mph = this.mp>>15;\n  this.um = (1<<(m.DB-15))-1;\n  this.mt2 = 2*m.t;\n}\n\n// xR mod m\nfunction montConvert(x) {\n  var r = nbi();\n  x.abs().dlShiftTo(this.m.t,r);\n  r.divRemTo(this.m,null,r);\n  if(x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r,r);\n  return r;\n}\n\n// x/R mod m\nfunction montRevert(x) {\n  var r = nbi();\n  x.copyTo(r);\n  this.reduce(r);\n  return r;\n}\n\n// x = x/R mod m (HAC 14.32)\nfunction montReduce(x) {\n  while(x.t <= this.mt2)\t// pad x so am has enough room later\n    x[x.t++] = 0;\n  for(var i = 0; i < this.m.t; ++i) {\n    // faster way of calculating u0 = x[i]*mp mod DV\n    var j = x[i]&0x7fff;\n    var u0 = (j*this.mpl+(((j*this.mph+(x[i]>>15)*this.mpl)&this.um)<<15))&x.DM;\n    // use am to combine the multiply-shift-add into one call\n    j = i+this.m.t;\n    x[j] += this.m.am(0,u0,x,i,0,this.m.t);\n    // propagate carry\n    while(x[j] >= x.DV) { x[j] -= x.DV; x[++j]++; }\n  }\n  x.clamp();\n  x.drShiftTo(this.m.t,x);\n  if(x.compareTo(this.m) >= 0) x.subTo(this.m,x);\n}\n\n// r = "x^2/R mod m"; x != r\nfunction montSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\n// r = "xy/R mod m"; x,y != r\nfunction montMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\n\nMontgomery.prototype.convert = montConvert;\nMontgomery.prototype.revert = montRevert;\nMontgomery.prototype.reduce = montReduce;\nMontgomery.prototype.mulTo = montMulTo;\nMontgomery.prototype.sqrTo = montSqrTo;\n\n// (protected) true iff this is even\nfunction bnpIsEven() { return ((this.t>0)?(this[0]&1):this.s) == 0; }\n\n// (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)\nfunction bnpExp(e,z) {\n  if(e > 0xffffffff || e < 1) return BigInteger.ONE;\n  var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e)-1;\n  g.copyTo(r);\n  while(--i >= 0) {\n    z.sqrTo(r,r2);\n    if((e&(1<<i)) > 0) z.mulTo(r2,g,r);\n    else { var t = r; r = r2; r2 = t; }\n  }\n  return z.revert(r);\n}\n\n// (public) this^e % m, 0 <= e < 2^32\nfunction bnModPowInt(e,m) {\n  var z;\n  if(e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);\n  return this.exp(e,z);\n}\n\n// protected\nBigInteger.prototype.copyTo = bnpCopyTo;\nBigInteger.prototype.fromInt = bnpFromInt;\nBigInteger.prototype.fromString = bnpFromString;\nBigInteger.prototype.clamp = bnpClamp;\nBigInteger.prototype.dlShiftTo = bnpDLShiftTo;\nBigInteger.prototype.drShiftTo = bnpDRShiftTo;\nBigInteger.prototype.lShiftTo = bnpLShiftTo;\nBigInteger.prototype.rShiftTo = bnpRShiftTo;\nBigInteger.prototype.subTo = bnpSubTo;\nBigInteger.prototype.multiplyTo = bnpMultiplyTo;\nBigInteger.prototype.squareTo = bnpSquareTo;\nBigInteger.prototype.divRemTo = bnpDivRemTo;\nBigInteger.prototype.invDigit = bnpInvDigit;\nBigInteger.prototype.isEven = bnpIsEven;\nBigInteger.prototype.exp = bnpExp;\n\n// public\nBigInteger.prototype.toString = bnToString;\nBigInteger.prototype.negate = bnNegate;\nBigInteger.prototype.abs = bnAbs;\nBigInteger.prototype.compareTo = bnCompareTo;\nBigInteger.prototype.bitLength = bnBitLength;\nBigInteger.prototype.mod = bnMod;\nBigInteger.prototype.modPowInt = bnModPowInt;\n\n// "constants"\nBigInteger.ZERO = nbv(0);\nBigInteger.ONE = nbv(1);\n// Copyright (c) 2005-2009  Tom Wu\n// All Rights Reserved.\n// See "LICENSE" for details.\n\n// Extended JavaScript BN functions, required for RSA private ops.\n\n// Version 1.1: new BigInteger("0", 10) returns "proper" zero\n// Version 1.2: square() API, isProbablePrime fix\n\n// (public)\nfunction bnClone() { var r = nbi(); this.copyTo(r); return r; }\n\n// (public) return value as integer\nfunction bnIntValue() {\n  if(this.s < 0) {\n    if(this.t == 1) return this[0]-this.DV;\n    else if(this.t == 0) return -1;\n  }\n  else if(this.t == 1) return this[0];\n  else if(this.t == 0) return 0;\n  // assumes 16 < DB < 32\n  return ((this[1]&((1<<(32-this.DB))-1))<<this.DB)|this[0];\n}\n\n// (public) return value as byte\nfunction bnByteValue() { return (this.t==0)?this.s:(this[0]<<24)>>24; }\n\n// (public) return value as short (assumes DB>=16)\nfunction bnShortValue() { return (this.t==0)?this.s:(this[0]<<16)>>16; }\n\n// (protected) return x s.t. r^x < DV\nfunction bnpChunkSize(r) { return Math.floor(Math.LN2*this.DB/Math.log(r)); }\n\n// (public) 0 if this == 0, 1 if this > 0\nfunction bnSigNum() {\n  if(this.s < 0) return -1;\n  else if(this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;\n  else return 1;\n}\n\n// (protected) convert to radix string\nfunction bnpToRadix(b) {\n  if(b == null) b = 10;\n  if(this.signum() == 0 || b < 2 || b > 36) return "0";\n  var cs = this.chunkSize(b);\n  var a = Math.pow(b,cs);\n  var d = nbv(a), y = nbi(), z = nbi(), r = "";\n  this.divRemTo(d,y,z);\n  while(y.signum() > 0) {\n    r = (a+z.intValue()).toString(b).substr(1) + r;\n    y.divRemTo(d,y,z);\n  }\n  return z.intValue().toString(b) + r;\n}\n\n// (protected) convert from radix string\nfunction bnpFromRadix(s,b) {\n  this.fromInt(0);\n  if(b == null) b = 10;\n  var cs = this.chunkSize(b);\n  var d = Math.pow(b,cs), mi = false, j = 0, w = 0;\n  for(var i = 0; i < s.length; ++i) {\n    var x = intAt(s,i);\n    if(x < 0) {\n      if(s.charAt(i) == "-" && this.signum() == 0) mi = true;\n      continue;\n    }\n    w = b*w+x;\n    if(++j >= cs) {\n      this.dMultiply(d);\n      this.dAddOffset(w,0);\n      j = 0;\n      w = 0;\n    }\n  }\n  if(j > 0) {\n    this.dMultiply(Math.pow(b,j));\n    this.dAddOffset(w,0);\n  }\n  if(mi) BigInteger.ZERO.subTo(this,this);\n}\n\n// (protected) alternate constructor\nfunction bnpFromNumber(a,b,c) {\n  if("number" == typeof b) {\n    // new BigInteger(int,int,RNG)\n    if(a < 2) this.fromInt(1);\n    else {\n      this.fromNumber(a,c);\n      if(!this.testBit(a-1))\t// force MSB set\n        this.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,this);\n      if(this.isEven()) this.dAddOffset(1,0); // force odd\n      while(!this.isProbablePrime(b)) {\n        this.dAddOffset(2,0);\n        if(this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a-1),this);\n      }\n    }\n  }\n  else {\n    // new BigInteger(int,RNG)\n    var x = new Array(), t = a&7;\n    x.length = (a>>3)+1;\n    b.nextBytes(x);\n    if(t > 0) x[0] &= ((1<<t)-1); else x[0] = 0;\n    this.fromString(x,256);\n  }\n}\n\n// (public) convert to bigendian byte array\nfunction bnToByteArray() {\n  var i = this.t, r = new Array();\n  r[0] = this.s;\n  var p = this.DB-(i*this.DB)%8, d, k = 0;\n  if(i-- > 0) {\n    if(p < this.DB && (d = this[i]>>p) != (this.s&this.DM)>>p)\n      r[k++] = d|(this.s<<(this.DB-p));\n    while(i >= 0) {\n      if(p < 8) {\n        d = (this[i]&((1<<p)-1))<<(8-p);\n        d |= this[--i]>>(p+=this.DB-8);\n      }\n      else {\n        d = (this[i]>>(p-=8))&0xff;\n        if(p <= 0) { p += this.DB; --i; }\n      }\n      if((d&0x80) != 0) d |= -256;\n      if(k == 0 && (this.s&0x80) != (d&0x80)) ++k;\n      if(k > 0 || d != this.s) r[k++] = d;\n    }\n  }\n  return r;\n}\n\nfunction bnEquals(a) { return(this.compareTo(a)==0); }\nfunction bnMin(a) { return(this.compareTo(a)<0)?this:a; }\nfunction bnMax(a) { return(this.compareTo(a)>0)?this:a; }\n\n// (protected) r = this op a (bitwise)\nfunction bnpBitwiseTo(a,op,r) {\n  var i, f, m = Math.min(a.t,this.t);\n  for(i = 0; i < m; ++i) r[i] = op(this[i],a[i]);\n  if(a.t < this.t) {\n    f = a.s&this.DM;\n    for(i = m; i < this.t; ++i) r[i] = op(this[i],f);\n    r.t = this.t;\n  }\n  else {\n    f = this.s&this.DM;\n    for(i = m; i < a.t; ++i) r[i] = op(f,a[i]);\n    r.t = a.t;\n  }\n  r.s = op(this.s,a.s);\n  r.clamp();\n}\n\n// (public) this & a\nfunction op_and(x,y) { return x&y; }\nfunction bnAnd(a) { var r = nbi(); this.bitwiseTo(a,op_and,r); return r; }\n\n// (public) this | a\nfunction op_or(x,y) { return x|y; }\nfunction bnOr(a) { var r = nbi(); this.bitwiseTo(a,op_or,r); return r; }\n\n// (public) this ^ a\nfunction op_xor(x,y) { return x^y; }\nfunction bnXor(a) { var r = nbi(); this.bitwiseTo(a,op_xor,r); return r; }\n\n// (public) this & ~a\nfunction op_andnot(x,y) { return x&~y; }\nfunction bnAndNot(a) { var r = nbi(); this.bitwiseTo(a,op_andnot,r); return r; }\n\n// (public) ~this\nfunction bnNot() {\n  var r = nbi();\n  for(var i = 0; i < this.t; ++i) r[i] = this.DM&~this[i];\n  r.t = this.t;\n  r.s = ~this.s;\n  return r;\n}\n\n// (public) this << n\nfunction bnShiftLeft(n) {\n  var r = nbi();\n  if(n < 0) this.rShiftTo(-n,r); else this.lShiftTo(n,r);\n  return r;\n}\n\n// (public) this >> n\nfunction bnShiftRight(n) {\n  var r = nbi();\n  if(n < 0) this.lShiftTo(-n,r); else this.rShiftTo(n,r);\n  return r;\n}\n\n// return index of lowest 1-bit in x, x < 2^31\nfunction lbit(x) {\n  if(x == 0) return -1;\n  var r = 0;\n  if((x&0xffff) == 0) { x >>= 16; r += 16; }\n  if((x&0xff) == 0) { x >>= 8; r += 8; }\n  if((x&0xf) == 0) { x >>= 4; r += 4; }\n  if((x&3) == 0) { x >>= 2; r += 2; }\n  if((x&1) == 0) ++r;\n  return r;\n}\n\n// (public) returns index of lowest 1-bit (or -1 if none)\nfunction bnGetLowestSetBit() {\n  for(var i = 0; i < this.t; ++i)\n    if(this[i] != 0) return i*this.DB+lbit(this[i]);\n  if(this.s < 0) return this.t*this.DB;\n  return -1;\n}\n\n// return number of 1 bits in x\nfunction cbit(x) {\n  var r = 0;\n  while(x != 0) { x &= x-1; ++r; }\n  return r;\n}\n\n// (public) return number of set bits\nfunction bnBitCount() {\n  var r = 0, x = this.s&this.DM;\n  for(var i = 0; i < this.t; ++i) r += cbit(this[i]^x);\n  return r;\n}\n\n// (public) true iff nth bit is set\nfunction bnTestBit(n) {\n  var j = Math.floor(n/this.DB);\n  if(j >= this.t) return(this.s!=0);\n  return((this[j]&(1<<(n%this.DB)))!=0);\n}\n\n// (protected) this op (1<<n)\nfunction bnpChangeBit(n,op) {\n  var r = BigInteger.ONE.shiftLeft(n);\n  this.bitwiseTo(r,op,r);\n  return r;\n}\n\n// (public) this | (1<<n)\nfunction bnSetBit(n) { return this.changeBit(n,op_or); }\n\n// (public) this & ~(1<<n)\nfunction bnClearBit(n) { return this.changeBit(n,op_andnot); }\n\n// (public) this ^ (1<<n)\nfunction bnFlipBit(n) { return this.changeBit(n,op_xor); }\n\n// (protected) r = this + a\nfunction bnpAddTo(a,r) {\n  var i = 0, c = 0, m = Math.min(a.t,this.t);\n  while(i < m) {\n    c += this[i]+a[i];\n    r[i++] = c&this.DM;\n    c >>= this.DB;\n  }\n  if(a.t < this.t) {\n    c += a.s;\n    while(i < this.t) {\n      c += this[i];\n      r[i++] = c&this.DM;\n      c >>= this.DB;\n    }\n    c += this.s;\n  }\n  else {\n    c += this.s;\n    while(i < a.t) {\n      c += a[i];\n      r[i++] = c&this.DM;\n      c >>= this.DB;\n    }\n    c += a.s;\n  }\n  r.s = (c<0)?-1:0;\n  if(c > 0) r[i++] = c;\n  else if(c < -1) r[i++] = this.DV+c;\n  r.t = i;\n  r.clamp();\n}\n\n// (public) this + a\nfunction bnAdd(a) { var r = nbi(); this.addTo(a,r); return r; }\n\n// (public) this - a\nfunction bnSubtract(a) { var r = nbi(); this.subTo(a,r); return r; }\n\n// (public) this * a\nfunction bnMultiply(a) { var r = nbi(); this.multiplyTo(a,r); return r; }\n\n// (public) this^2\nfunction bnSquare() { var r = nbi(); this.squareTo(r); return r; }\n\n// (public) this / a\nfunction bnDivide(a) { var r = nbi(); this.divRemTo(a,r,null); return r; }\n\n// (public) this % a\nfunction bnRemainder(a) { var r = nbi(); this.divRemTo(a,null,r); return r; }\n\n// (public) [this/a,this%a]\nfunction bnDivideAndRemainder(a) {\n  var q = nbi(), r = nbi();\n  this.divRemTo(a,q,r);\n  return new Array(q,r);\n}\n\n// (protected) this *= n, this >= 0, 1 < n < DV\nfunction bnpDMultiply(n) {\n  this[this.t] = this.am(0,n-1,this,0,0,this.t);\n  ++this.t;\n  this.clamp();\n}\n\n// (protected) this += n << w words, this >= 0\nfunction bnpDAddOffset(n,w) {\n  if(n == 0) return;\n  while(this.t <= w) this[this.t++] = 0;\n  this[w] += n;\n  while(this[w] >= this.DV) {\n    this[w] -= this.DV;\n    if(++w >= this.t) this[this.t++] = 0;\n    ++this[w];\n  }\n}\n\n// A "null" reducer\nfunction NullExp() {}\nfunction nNop(x) { return x; }\nfunction nMulTo(x,y,r) { x.multiplyTo(y,r); }\nfunction nSqrTo(x,r) { x.squareTo(r); }\n\nNullExp.prototype.convert = nNop;\nNullExp.prototype.revert = nNop;\nNullExp.prototype.mulTo = nMulTo;\nNullExp.prototype.sqrTo = nSqrTo;\n\n// (public) this^e\nfunction bnPow(e) { return this.exp(e,new NullExp()); }\n\n// (protected) r = lower n words of "this * a", a.t <= n\n// "this" should be the larger one if appropriate.\nfunction bnpMultiplyLowerTo(a,n,r) {\n  var i = Math.min(this.t+a.t,n);\n  r.s = 0; // assumes a,this >= 0\n  r.t = i;\n  while(i > 0) r[--i] = 0;\n  var j;\n  for(j = r.t-this.t; i < j; ++i) r[i+this.t] = this.am(0,a[i],r,i,0,this.t);\n  for(j = Math.min(a.t,n); i < j; ++i) this.am(0,a[i],r,i,0,n-i);\n  r.clamp();\n}\n\n// (protected) r = "this * a" without lower n words, n > 0\n// "this" should be the larger one if appropriate.\nfunction bnpMultiplyUpperTo(a,n,r) {\n  --n;\n  var i = r.t = this.t+a.t-n;\n  r.s = 0; // assumes a,this >= 0\n  while(--i >= 0) r[i] = 0;\n  for(i = Math.max(n-this.t,0); i < a.t; ++i)\n    r[this.t+i-n] = this.am(n-i,a[i],r,0,0,this.t+i-n);\n  r.clamp();\n  r.drShiftTo(1,r);\n}\n\n// Barrett modular reduction\nfunction Barrett(m) {\n  // setup Barrett\n  this.r2 = nbi();\n  this.q3 = nbi();\n  BigInteger.ONE.dlShiftTo(2*m.t,this.r2);\n  this.mu = this.r2.divide(m);\n  this.m = m;\n}\n\nfunction barrettConvert(x) {\n  if(x.s < 0 || x.t > 2*this.m.t) return x.mod(this.m);\n  else if(x.compareTo(this.m) < 0) return x;\n  else { var r = nbi(); x.copyTo(r); this.reduce(r); return r; }\n}\n\nfunction barrettRevert(x) { return x; }\n\n// x = x mod m (HAC 14.42)\nfunction barrettReduce(x) {\n  x.drShiftTo(this.m.t-1,this.r2);\n  if(x.t > this.m.t+1) { x.t = this.m.t+1; x.clamp(); }\n  this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);\n  this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);\n  while(x.compareTo(this.r2) < 0) x.dAddOffset(1,this.m.t+1);\n  x.subTo(this.r2,x);\n  while(x.compareTo(this.m) >= 0) x.subTo(this.m,x);\n}\n\n// r = x^2 mod m; x != r\nfunction barrettSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\n// r = x*y mod m; x,y != r\nfunction barrettMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\n\nBarrett.prototype.convert = barrettConvert;\nBarrett.prototype.revert = barrettRevert;\nBarrett.prototype.reduce = barrettReduce;\nBarrett.prototype.mulTo = barrettMulTo;\nBarrett.prototype.sqrTo = barrettSqrTo;\n\n// (public) this^e % m (HAC 14.85)\nfunction bnModPow(e,m) {\n  var i = e.bitLength(), k, r = nbv(1), z;\n  if(i <= 0) return r;\n  else if(i < 18) k = 1;\n  else if(i < 48) k = 3;\n  else if(i < 144) k = 4;\n  else if(i < 768) k = 5;\n  else k = 6;\n  if(i < 8)\n    z = new Classic(m);\n  else if(m.isEven())\n    z = new Barrett(m);\n  else\n    z = new Montgomery(m);\n\n  // precomputation\n  var g = new Array(), n = 3, k1 = k-1, km = (1<<k)-1;\n  g[1] = z.convert(this);\n  if(k > 1) {\n    var g2 = nbi();\n    z.sqrTo(g[1],g2);\n    while(n <= km) {\n      g[n] = nbi();\n      z.mulTo(g2,g[n-2],g[n]);\n      n += 2;\n    }\n  }\n\n  var j = e.t-1, w, is1 = true, r2 = nbi(), t;\n  i = nbits(e[j])-1;\n  while(j >= 0) {\n    if(i >= k1) w = (e[j]>>(i-k1))&km;\n    else {\n      w = (e[j]&((1<<(i+1))-1))<<(k1-i);\n      if(j > 0) w |= e[j-1]>>(this.DB+i-k1);\n    }\n\n    n = k;\n    while((w&1) == 0) { w >>= 1; --n; }\n    if((i -= n) < 0) { i += this.DB; --j; }\n    if(is1) {\t// ret == 1, don\'t bother squaring or multiplying it\n      g[w].copyTo(r);\n      is1 = false;\n    }\n    else {\n      while(n > 1) { z.sqrTo(r,r2); z.sqrTo(r2,r); n -= 2; }\n      if(n > 0) z.sqrTo(r,r2); else { t = r; r = r2; r2 = t; }\n      z.mulTo(r2,g[w],r);\n    }\n\n    while(j >= 0 && (e[j]&(1<<i)) == 0) {\n      z.sqrTo(r,r2); t = r; r = r2; r2 = t;\n      if(--i < 0) { i = this.DB-1; --j; }\n    }\n  }\n  return z.revert(r);\n}\n\n// (public) gcd(this,a) (HAC 14.54)\nfunction bnGCD(a) {\n  var x = (this.s<0)?this.negate():this.clone();\n  var y = (a.s<0)?a.negate():a.clone();\n  if(x.compareTo(y) < 0) { var t = x; x = y; y = t; }\n  var i = x.getLowestSetBit(), g = y.getLowestSetBit();\n  if(g < 0) return x;\n  if(i < g) g = i;\n  if(g > 0) {\n    x.rShiftTo(g,x);\n    y.rShiftTo(g,y);\n  }\n  while(x.signum() > 0) {\n    if((i = x.getLowestSetBit()) > 0) x.rShiftTo(i,x);\n    if((i = y.getLowestSetBit()) > 0) y.rShiftTo(i,y);\n    if(x.compareTo(y) >= 0) {\n      x.subTo(y,x);\n      x.rShiftTo(1,x);\n    }\n    else {\n      y.subTo(x,y);\n      y.rShiftTo(1,y);\n    }\n  }\n  if(g > 0) y.lShiftTo(g,y);\n  return y;\n}\n\n// (protected) this % n, n < 2^26\nfunction bnpModInt(n) {\n  if(n <= 0) return 0;\n  var d = this.DV%n, r = (this.s<0)?n-1:0;\n  if(this.t > 0)\n    if(d == 0) r = this[0]%n;\n    else for(var i = this.t-1; i >= 0; --i) r = (d*r+this[i])%n;\n  return r;\n}\n\n// (public) 1/this % m (HAC 14.61)\nfunction bnModInverse(m) {\n  var ac = m.isEven();\n  if((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;\n  var u = m.clone(), v = this.clone();\n  var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);\n  while(u.signum() != 0) {\n    while(u.isEven()) {\n      u.rShiftTo(1,u);\n      if(ac) {\n        if(!a.isEven() || !b.isEven()) { a.addTo(this,a); b.subTo(m,b); }\n        a.rShiftTo(1,a);\n      }\n      else if(!b.isEven()) b.subTo(m,b);\n      b.rShiftTo(1,b);\n    }\n    while(v.isEven()) {\n      v.rShiftTo(1,v);\n      if(ac) {\n        if(!c.isEven() || !d.isEven()) { c.addTo(this,c); d.subTo(m,d); }\n        c.rShiftTo(1,c);\n      }\n      else if(!d.isEven()) d.subTo(m,d);\n      d.rShiftTo(1,d);\n    }\n    if(u.compareTo(v) >= 0) {\n      u.subTo(v,u);\n      if(ac) a.subTo(c,a);\n      b.subTo(d,b);\n    }\n    else {\n      v.subTo(u,v);\n      if(ac) c.subTo(a,c);\n      d.subTo(b,d);\n    }\n  }\n  if(v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;\n  if(d.compareTo(m) >= 0) return d.subtract(m);\n  if(d.signum() < 0) d.addTo(m,d); else return d;\n  if(d.signum() < 0) return d.add(m); else return d;\n}\n\nvar lowprimes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997];\nvar lplim = (1<<26)/lowprimes[lowprimes.length-1];\n\n// (public) test primality with certainty >= 1-.5^t\nfunction bnIsProbablePrime(t) {\n  var i, x = this.abs();\n  if(x.t == 1 && x[0] <= lowprimes[lowprimes.length-1]) {\n    for(i = 0; i < lowprimes.length; ++i)\n      if(x[0] == lowprimes[i]) return true;\n    return false;\n  }\n  if(x.isEven()) return false;\n  i = 1;\n  while(i < lowprimes.length) {\n    var m = lowprimes[i], j = i+1;\n    while(j < lowprimes.length && m < lplim) m *= lowprimes[j++];\n    m = x.modInt(m);\n    while(i < j) if(m%lowprimes[i++] == 0) return false;\n  }\n  return x.millerRabin(t);\n}\n\n// (protected) true if probably prime (HAC 4.24, Miller-Rabin)\nfunction bnpMillerRabin(t) {\n  var n1 = this.subtract(BigInteger.ONE);\n  var k = n1.getLowestSetBit();\n  if(k <= 0) return false;\n  var r = n1.shiftRight(k);\n  t = (t+1)>>1;\n  if(t > lowprimes.length) t = lowprimes.length;\n  var a = nbi();\n  for(var i = 0; i < t; ++i) {\n    //Pick bases at random, instead of starting at 2\n    a.fromInt(lowprimes[Math.floor(Math.random()*lowprimes.length)]);\n    var y = a.modPow(r,this);\n    if(y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {\n      var j = 1;\n      while(j++ < k && y.compareTo(n1) != 0) {\n        y = y.modPowInt(2,this);\n        if(y.compareTo(BigInteger.ONE) == 0) return false;\n      }\n      if(y.compareTo(n1) != 0) return false;\n    }\n  }\n  return true;\n}\n\n// protected\nBigInteger.prototype.chunkSize = bnpChunkSize;\nBigInteger.prototype.toRadix = bnpToRadix;\nBigInteger.prototype.fromRadix = bnpFromRadix;\nBigInteger.prototype.fromNumber = bnpFromNumber;\nBigInteger.prototype.bitwiseTo = bnpBitwiseTo;\nBigInteger.prototype.changeBit = bnpChangeBit;\nBigInteger.prototype.addTo = bnpAddTo;\nBigInteger.prototype.dMultiply = bnpDMultiply;\nBigInteger.prototype.dAddOffset = bnpDAddOffset;\nBigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;\nBigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;\nBigInteger.prototype.modInt = bnpModInt;\nBigInteger.prototype.millerRabin = bnpMillerRabin;\n\n// public\nBigInteger.prototype.clone = bnClone;\nBigInteger.prototype.intValue = bnIntValue;\nBigInteger.prototype.byteValue = bnByteValue;\nBigInteger.prototype.shortValue = bnShortValue;\nBigInteger.prototype.signum = bnSigNum;\nBigInteger.prototype.toByteArray = bnToByteArray;\nBigInteger.prototype.equals = bnEquals;\nBigInteger.prototype.min = bnMin;\nBigInteger.prototype.max = bnMax;\nBigInteger.prototype.and = bnAnd;\nBigInteger.prototype.or = bnOr;\nBigInteger.prototype.xor = bnXor;\nBigInteger.prototype.andNot = bnAndNot;\nBigInteger.prototype.not = bnNot;\nBigInteger.prototype.shiftLeft = bnShiftLeft;\nBigInteger.prototype.shiftRight = bnShiftRight;\nBigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;\nBigInteger.prototype.bitCount = bnBitCount;\nBigInteger.prototype.testBit = bnTestBit;\nBigInteger.prototype.setBit = bnSetBit;\nBigInteger.prototype.clearBit = bnClearBit;\nBigInteger.prototype.flipBit = bnFlipBit;\nBigInteger.prototype.add = bnAdd;\nBigInteger.prototype.subtract = bnSubtract;\nBigInteger.prototype.multiply = bnMultiply;\nBigInteger.prototype.divide = bnDivide;\nBigInteger.prototype.remainder = bnRemainder;\nBigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;\nBigInteger.prototype.modPow = bnModPow;\nBigInteger.prototype.modInverse = bnModInverse;\nBigInteger.prototype.pow = bnPow;\nBigInteger.prototype.gcd = bnGCD;\nBigInteger.prototype.isProbablePrime = bnIsProbablePrime;\n\n// JSBN-specific extension\nBigInteger.prototype.square = bnSquare;\n\n// BigInteger interfaces not implemented in jsbn:\n\n// BigInteger(int signum, byte[] magnitude)\n// double doubleValue()\n// float floatValue()\n// int hashCode()\n// long longValue()\n// static BigInteger valueOf(long val)\n\n})(require("__browserify_buffer").Buffer)\n},{"__browserify_buffer":8}],9:[function(require,module,exports){\n// shim for using process in browser\n\nvar process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== \'undefined\'\n    && window.setImmediate;\n    var canPost = typeof window !== \'undefined\'\n    && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    if (canPost) {\n        var queue = [];\n        window.addEventListener(\'message\', function (ev) {\n            var source = ev.source;\n            if ((source === window || source === null) && ev.data === \'process-tick\') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage(\'process-tick\', \'*\');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = \'browser\';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nprocess.binding = function (name) {\n    throw new Error(\'process.binding is not supported\');\n}\n\n// TODO(shtylman)\nprocess.cwd = function () { return \'/\' };\nprocess.chdir = function (dir) {\n    throw new Error(\'process.chdir is not supported\');\n};\n\n},{}],10:[function(require,module,exports){\n(function(process){if (!process.EventEmitter) process.EventEmitter = function () {};\n\nvar EventEmitter = exports.EventEmitter = process.EventEmitter;\nvar isArray = typeof Array.isArray === \'function\'\n    ? Array.isArray\n    : function (xs) {\n        return Object.prototype.toString.call(xs) === \'[object Array]\'\n    }\n;\nfunction indexOf (xs, x) {\n    if (xs.indexOf) return xs.indexOf(x);\n    for (var i = 0; i < xs.length; i++) {\n        if (x === xs[i]) return i;\n    }\n    return -1;\n}\n\n// By default EventEmitters will print a warning if more than\n// 10 listeners are added to it. This is a useful default which\n// helps finding memory leaks.\n//\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nvar defaultMaxListeners = 10;\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!this._events) this._events = {};\n  this._events.maxListeners = n;\n};\n\n\nEventEmitter.prototype.emit = function(type) {\n  // If there is no \'error\' event listener then throw.\n  if (type === \'error\') {\n    if (!this._events || !this._events.error ||\n        (isArray(this._events.error) && !this._events.error.length))\n    {\n      if (arguments[1] instanceof Error) {\n        throw arguments[1]; // Unhandled \'error\' event\n      } else {\n        throw new Error("Uncaught, unspecified \'error\' event.");\n      }\n      return false;\n    }\n  }\n\n  if (!this._events) return false;\n  var handler = this._events[type];\n  if (!handler) return false;\n\n  if (typeof handler == \'function\') {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        var args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n    return true;\n\n  } else if (isArray(handler)) {\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    var listeners = handler.slice();\n    for (var i = 0, l = listeners.length; i < l; i++) {\n      listeners[i].apply(this, args);\n    }\n    return true;\n\n  } else {\n    return false;\n  }\n};\n\n// EventEmitter is defined in src/node_events.cc\n// EventEmitter.prototype.emit() is also defined there.\nEventEmitter.prototype.addListener = function(type, listener) {\n  if (\'function\' !== typeof listener) {\n    throw new Error(\'addListener only takes instances of Function\');\n  }\n\n  if (!this._events) this._events = {};\n\n  // To avoid recursion in the case that type == "newListeners"! Before\n  // adding it to the listeners, first emit "newListeners".\n  this.emit(\'newListener\', type, listener);\n\n  if (!this._events[type]) {\n    // Optimize the case of one listener. Don\'t need the extra array object.\n    this._events[type] = listener;\n  } else if (isArray(this._events[type])) {\n\n    // Check for listener leak\n    if (!this._events[type].warned) {\n      var m;\n      if (this._events.maxListeners !== undefined) {\n        m = this._events.maxListeners;\n      } else {\n        m = defaultMaxListeners;\n      }\n\n      if (m && m > 0 && this._events[type].length > m) {\n        this._events[type].warned = true;\n        console.error(\'(node) warning: possible EventEmitter memory \' +\n                      \'leak detected. %d listeners added. \' +\n                      \'Use emitter.setMaxListeners() to increase limit.\',\n                      this._events[type].length);\n        console.trace();\n      }\n    }\n\n    // If we\'ve already got an array, just append.\n    this._events[type].push(listener);\n  } else {\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  var self = this;\n  self.on(type, function g() {\n    self.removeListener(type, g);\n    listener.apply(this, arguments);\n  });\n\n  return this;\n};\n\nEventEmitter.prototype.removeListener = function(type, listener) {\n  if (\'function\' !== typeof listener) {\n    throw new Error(\'removeListener only takes instances of Function\');\n  }\n\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (!this._events || !this._events[type]) return this;\n\n  var list = this._events[type];\n\n  if (isArray(list)) {\n    var i = indexOf(list, listener);\n    if (i < 0) return this;\n    list.splice(i, 1);\n    if (list.length == 0)\n      delete this._events[type];\n  } else if (this._events[type] === listener) {\n    delete this._events[type];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  if (arguments.length === 0) {\n    this._events = {};\n    return this;\n  }\n\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (type && this._events && this._events[type]) this._events[type] = null;\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  if (!this._events) this._events = {};\n  if (!this._events[type]) this._events[type] = [];\n  if (!isArray(this._events[type])) {\n    this._events[type] = [this._events[type]];\n  }\n  return this._events[type];\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  var ret;\n  if (!emitter._events || !emitter._events[type])\n    ret = 0;\n  else if (typeof emitter._events[type] === \'function\')\n    ret = 1;\n  else\n    ret = emitter._events[type].length;\n  return ret;\n};\n\n})(require("__browserify_process"))\n},{"__browserify_process":9}],11:[function(require,module,exports){\nvar events = require(\'events\');\n\nexports.isArray = isArray;\nexports.isDate = function(obj){return Object.prototype.toString.call(obj) === \'[object Date]\'};\nexports.isRegExp = function(obj){return Object.prototype.toString.call(obj) === \'[object RegExp]\'};\n\n\nexports.print = function () {};\nexports.puts = function () {};\nexports.debug = function() {};\n\nexports.inspect = function(obj, showHidden, depth, colors) {\n  var seen = [];\n\n  var stylize = function(str, styleType) {\n    // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\n    var styles =\n        { \'bold\' : [1, 22],\n          \'italic\' : [3, 23],\n          \'underline\' : [4, 24],\n          \'inverse\' : [7, 27],\n          \'white\' : [37, 39],\n          \'grey\' : [90, 39],\n          \'black\' : [30, 39],\n          \'blue\' : [34, 39],\n          \'cyan\' : [36, 39],\n          \'green\' : [32, 39],\n          \'magenta\' : [35, 39],\n          \'red\' : [31, 39],\n          \'yellow\' : [33, 39] };\n\n    var style =\n        { \'special\': \'cyan\',\n          \'number\': \'blue\',\n          \'boolean\': \'yellow\',\n          \'undefined\': \'grey\',\n          \'null\': \'bold\',\n          \'string\': \'green\',\n          \'date\': \'magenta\',\n          // "name": intentionally not styling\n          \'regexp\': \'red\' }[styleType];\n\n    if (style) {\n      return \'\\u001b[\' + styles[style][0] + \'m\' + str +\n             \'\\u001b[\' + styles[style][1] + \'m\';\n    } else {\n      return str;\n    }\n  };\n  if (! colors) {\n    stylize = function(str, styleType) { return str; };\n  }\n\n  function format(value, recurseTimes) {\n    // Provide a hook for user-specified inspect functions.\n    // Check that value is an object with an inspect function on it\n    if (value && typeof value.inspect === \'function\' &&\n        // Filter out the util module, it\'s inspect function is special\n        value !== exports &&\n        // Also filter out any prototype objects using the circular check.\n        !(value.constructor && value.constructor.prototype === value)) {\n      return value.inspect(recurseTimes);\n    }\n\n    // Primitive types cannot have properties\n    switch (typeof value) {\n      case \'undefined\':\n        return stylize(\'undefined\', \'undefined\');\n\n      case \'string\':\n        var simple = \'\\\'\' + JSON.stringify(value).replace(/^"|"$/g, \'\')\n                                                 .replace(/\'/g, "\\\\\'")\n                                                 .replace(/\\\\"/g, \'"\') + \'\\\'\';\n        return stylize(simple, \'string\');\n\n      case \'number\':\n        return stylize(\'\' + value, \'number\');\n\n      case \'boolean\':\n        return stylize(\'\' + value, \'boolean\');\n    }\n    // For some reason typeof null is "object", so special case here.\n    if (value === null) {\n      return stylize(\'null\', \'null\');\n    }\n\n    // Look up the keys of the object.\n    var visible_keys = Object_keys(value);\n    var keys = showHidden ? Object_getOwnPropertyNames(value) : visible_keys;\n\n    // Functions without properties can be shortcutted.\n    if (typeof value === \'function\' && keys.length === 0) {\n      if (isRegExp(value)) {\n        return stylize(\'\' + value, \'regexp\');\n      } else {\n        var name = value.name ? \': \' + value.name : \'\';\n        return stylize(\'[Function\' + name + \']\', \'special\');\n      }\n    }\n\n    // Dates without properties can be shortcutted\n    if (isDate(value) && keys.length === 0) {\n      return stylize(value.toUTCString(), \'date\');\n    }\n\n    var base, type, braces;\n    // Determine the object type\n    if (isArray(value)) {\n      type = \'Array\';\n      braces = [\'[\', \']\'];\n    } else {\n      type = \'Object\';\n      braces = [\'{\', \'}\'];\n    }\n\n    // Make functions say that they are functions\n    if (typeof value === \'function\') {\n      var n = value.name ? \': \' + value.name : \'\';\n      base = (isRegExp(value)) ? \' \' + value : \' [Function\' + n + \']\';\n    } else {\n      base = \'\';\n    }\n\n    // Make dates with properties first say the date\n    if (isDate(value)) {\n      base = \' \' + value.toUTCString();\n    }\n\n    if (keys.length === 0) {\n      return braces[0] + base + braces[1];\n    }\n\n    if (recurseTimes < 0) {\n      if (isRegExp(value)) {\n        return stylize(\'\' + value, \'regexp\');\n      } else {\n        return stylize(\'[Object]\', \'special\');\n      }\n    }\n\n    seen.push(value);\n\n    var output = keys.map(function(key) {\n      var name, str;\n      if (value.__lookupGetter__) {\n        if (value.__lookupGetter__(key)) {\n          if (value.__lookupSetter__(key)) {\n            str = stylize(\'[Getter/Setter]\', \'special\');\n          } else {\n            str = stylize(\'[Getter]\', \'special\');\n          }\n        } else {\n          if (value.__lookupSetter__(key)) {\n            str = stylize(\'[Setter]\', \'special\');\n          }\n        }\n      }\n      if (visible_keys.indexOf(key) < 0) {\n        name = \'[\' + key + \']\';\n      }\n      if (!str) {\n        if (seen.indexOf(value[key]) < 0) {\n          if (recurseTimes === null) {\n            str = format(value[key]);\n          } else {\n            str = format(value[key], recurseTimes - 1);\n          }\n          if (str.indexOf(\'\\n\') > -1) {\n            if (isArray(value)) {\n              str = str.split(\'\\n\').map(function(line) {\n                return \'  \' + line;\n              }).join(\'\\n\').substr(2);\n            } else {\n              str = \'\\n\' + str.split(\'\\n\').map(function(line) {\n                return \'   \' + line;\n              }).join(\'\\n\');\n            }\n          }\n        } else {\n          str = stylize(\'[Circular]\', \'special\');\n        }\n      }\n      if (typeof name === \'undefined\') {\n        if (type === \'Array\' && key.match(/^\\d+$/)) {\n          return str;\n        }\n        name = JSON.stringify(\'\' + key);\n        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {\n          name = name.substr(1, name.length - 2);\n          name = stylize(name, \'name\');\n        } else {\n          name = name.replace(/\'/g, "\\\\\'")\n                     .replace(/\\\\"/g, \'"\')\n                     .replace(/(^"|"$)/g, "\'");\n          name = stylize(name, \'string\');\n        }\n      }\n\n      return name + \': \' + str;\n    });\n\n    seen.pop();\n\n    var numLinesEst = 0;\n    var length = output.reduce(function(prev, cur) {\n      numLinesEst++;\n      if (cur.indexOf(\'\\n\') >= 0) numLinesEst++;\n      return prev + cur.length + 1;\n    }, 0);\n\n    if (length > 50) {\n      output = braces[0] +\n               (base === \'\' ? \'\' : base + \'\\n \') +\n               \' \' +\n               output.join(\',\\n  \') +\n               \' \' +\n               braces[1];\n\n    } else {\n      output = braces[0] + base + \' \' + output.join(\', \') + \' \' + braces[1];\n    }\n\n    return output;\n  }\n  return format(obj, (typeof depth === \'undefined\' ? 2 : depth));\n};\n\n\nfunction isArray(ar) {\n  return Array.isArray(ar) ||\n         (typeof ar === \'object\' && Object.prototype.toString.call(ar) === \'[object Array]\');\n}\n\n\nfunction isRegExp(re) {\n  typeof re === \'object\' && Object.prototype.toString.call(re) === \'[object RegExp]\';\n}\n\n\nfunction isDate(d) {\n  return typeof d === \'object\' && Object.prototype.toString.call(d) === \'[object Date]\';\n}\n\nfunction pad(n) {\n  return n < 10 ? \'0\' + n.toString(10) : n.toString(10);\n}\n\nvar months = [\'Jan\', \'Feb\', \'Mar\', \'Apr\', \'May\', \'Jun\', \'Jul\', \'Aug\', \'Sep\',\n              \'Oct\', \'Nov\', \'Dec\'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(\':\');\n  return [d.getDate(), months[d.getMonth()], time].join(\' \');\n}\n\nexports.log = function (msg) {};\n\nexports.pump = null;\n\nvar Object_keys = Object.keys || function (obj) {\n    var res = [];\n    for (var key in obj) res.push(key);\n    return res;\n};\n\nvar Object_getOwnPropertyNames = Object.getOwnPropertyNames || function (obj) {\n    var res = [];\n    for (var key in obj) {\n        if (Object.hasOwnProperty.call(obj, key)) res.push(key);\n    }\n    return res;\n};\n\nvar Object_create = Object.create || function (prototype, properties) {\n    // from es5-shim\n    var object;\n    if (prototype === null) {\n        object = { \'__proto__\' : null };\n    }\n    else {\n        if (typeof prototype !== \'object\') {\n            throw new TypeError(\n                \'typeof prototype[\' + (typeof prototype) + \'] != \\\'object\\\'\'\n            );\n        }\n        var Type = function () {};\n        Type.prototype = prototype;\n        object = new Type();\n        object.__proto__ = prototype;\n    }\n    if (typeof properties !== \'undefined\' && Object.defineProperties) {\n        Object.defineProperties(object, properties);\n    }\n    return object;\n};\n\nexports.inherits = function(ctor, superCtor) {\n  ctor.super_ = superCtor;\n  ctor.prototype = Object_create(superCtor.prototype, {\n    constructor: {\n      value: ctor,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n};\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (typeof f !== \'string\') {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(exports.inspect(arguments[i]));\n    }\n    return objects.join(\' \');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === \'%%\') return \'%\';\n    if (i >= len) return x;\n    switch (x) {\n      case \'%s\': return String(args[i++]);\n      case \'%d\': return Number(args[i++]);\n      case \'%j\': return JSON.stringify(args[i++]);\n      default:\n        return x;\n    }\n  });\n  for(var x = args[i]; i < len; x = args[++i]){\n    if (x === null || typeof x !== \'object\') {\n      str += \' \' + x;\n    } else {\n      str += \' \' + exports.inspect(x);\n    }\n  }\n  return str;\n};\n\n},{"events":10}],2:[function(require,module,exports){\nvar ndn = require(\'ndn-browser-shim\');\nvar BinaryXmlElementReader = ndn.BinaryXmlElementReader;\nvar ndnbuf = ndn.ndnbuf;\nvar Name = ndn.Name\nvar Data = ndn.Data\nvar LOG = require(\'./LOG.js\')\nvar local = {}\n\nlocal.transport = function (port) {\n  this.port = port\n};\n\n\n/**\n * Connect to the host and port in face.  This replaces a previous connection and sets connectedHost\n *   and connectedPort.  Once connected, call onopenCallback().\n * Listen on the port to read an entire binary XML encoded element and call\n *    face.onReceivedElement(element).\n */\nlocal.transport.prototype.connect = function(face, onopenCallback)\n{\n  this.elementReader = new BinaryXmlElementReader(face);\n  var self = this;\n  this.port.onmessage = function(ev) {\n    //console.log(\'RecvHandle called on local face\', result);\n\n    if (ev.data == null || ev.data == undefined || ev.data == "") {\n      console.log(\'INVALID ANSWER\');\n    }\n    else if (ev.data instanceof ArrayBuffer) {\n      var bytearray = new ndnbuf(ev.data);\n\n      if (LOG > 3) console.log(\'BINARY RESPONSE IS \' + bytearray.toString(\'hex\'));\n\n      try {\n        // Find the end of the binary XML element and call face.onReceivedElement.\n        self.elementReader.onReceivedData(bytearray);\n      } catch (ex) {\n        console.log("NDN.ws.onmessage exception: " + ex);\n        return;\n      }\n      // garbage collect arraybuffer\n      //var ms = new MessageChannel()\n      //ms.port1.postMessage(ev.data, [ev.data])\n    }\n  };\n\n  onopenCallback();\n\n};\n\n/**\n * Send the Uint8Array data.\n */\nlocal.transport.prototype.send = function(data)\n{\n  if (true) {\n        // If we directly use data.buffer to feed ws.send(),\n        // WebSocket may end up sending a packet with 10000 bytes of data.\n        // That is, WebSocket will flush the entire buffer\n        // regardless of the offset of the Uint8Array. So we have to create\n        // a new Uint8Array buffer with just the right size and copy the\n        // content from binaryInterest to the new buffer.\n        //    ---Wentao\n        var bytearray = new Uint8Array(data.length);\n        bytearray.set(data);\n        this.port.postMessage(bytearray.buffer);\n\n        //garbage collect\n        //var ms = new MessageChannel();\n        //ms.port1.postMessage(bytearray.buffer, [bytearray.buffer])\n        //ms.port1.postMessage(data.buffer, [data.buffer])\n    console.log(\'local.send() returned.\');\n  }\n  else\n    console.log(\'local connection is not established.\');\n};\n\nmodule.exports = local;\n\n},{"./LOG.js":7,"ndn-browser-shim":6}],3:[function(require,module,exports){\nvar utils = {}\nvar Data = require(\'ndn-browser-shim\').Data\nvar Name = require(\'ndn-browser-shim\').Name\nvar SignedInfo = require(\'ndn-browser-shim\').SignedInfo\nvar ndnbuf = require(\'ndn-browser-shim\').ndnbuf\nvar DataUtils = require(\'ndn-browser-shim\').DataUtils\n\nutils.chunkArbitraryData = function(opts) {\n  var ndnArray = [];\n  //console.log(name)\n  if (opts.type == \'object\') {\n    var string = JSON.stringify(opts.thing);\n  } else if (typeof opts.data == \'string\') {\n    var string = data;\n  } else if (typeof opts.data == \'file\') {\n    //console.log(\'no handlers yet for datatype: \', typeof data);\n    return;\n  };\n  var name = new ndn.Name(opts.uri)\n  if (opts.version != false) {\n    utils.appendVersion(name, opts.version)\n  }\n  var stringArray = string.match(/.{1,4000}/g);\n  var segmentNames = [];\n  for (i = 0; i < stringArray.length; i++) {\n    segmentNames[i] = new Name(name).appendSegment(i)\n    var co = new Data(segmentNames[i], new SignedInfo(), new ndnbuf(stringArray[i]));\n    co.signedInfo.setFields()\n    co.signedInfo.finalBlockID = utils.initSegment(stringArray.length - 1)\n    console.log(co.signedInfo.finalBlockID)\n    if (opts.freshness != undefined) {\n      co.signedInfo.freshnessSeconds = fresh\n    }\n    co.sign()\n    ndnArray[i] = co.encode()\n  };\n\n  return {array:ndnArray, name: name};\n\n};\n\nutils.initSegment = function(seg) {\n    if (seg == null || seg == 0)\n\t  return (new ndnbuf(\'00\', \'hex\'));\n\n    var segStr = seg.toString(16);\n\n    if (segStr.length % 2 == 1)\n\tsegStr = \'0\' + segStr;\n\n    segStr = \'00\' + segStr;\n    return (new ndnbuf(segStr, \'hex\'));\n};\n\nutils.getAllPrefixes = function(name) {\n  var uriArray = [];\n  for (i = 0 ; i < name.components.length + 1 ; i++) {\n    var uri = name.getPrefix(i).toUri()\n    uriArray.push(uri);\n  };\n  return uriArray;\n};\n\nutils.isFirstSegment = function(name) {\n    return name.components != null && name.components.length >= 1 &&\n        name.components[name.components.length - 1].value.length == 1 &&\n        name.components[name.components.length - 1].value[0] == 0;\n};\n\nutils.isLastSegment = function(name, co) {\n\n    return DataUtils.arraysEqual(name.components[name.components.length - 1].value, co.signedInfo.finalBlockID);\n}\n\nutils.normalizeUri = function(name) {\n  //console.log(name)\n  if (!endsWithSegmentNumber(name)) {\n    normalizedName = name;\n    requestedSegment = 0\n  } else if (!isFirstSegment(name)) {\n    normalizedName = name.getPrefix(name.components.length - 1);\n    requestedSegment = DataUtils.bigEndianToUnsignedInt(name.components[name.components.length - 1].value);\n  } else {\n    normalizedName = name.getPrefix(name.components.length - 1) ;\n    requestedSegment = 0;\n  };\n  var returns = [normalizedName, requestedSegment];\n  return returns;\n};\n\nutils.getSegmentInteger = function(name) {\n  if (name.components != null && name.components.length >= 1 &&\n  name.components[name.components.length - 1].value.length >= 1 &&\n  name.components[name.components.length - 1].value[0] == 0) {\n    return DataUtils.bigEndianToUnsignedInt(name.components[name.components.length - 1].value)\n  } else {\n    return 0;\n  }\n};\n\nutils.normalizeNameToObjectStore = function(name) {\n  var throwaway = utils.getNameWithoutCommandMarker(name);\n\n  if (!utils.endsWithSegmentNumber(throwaway)) {\n    return throwaway.appendSegment(0).toUri();\n  } else if (!utils.isFirstSegment(throwaway)) {\n    return throwaway.getPrefix(name.components.length - 1).appendSegment(0).toUri();\n  } else {\n    return throwaway.toUri();\n  };\n};\n\nutils.endsWithSegmentNumber = function(name) {\n    return name.components != null && name.components.length >= 1 &&\n        name.components[name.components.length - 1].value.length >= 1 &&\n        name.components[name.components.length - 1].value[0] == 0;\n}\n\nutils.nameHasCommandMarker = function(name) {\n  for (var i = name.size() - 1; i >= 0; --i) {\n    var component = name.components[i].getValue();\n    if (component.length <= 0)\n      continue;\n\n    if (component[0] == 0xC1) {\n      return true\n    };\n  }\n\n  return false;\n};\n\nutils.getCommandMarker = function(name) {\n  //console.log(name)\n  for (var i = name.size() - 1; i >= 0; --i) {\n    var component = name.components[i].getValue();\n    if (component.length <= 0)\n      continue;\n\n    if (component[0] == 0xC1 && component[2] != 0x4E) {\n      return name.components[i].toEscapedString()\n    };\n  }\n};\n\nutils.getNameWithoutCommandMarker = function(name) {\n  var strippedName = new Name(\'\');\n\n  for (var i = 0 ; i < name.size(); i++) {\n    var component = name.components[i].getValue();\n    if (component.length <= 0)\n      continue;\n\n    if (component[0] != 0xC1) {\n      strippedName.append(name.components[i]);\n    };\n  };\n  return strippedName;\n};\n\n\nutils.getSuffix = function(name, p) {\n    return new Name(name.components.slice(p));\n};\n\nutils.appendVersion = function(name, date) {\n    console.log(date)\n    if (date) {\n      if (date instanceof Date) {\n        var d = date.getTime()\n\n      } else if (typeof date == "number")\n        var d = new Date().setTime(date)\n    } else {\n      var d = new Date().getTime();\n    };\n\n    var time = d.toString(16);\n    if (time.length % 2 == 1) {\n\t    time = \'0\' + time;\n    };\n    time = \'fd\' + time;\n    var binTime = new ndnbuf(time, \'hex\');\n    //console.log(binTime)\n    return name.append(binTime);\n};\n\nutils.timeToVersion = function(date) {\n  if (date instanceof Date) {\n    var d = date.getTime\n  } else {\n    var d = date;\n  };\n  var time = d.toString(16);\n  if (time.length % 2 == 1) {\n    time = \'0\' + time;\n  };\n  time = \'fd\' + time;\n  var binTime = new ndnbuf(time, \'hex\');\n  return (new Name.Component(binTime).toEscapedString())\n\n};\n\nutils.versionToTime = function(version) {\n  time = 0\n  array = DataUtils.toNumbers(DataUtils.toHex(version))\n  //console.log(array)\n  for (i = 1; i < array.length ; i++) {\n    time = time + (array[i] * Math.pow(2, (7 - i)));\n    //console.log(time)\n  };\n  return time\n};\n\n\n\nutils.setNonce = function(interest) {\n  var bytes = [0xc1, 0x2e, 0x4e, 0x00];\n  for (var n = 8; n > 0; n--) {\n\t  bytes.push(Math.floor(Math.random() * 256));\n\t  //console.log(bytes)\n  }\n  var buf = new ndnbuf(bytes);\n  interest.nonce = buf;\n}\n\nmodule.exports = utils;\n\n},{"ndn-browser-shim":6}],5:[function(require,module,exports){\n(function(Buffer){module.exports = Level\n\nvar IDB = require(\'idb-wrapper\')\nvar AbstractLevelDOWN = require(\'abstract-leveldown\').AbstractLevelDOWN\nvar util = require(\'util\')\nvar Iterator = require(\'./iterator\')\nvar isBuffer = require(\'isbuffer\')\n\nfunction Level(location) {\n  if (!(this instanceof Level)) return new Level(location)\n  if (!location) throw new Error("constructor requires at least a location argument")\n  \n  this.location = location\n}\n\nutil.inherits(Level, AbstractLevelDOWN)\n\nLevel.prototype._open = function(options, callback) {\n  var self = this\n  \n  this.idb = new IDB({\n    storeName: this.location,\n    autoIncrement: false,\n    keyPath: null,\n    onStoreReady: function () {\n      callback && callback(null, self.idb)\n    }, \n    onError: function(err) {\n      callback && callback(err)\n    }\n  })\n}\n\nLevel.prototype._get = function (key, options, callback) {\n  this.idb.get(key, function (value) {\n    if (value === undefined) {\n      // \'NotFound\' error, consistent with LevelDOWN API\n      return callback(new Error(\'NotFound\'))\n    }\n    if (options.asBuffer !== false && !Buffer.isBuffer(value))\n      value = new Buffer(String(value))\n    return callback(null, value, key)\n  }, callback)\n}\n\nLevel.prototype._del = function(id, options, callback) {\n  this.idb.remove(id, callback, callback)\n}\n\nLevel.prototype._put = function (key, value, options, callback) {\n  if (value instanceof ArrayBuffer) {\n    value = String.fromCharCode.apply(null, new Uint16Array(value))\n  }\n  this.idb.put(key, value, function() { callback() }, callback)\n}\n\nLevel.prototype.iterator = function (options) {\n  if (typeof options !== \'object\') options = {}\n  return new Iterator(this.idb, options)\n}\n\nLevel.prototype._batch = function (array, options, callback) {\n  var op\n  var i\n  var k\n  var copiedOp\n  var currentOp\n  var modified = []\n\n  for (i = 0; i < array.length; i++) {\n    copiedOp = {}\n    currentOp = array[i]\n    modified[i] = copiedOp\n\n    for (k in currentOp) {\n      if (k === \'type\' && currentOp[k] == \'del\') {\n        copiedOp[k] = \'remove\'\n      } else {\n        copiedOp[k] = currentOp[k]\n      }\n    }\n  }\n\n  return this.idb.batch(modified, function(){ callback() }, callback)\n}\n\nLevel.prototype._close = function (callback) {\n  this.idb.db.close()\n  callback()\n}\n\nLevel.prototype._approximateSize = function (start, end, callback) {\n  var err = new Error(\'Not implemented\')\n  if (callback)\n    return callback(err)\n\n  throw err\n}\n\nLevel.prototype._isBuffer = function (obj) {\n  return Buffer.isBuffer(obj)\n}\n\nvar checkKeyValue = Level.prototype._checkKeyValue = function (obj, type) {\n  if (obj === null || obj === undefined)\n    return new Error(type + \' cannot be `null` or `undefined`\')\n  if (obj === null || obj === undefined)\n    return new Error(type + \' cannot be `null` or `undefined`\')\n  if (isBuffer(obj) && obj.byteLength === 0)\n    return new Error(type + \' cannot be an empty ArrayBuffer\')\n  if (String(obj) === \'\')\n    return new Error(type + \' cannot be an empty String\')\n  if (obj.length === 0)\n    return new Error(type + \' cannot be an empty Array\')\n}\n\n})(require("__browserify_buffer").Buffer)\n},{"./iterator":12,"__browserify_buffer":8,"abstract-leveldown":13,"idb-wrapper":15,"isbuffer":14,"util":11}],16:[function(require,module,exports){\nvar events = require(\'events\');\nvar util = require(\'util\');\n\nfunction Stream() {\n  events.EventEmitter.call(this);\n}\nutil.inherits(Stream, events.EventEmitter);\nmodule.exports = Stream;\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on(\'data\', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on(\'drain\', ondrain);\n\n  // If the \'end\' option is not supplied, dest.end() will be called when\n  // source gets the \'end\' or \'close\' events.  Only dest.end() once, and\n  // only when all sources have ended.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    dest._pipeCount = dest._pipeCount || 0;\n    dest._pipeCount++;\n\n    source.on(\'end\', onend);\n    source.on(\'close\', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest._pipeCount--;\n\n    // remove the listeners\n    cleanup();\n\n    if (dest._pipeCount > 0) {\n      // waiting for other incoming streams to end.\n      return;\n    }\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest._pipeCount--;\n\n    // remove the listeners\n    cleanup();\n\n    if (dest._pipeCount > 0) {\n      // waiting for other incoming streams to end.\n      return;\n    }\n\n    dest.destroy();\n  }\n\n  // don\'t leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (this.listeners(\'error\').length === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on(\'error\', onerror);\n  dest.on(\'error\', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener(\'data\', ondata);\n    dest.removeListener(\'drain\', ondrain);\n\n    source.removeListener(\'end\', onend);\n    source.removeListener(\'close\', onclose);\n\n    source.removeListener(\'error\', onerror);\n    dest.removeListener(\'error\', onerror);\n\n    source.removeListener(\'end\', cleanup);\n    source.removeListener(\'close\', cleanup);\n\n    dest.removeListener(\'end\', cleanup);\n    dest.removeListener(\'close\', cleanup);\n  }\n\n  source.on(\'end\', cleanup);\n  source.on(\'close\', cleanup);\n\n  dest.on(\'end\', cleanup);\n  dest.on(\'close\', cleanup);\n\n  dest.emit(\'pipe\', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n\n},{"events":10,"util":11}],14:[function(require,module,exports){\n(function(){var Buffer = require(\'buffer\').Buffer;\n\nmodule.exports = isBuffer;\n\nfunction isBuffer (o) {\n  return Buffer.isBuffer(o)\n    || /\\[object (.+Array|Array.+)\\]/.test(Object.prototype.toString.call(o));\n}\n\n})()\n},{"buffer":17}],15:[function(require,module,exports){\n(function(){/*global window:false, self:false, define:false, module:false */\n\n/**\n * @license IDBWrapper - A cross-browser wrapper for IndexedDB\n * Copyright (c) 2011 - 2013 Jens Arps\n * http://jensarps.de/\n *\n * Licensed under the MIT (X11) license\n */\n\n(function (name, definition, global) {\n  if (typeof define === \'function\') {\n    define(definition);\n  } else if (typeof module !== \'undefined\' && module.exports) {\n    module.exports = definition();\n  } else {\n    global[name] = definition();\n  }\n})(\'IDBStore\', function () {\n\n  \'use strict\';\n\n  var defaultErrorHandler = function (error) {\n    throw error;\n  };\n\n  var defaults = {\n    storeName: \'Store\',\n    storePrefix: \'IDBWrapper-\',\n    dbVersion: 1,\n    keyPath: \'id\',\n    autoIncrement: true,\n    onStoreReady: function () {\n    },\n    onError: defaultErrorHandler,\n    indexes: []\n  };\n\n  /**\n   *\n   * The IDBStore constructor\n   *\n   * @constructor\n   * @name IDBStore\n   * @version 1.4.1\n   *\n   * @param {Object} [kwArgs] An options object used to configure the store and\n   *  set callbacks\n   * @param {String} [kwArgs.storeName=\'Store\'] The name of the store\n   * @param {String} [kwArgs.storePrefix=\'IDBWrapper-\'] A prefix that is\n   *  internally used to construct the name of the database, which will be\n   *  kwArgs.storePrefix + kwArgs.storeName\n   * @param {Number} [kwArgs.dbVersion=1] The version of the store\n   * @param {String} [kwArgs.keyPath=\'id\'] The key path to use. If you want to\n   *  setup IDBWrapper to work with out-of-line keys, you need to set this to\n   *  `null`\n   * @param {Boolean} [kwArgs.autoIncrement=true] If set to true, IDBStore will\n   *  automatically make sure a unique keyPath value is present on each object\n   *  that is stored.\n   * @param {Function} [kwArgs.onStoreReady] A callback to be called when the\n   *  store is ready to be used.\n   * @param {Function} [kwArgs.onError=throw] A callback to be called when an\n   *  error occurred during instantiation of the store.\n   * @param {Array} [kwArgs.indexes=[]] An array of indexData objects\n   *  defining the indexes to use with the store. For every index to be used\n   *  one indexData object needs to be passed in the array.\n   *  An indexData object is defined as follows:\n   * @param {Object} [kwArgs.indexes.indexData] An object defining the index to\n   *  use\n   * @param {String} kwArgs.indexes.indexData.name The name of the index\n   * @param {String} [kwArgs.indexes.indexData.keyPath] The key path of the index\n   * @param {Boolean} [kwArgs.indexes.indexData.unique] Whether the index is unique\n   * @param {Boolean} [kwArgs.indexes.indexData.multiEntry] Whether the index is multi entry\n   * @param {Function} [onStoreReady] A callback to be called when the store\n   * is ready to be used.\n   * @example\n      // create a store for customers with an additional index over the\n      // `lastname` property.\n      var myCustomerStore = new IDBStore({\n        dbVersion: 1,\n        storeName: \'customer-index\',\n        keyPath: \'customerid\',\n        autoIncrement: true,\n        onStoreReady: populateTable,\n        indexes: [\n          { name: \'lastname\', keyPath: \'lastname\', unique: false, multiEntry: false }\n        ]\n      });\n   * @example\n      // create a generic store\n      var myCustomerStore = new IDBStore({\n        storeName: \'my-data-store\',\n        onStoreReady: function(){\n          // start working with the store.\n        }\n      });\n   */\n  var IDBStore = function (kwArgs, onStoreReady) {\n\n    if (typeof onStoreReady == \'undefined\' && typeof kwArgs == \'function\') {\n      onStoreReady = kwArgs;\n    }\n    if (Object.prototype.toString.call(kwArgs) != \'[object Object]\') {\n      kwArgs = {};\n    }\n\n    for (var key in defaults) {\n      this[key] = typeof kwArgs[key] != \'undefined\' ? kwArgs[key] : defaults[key];\n    }\n\n    this.dbName = this.storePrefix + this.storeName;\n    this.dbVersion = parseInt(this.dbVersion, 10) || 1;\n\n    onStoreReady && (this.onStoreReady = onStoreReady);\n\n    var env = typeof window == \'object\' ? window : self;\n    this.idb = env.indexedDB || env.webkitIndexedDB || env.mozIndexedDB;\n    this.keyRange = env.IDBKeyRange || env.webkitIDBKeyRange || env.mozIDBKeyRange;\n\n    this.features = {\n      hasAutoIncrement: !env.mozIndexedDB\n    };\n\n    this.consts = {\n      \'READ_ONLY\':         \'readonly\',\n      \'READ_WRITE\':        \'readwrite\',\n      \'VERSION_CHANGE\':    \'versionchange\',\n      \'NEXT\':              \'next\',\n      \'NEXT_NO_DUPLICATE\': \'nextunique\',\n      \'PREV\':              \'prev\',\n      \'PREV_NO_DUPLICATE\': \'prevunique\'\n    };\n\n    this.openDB();\n  };\n\n  IDBStore.prototype = /** @lends IDBStore */ {\n\n    /**\n     * A pointer to the IDBStore ctor\n     *\n     * @type IDBStore\n     */\n    constructor: IDBStore,\n\n    /**\n     * The version of IDBStore\n     *\n     * @type String\n     */\n    version: \'1.4.1\',\n\n    /**\n     * A reference to the IndexedDB object\n     *\n     * @type Object\n     */\n    db: null,\n\n    /**\n     * The full name of the IndexedDB used by IDBStore, composed of\n     * this.storePrefix + this.storeName\n     *\n     * @type String\n     */\n    dbName: null,\n\n    /**\n     * The version of the IndexedDB used by IDBStore\n     *\n     * @type Number\n     */\n    dbVersion: null,\n\n    /**\n     * A reference to the objectStore used by IDBStore\n     *\n     * @type Object\n     */\n    store: null,\n\n    /**\n     * The store name\n     *\n     * @type String\n     */\n    storeName: null,\n\n    /**\n     * The key path\n     *\n     * @type String\n     */\n    keyPath: null,\n\n    /**\n     * Whether IDBStore uses autoIncrement\n     *\n     * @type Boolean\n     */\n    autoIncrement: null,\n\n    /**\n     * The indexes used by IDBStore\n     *\n     * @type Array\n     */\n    indexes: null,\n\n    /**\n     * A hashmap of features of the used IDB implementation\n     *\n     * @type Object\n     * @proprty {Boolean} autoIncrement If the implementation supports\n     *  native auto increment\n     */\n    features: null,\n\n    /**\n     * The callback to be called when the store is ready to be used\n     *\n     * @type Function\n     */\n    onStoreReady: null,\n\n    /**\n     * The callback to be called if an error occurred during instantiation\n     * of the store\n     *\n     * @type Function\n     */\n    onError: null,\n\n    /**\n     * The internal insertID counter\n     *\n     * @type Number\n     * @private\n     */\n    _insertIdCount: 0,\n\n    /**\n     * Opens an IndexedDB; called by the constructor.\n     *\n     * Will check if versions match and compare provided index configuration\n     * with existing ones, and update indexes if necessary.\n     *\n     * Will call this.onStoreReady() if everything went well and the store\n     * is ready to use, and this.onError() is something went wrong.\n     *\n     * @private\n     *\n     */\n    openDB: function () {\n\n      var openRequest = this.idb.open(this.dbName, this.dbVersion);\n      var preventSuccessCallback = false;\n\n      openRequest.onerror = function (error) {\n\n        var gotVersionErr = false;\n        if (\'error\' in error.target) {\n          gotVersionErr = error.target.error.name == \'VersionError\';\n        } else if (\'errorCode\' in error.target) {\n          gotVersionErr = error.target.errorCode == 12;\n        }\n\n        if (gotVersionErr) {\n          this.onError(new Error(\'The version number provided is lower than the existing one.\'));\n        } else {\n          this.onError(error);\n        }\n      }.bind(this);\n\n      openRequest.onsuccess = function (event) {\n\n        if (preventSuccessCallback) {\n          return;\n        }\n\n        if(this.db){\n          this.onStoreReady();\n          return;\n        }\n\n        this.db = event.target.result;\n\n        if(typeof this.db.version == \'string\'){\n          this.onError(new Error(\'The IndexedDB implementation in this browser is outdated. Please upgrade your browser.\'));\n          return;\n        }\n\n        if(!this.db.objectStoreNames.contains(this.storeName)){\n          // We should never ever get here.\n          // Lets notify the user anyway.\n          this.onError(new Error(\'Something is wrong with the IndexedDB implementation in this browser. Please upgrade your browser.\'));\n          return;\n        }\n\n        var emptyTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n        this.store = emptyTransaction.objectStore(this.storeName);\n\n        // check indexes\n        var existingIndexes = Array.prototype.slice.call(this.getIndexList());\n        this.indexes.forEach(function(indexData){\n          var indexName = indexData.name;\n\n          if(!indexName){\n            preventSuccessCallback = true;\n            this.onError(new Error(\'Cannot create index: No index name given.\'));\n            return;\n          }\n\n          this.normalizeIndexData(indexData);\n\n          if(this.hasIndex(indexName)){\n            // check if it complies\n            var actualIndex = this.store.index(indexName);\n            var complies = this.indexComplies(actualIndex, indexData);\n            if(!complies){\n              preventSuccessCallback = true;\n              this.onError(new Error(\'Cannot modify index "\' + indexName + \'" for current version. Please bump version number to \' + ( this.dbVersion + 1 ) + \'.\'));\n            }\n\n            existingIndexes.splice(existingIndexes.indexOf(indexName), 1);\n          } else {\n            preventSuccessCallback = true;\n            this.onError(new Error(\'Cannot create new index "\' + indexName + \'" for current version. Please bump version number to \' + ( this.dbVersion + 1 ) + \'.\'));\n          }\n\n        }, this);\n\n        if (existingIndexes.length) {\n          preventSuccessCallback = true;\n          this.onError(new Error(\'Cannot delete index(es) "\' + existingIndexes.toString() + \'" for current version. Please bump version number to \' + ( this.dbVersion + 1 ) + \'.\'));\n        }\n\n        preventSuccessCallback || this.onStoreReady();\n      }.bind(this);\n\n      openRequest.onupgradeneeded = function(/* IDBVersionChangeEvent */ event){\n\n        this.db = event.target.result;\n\n        if(this.db.objectStoreNames.contains(this.storeName)){\n          this.store = event.target.transaction.objectStore(this.storeName);\n        } else {\n          var optionalParameters = { autoIncrement: this.autoIncrement };\n          if (this.keyPath !== null) {\n            optionalParameters.keyPath = this.keyPath;\n          }\n          this.store = this.db.createObjectStore(this.storeName, optionalParameters);\n        }\n\n        var existingIndexes = Array.prototype.slice.call(this.getIndexList());\n        this.indexes.forEach(function(indexData){\n          var indexName = indexData.name;\n\n          if(!indexName){\n            preventSuccessCallback = true;\n            this.onError(new Error(\'Cannot create index: No index name given.\'));\n          }\n\n          this.normalizeIndexData(indexData);\n\n          if(this.hasIndex(indexName)){\n            // check if it complies\n            var actualIndex = this.store.index(indexName);\n            var complies = this.indexComplies(actualIndex, indexData);\n            if(!complies){\n              // index differs, need to delete and re-create\n              this.store.deleteIndex(indexName);\n              this.store.createIndex(indexName, indexData.keyPath, { unique: indexData.unique, multiEntry: indexData.multiEntry });\n            }\n\n            existingIndexes.splice(existingIndexes.indexOf(indexName), 1);\n          } else {\n            this.store.createIndex(indexName, indexData.keyPath, { unique: indexData.unique, multiEntry: indexData.multiEntry });\n          }\n\n        }, this);\n\n        if (existingIndexes.length) {\n          existingIndexes.forEach(function(_indexName){\n            this.store.deleteIndex(_indexName);\n          }, this);\n        }\n\n      }.bind(this);\n    },\n\n    /**\n     * Deletes the database used for this store if the IDB implementations\n     * provides that functionality.\n     */\n    deleteDatabase: function () {\n      if (this.idb.deleteDatabase) {\n        this.idb.deleteDatabase(this.dbName);\n      }\n    },\n\n    /*********************\n     * data manipulation *\n     *********************/\n\n    /**\n     * Puts an object into the store. If an entry with the given id exists,\n     * it will be overwritten. This method has a different signature for inline\n     * keys and out-of-line keys; please see the examples below.\n     *\n     * @param {*} [key] The key to store. This is only needed if IDBWrapper\n     *  is set to use out-of-line keys. For inline keys - the default scenario -\n     *  this can be omitted.\n     * @param {Object} value The data object to store.\n     * @param {Function} [onSuccess] A callback that is called if insertion\n     *  was successful.\n     * @param {Function} [onError] A callback that is called if insertion\n     *  failed.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     * @example\n        // Storing an object, using inline keys (the default scenario):\n        var myCustomer = {\n          customerid: 2346223,\n          lastname: \'Doe\',\n          firstname: \'John\'\n        };\n        myCustomerStore.put(myCustomer, mySuccessHandler, myErrorHandler);\n        // Note that passing success- and error-handlers is optional.\n     * @example\n        // Storing an object, using out-of-line keys:\n       var myCustomer = {\n         lastname: \'Doe\',\n         firstname: \'John\'\n       };\n       myCustomerStore.put(2346223, myCustomer, mySuccessHandler, myErrorHandler);\n      // Note that passing success- and error-handlers is optional.\n     */\n    put: function (key, value, onSuccess, onError) {\n      if (this.keyPath !== null) {\n        onError = onSuccess;\n        onSuccess = value;\n        value = key;\n      }\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = noop);\n\n      var hasSuccess = false,\n          result = null,\n          putRequest;\n\n      var putTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);\n      putTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n      putTransaction.onabort = onError;\n      putTransaction.onerror = onError;\n\n      if (this.keyPath !== null) { // in-line keys\n        this._addIdPropertyIfNeeded(value);\n        putRequest = putTransaction.objectStore(this.storeName).put(value);\n      } else { // out-of-line keys\n        putRequest = putTransaction.objectStore(this.storeName).put(value, key);\n      }\n      putRequest.onsuccess = function (event) {\n        hasSuccess = true;\n        result = event.target.result;\n      };\n      putRequest.onerror = onError;\n\n      return putTransaction;\n    },\n\n    /**\n     * Retrieves an object from the store. If no entry exists with the given id,\n     * the success handler will be called with null as first and only argument.\n     *\n     * @param {*} key The id of the object to fetch.\n     * @param {Function} [onSuccess] A callback that is called if fetching\n     *  was successful. Will receive the object as only argument.\n     * @param {Function} [onError] A callback that will be called if an error\n     *  occurred during the operation.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    get: function (key, onSuccess, onError) {\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = noop);\n\n      var hasSuccess = false,\n          result = null;\n      \n      var getTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n      getTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n      getTransaction.onabort = onError;\n      getTransaction.onerror = onError;\n      var getRequest = getTransaction.objectStore(this.storeName).get(key);\n      getRequest.onsuccess = function (event) {\n        hasSuccess = true;\n        result = event.target.result;\n      };\n      getRequest.onerror = onError;\n\n      return getTransaction;\n    },\n\n    /**\n     * Removes an object from the store.\n     *\n     * @param {*} key The id of the object to remove.\n     * @param {Function} [onSuccess] A callback that is called if the removal\n     *  was successful.\n     * @param {Function} [onError] A callback that will be called if an error\n     *  occurred during the operation.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    remove: function (key, onSuccess, onError) {\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = noop);\n\n      var hasSuccess = false,\n          result = null;\n\n      var removeTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);\n      removeTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n      removeTransaction.onabort = onError;\n      removeTransaction.onerror = onError;\n\n      var deleteRequest = removeTransaction.objectStore(this.storeName)[\'delete\'](key);\n      deleteRequest.onsuccess = function (event) {\n        hasSuccess = true;\n        result = event.target.result;\n      };\n      deleteRequest.onerror = onError;\n\n      return removeTransaction;\n    },\n\n    /**\n     * Runs a batch of put and/or remove operations on the store.\n     *\n     * @param {Array} dataArray An array of objects containing the operation to run\n     *  and the data object (for put operations).\n     * @param {Function} [onSuccess] A callback that is called if all operations\n     *  were successful.\n     * @param {Function} [onError] A callback that is called if an error\n     *  occurred during one of the operations.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    batch: function (dataArray, onSuccess, onError) {\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = noop);\n\n      if(Object.prototype.toString.call(dataArray) != \'[object Array]\'){\n        onError(new Error(\'dataArray argument must be of type Array.\'));\n      }\n      var batchTransaction = this.db.transaction([this.storeName] , this.consts.READ_WRITE);\n      batchTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(hasSuccess);\n      };\n      batchTransaction.onabort = onError;\n      batchTransaction.onerror = onError;\n      \n      var count = dataArray.length;\n      var called = false;\n      var hasSuccess = false;\n\n      var onItemSuccess = function () {\n        count--;\n        if (count === 0 && !called) {\n          called = true;\n          hasSuccess = true;\n        }\n      };\n\n      dataArray.forEach(function (operation) {\n        var type = operation.type;\n        var key = operation.key;\n        var value = operation.value;\n\n        var onItemError = function (err) {\n          batchTransaction.abort();\n          if (!called) {\n            called = true;\n            onError(err, type, key);\n          }\n        };\n\n        if (type == \'remove\') {\n          var deleteRequest = batchTransaction.objectStore(this.storeName)[\'delete\'](key);\n          deleteRequest.onsuccess = onItemSuccess;\n          deleteRequest.onerror = onItemError;\n        } else if (type == \'put\') {\n          var putRequest;\n          if (this.keyPath !== null) { // in-line keys\n            this._addIdPropertyIfNeeded(value);\n            putRequest = batchTransaction.objectStore(this.storeName).put(value);\n          } else { // out-of-line keys\n            putRequest = batchTransaction.objectStore(this.storeName).put(value, key);\n          }\n          putRequest.onsuccess = onItemSuccess;\n          putRequest.onerror = onItemError;\n        }\n      }, this);\n\n      return batchTransaction;\n    },\n\n    /**\n     * Takes an array of objects and stores them in a single transaction.\n     *\n     * @param {Array} dataArray An array of objects to store\n     * @param {Function} [onSuccess] A callback that is called if all operations\n     *  were successful.\n     * @param {Function} [onError] A callback that is called if an error\n     *  occurred during one of the operations.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    putBatch: function (dataArray, onSuccess, onError) {\n      var batchData = dataArray.map(function(item){\n        return { type: \'put\', value: item };\n      });\n\n      return this.batch(batchData, onSuccess, onError);\n    },\n\n    /**\n     * Takes an array of keys and removes matching objects in a single\n     * transaction.\n     *\n     * @param {Array} keyArray An array of keys to remove\n     * @param {Function} [onSuccess] A callback that is called if all operations\n     *  were successful.\n     * @param {Function} [onError] A callback that is called if an error\n     *  occurred during one of the operations.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    removeBatch: function (keyArray, onSuccess, onError) {\n      var batchData = keyArray.map(function(key){\n        return { type: \'remove\', key: key };\n      });\n\n      return this.batch(batchData, onSuccess, onError);\n    },\n\n    /**\n     * Takes an array of keys and fetches matching objects\n     *\n     * @param {Array} keyArray An array of keys identifying the objects to fetch\n     * @param {Function} [onSuccess] A callback that is called if all operations\n     *  were successful.\n     * @param {Function} [onError] A callback that is called if an error\n     *  occurred during one of the operations.\n     * @param {String} [arrayType=\'sparse\'] The type of array to pass to the\n     *  success handler. May be one of \'sparse\', \'dense\' or \'skip\'. Defaults to\n     *  \'sparse\'. This parameter specifies how to handle the situation if a get\n     *  operation did not throw an error, but there was no matching object in\n     *  the database. In most cases, \'sparse\' provides the most desired\n     *  behavior. See the examples for details.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     * @example\n     // given that there are two objects in the database with the keypath\n     // values 1 and 2, and the call looks like this:\n     myStore.getBatch([1, 5, 2], onError, function (data) { \u2026 }, arrayType);\n\n     // this is what the `data` array will be like:\n\n     // arrayType == \'sparse\':\n     // data is a sparse array containing two entries and having a length of 3:\n       [Object, 2: Object]\n         0: Object\n         2: Object\n         length: 3\n         __proto__: Array[0]\n     // calling forEach on data will result in the callback being called two\n     // times, with the index parameter matching the index of the key in the\n     // keyArray.\n\n     // arrayType == \'dense\':\n     // data is a dense array containing three entries and having a length of 3,\n     // where data[1] is of type undefined:\n       [Object, undefined, Object]\n         0: Object\n         1: undefined\n         2: Object\n         length: 3\n         __proto__: Array[0]\n     // calling forEach on data will result in the callback being called three\n     // times, with the index parameter matching the index of the key in the\n     // keyArray, but the second call will have undefined as first argument.\n\n     // arrayType == \'skip\':\n     // data is a dense array containing two entries and having a length of 2:\n       [Object, Object]\n         0: Object\n         1: Object\n         length: 2\n         __proto__: Array[0]\n     // calling forEach on data will result in the callback being called two\n     // times, with the index parameter not matching the index of the key in the\n     // keyArray.\n     */\n    getBatch: function (keyArray, onSuccess, onError, arrayType) {\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = noop);\n      arrayType || (arrayType = \'sparse\');\n\n      if(Object.prototype.toString.call(keyArray) != \'[object Array]\'){\n        onError(new Error(\'keyArray argument must be of type Array.\'));\n      }\n      var batchTransaction = this.db.transaction([this.storeName] , this.consts.READ_ONLY);\n      batchTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n      batchTransaction.onabort = onError;\n      batchTransaction.onerror = onError;\n\n      var data = [];\n      var count = keyArray.length;\n      var called = false;\n      var hasSuccess = false;\n      var result = null;\n\n      var onItemSuccess = function (event) {\n        if (event.target.result || arrayType == \'dense\') {\n          data.push(event.target.result);\n        } else if (arrayType == \'sparse\') {\n          data.length++;\n        }\n        count--;\n        if (count === 0) {\n          called = true;\n          hasSuccess = true;\n          result = data;\n        }\n      };\n\n      keyArray.forEach(function (key) {\n\n        var onItemError = function (err) {\n          called = true;\n          result = err;\n          onError(err);\n          batchTransaction.abort();\n        };\n\n        var getRequest = batchTransaction.objectStore(this.storeName).get(key);\n        getRequest.onsuccess = onItemSuccess;\n        getRequest.onerror = onItemError;\n\n      }, this);\n\n      return batchTransaction;\n    },\n\n    /**\n     * Fetches all entries in the store.\n     *\n     * @param {Function} [onSuccess] A callback that is called if the operation\n     *  was successful. Will receive an array of objects.\n     * @param {Function} [onError] A callback that will be called if an error\n     *  occurred during the operation.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    getAll: function (onSuccess, onError) {\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = noop);\n      var getAllTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n      var store = getAllTransaction.objectStore(this.storeName);\n      if (store.getAll) {\n        this._getAllNative(getAllTransaction, store, onSuccess, onError);\n      } else {\n        this._getAllCursor(getAllTransaction, store, onSuccess, onError);\n      }\n\n      return getAllTransaction;\n    },\n\n    /**\n     * Implements getAll for IDB implementations that have a non-standard\n     * getAll() method.\n     *\n     * @param {Object} getAllTransaction An open READ transaction.\n     * @param {Object} store A reference to the store.\n     * @param {Function} onSuccess A callback that will be called if the\n     *  operation was successful.\n     * @param {Function} onError A callback that will be called if an\n     *  error occurred during the operation.\n     * @private\n     */\n    _getAllNative: function (getAllTransaction, store, onSuccess, onError) {\n      var hasSuccess = false,\n          result = null;\n\n      getAllTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n      getAllTransaction.onabort = onError;\n      getAllTransaction.onerror = onError;\n\n      var getAllRequest = store.getAll();\n      getAllRequest.onsuccess = function (event) {\n        hasSuccess = true;\n        result = event.target.result;\n      };\n      getAllRequest.onerror = onError;\n    },\n\n    /**\n     * Implements getAll for IDB implementations that do not have a getAll()\n     * method.\n     *\n     * @param {Object} getAllTransaction An open READ transaction.\n     * @param {Object} store A reference to the store.\n     * @param {Function} onSuccess A callback that will be called if the\n     *  operation was successful.\n     * @param {Function} onError A callback that will be called if an\n     *  error occurred during the operation.\n     * @private\n     */\n    _getAllCursor: function (getAllTransaction, store, onSuccess, onError) {\n      var all = [],\n          hasSuccess = false,\n          result = null;\n\n      getAllTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n      getAllTransaction.onabort = onError;\n      getAllTransaction.onerror = onError;\n\n      var cursorRequest = store.openCursor();\n      cursorRequest.onsuccess = function (event) {\n        var cursor = event.target.result;\n        if (cursor) {\n          all.push(cursor.value);\n          cursor[\'continue\']();\n        }\n        else {\n          hasSuccess = true;\n          result = all;\n        }\n      };\n      cursorRequest.onError = onError;\n    },\n\n    /**\n     * Clears the store, i.e. deletes all entries in the store.\n     *\n     * @param {Function} [onSuccess] A callback that will be called if the\n     *  operation was successful.\n     * @param {Function} [onError] A callback that will be called if an\n     *  error occurred during the operation.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    clear: function (onSuccess, onError) {\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = noop);\n\n      var hasSuccess = false,\n          result = null;\n\n      var clearTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);\n      clearTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n      clearTransaction.onabort = onError;\n      clearTransaction.onerror = onError;\n\n      var clearRequest = clearTransaction.objectStore(this.storeName).clear();\n      clearRequest.onsuccess = function (event) {\n        hasSuccess = true;\n        result = event.target.result;\n      };\n      clearRequest.onerror = onError;\n\n      return clearTransaction;\n    },\n\n    /**\n     * Checks if an id property needs to present on a object and adds one if\n     * necessary.\n     *\n     * @param {Object} dataObj The data object that is about to be stored\n     * @private\n     */\n    _addIdPropertyIfNeeded: function (dataObj) {\n      if (!this.features.hasAutoIncrement && typeof dataObj[this.keyPath] == \'undefined\') {\n        dataObj[this.keyPath] = this._insertIdCount++ + Date.now();\n      }\n    },\n\n    /************\n     * indexing *\n     ************/\n\n    /**\n     * Returns a DOMStringList of index names of the store.\n     *\n     * @return {DOMStringList} The list of index names\n     */\n    getIndexList: function () {\n      return this.store.indexNames;\n    },\n\n    /**\n     * Checks if an index with the given name exists in the store.\n     *\n     * @param {String} indexName The name of the index to look for\n     * @return {Boolean} Whether the store contains an index with the given name\n     */\n    hasIndex: function (indexName) {\n      return this.store.indexNames.contains(indexName);\n    },\n\n    /**\n     * Normalizes an object containing index data and assures that all\n     * properties are set.\n     *\n     * @param {Object} indexData The index data object to normalize\n     * @param {String} indexData.name The name of the index\n     * @param {String} [indexData.keyPath] The key path of the index\n     * @param {Boolean} [indexData.unique] Whether the index is unique\n     * @param {Boolean} [indexData.multiEntry] Whether the index is multi entry\n     */\n    normalizeIndexData: function (indexData) {\n      indexData.keyPath = indexData.keyPath || indexData.name;\n      indexData.unique = !!indexData.unique;\n      indexData.multiEntry = !!indexData.multiEntry;\n    },\n\n    /**\n     * Checks if an actual index complies with an expected index.\n     *\n     * @param {Object} actual The actual index found in the store\n     * @param {Object} expected An Object describing an expected index\n     * @return {Boolean} Whether both index definitions are identical\n     */\n    indexComplies: function (actual, expected) {\n      var complies = [\'keyPath\', \'unique\', \'multiEntry\'].every(function (key) {\n        // IE10 returns undefined for no multiEntry\n        if (key == \'multiEntry\' && actual[key] === undefined && expected[key] === false) {\n          return true;\n        }\n        // Compound keys\n        if (key == \'keyPath\' && Object.prototype.toString.call(expected[key]) == \'[object Array]\') {\n          var exp = expected.keyPath;\n          var act = actual.keyPath;\n\n          // IE10 can\'t handle keyPath sequences and stores them as a string.\n          // The index will be unusable there, but let\'s still return true if\n          // the keyPath sequence matches.\n          if (typeof act == \'string\') {\n            return exp.toString() == act;\n          }\n\n          // Chrome/Opera stores keyPath squences as DOMStringList, Firefox\n          // as Array\n          if ( ! (typeof act.contains == \'function\' || typeof act.indexOf == \'function\') ) {\n            return false;\n          }\n\n          if (act.length !== exp.length) {\n            return false;\n          }\n\n          for (var i = 0, m = exp.length; i<m; i++) {\n            if ( ! ( (act.contains && act.contains(exp[i])) || act.indexOf(exp[i] !== -1) )) {\n              return false;\n            }\n          }\n          return true;\n        }\n        return expected[key] == actual[key];\n      });\n      return complies;\n    },\n\n    /**********\n     * cursor *\n     **********/\n\n    /**\n     * Iterates over the store using the given options and calling onItem\n     * for each entry matching the options.\n     *\n     * @param {Function} onItem A callback to be called for each match\n     * @param {Object} [options] An object defining specific options\n     * @param {Object} [options.index=null] An IDBIndex to operate on\n     * @param {String} [options.order=ASC] The order in which to provide the\n     *  results, can be \'DESC\' or \'ASC\'\n     * @param {Boolean} [options.autoContinue=true] Whether to automatically\n     *  iterate the cursor to the next result\n     * @param {Boolean} [options.filterDuplicates=false] Whether to exclude\n     *  duplicate matches\n     * @param {Object} [options.keyRange=null] An IDBKeyRange to use\n     * @param {Boolean} [options.writeAccess=false] Whether grant write access\n     *  to the store in the onItem callback\n     * @param {Function} [options.onEnd=null] A callback to be called after\n     *  iteration has ended\n     * @param {Function} [options.onError=throw] A callback to be called\n     *  if an error occurred during the operation.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    iterate: function (onItem, options) {\n      options = mixin({\n        index: null,\n        order: \'ASC\',\n        autoContinue: true,\n        filterDuplicates: false,\n        keyRange: null,\n        writeAccess: false,\n        onEnd: null,\n        onError: defaultErrorHandler\n      }, options || {});\n\n      var directionType = options.order.toLowerCase() == \'desc\' ? \'PREV\' : \'NEXT\';\n      if (options.filterDuplicates) {\n        directionType += \'_NO_DUPLICATE\';\n      }\n\n      var hasSuccess = false;\n      var cursorTransaction = this.db.transaction([this.storeName], this.consts[options.writeAccess ? \'READ_WRITE\' : \'READ_ONLY\']);\n      var cursorTarget = cursorTransaction.objectStore(this.storeName);\n      if (options.index) {\n        cursorTarget = cursorTarget.index(options.index);\n      }\n\n      cursorTransaction.oncomplete = function () {\n        if (!hasSuccess) {\n          options.onError(null);\n          return;\n        }\n        if (options.onEnd) {\n          options.onEnd();\n        } else {\n          onItem(null);\n        }\n      };\n      cursorTransaction.onabort = options.onError;\n      cursorTransaction.onerror = options.onError;\n\n      var cursorRequest = cursorTarget.openCursor(options.keyRange, this.consts[directionType]);\n      cursorRequest.onerror = options.onError;\n      cursorRequest.onsuccess = function (event) {\n        var cursor = event.target.result;\n        if (cursor) {\n          onItem(cursor.value, cursor, cursorTransaction);\n          if (options.autoContinue) {\n            cursor[\'continue\']();\n          }\n        } else {\n          hasSuccess = true;\n        }\n      };\n\n      return cursorTransaction;\n    },\n\n    /**\n     * Runs a query against the store and passes an array containing matched\n     * objects to the success handler.\n     *\n     * @param {Function} onSuccess A callback to be called when the operation\n     *  was successful.\n     * @param {Object} [options] An object defining specific query options\n     * @param {Object} [options.index=null] An IDBIndex to operate on\n     * @param {String} [options.order=ASC] The order in which to provide the\n     *  results, can be \'DESC\' or \'ASC\'\n     * @param {Boolean} [options.filterDuplicates=false] Whether to exclude\n     *  duplicate matches\n     * @param {Object} [options.keyRange=null] An IDBKeyRange to use\n     * @param {Function} [options.onError=throw] A callback to be called if an error\n     *  occurred during the operation.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    query: function (onSuccess, options) {\n      var result = [];\n      options = options || {};\n      options.onEnd = function () {\n        onSuccess(result);\n      };\n      return this.iterate(function (item) {\n        result.push(item);\n      }, options);\n    },\n\n    /**\n     *\n     * Runs a query against the store, but only returns the number of matches\n     * instead of the matches itself.\n     *\n     * @param {Function} onSuccess A callback to be called if the opration\n     *  was successful.\n     * @param {Object} [options] An object defining specific options\n     * @param {Object} [options.index=null] An IDBIndex to operate on\n     * @param {Object} [options.keyRange=null] An IDBKeyRange to use\n     * @param {Function} [options.onError=throw] A callback to be called if an error\n     *  occurred during the operation.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    count: function (onSuccess, options) {\n\n      options = mixin({\n        index: null,\n        keyRange: null\n      }, options || {});\n\n      var onError = options.onError || defaultErrorHandler;\n\n      var hasSuccess = false,\n          result = null;\n\n      var cursorTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n      cursorTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n      cursorTransaction.onabort = onError;\n      cursorTransaction.onerror = onError;\n\n      var cursorTarget = cursorTransaction.objectStore(this.storeName);\n      if (options.index) {\n        cursorTarget = cursorTarget.index(options.index);\n      }\n      var countRequest = cursorTarget.count(options.keyRange);\n      countRequest.onsuccess = function (evt) {\n        hasSuccess = true;\n        result = evt.target.result;\n      };\n      countRequest.onError = onError;\n\n      return cursorTransaction;\n    },\n\n    /**************/\n    /* key ranges */\n    /**************/\n\n    /**\n     * Creates a key range using specified options. This key range can be\n     * handed over to the count() and iterate() methods.\n     *\n     * Note: You must provide at least one or both of "lower" or "upper" value.\n     *\n     * @param {Object} options The options for the key range to create\n     * @param {*} [options.lower] The lower bound\n     * @param {Boolean} [options.excludeLower] Whether to exclude the lower\n     *  bound passed in options.lower from the key range\n     * @param {*} [options.upper] The upper bound\n     * @param {Boolean} [options.excludeUpper] Whether to exclude the upper\n     *  bound passed in options.upper from the key range\n     * @param {*} [options.only] A single key value. Use this if you need a key\n     *  range that only includes one value for a key. Providing this\n     *  property invalidates all other properties.\n     * @return {Object} The IDBKeyRange representing the specified options\n     */\n    makeKeyRange: function(options){\n      /*jshint onecase:true */\n      var keyRange,\n          hasLower = typeof options.lower != \'undefined\',\n          hasUpper = typeof options.upper != \'undefined\',\n          isOnly = typeof options.only != \'undefined\';\n\n      switch(true){\n        case isOnly:\n          keyRange = this.keyRange.only(options.only);\n          break;\n        case hasLower && hasUpper:\n          keyRange = this.keyRange.bound(options.lower, options.upper, options.excludeLower, options.excludeUpper);\n          break;\n        case hasLower:\n          keyRange = this.keyRange.lowerBound(options.lower, options.excludeLower);\n          break;\n        case hasUpper:\n          keyRange = this.keyRange.upperBound(options.upper, options.excludeUpper);\n          break;\n        default:\n          throw new Error(\'Cannot create KeyRange. Provide one or both of "lower" or "upper" value, or an "only" value.\');\n      }\n\n      return keyRange;\n\n    }\n\n  };\n\n  /** helpers **/\n\n  var noop = function () {\n  };\n  var empty = {};\n  var mixin = function (target, source) {\n    var name, s;\n    for (name in source) {\n      s = source[name];\n      if (s !== empty[name] && s !== target[name]) {\n        target[name] = s;\n      }\n    }\n    return target;\n  };\n\n  IDBStore.version = IDBStore.prototype.version;\n\n  return IDBStore;\n\n}, this);\n\n})()\n},{}],18:[function(require,module,exports){\n/* Copyright (c) 2012-2013 LevelUP contributors\n * See list at <https://github.com/rvagg/node-levelup#contributing>\n * MIT +no-false-attribs License\n * <https://github.com/rvagg/node-levelup/blob/master/LICENSE>\n */\n\nvar util          = require(\'./util\')\n  , WriteError    = require(\'./errors\').WriteError\n\n  , getOptions    = util.getOptions\n  , dispatchError = util.dispatchError\n\nfunction Batch (levelup) {\n  this._levelup = levelup\n  this.batch = levelup.db.batch()\n  this.ops = []\n}\n\nBatch.prototype.put = function (key_, value_, options) {\n  options = getOptions(this._levelup, options)\n\n  var key   = util.encodeKey(key_, options)\n    , value = util.encodeValue(value_, options)\n\n  try {\n    this.batch.put(key, value)\n  } catch (e) {\n    throw new WriteError(e)\n  }\n  this.ops.push({ type : \'put\', key : key, value : value })\n\n  return this\n}\n\nBatch.prototype.del = function (key_, options) {\n  options = getOptions(this._levelup, options)\n\n  var key = util.encodeKey(key_, options)\n\n  try {\n    this.batch.del(key)\n  } catch (err) {\n    throw new WriteError(err)\n  }\n  this.ops.push({ type : \'del\', key : key })\n\n  return this\n}\n\nBatch.prototype.clear = function () {\n  try {\n    this.batch.clear()\n  } catch (err) {\n    throw new WriteError(err)\n  }\n\n  this.ops = []\n  return this\n}\n\nBatch.prototype.write = function (callback) {\n  var levelup = this._levelup\n    , ops     = this.ops\n\n  try {\n    this.batch.write(function (err) {\n      if (err)\n        return dispatchError(levelup, new WriteError(err), callback)\n      levelup.emit(\'batch\', ops)\n      if (callback)\n        callback()\n    })\n  } catch (err) {\n    throw new WriteError(err)\n  }\n}\n\nmodule.exports = Batch\n\n},{"./errors":20,"./util":19}],4:[function(require,module,exports){\n(function(process){/* Copyright (c) 2012-2013 LevelUP contributors\n * See list at <https://github.com/rvagg/node-levelup#contributing>\n * MIT +no-false-attribs License\n * <https://github.com/rvagg/node-levelup/blob/master/LICENSE>\n */\n\nvar EventEmitter   = require(\'events\').EventEmitter\n  , inherits       = require(\'util\').inherits\n  , extend         = require(\'xtend\')\n  , prr            = require(\'prr\')\n  , DeferredLevelDOWN = require(\'deferred-leveldown\')\n\n  , WriteError     = require(\'./errors\').WriteError\n  , ReadError      = require(\'./errors\').ReadError\n  , NotFoundError  = require(\'./errors\').NotFoundError\n  , OpenError      = require(\'./errors\').OpenError\n  , EncodingError  = require(\'./errors\').EncodingError\n  , InitializationError = require(\'./errors\').InitializationError\n\n  , ReadStream     = require(\'./read-stream\')\n  , WriteStream    = require(\'./write-stream\')\n  , util           = require(\'./util\')\n  , Batch          = require(\'./batch\')\n\n  , getOptions     = util.getOptions\n  , defaultOptions = util.defaultOptions\n  , getLevelDOWN   = util.getLevelDOWN\n  , dispatchError  = util.dispatchError\n\nfunction getCallback (options, callback) {\n  return typeof options == \'function\' ? options : callback\n}\n\n// Possible LevelUP#_status values:\n//  - \'new\'     - newly created, not opened or closed\n//  - \'opening\' - waiting for the database to be opened, post open()\n//  - \'open\'    - successfully opened the database, available for use\n//  - \'closing\' - waiting for the database to be closed, post close()\n//  - \'closed\'  - database has been successfully closed, should not be\n//                 used except for another open() operation\n\nfunction LevelUP (location, options, callback) {\n  if (!(this instanceof LevelUP))\n    return new LevelUP(location, options, callback)\n\n  var error\n\n  EventEmitter.call(this)\n  this.setMaxListeners(Infinity)\n\n  if (typeof location == \'function\') {\n    options = typeof options == \'object\' ? options : {}\n    options.db = location\n    location = null\n  } else if (typeof location == \'object\' && typeof location.db == \'function\') {\n    options = location\n    location = null\n  }\n\n  if (typeof options == \'function\') {\n    callback = options\n    options  = {}\n  }\n\n  if ((!options || typeof options.db != \'function\') && typeof location != \'string\') {\n    error = new InitializationError(\n        \'Must provide a location for the database\')\n    if (callback) {\n      return process.nextTick(function () {\n        callback(error)\n      })\n    }\n    throw error\n  }\n\n  options      = getOptions(this, options)\n  this.options = extend(defaultOptions, options)\n  this._status = \'new\'\n  // set this.location as enumerable but not configurable or writable\n  prr(this, \'location\', location, \'e\')\n\n  this.open(callback)\n}\n\ninherits(LevelUP, EventEmitter)\n\nLevelUP.prototype.open = function (callback) {\n  var self = this\n    , dbFactory\n    , db\n\n  if (this.isOpen()) {\n    if (callback)\n      process.nextTick(function () { callback(null, self) })\n    return this\n  }\n\n  if (this._isOpening()) {\n    return callback && this.once(\n        \'open\'\n      , function () { callback(null, self) }\n    )\n  }\n\n  this.emit(\'opening\')\n\n  this._status = \'opening\'\n  this.db      = new DeferredLevelDOWN(this.location)\n  dbFactory    = this.options.db || getLevelDOWN()\n  db           = dbFactory(this.location)\n\n  db.open(this.options, function (err) {\n    if (err) {\n      return dispatchError(self, new OpenError(err), callback)\n    } else {\n      self.db.setDb(db)\n      self.db = db\n      self._status = \'open\'\n      if (callback)\n        callback(null, self)\n      self.emit(\'open\')\n      self.emit(\'ready\')\n    }\n  })\n}\n\nLevelUP.prototype.close = function (callback) {\n  var self = this\n\n  if (this.isOpen()) {\n    this._status = \'closing\'\n    this.db.close(function () {\n      self._status = \'closed\'\n      self.emit(\'closed\')\n      if (callback)\n        callback.apply(null, arguments)\n    })\n    this.emit(\'closing\')\n    this.db = null\n  } else if (this._status == \'closed\' && callback) {\n    return process.nextTick(callback)\n  } else if (this._status == \'closing\' && callback) {\n    this.once(\'closed\', callback)\n  } else if (this._isOpening()) {\n    this.once(\'open\', function () {\n      self.close(callback)\n    })\n  }\n}\n\nLevelUP.prototype.isOpen = function () {\n  return this._status == \'open\'\n}\n\nLevelUP.prototype._isOpening = function () {\n  return this._status == \'opening\'\n}\n\nLevelUP.prototype.isClosed = function () {\n  return (/^clos/).test(this._status)\n}\n\nLevelUP.prototype.get = function (key_, options, callback) {\n  var self = this\n    , key\n\n  callback = getCallback(options, callback)\n\n  if (typeof callback != \'function\') {\n    return dispatchError(\n        this\n      , new ReadError(\'get() requires key and callback arguments\')\n    )\n  }\n\n  if (!this._isOpening() && !this.isOpen()) {\n    return dispatchError(\n        this\n      , new ReadError(\'Database is not open\')\n      , callback\n    )\n  }\n\n  options = util.getOptions(this, options)\n  key = util.encodeKey(key_, options)\n\n  options.asBuffer = util.isValueAsBuffer(options)\n\n  this.db.get(key, options, function (err, value) {\n    if (err) {\n      if ((/notfound/i).test(err)) {\n        err = new NotFoundError(\n            \'Key not found in database [\' + key_ + \']\', err)\n      } else {\n        err = new ReadError(err)\n      }\n      return dispatchError(self, err, callback)\n    }\n    if (callback) {\n      try {\n        value = util.decodeValue(value, options)\n      } catch (e) {\n        return callback(new EncodingError(e))\n      }\n      callback(null, value)\n    }\n  })\n}\n\nLevelUP.prototype.put = function (key_, value_, options, callback) {\n  var self = this\n    , key\n    , value\n\n  callback = getCallback(options, callback)\n\n  if (key_ === null || key_ === undefined\n        || value_ === null || value_ === undefined) {\n    return dispatchError(\n        this\n       , new WriteError(\'put() requires key and value arguments\')\n       , callback\n    )\n  }\n\n  if (!this._isOpening() && !this.isOpen()) {\n    return dispatchError(\n        this\n      , new WriteError(\'Database is not open\')\n      , callback\n    )\n  }\n\n  options = getOptions(this, options)\n  key     = util.encodeKey(key_, options)\n  value   = util.encodeValue(value_, options)\n\n  this.db.put(key, value, options, function (err) {\n    if (err) {\n      return dispatchError(self, new WriteError(err), callback)\n    } else {\n      self.emit(\'put\', key_, value_)\n      if (callback)\n        callback()\n    }\n  })\n}\n\nLevelUP.prototype.del = function (key_, options, callback) {\n  var self = this\n    , key\n\n  callback = getCallback(options, callback)\n\n  if (key_ === null || key_ === undefined) {\n    return dispatchError(\n        this\n      , new WriteError(\'del() requires a key argument\')\n      , callback\n    )\n  }\n\n  if (!this._isOpening() && !this.isOpen()) {\n    return dispatchError(\n        this\n      , new WriteError(\'Database is not open\')\n      , callback\n    )\n  }\n\n  options = getOptions(this, options)\n  key     = util.encodeKey(key_, options)\n\n  this.db.del(key, options, function (err) {\n    if (err) {\n      return dispatchError(self, new WriteError(err), callback)\n    } else {\n      self.emit(\'del\', key_)\n      if (callback)\n        callback()\n    }\n  })\n}\n\nLevelUP.prototype.batch = function (arr_, options, callback) {\n  var self = this\n    , keyEnc\n    , valueEnc\n    , arr\n\n  if (!arguments.length)\n    return new Batch(this)\n\n  callback = getCallback(options, callback)\n\n  if (!Array.isArray(arr_)) {\n    return dispatchError(\n        this\n      , new WriteError(\'batch() requires an array argument\')\n      , callback\n    )\n  }\n\n  if (!this._isOpening() && !this.isOpen()) {\n    return dispatchError(\n        this\n      , new WriteError(\'Database is not open\')\n      , callback\n    )\n  }\n\n  options  = getOptions(this, options)\n  keyEnc   = options.keyEncoding\n  valueEnc = options.valueEncoding\n\n  arr = arr_.map(function (e) {\n    if (e.type === undefined || e.key === undefined)\n      return {}\n\n    // inherit encoding\n    var kEnc = e.keyEncoding || keyEnc\n      , vEnc = e.valueEncoding || e.encoding || valueEnc\n      , o\n\n    // If we\'re not dealing with plain utf8 strings or plain\n    // Buffers then we have to do some work on the array to\n    // encode the keys and/or values. This includes JSON types.\n\n    if (kEnc != \'utf8\' && kEnc != \'binary\'\n        || vEnc != \'utf8\' && vEnc != \'binary\') {\n      o = {\n          type: e.type\n        , key: util.encodeKey(e.key, options, e)\n      }\n\n      if (e.value !== undefined)\n        o.value = util.encodeValue(e.value, options, e)\n\n      return o\n    } else {\n      return e\n    }\n  })\n\n  this.db.batch(arr, options, function (err) {\n    if (err) {\n      return dispatchError(self, new WriteError(err), callback)\n    } else {\n      self.emit(\'batch\', arr_)\n      if (callback)\n        callback()\n    }\n  })\n}\n\n// DEPRECATED: prefer accessing LevelDOWN for this: db.db.approximateSize()\nLevelUP.prototype.approximateSize = function (start_, end_, callback) {\n  var self = this\n    , start\n    , end\n\n  if (start_ === null || start_ === undefined\n        || end_ === null || end_ === undefined\n        || typeof callback != \'function\') {\n    return dispatchError(\n        this\n      , new ReadError(\'approximateSize() requires start, end and callback arguments\')\n      , callback\n    )\n  }\n\n  start = util.encodeKey(start_, this.options)\n  end   = util.encodeKey(end_, this.options)\n\n  if (!this._isOpening() && !this.isOpen()) {\n    return dispatchError(\n        this\n      , new WriteError(\'Database is not open\')\n      , callback\n    )\n  }\n\n  this.db.approximateSize(start, end, function (err, size) {\n    if (err) {\n      return dispatchError(self, new OpenError(err), callback)\n    } else if (callback) {\n      callback(null, size)\n    }\n  })\n}\n\nLevelUP.prototype.readStream =\nLevelUP.prototype.createReadStream = function (options) {\n  var self = this\n  options = extend(this.options, options)\n  return new ReadStream(\n      options\n    , this\n    , function (options) {\n        return self.db.iterator(options)\n      }\n  )\n}\n\nLevelUP.prototype.keyStream =\nLevelUP.prototype.createKeyStream = function (options) {\n  return this.createReadStream(extend(options, { keys: true, values: false }))\n}\n\nLevelUP.prototype.valueStream =\nLevelUP.prototype.createValueStream = function (options) {\n  return this.createReadStream(extend(options, { keys: false, values: true }))\n}\n\nLevelUP.prototype.writeStream =\nLevelUP.prototype.createWriteStream = function (options) {\n  return new WriteStream(extend(options), this)\n}\n\nLevelUP.prototype.toString = function () {\n  return \'LevelUP\'\n}\n\nfunction utilStatic (name) {\n  return function (location, callback) {\n    getLevelDOWN()[name](location, callback || function () {})\n  }\n}\n\nmodule.exports         = LevelUP\nmodule.exports.copy    = util.copy\n// DEPRECATED: prefer accessing LevelDOWN for this: require(\'leveldown\').destroy()\nmodule.exports.destroy = utilStatic(\'destroy\')\n// DEPRECATED: prefer accessing LevelDOWN for this: require(\'leveldown\').repair()\nmodule.exports.repair  = utilStatic(\'repair\')\n\n})(require("__browserify_process"))\n},{"./batch":18,"./errors":20,"./read-stream":21,"./util":19,"./write-stream":22,"__browserify_process":9,"deferred-leveldown":24,"events":10,"prr":23,"util":11,"xtend":25}],26:[function(require,module,exports){\n(function(){module.exports={\n  "name": "levelup",\n  "description": "Fast & simple storage - a Node.js-style LevelDB wrapper",\n  "version": "0.18.2",\n  "contributors": [\n    {\n      "name": "Rod Vagg",\n      "email": "r@va.gg",\n      "url": "https://github.com/rvagg"\n    },\n    {\n      "name": "John Chesley",\n      "email": "john@chesl.es",\n      "url": "https://github.com/chesles/"\n    },\n    {\n      "name": "Jake Verbaten",\n      "email": "raynos2@gmail.com",\n      "url": "https://github.com/raynos"\n    },\n    {\n      "name": "Dominic Tarr",\n      "email": "dominic.tarr@gmail.com",\n      "url": "https://github.com/dominictarr"\n    },\n    {\n      "name": "Max Ogden",\n      "email": "max@maxogden.com",\n      "url": "https://github.com/maxogden"\n    },\n    {\n      "name": "Lars-Magnus Skog",\n      "email": "lars.magnus.skog@gmail.com",\n      "url": "https://github.com/ralphtheninja"\n    },\n    {\n      "name": "David Bj\xF6rklund",\n      "email": "david.bjorklund@gmail.com",\n      "url": "https://github.com/kesla"\n    },\n    {\n      "name": "Julian Gruber",\n      "email": "julian@juliangruber.com",\n      "url": "https://github.com/juliangruber"\n    },\n    {\n      "name": "Paolo Fragomeni",\n      "email": "paolo@async.ly",\n      "url": "https://github.com/hij1nx"\n    },\n    {\n      "name": "Anton Whalley",\n      "email": "anton.whalley@nearform.com",\n      "url": "https://github.com/No9"\n    },\n    {\n      "name": "Matteo Collina",\n      "email": "matteo.collina@gmail.com",\n      "url": "https://github.com/mcollina"\n    },\n    {\n      "name": "Pedro Teixeira",\n      "email": "pedro.teixeira@gmail.com",\n      "url": "https://github.com/pgte"\n    },\n    {\n      "name": "James Halliday",\n      "email": "mail@substack.net",\n      "url": "https://github.com/substack"\n    }\n  ],\n  "repository": {\n    "type": "git",\n    "url": "https://github.com/rvagg/node-levelup.git"\n  },\n  "homepage": "https://github.com/rvagg/node-levelup",\n  "keywords": [\n    "leveldb",\n    "stream",\n    "database",\n    "db",\n    "store",\n    "storage",\n    "json"\n  ],\n  "main": "lib/levelup.js",\n  "dependencies": {\n    "errno": "~0.1.0",\n    "concat-stream": "~0.1.1",\n    "readable-stream": "~1.0.17",\n    "xtend": "~2.1.1",\n    "prr": "~0.0.0",\n    "semver": "~2.2.1",\n    "bops": "~0.1.0",\n    "deferred-leveldown": "~0.1.0"\n  },\n  "devDependencies": {\n    "leveldown": "~0.10.0",\n    "bustermove": "*",\n    "tap": "*",\n    "referee": "*",\n    "rimraf": "*",\n    "async": "*",\n    "fstream": "*",\n    "tar": "*",\n    "mkfiletree": "*",\n    "readfiletree": "*",\n    "slow-stream": ">=0.0.4",\n    "delayed": "*",\n    "boganipsum": "*",\n    "du": "*",\n    "memdown": "*",\n    "msgpack-js": "*"\n  },\n  "browser": {\n    "leveldown": false,\n    "leveldown/package": false,\n    "semver": false\n  },\n  "scripts": {\n    "test": "tap test/*-test.js --stderr",\n    "functionaltests": "node ./test/functional/fstream-test.js && node ./test/functional/binary-data-test.js && node ./test/functional/compat-test.js",\n    "alltests": "npm test && npm run-script functionaltests"\n  },\n  "license": "MIT",\n  "readme": "LevelUP\\n=======\\n\\n![LevelDB Logo](https://twimg0-a.akamaihd.net/profile_images/3360574989/92fc472928b444980408147e5e5db2fa_bigger.png)\\n\\nFast & simple storage - a Node.js-style LevelDB wrapper\\n-------------------------------------------------------\\n\\n[![Build Status](https://secure.travis-ci.org/rvagg/node-levelup.png)](http://travis-ci.org/rvagg/node-levelup)\\n\\n[![NPM](https://nodei.co/npm/levelup.png?stars&downloads)](https://nodei.co/npm/levelup/) [![NPM](https://nodei.co/npm-dl/levelup.png)](https://nodei.co/npm/levelup/)\\n\\n\\n  * <a href=\\"#intro\\">Introduction</a>\\n  * <a href=\\"#leveldown\\">Relationship to LevelDOWN</a>\\n  * <a href=\\"#platforms\\">Tested &amp; supported platforms</a>\\n  * <a href=\\"#basic\\">Basic usage</a>\\n  * <a href=\\"#api\\">API</a>\\n  * <a href=\\"#events\\">Events</a>\\n  * <a href=\\"#json\\">JSON data</a>\\n  * <a href=\\"#custom_encodings\\">Custom encodings</a>\\n  * <a href=\\"#extending\\">Extending LevelUP</a>\\n  * <a href=\\"#multiproc\\">Multi-process access</a>\\n  * <a href=\\"#support\\">Getting support</a>\\n  * <a href=\\"#contributing\\">Contributing</a>\\n  * <a href=\\"#licence\\">Licence &amp; copyright</a>\\n\\n<a name=\\"intro\\"></a>\\nIntroduction\\n------------\\n\\n**[LevelDB](http://code.google.com/p/leveldb/)** is a simple key/value data store built by Google, inspired by BigTable. It\'s used in Google Chrome and many other products. LevelDB supports arbitrary byte arrays as both keys and values, singular *get*, *put* and *delete* operations, *batched put and delete*, bi-directional iterators and simple compression using the very fast [Snappy](http://code.google.com/p/snappy/) algorithm.\\n\\n**LevelUP** aims to expose the features of LevelDB in a **Node.js-friendly way**. All standard `Buffer` encoding types are supported, as is a special JSON encoding. LevelDB\'s iterators are exposed as a Node.js-style **readable stream** a matching **writeable stream** converts writes to *batch* operations.\\n\\nLevelDB stores entries **sorted lexicographically by keys**. This makes LevelUP\'s <a href=\\"#createReadStream\\"><code>ReadStream</code></a> interface a very powerful query mechanism.\\n\\n**LevelUP** is an **OPEN Open Source Project**, see the <a href=\\"#contributing\\">Contributing</a> section to find out what this means.\\n\\n<a name=\\"leveldown\\"></a>\\nRelationship to LevelDOWN\\n-------------------------\\n\\nLevelUP is designed to be backed by **[LevelDOWN](https://github.com/rvagg/node-leveldown/)** which provides a pure C++ binding to LevelDB and can be used as a stand-alone package if required.\\n\\n**As of version 0.9, LevelUP no longer requires LevelDOWN as a dependency so you must `npm install leveldown` when you install LevelUP.**\\n\\nLevelDOWN is now optional because LevelUP can be used with alternative backends, such as **[level.js](https://github.com/maxogden/level.js)** in the browser or [MemDOWN](https://github.com/rvagg/node-memdown) for a pure in-memory store.\\n\\nLevelUP will look for LevelDOWN and throw an error if it can\'t find it in its Node `require()` path. It will also tell you if the installed version of LevelDOWN is incompatible.\\n\\n**The [level](https://github.com/level/level) package is available as an alternative installation mechanism.** Install it instead to automatically get both LevelUP & LevelDOWN. It exposes LevelUP on its export (i.e. you can `var leveldb = require(\'level\')`).\\n\\n\\n<a name=\\"platforms\\"></a>\\nTested & supported platforms\\n----------------------------\\n\\n  * **Linux**: including ARM platforms such as Raspberry Pi *and Kindle!*\\n  * **Mac OS**\\n  * **Solaris**: including Joyent\'s SmartOS & Nodejitsu\\n  * **Windows**: Node 0.10 and above only. See installation instructions for *node-gyp\'s* dependencies [here](https://github.com/TooTallNate/node-gyp#installation), you\'ll need these (free) components from Microsoft to compile and run any native Node add-on in Windows.\\n\\n<a name=\\"basic\\"></a>\\nBasic usage\\n-----------\\n\\nFirst you need to install LevelUP!\\n\\n```sh\\n$ npm install levelup leveldown\\n```\\n\\nOr\\n\\n```sh\\n$ npm install level\\n```\\n\\n*(this second option requires you to use LevelUP by calling `var levelup = require(\'level\')`)*\\n\\n\\nAll operations are asynchronous although they don\'t necessarily require a callback if you don\'t need to know when the operation was performed.\\n\\n```js\\nvar levelup = require(\'levelup\')\\n\\n// 1) Create our database, supply location and options.\\n//    This will create or open the underlying LevelDB store.\\nvar db = levelup(\'./mydb\')\\n\\n// 2) put a key & value\\ndb.put(\'name\', \'LevelUP\', function (err) {\\n  if (err) return console.log(\'Ooops!\', err) // some kind of I/O error\\n\\n  // 3) fetch by key\\n  db.get(\'name\', function (err, value) {\\n    if (err) return console.log(\'Ooops!\', err) // likely the key was not found\\n\\n    // ta da!\\n    console.log(\'name=\' + value)\\n  })\\n})\\n```\\n\\n<a name=\\"api\\"></a>\\n## API\\n\\n  * <a href=\\"#ctor\\"><code><b>levelup()</b></code></a>\\n  * <a href=\\"#open\\"><code>db.<b>open()</b></code></a>\\n  * <a href=\\"#close\\"><code>db.<b>close()</b></code></a>\\n  * <a href=\\"#put\\"><code>db.<b>put()</b></code></a>\\n  * <a href=\\"#get\\"><code>db.<b>get()</b></code></a>\\n  * <a href=\\"#del\\"><code>db.<b>del()</b></code></a>\\n  * <a href=\\"#batch\\"><code>db.<b>batch()</b></code> *(array form)*</a>\\n  * <a href=\\"#batch_chained\\"><code>db.<b>batch()</b></code> *(chained form)*</a>\\n  * <a href=\\"#isOpen\\"><code>db.<b>isOpen()</b></code></a>\\n  * <a href=\\"#isClosed\\"><code>db.<b>isClosed()</b></code></a>\\n  * <a href=\\"#createReadStream\\"><code>db.<b>createReadStream()</b></code></a>\\n  * <a href=\\"#createKeyStream\\"><code>db.<b>createKeyStream()</b></code></a>\\n  * <a href=\\"#createValueStream\\"><code>db.<b>createValueStream()</b></code></a>\\n  * <a href=\\"#createWriteStream\\"><code>db.<b>createWriteStream()</b></code></a>\\n\\n### Special operations exposed by LevelDOWN\\n\\n  * <a href=\\"#approximateSize\\"><code>db.db.<b>approximateSize()</b></code></a>\\n  * <a href=\\"#getProperty\\"><code>db.db.<b>getProperty()</b></code></a>\\n  * <a href=\\"#destroy\\"><code><b>leveldown.destroy()</b></code></a>\\n  * <a href=\\"#repair\\"><code><b>leveldown.repair()</b></code></a>\\n\\n\\n--------------------------------------------------------\\n<a name=\\"ctor\\"></a>\\n### levelup(location[, options[, callback]])\\n### levelup(options[, callback ])\\n### levelup(db[, callback ])\\n<code>levelup()</code> is the main entry point for creating a new LevelUP instance and opening the underlying store with LevelDB.\\n\\nThis function returns a new instance of LevelUP and will also initiate an <a href=\\"#open\\"><code>open()</code></a> operation. Opening the database is an asynchronous operation which will trigger your callback if you provide one. The callback should take the form: `function (err, db) {}` where the `db` is the LevelUP instance. If you don\'t provide a callback, any read & write operations are simply queued internally until the database is fully opened.\\n\\nThis leads to two alternative ways of managing a new LevelUP instance:\\n\\n```js\\nlevelup(location, options, function (err, db) {\\n  if (err) throw err\\n  db.get(\'foo\', function (err, value) {\\n    if (err) return console.log(\'foo does not exist\')\\n    console.log(\'got foo =\', value)\\n  })\\n})\\n\\n// vs the equivalent:\\n\\nvar db = levelup(location, options) // will throw if an error occurs\\ndb.get(\'foo\', function (err, value) {\\n  if (err) return console.log(\'foo does not exist\')\\n  console.log(\'got foo =\', value)\\n})\\n```\\n\\nThe `location` argument is available as a read-only property on the returned LevelUP instance.\\n\\nThe `levelup(options, callback)` form (with optional `callback`) is only available where you provide a valid `\'db\'` property on the options object (see below). Only for back-ends that don\'t require a `location` argument, such as [MemDOWN](https://github.com/rvagg/memdown).\\n\\nFor example:\\n\\n```js\\nvar levelup = require(\'levelup\')\\nvar memdown = require(\'memdown\')\\nvar db = levelup({ db: memdown })\\n```\\n\\nThe `levelup(db, callback)` form (with optional `callback`) is only available where `db` is a factory function, as would be provided as a `\'db\'` property on an `options` object (see below). Only for back-ends that don\'t require a `location` argument, such as [MemDOWN](https://github.com/rvagg/memdown).\\n\\nFor example:\\n\\n```js\\nvar levelup = require(\'levelup\')\\nvar memdown = require(\'memdown\')\\nvar db = levelup(memdown)\\n```\\n\\n#### `options`\\n\\n`levelup()` takes an optional options object as its second argument; the following properties are accepted:\\n\\n* `\'createIfMissing\'` *(boolean, default: `true`)*: If `true`, will initialise an empty database at the specified location if one doesn\'t already exist. If `false` and a database doesn\'t exist you will receive an error in your `open()` callback and your database won\'t open.\\n\\n* `\'errorIfExists\'` *(boolean, default: `false`)*: If `true`, you will receive an error in your `open()` callback if the database exists at the specified location.\\n\\n* `\'compression\'` *(boolean, default: `true`)*: If `true`, all *compressible* data will be run through the Snappy compression algorithm before being stored. Snappy is very fast and shouldn\'t gain much speed by disabling so leave this on unless you have good reason to turn it off.\\n\\n* `\'cacheSize\'` *(number, default: `8 * 1024 * 1024`)*: The size (in bytes) of the in-memory [LRU](http://en.wikipedia.org/wiki/Cache_algorithms#Least_Recently_Used) cache with frequently used uncompressed block contents. \\n\\n* `\'keyEncoding\'` and `\'valueEncoding\'` *(string, default: `\'utf8\'`)*: The encoding of the keys and values passed through Node.js\' `Buffer` implementation (see [Buffer#toString()](http://nodejs.org/docs/latest/api/buffer.html#buffer_buf_tostring_encoding_start_end)).\\n  <p><code>\'utf8\'</code> is the default encoding for both keys and values so you can simply pass in strings and expect strings from your <code>get()</code> operations. You can also pass <code>Buffer</code> objects as keys and/or values and conversion will be performed.</p>\\n  <p>Supported encodings are: hex, utf8, ascii, binary, base64, ucs2, utf16le.</p>\\n  <p><code>\'json\'</code> encoding is also supported, see below.</p>\\n\\n* `\'db\'` *(object, default: LevelDOWN)*: LevelUP is backed by [LevelDOWN](https://github.com/rvagg/node-leveldown/) to provide an interface to LevelDB. You can completely replace the use of LevelDOWN by providing a \\"factory\\" function that will return a LevelDOWN API compatible object given a `location` argument. For further information, see [MemDOWN](https://github.com/rvagg/node-memdown/), a fully LevelDOWN API compatible replacement that uses a memory store rather than LevelDB. Also see [Abstract LevelDOWN](http://github.com/rvagg/node-abstract-leveldown), a partial implementation of the LevelDOWN API that can be used as a base prototype for a LevelDOWN substitute.\\n\\nAdditionally, each of the main interface methods accept an optional options object that can be used to override `\'keyEncoding\'` and `\'valueEncoding\'`.\\n\\n--------------------------------------------------------\\n<a name=\\"open\\"></a>\\n### db.open([callback])\\n<code>open()</code> opens the underlying LevelDB store. In general **you should never need to call this method directly** as it\'s automatically called by <a href=\\"#ctor\\"><code>levelup()</code></a>.\\n\\nHowever, it is possible to *reopen* a database after it has been closed with <a href=\\"#close\\"><code>close()</code></a>, although this is not generally advised.\\n\\n--------------------------------------------------------\\n<a name=\\"close\\"></a>\\n### db.close([callback])\\n<code>close()</code> closes the underlying LevelDB store. The callback will receive any error encountered during closing as the first argument.\\n\\nYou should always clean up your LevelUP instance by calling `close()` when you no longer need it to free up resources. A LevelDB store cannot be opened by multiple instances of LevelDB/LevelUP simultaneously.\\n\\n--------------------------------------------------------\\n<a name=\\"put\\"></a>\\n### db.put(key, value[, options][, callback])\\n<code>put()</code> is the primary method for inserting data into the store. Both the `key` and `value` can be arbitrary data objects.\\n\\nThe callback argument is optional but if you don\'t provide one and an error occurs then expect the error to be thrown.\\n\\n#### `options`\\n\\nEncoding of the `key` and `value` objects will adhere to `\'keyEncoding\'` and `\'valueEncoding\'` options provided to <a href=\\"#ctor\\"><code>levelup()</code></a>, although you can provide alternative encoding settings in the options for `put()` (it\'s recommended that you stay consistent in your encoding of keys and values in a single store).\\n\\nIf you provide a `\'sync\'` value of `true` in your `options` object, LevelDB will perform a synchronous write of the data; although the operation will be asynchronous as far as Node is concerned. Normally, LevelDB passes the data to the operating system for writing and returns immediately, however a synchronous write will use `fsync()` or equivalent so your callback won\'t be triggered until the data is actually on disk. Synchronous filesystem writes are **significantly** slower than asynchronous writes but if you want to be absolutely sure that the data is flushed then you can use `\'sync\': true`.\\n\\n--------------------------------------------------------\\n<a name=\\"get\\"></a>\\n### db.get(key[, options][, callback])\\n<code>get()</code> is the primary method for fetching data from the store. The `key` can be an arbitrary data object. If it doesn\'t exist in the store then the callback will receive an error as its first argument. A not-found err object will be of type `\'NotFoundError\'` so you can `err.type == \'NotFoundError\'` or you can perform a truthy test on the property `err.notFound`.\\n\\n```js\\ndb.get(\'foo\', function (err, value) {\\n  if (err) {\\n    if (err.notFound) {\\n      // handle a \'NotFoundError\' here\\n      return\\n    }\\n    // I/O or other error, pass it up the callback chain\\n    return callback(err)\\n  }\\n\\n  // .. handle `value` here\\n})\\n```\\n\\n#### `options`\\n\\nEncoding of the `key` object will adhere to the `\'keyEncoding\'` option provided to <a href=\\"#ctor\\"><code>levelup()</code></a>, although you can provide alternative encoding settings in the options for `get()` (it\'s recommended that you stay consistent in your encoding of keys and values in a single store).\\n\\nLevelDB will by default fill the in-memory LRU Cache with data from a call to get. Disabling this is done by setting `fillCache` to `false`. \\n\\n--------------------------------------------------------\\n<a name=\\"del\\"></a>\\n### db.del(key[, options][, callback])\\n<code>del()</code> is the primary method for removing data from the store.\\n\\n#### `options`\\n\\nEncoding of the `key` object will adhere to the `\'keyEncoding\'` option provided to <a href=\\"#ctor\\"><code>levelup()</code></a>, although you can provide alternative encoding settings in the options for `del()` (it\'s recommended that you stay consistent in your encoding of keys and values in a single store).\\n\\nA `\'sync\'` option can also be passed, see <a href=\\"#put\\"><code>put()</code></a> for details on how this works.\\n\\n--------------------------------------------------------\\n<a name=\\"batch\\"></a>\\n### db.batch(array[, options][, callback]) *(array form)*\\n<code>batch()</code> can be used for very fast bulk-write operations (both *put* and *delete*). The `array` argument should contain a list of operations to be executed sequentially, although as a whole they are performed as an atomic operation inside LevelDB. Each operation is contained in an object having the following properties: `type`, `key`, `value`, where the *type* is either `\'put\'` or `\'del\'`. In the case of `\'del\'` the `\'value\'` property is ignored. Any entries with a `\'key\'` of `null` or `undefined` will cause an error to be returned on the `callback` and any `\'type\': \'put\'` entry with a `\'value\'` of `null` or `undefined` will return an error.\\n\\n```js\\nvar ops = [\\n    { type: \'del\', key: \'father\' }\\n  , { type: \'put\', key: \'name\', value: \'Yuri Irsenovich Kim\' }\\n  , { type: \'put\', key: \'dob\', value: \'16 February 1941\' }\\n  , { type: \'put\', key: \'spouse\', value: \'Kim Young-sook\' }\\n  , { type: \'put\', key: \'occupation\', value: \'Clown\' }\\n]\\n\\ndb.batch(ops, function (err) {\\n  if (err) return console.log(\'Ooops!\', err)\\n  console.log(\'Great success dear leader!\')\\n})\\n```\\n\\n#### `options`\\n\\nSee <a href=\\"#put\\"><code>put()</code></a> for a discussion on the `options` object. You can overwrite default `\'keyEncoding\'` and `\'valueEncoding\'` and also specify the use of `sync` filesystem operations.\\n\\nIn addition to encoding options for the whole batch you can also overwrite the encoding per operation, like:\\n\\n```js\\nvar ops = [{\\n    type          : \'put\'\\n  , key           : new Buffer([1, 2, 3])\\n  , value         : { some: \'json\' }\\n  , keyEncoding   : \'binary\'\\n  , valueEncoding : \'json\'\\n}]\\n```\\n\\n--------------------------------------------------------\\n<a name=\\"batch_chained\\"></a>\\n### db.batch() *(chained form)*\\n<code>batch()</code>, when called with no arguments will return a `Batch` object which can be used to build, and eventually commit, an atomic LevelDB batch operation. Depending on how it\'s used, it is possible to obtain greater performance when using the chained form of `batch()` over the array form.\\n\\n```js\\ndb.batch()\\n  .del(\'father\')\\n  .put(\'name\', \'Yuri Irsenovich Kim\')\\n  .put(\'dob\', \'16 February 1941\')\\n  .put(\'spouse\', \'Kim Young-sook\')\\n  .put(\'occupation\', \'Clown\')\\n  .write(function () { console.log(\'Done!\') })\\n```\\n\\n<b><code>batch.put(key, value[, options])</code></b>\\n\\nQueue a *put* operation on the current batch, not committed until a `write()` is called on the batch.\\n\\nThe optional `options` argument can be used to override the default `\'keyEncoding\'` and/or `\'valueEncoding\'`.\\n\\nThis method may `throw` a `WriteError` if there is a problem with your put (such as the `value` being `null` or `undefined`).\\n\\n<b><code>batch.del(key[, options])</code></b>\\n\\nQueue a *del* operation on the current batch, not committed until a `write()` is called on the batch.\\n\\nThe optional `options` argument can be used to override the default `\'keyEncoding\'`.\\n\\nThis method may `throw` a `WriteError` if there is a problem with your delete.\\n\\n<b><code>batch.clear()</code></b>\\n\\nClear all queued operations on the current batch, any previous operations will be discarded.\\n\\n<b><code>batch.write([callback])</code></b>\\n\\nCommit the queued operations for this batch. All operations not *cleared* will be written to the database atomically, that is, they will either all succeed or fail with no partial commits. The optional `callback` will be called when the operation has completed with an *error* argument if an error has occurred; if no `callback` is supplied and an error occurs then this method will `throw` a `WriteError`.\\n\\n\\n--------------------------------------------------------\\n<a name=\\"isOpen\\"></a>\\n### db.isOpen()\\n\\nA LevelUP object can be in one of the following states:\\n\\n  * *\\"new\\"*     - newly created, not opened or closed\\n  * *\\"opening\\"* - waiting for the database to be opened\\n  * *\\"open\\"*    - successfully opened the database, available for use\\n  * *\\"closing\\"* - waiting for the database to be closed\\n  * *\\"closed\\"*  - database has been successfully closed, should not be used\\n\\n`isOpen()` will return `true` only when the state is \\"open\\".\\n\\n--------------------------------------------------------\\n<a name=\\"isClosed\\"></a>\\n### db.isClosed()\\n\\n*See <a href=\\"#put\\"><code>isOpen()</code></a>*\\n\\n`isClosed()` will return `true` only when the state is \\"closing\\" *or* \\"closed\\", it can be useful for determining if read and write operations are permissible.\\n\\n--------------------------------------------------------\\n<a name=\\"createReadStream\\"></a>\\n### db.createReadStream([options])\\n\\nYou can obtain a **ReadStream** of the full database by calling the `createReadStream()` method. The resulting stream is a complete Node.js-style [Readable Stream](http://nodejs.org/docs/latest/api/stream.html#stream_readable_stream) where `\'data\'` events emit objects with `\'key\'` and `\'value\'` pairs.\\n\\n```js\\ndb.createReadStream()\\n  .on(\'data\', function (data) {\\n    console.log(data.key, \'=\', data.value)\\n  })\\n  .on(\'error\', function (err) {\\n    console.log(\'Oh my!\', err)\\n  })\\n  .on(\'close\', function () {\\n    console.log(\'Stream closed\')\\n  })\\n  .on(\'end\', function () {\\n    console.log(\'Stream closed\')\\n  })\\n```\\n\\nThe standard `pause()`, `resume()` and `destroy()` methods are implemented on the ReadStream, as is `pipe()` (see below). `\'data\'`, \'`error\'`, `\'end\'` and `\'close\'` events are emitted.\\n\\nAdditionally, you can supply an options object as the first parameter to `createReadStream()` with the following options:\\n\\n* `\'start\'`: the key you wish to start the read at. By default it will start at the beginning of the store. Note that the *start* doesn\'t have to be an actual key that exists, LevelDB will simply find the *next* key, greater than the key you provide.\\n\\n* `\'end\'`: the key you wish to end the read on. By default it will continue until the end of the store. Again, the *end* doesn\'t have to be an actual key as an (inclusive) `<=`-type operation is performed to detect the end. You can also use the `destroy()` method instead of supplying an `\'end\'` parameter to achieve the same effect.\\n\\n* `\'reverse\'` *(boolean, default: `false`)*: a boolean, set to true if you want the stream to go in reverse order. Beware that due to the way LevelDB works, a reverse seek will be slower than a forward seek.\\n\\n* `\'keys\'` *(boolean, default: `true`)*: whether the `\'data\'` event should contain keys. If set to `true` and `\'values\'` set to `false` then `\'data\'` events will simply be keys, rather than objects with a `\'key\'` property. Used internally by the `createKeyStream()` method.\\n\\n* `\'values\'` *(boolean, default: `true`)*: whether the `\'data\'` event should contain values. If set to `true` and `\'keys\'` set to `false` then `\'data\'` events will simply be values, rather than objects with a `\'value\'` property. Used internally by the `createValueStream()` method.\\n\\n* `\'limit\'` *(number, default: `-1`)*: limit the number of results collected by this stream. This number represents a *maximum* number of results and may not be reached if you get to the end of the store or your `\'end\'` value first. A value of `-1` means there is no limit.\\n\\n* `\'fillCache\'` *(boolean, default: `false`)*: wheather LevelDB\'s LRU-cache should be filled with data read.\\n\\n* `\'keyEncoding\'` / `\'valueEncoding\'` *(string)*: the encoding applied to each read piece of data.\\n\\n--------------------------------------------------------\\n<a name=\\"createKeyStream\\"></a>\\n### db.createKeyStream([options])\\n\\nA **KeyStream** is a **ReadStream** where the `\'data\'` events are simply the keys from the database so it can be used like a traditional stream rather than an object stream.\\n\\nYou can obtain a KeyStream either by calling the `createKeyStream()` method on a LevelUP object or by passing passing an options object to `createReadStream()` with `keys` set to `true` and `values` set to `false`.\\n\\n```js\\ndb.createKeyStream()\\n  .on(\'data\', function (data) {\\n    console.log(\'key=\', data)\\n  })\\n\\n// same as:\\ndb.createReadStream({ keys: true, values: false })\\n  .on(\'data\', function (data) {\\n    console.log(\'key=\', data)\\n  })\\n```\\n\\n--------------------------------------------------------\\n<a name=\\"createValueStream\\"></a>\\n### db.createValueStream([options])\\n\\nA **ValueStream** is a **ReadStream** where the `\'data\'` events are simply the values from the database so it can be used like a traditional stream rather than an object stream.\\n\\nYou can obtain a ValueStream either by calling the `createValueStream()` method on a LevelUP object or by passing passing an options object to `createReadStream()` with `values` set to `true` and `keys` set to `false`.\\n\\n```js\\ndb.createValueStream()\\n  .on(\'data\', function (data) {\\n    console.log(\'value=\', data)\\n  })\\n\\n// same as:\\ndb.createReadStream({ keys: false, values: true })\\n  .on(\'data\', function (data) {\\n    console.log(\'value=\', data)\\n  })\\n```\\n\\n--------------------------------------------------------\\n<a name=\\"createWriteStream\\"></a>\\n### db.createWriteStream([options])\\n\\nA **WriteStream** can be obtained by calling the `createWriteStream()` method. The resulting stream is a complete Node.js-style [Writable Stream](http://nodejs.org/docs/latest/api/stream.html#stream_writable_stream) which accepts objects with `\'key\'` and `\'value\'` pairs on its `write()` method.\\n\\nThe WriteStream will buffer writes and submit them as a `batch()` operations where writes occur *within the same tick*.\\n\\n```js\\nvar ws = db.createWriteStream()\\n\\nws.on(\'error\', function (err) {\\n  console.log(\'Oh my!\', err)\\n})\\nws.on(\'close\', function () {\\n  console.log(\'Stream closed\')\\n})\\n\\nws.write({ key: \'name\', value: \'Yuri Irsenovich Kim\' })\\nws.write({ key: \'dob\', value: \'16 February 1941\' })\\nws.write({ key: \'spouse\', value: \'Kim Young-sook\' })\\nws.write({ key: \'occupation\', value: \'Clown\' })\\nws.end()\\n```\\n\\nThe standard `write()`, `end()`, `destroy()` and `destroySoon()` methods are implemented on the WriteStream. `\'drain\'`, `\'error\'`, `\'close\'` and `\'pipe\'` events are emitted.\\n\\nYou can specify encodings both for the whole stream and individual entries:\\n\\nTo set the encoding for the whole stream, provide an options object as the first parameter to `createWriteStream()` with `\'keyEncoding\'` and/or `\'valueEncoding\'`.\\n\\nTo set the encoding for an individual entry:\\n\\n```js\\nwriteStream.write({\\n    key           : new Buffer([1, 2, 3])\\n  , value         : { some: \'json\' }\\n  , keyEncoding   : \'binary\'\\n  , valueEncoding : \'json\'\\n})\\n```\\n\\n#### write({ type: \'put\' })\\n\\nIf individual `write()` operations are performed with a `\'type\'` property of `\'del\'`, they will be passed on as `\'del\'` operations to the batch.\\n\\n```js\\nvar ws = db.createWriteStream()\\n\\nws.on(\'error\', function (err) {\\n  console.log(\'Oh my!\', err)\\n})\\nws.on(\'close\', function () {\\n  console.log(\'Stream closed\')\\n})\\n\\nws.write({ type: \'del\', key: \'name\' })\\nws.write({ type: \'del\', key: \'dob\' })\\nws.write({ type: \'put\', key: \'spouse\' })\\nws.write({ type: \'del\', key: \'occupation\' })\\nws.end()\\n```\\n\\n#### db.createWriteStream({ type: \'del\' })\\n\\nIf the *WriteStream* is created with a `\'type\'` option of `\'del\'`, all `write()` operations will be interpreted as `\'del\'`, unless explicitly specified as `\'put\'`.\\n\\n```js\\nvar ws = db.createWriteStream({ type: \'del\' })\\n\\nws.on(\'error\', function (err) {\\n  console.log(\'Oh my!\', err)\\n})\\nws.on(\'close\', function () {\\n  console.log(\'Stream closed\')\\n})\\n\\nws.write({ key: \'name\' })\\nws.write({ key: \'dob\' })\\n// but it can be overridden\\nws.write({ type: \'put\', key: \'spouse\', value: \'Ri Sol-ju\' })\\nws.write({ key: \'occupation\' })\\nws.end()\\n```\\n\\n#### Pipes and Node Stream compatibility\\n\\nA ReadStream can be piped directly to a WriteStream, allowing for easy copying of an entire database. A simple `copy()` operation is included in LevelUP that performs exactly this on two open databases:\\n\\n```js\\nfunction copy (srcdb, dstdb, callback) {\\n  srcdb.createReadStream().pipe(dstdb.createWriteStream()).on(\'close\', callback)\\n}\\n```\\n\\nThe ReadStream is also [fstream](https://github.com/isaacs/fstream)-compatible which means you should be able to pipe to and from fstreams. So you can serialize and deserialize an entire database to a directory where keys are filenames and values are their contents, or even into a *tar* file using [node-tar](https://github.com/isaacs/node-tar). See the [fstream functional test](https://github.com/rvagg/node-levelup/blob/master/test/functional/fstream-test.js) for an example. *(Note: I\'m not really sure there\'s a great use-case for this but it\'s a fun example and it helps to harden the stream implementations.)*\\n\\nKeyStreams and ValueStreams can be treated like standard streams of raw data. If `\'keyEncoding\'` or `\'valueEncoding\'` is set to `\'binary\'` the `\'data\'` events will simply be standard Node `Buffer` objects straight out of the data store.\\n\\n\\n--------------------------------------------------------\\n<a name=\'approximateSize\'></a>\\n### db.db.approximateSize(start, end, callback)\\n<code>approximateSize()</code> can used to get the approximate number of bytes of file system space used by the range `[start..end)`. The result may not include recently written data.\\n\\n```js\\nvar db = require(\'level\')(\'./huge.db\')\\n\\ndb.db.approximateSize(\'a\', \'c\', function (err, size) {\\n  if (err) return console.error(\'Ooops!\', err)\\n  console.log(\'Approximate size of range is %d\', size)\\n})\\n```\\n\\n**Note:** `approximateSize()` is available via [LevelDOWN](https://github.com/rvagg/node-leveldown/), which by default is accessible as the `db` property of your LevelUP instance. This is a specific LevelDB operation and is not likely to be available where you replace LevelDOWN with an alternative back-end via the `\'db\'` option.\\n\\n\\n--------------------------------------------------------\\n<a name=\'getProperty\'></a>\\n### db.db.getProperty(property)\\n<code>getProperty</code> can be used to get internal details from LevelDB. When issued with a valid property string, a readable string will be returned (this method is synchronous).\\n\\nCurrently, the only valid properties are:\\n\\n* <b><code>\'leveldb.num-files-at-levelN\'</code></b>: returns the number of files at level *N*, where N is an integer representing a valid level (e.g. \\"0\\").\\n\\n* <b><code>\'leveldb.stats\'</code></b>: returns a multi-line string describing statistics about LevelDB\'s internal operation.\\n\\n* <b><code>\'leveldb.sstables\'</code></b>: returns a multi-line string describing all of the *sstables* that make up contents of the current database.\\n\\n\\n```js\\nvar db = require(\'level\')(\'./huge.db\')\\nconsole.log(db.db.getProperty(\'leveldb.num-files-at-level3\'))\\n// \u2192 \'243\'\\n```\\n\\n**Note:** `getProperty()` is available via [LevelDOWN](https://github.com/rvagg/node-leveldown/), which by default is accessible as the `db` property of your LevelUP instance. This is a specific LevelDB operation and is not likely to be available where you replace LevelDOWN with an alternative back-end via the `\'db\'` option.\\n\\n\\n--------------------------------------------------------\\n<a name=\\"destroy\\"></a>\\n### leveldown.destroy(location, callback)\\n<code>destroy()</code> is used to completely remove an existing LevelDB database directory. You can use this function in place of a full directory *rm* if you want to be sure to only remove LevelDB-related files. If the directory only contains LevelDB files, the directory itself will be removed as well. If there are additional, non-LevelDB files in the directory, those files, and the directory, will be left alone.\\n\\nThe callback will be called when the destroy operation is complete, with a possible `error` argument.\\n\\n**Note:** `destroy()` is available via [LevelDOWN](https://github.com/rvagg/node-leveldown/) which you will have to have available to `require()`, e.g.:\\n\\n```js\\nrequire(\'leveldown\').destroy(\'./huge.db\', function () { console.log(\'done!\') })\\n```\\n\\n--------------------------------------------------------\\n<a name=\\"repair\\"></a>\\n### leveldown.repair(location, callback)\\n<code>repair()</code> can be used to attempt a restoration of a damaged LevelDB store. From the LevelDB documentation:\\n\\n> If a DB cannot be opened, you may attempt to call this method to resurrect as much of the contents of the database as possible. Some data may be lost, so be careful when calling this function on a database that contains important information.\\n\\nYou will find information on the *repair* operation in the *LOG* file inside the store directory. \\n\\nA `repair()` can also be used to perform a compaction of the LevelDB log into table files.\\n\\nThe callback will be called when the repair operation is complete, with a possible `error` argument.\\n\\n**Note:** `destroy()` is available via [LevelDOWN](https://github.com/rvagg/node-leveldown/) which you will have to have available to `require()`, e.g.:\\n\\n```js\\nrequire(\'leveldown\').repair(\'./huge.db\', function () { console.log(\'done!\') })\\n```\\n\\n--------------------------------------------------------\\n\\n<a name=\\"events\\"></a>\\nEvents\\n------\\n\\nLevelUP emits events when the callbacks to the corresponding methods are called.\\n\\n* `db.emit(\'put\', key, value)` emitted when a new value is `\'put\'`\\n* `db.emit(\'del\', key)` emitted when a value is deleted\\n* `db.emit(\'batch\', ary)` emitted when a batch operation has executed\\n* `db.emit(\'ready\')` emitted when the database has opened (`\'open\'` is synonym)\\n* `db.emit(\'closed\')` emitted when the database has closed\\n* `db.emit(\'opening\')` emitted when the database is opening\\n* `db.emit(\'closing\')` emitted when the database is closing\\n\\nIf you do not pass a callback to an async function, and there is an error, LevelUP will `emit(\'error\', err)` instead.\\n\\n<a name=\\"json\\"></a>\\nJSON data\\n---------\\n\\nYou specify `\'json\'` encoding for both keys and/or values, you can then supply JavaScript objects to LevelUP and receive them from all fetch operations, including ReadStreams. LevelUP will automatically *stringify* your objects and store them as *utf8* and parse the strings back into objects before passing them back to you.\\n\\n<a name=\\"custom_encodings\\"></a>\\nCustom encodings\\n----------------\\n\\nA custom encoding may be provided by passing in an object as an value for `keyEncoding` or `valueEncoding` (wherever accepted), it must have the following properties:\\n\\n```js\\n{\\n    encode : function (val) { ... }\\n  , decode : function (val) { ... }\\n  , buffer : boolean // encode returns a buffer-like and decode accepts a buffer\\n  , type   : String  // name of this encoding type.\\n}\\n```\\n\\n*\\"buffer-like\\"* means either a `Buffer` if running in Node, or a Uint8Array if in a browser. Use [bops](https://github.com/chrisdickinson/bops) to get portable binary operations.\\n\\n<a name=\\"extending\\"></a>\\nExtending LevelUP\\n-----------------\\n\\nA list of <a href=\\"https://github.com/rvagg/node-levelup/wiki/Modules\\"><b>Node.js LevelDB modules and projects</b></a> can be found in the wiki.\\n\\nWhen attempting to extend the functionality of LevelUP, it is recommended that you consider using [level-hooks](https://github.com/dominictarr/level-hooks) and/or [level-sublevel](https://github.com/dominictarr/level-sublevel). **level-sublevel** is particularly helpful for keeping additional, extension-specific, data in a LevelDB store. It allows you to partition a LevelUP instance into multiple sub-instances that each correspond to discrete namespaced key ranges.\\n\\n<a name=\\"multiproc\\"></a>\\nMulti-process access\\n--------------------\\n\\nLevelDB is thread-safe but is **not** suitable for accessing with multiple processes. You should only ever have a LevelDB database open from a single Node.js process. Node.js clusters are made up of multiple processes so a LevelUP instance cannot be shared between them either.\\n\\nSee the <a href=\\"https://github.com/rvagg/node-levelup/wiki/Modules\\"><b>wiki</b></a> for some LevelUP extensions, including [multilevel](https://github.com/juliangruber/multilevel), that may help if you require a single data store to be shared across processes.\\n\\n<a name=\\"support\\"></a>\\nGetting support\\n---------------\\n\\nThere are multiple ways you can find help in using LevelDB in Node.js:\\n\\n * **IRC:** you\'ll find an active group of LevelUP users in the **##leveldb** channel on Freenode, including most of the contributors to this project.\\n * **Mailing list:** there is an active [Node.js LevelDB](https://groups.google.com/forum/#!forum/node-levelup) Google Group.\\n * **GitHub:** you\'re welcome to open an issue here on this GitHub repository if you have a question.\\n\\n<a name=\\"contributing\\"></a>\\nContributing\\n------------\\n\\nLevelUP is an **OPEN Open Source Project**. This means that:\\n\\n> Individuals making significant and valuable contributions are given commit-access to the project to contribute as they see fit. This project is more like an open wiki than a standard guarded open source project.\\n\\nSee the [CONTRIBUTING.md](https://github.com/rvagg/node-levelup/blob/master/CONTRIBUTING.md) file for more details.\\n\\n### Contributors\\n\\nLevelUP is only possible due to the excellent work of the following contributors:\\n\\n<table><tbody>\\n<tr><th align=\\"left\\">Rod Vagg</th><td><a href=\\"https://github.com/rvagg\\">GitHub/rvagg</a></td><td><a href=\\"http://twitter.com/rvagg\\">Twitter/@rvagg</a></td></tr>\\n<tr><th align=\\"left\\">John Chesley</th><td><a href=\\"https://github.com/chesles/\\">GitHub/chesles</a></td><td><a href=\\"http://twitter.com/chesles\\">Twitter/@chesles</a></td></tr>\\n<tr><th align=\\"left\\">Jake Verbaten</th><td><a href=\\"https://github.com/raynos\\">GitHub/raynos</a></td><td><a href=\\"http://twitter.com/raynos2\\">Twitter/@raynos2</a></td></tr>\\n<tr><th align=\\"left\\">Dominic Tarr</th><td><a href=\\"https://github.com/dominictarr\\">GitHub/dominictarr</a></td><td><a href=\\"http://twitter.com/dominictarr\\">Twitter/@dominictarr</a></td></tr>\\n<tr><th align=\\"left\\">Max Ogden</th><td><a href=\\"https://github.com/maxogden\\">GitHub/maxogden</a></td><td><a href=\\"http://twitter.com/maxogden\\">Twitter/@maxogden</a></td></tr>\\n<tr><th align=\\"left\\">Lars-Magnus Skog</th><td><a href=\\"https://github.com/ralphtheninja\\">GitHub/ralphtheninja</a></td><td><a href=\\"http://twitter.com/ralphtheninja\\">Twitter/@ralphtheninja</a></td></tr>\\n<tr><th align=\\"left\\">David Bj\xF6rklund</th><td><a href=\\"https://github.com/kesla\\">GitHub/kesla</a></td><td><a href=\\"http://twitter.com/david_bjorklund\\">Twitter/@david_bjorklund</a></td></tr>\\n<tr><th align=\\"left\\">Julian Gruber</th><td><a href=\\"https://github.com/juliangruber\\">GitHub/juliangruber</a></td><td><a href=\\"http://twitter.com/juliangruber\\">Twitter/@juliangruber</a></td></tr>\\n<tr><th align=\\"left\\">Paolo Fragomeni</th><td><a href=\\"https://github.com/hij1nx\\">GitHub/hij1nx</a></td><td><a href=\\"http://twitter.com/hij1nx\\">Twitter/@hij1nx</a></td></tr>\\n<tr><th align=\\"left\\">Anton Whalley</th><td><a href=\\"https://github.com/No9\\">GitHub/No9</a></td><td><a href=\\"https://twitter.com/antonwhalley\\">Twitter/@antonwhalley</a></td></tr>\\n<tr><th align=\\"left\\">Matteo Collina</th><td><a href=\\"https://github.com/mcollina\\">GitHub/mcollina</a></td><td><a href=\\"https://twitter.com/matteocollina\\">Twitter/@matteocollina</a></td></tr>\\n<tr><th align=\\"left\\">Pedro Teixeira</th><td><a href=\\"https://github.com/pgte\\">GitHub/pgte</a></td><td><a href=\\"https://twitter.com/pgte\\">Twitter/@pgte</a></td></tr>\\n<tr><th align=\\"left\\">James Halliday</th><td><a href=\\"https://github.com/substack\\">GitHub/substack</a></td><td><a href=\\"https://twitter.com/substack\\">Twitter/@substack</a></td></tr>\\n</tbody></table>\\n\\n### Windows\\n\\nA large portion of the Windows support comes from code by [Krzysztof Kowalczyk](http://blog.kowalczyk.info/) [@kjk](https://twitter.com/kjk), see his Windows LevelDB port [here](http://code.google.com/r/kkowalczyk-leveldb/). If you\'re using LevelUP on Windows, you should give him your thanks!\\n\\n\\n<a name=\\"licence\\"></a>\\nLicence &amp; copyright\\n-------------------\\n\\nCopyright (c) 2012-2013 LevelUP contributors (listed above).\\n\\nLevelUP is licensed under an MIT +no-false-attribs license. All rights not explicitly granted in the MIT license are reserved. See the included LICENSE file for more details.\\n\\n=======\\n*LevelUP builds on the excellent work of the LevelDB and Snappy teams from Google and additional contributors. LevelDB and Snappy are both issued under the [New BSD Licence](http://opensource.org/licenses/BSD-3-Clause).*\\n",\n  "readmeFilename": "README.md",\n  "bugs": {\n    "url": "https://github.com/rvagg/node-levelup/issues"\n  },\n  "_id": "levelup@0.18.2",\n  "_from": "levelup@*"\n}\n\n})()\n},{}],27:[function(require,module,exports){\n\n},{}],23:[function(require,module,exports){\n/*!\n  * prr\n  * (c) 2013 Rod Vagg <rod@vagg.org>\n  * https://github.com/rvagg/prr\n  * License: MIT\n  */\n\n(function (name, context, definition) {\n  if (typeof module != \'undefined\' && module.exports)\n    module.exports = definition()\n  else\n    context[name] = definition()\n})(\'prr\', this, function() {\n\n  var setProperty = typeof Object.defineProperty == \'function\'\n      ? function (obj, key, options) {\n          Object.defineProperty(obj, key, options)\n          return obj\n        }\n      : function (obj, key, options) { // < es5\n          obj[key] = options.value\n          return obj\n        }\n\n    , makeOptions = function (value, options) {\n        var oo = typeof options == \'object\'\n          , os = !oo && typeof options == \'string\'\n          , op = function (p) {\n              return oo\n                ? !!options[p]\n                : os\n                  ? options.indexOf(p[0]) > -1\n                  : false\n            }\n\n        return {\n            enumerable   : op(\'enumerable\')\n          , configurable : op(\'configurable\')\n          , writable     : op(\'writable\')\n          , value        : value\n        }\n      }\n\n    , prr = function (obj, key, value, options) {\n        var k\n\n        options = makeOptions(value, options)\n\n        if (typeof key == \'object\') {\n          for (k in key) {\n            if (Object.hasOwnProperty.call(key, k)) {\n              options.value = key[k]\n              setProperty(obj, k, options)\n            }\n          }\n          return obj\n        }\n\n        return setProperty(obj, key, options)\n      }\n\n  return prr\n})\n},{}],12:[function(require,module,exports){\nvar util = require(\'util\')\nvar AbstractIterator  = require(\'abstract-leveldown\').AbstractIterator\nmodule.exports = Iterator\n\nfunction Iterator (db, options) {\n  if (!options) options = {}\n  this.options = options\n  AbstractIterator.call(this, db)\n  this._order = options.reverse ? \'DESC\': \'ASC\'\n  this._start = options.start\n  this._limit = options.limit\n  this._count = 0\n  this._end   = options.end\n  this._done  = false\n  this._gt    = options.gt\n  this._gte   = options.gte\n  this._lt    = options.lt\n  this._lte   = options.lte\n}\n\nutil.inherits(Iterator, AbstractIterator)\n\nIterator.prototype.createIterator = function() {\n  var self = this\n  var lower, upper\n  var onlyStart = typeof self._start !== \'undefined\' && typeof self._end === \'undefined\'\n  var onlyEnd = typeof self._start === \'undefined\' && typeof self._end !== \'undefined\'\n  var startAndEnd = typeof self._start !== \'undefined\' && typeof self._end !== \'undefined\'\n  if (onlyStart) {\n    var index = self._start\n    if (self._order === \'ASC\') {\n      lower = index\n    } else {\n      upper = index\n    }\n  } else if (onlyEnd) {\n    var index = self._end\n    if (self._order === \'DESC\') {\n      lower = index\n    } else {\n      upper = index\n    }\n  } else if (startAndEnd) {\n    lower = self._start\n    upper = self._end\n    if (self._start > self._end) {\n      lower = self._end\n      upper = self._start\n    }\n  }\n  if (!lower) {\n    if (self._gte !== \'undefined\') lower = self._gte\n    else if (self._gt !== \'undefined\') lower = self._gt\n  }\n  if (!upper) {\n    if (self._lte !== \'undefined\') upper = self._lte\n    else if (self._lt !== \'undefined\') upper = self._lt\n  }\n  if (lower || upper) {\n    self._keyRange = self.options.keyRange || self.db.makeKeyRange({\n      lower: lower,\n      upper: upper\n      // TODO expose excludeUpper/excludeLower\n    })\n  }\n  self.iterator = self.db.iterate(function () {\n    self.onItem.apply(self, arguments)\n  }, {\n    keyRange: self._keyRange,\n    autoContinue: false,\n    order: self._order,\n    onError: function(err) { console.log(\'horrible error\', err) },\n  })\n}\n\n// TODO the limit implementation here just ignores all reads after limit has been reached\n// it should cancel the iterator instead but I don\'t know how\nIterator.prototype.onItem = function (value, cursor, cursorTransaction) {\n  if (!cursor && this.callback) {\n    this.callback()\n    this.callback = false\n    return\n  }\n  var shouldCall = true\n\n  if (!!this._limit && this._limit > 0 && this._count++ >= this._limit)\n    shouldCall = false\n\n  if (  (this._lt  && cursor.key >= this._lt)\n     || (this._lte && cursor.key > this._lte)\n     || (this._gt  && cursor.key <= this._gt)\n     || (this._gte && cursor.key < this._gte))\n    shouldCall = false\n\n  if (shouldCall) this.callback(false, cursor.key, cursor.value)\n  if (cursor) cursor.continue()\n}\n\nIterator.prototype._next = function (callback) {\n  if (!callback) return new Error(\'next() requires a callback argument\')\n  if (!this._started) {\n    this.createIterator()\n    this._started = true\n  }\n  this.callback = callback\n}\n\n},{"abstract-leveldown":13,"util":11}],28:[function(require,module,exports){\n(function(){// UTILITY\nvar util = require(\'util\');\nvar Buffer = require("buffer").Buffer;\nvar pSlice = Array.prototype.slice;\n\nfunction objectKeys(object) {\n  if (Object.keys) return Object.keys(object);\n  var result = [];\n  for (var name in object) {\n    if (Object.prototype.hasOwnProperty.call(object, name)) {\n      result.push(name);\n    }\n  }\n  return result;\n}\n\n// 1. The assert module provides functions that throw\n// AssertionError\'s when particular conditions are not met. The\n// assert module must conform to the following interface.\n\nvar assert = module.exports = ok;\n\n// 2. The AssertionError is defined in assert.\n// new assert.AssertionError({ message: message,\n//                             actual: actual,\n//                             expected: expected })\n\nassert.AssertionError = function AssertionError(options) {\n  this.name = \'AssertionError\';\n  this.message = options.message;\n  this.actual = options.actual;\n  this.expected = options.expected;\n  this.operator = options.operator;\n  var stackStartFunction = options.stackStartFunction || fail;\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, stackStartFunction);\n  }\n};\n\n// assert.AssertionError instanceof Error\nutil.inherits(assert.AssertionError, Error);\n\nfunction replacer(key, value) {\n  if (value === undefined) {\n    return \'\' + value;\n  }\n  if (typeof value === \'number\' && (isNaN(value) || !isFinite(value))) {\n    return value.toString();\n  }\n  if (typeof value === \'function\' || value instanceof RegExp) {\n    return value.toString();\n  }\n  return value;\n}\n\nfunction truncate(s, n) {\n  if (typeof s == \'string\') {\n    return s.length < n ? s : s.slice(0, n);\n  } else {\n    return s;\n  }\n}\n\nassert.AssertionError.prototype.toString = function() {\n  if (this.message) {\n    return [this.name + \':\', this.message].join(\' \');\n  } else {\n    return [\n      this.name + \':\',\n      truncate(JSON.stringify(this.actual, replacer), 128),\n      this.operator,\n      truncate(JSON.stringify(this.expected, replacer), 128)\n    ].join(\' \');\n  }\n};\n\n// At present only the three keys mentioned above are used and\n// understood by the spec. Implementations or sub modules can pass\n// other keys to the AssertionError\'s constructor - they will be\n// ignored.\n\n// 3. All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided.  All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n\nfunction fail(actual, expected, message, operator, stackStartFunction) {\n  throw new assert.AssertionError({\n    message: message,\n    actual: actual,\n    expected: expected,\n    operator: operator,\n    stackStartFunction: stackStartFunction\n  });\n}\n\n// EXTENSION! allows for well behaved errors defined elsewhere.\nassert.fail = fail;\n\n// 4. Pure assertion tests whether a value is truthy, as determined\n// by !!guard.\n// assert.ok(guard, message_opt);\n// This statement is equivalent to assert.equal(true, guard,\n// message_opt);. To test strictly for the value true, use\n// assert.strictEqual(true, guard, message_opt);.\n\nfunction ok(value, message) {\n  if (!!!value) fail(value, true, message, \'==\', assert.ok);\n}\nassert.ok = ok;\n\n// 5. The equality assertion tests shallow, coercive equality with\n// ==.\n// assert.equal(actual, expected, message_opt);\n\nassert.equal = function equal(actual, expected, message) {\n  if (actual != expected) fail(actual, expected, message, \'==\', assert.equal);\n};\n\n// 6. The non-equality assertion tests for whether two objects are not equal\n// with != assert.notEqual(actual, expected, message_opt);\n\nassert.notEqual = function notEqual(actual, expected, message) {\n  if (actual == expected) {\n    fail(actual, expected, message, \'!=\', assert.notEqual);\n  }\n};\n\n// 7. The equivalence assertion tests a deep equality relation.\n// assert.deepEqual(actual, expected, message_opt);\n\nassert.deepEqual = function deepEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected)) {\n    fail(actual, expected, message, \'deepEqual\', assert.deepEqual);\n  }\n};\n\nfunction _deepEqual(actual, expected) {\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n\n  } else if (Buffer.isBuffer(actual) && Buffer.isBuffer(expected)) {\n    if (actual.length != expected.length) return false;\n\n    for (var i = 0; i < actual.length; i++) {\n      if (actual[i] !== expected[i]) return false;\n    }\n\n    return true;\n\n  // 7.2. If the expected value is a Date object, the actual value is\n  // equivalent if it is also a Date object that refers to the same time.\n  } else if (actual instanceof Date && expected instanceof Date) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3. Other pairs that do not both pass typeof value == \'object\',\n  // equivalence is determined by ==.\n  } else if (typeof actual != \'object\' && typeof expected != \'object\') {\n    return actual == expected;\n\n  // 7.4. For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical \'prototype\' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else {\n    return objEquiv(actual, expected);\n  }\n}\n\nfunction isUndefinedOrNull(value) {\n  return value === null || value === undefined;\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) == \'[object Arguments]\';\n}\n\nfunction objEquiv(a, b) {\n  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))\n    return false;\n  // an identical \'prototype\' property.\n  if (a.prototype !== b.prototype) return false;\n  //~~~I\'ve managed to break Object.keys through screwy arguments passing.\n  //   Converting to array solves the problem.\n  if (isArguments(a)) {\n    if (!isArguments(b)) {\n      return false;\n    }\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return _deepEqual(a, b);\n  }\n  try {\n    var ka = objectKeys(a),\n        kb = objectKeys(b),\n        key, i;\n  } catch (e) {//happens when one is a string literal and the other isn\'t\n    return false;\n  }\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length != kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!_deepEqual(a[key], b[key])) return false;\n  }\n  return true;\n}\n\n// 8. The non-equivalence assertion tests for any deep inequality.\n// assert.notDeepEqual(actual, expected, message_opt);\n\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected)) {\n    fail(actual, expected, message, \'notDeepEqual\', assert.notDeepEqual);\n  }\n};\n\n// 9. The strict equality assertion tests strict equality, as determined by ===.\n// assert.strictEqual(actual, expected, message_opt);\n\nassert.strictEqual = function strictEqual(actual, expected, message) {\n  if (actual !== expected) {\n    fail(actual, expected, message, \'===\', assert.strictEqual);\n  }\n};\n\n// 10. The strict non-equality assertion tests for strict inequality, as\n// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);\n\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n  if (actual === expected) {\n    fail(actual, expected, message, \'!==\', assert.notStrictEqual);\n  }\n};\n\nfunction expectedException(actual, expected) {\n  if (!actual || !expected) {\n    return false;\n  }\n\n  if (expected instanceof RegExp) {\n    return expected.test(actual);\n  } else if (actual instanceof expected) {\n    return true;\n  } else if (expected.call({}, actual) === true) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction _throws(shouldThrow, block, expected, message) {\n  var actual;\n\n  if (typeof expected === \'string\') {\n    message = expected;\n    expected = null;\n  }\n\n  try {\n    block();\n  } catch (e) {\n    actual = e;\n  }\n\n  message = (expected && expected.name ? \' (\' + expected.name + \').\' : \'.\') +\n            (message ? \' \' + message : \'.\');\n\n  if (shouldThrow && !actual) {\n    fail(\'Missing expected exception\' + message);\n  }\n\n  if (!shouldThrow && expectedException(actual, expected)) {\n    fail(\'Got unwanted exception\' + message);\n  }\n\n  if ((shouldThrow && actual && expected &&\n      !expectedException(actual, expected)) || (!shouldThrow && actual)) {\n    throw actual;\n  }\n}\n\n// 11. Expected to throw an error:\n// assert.throws(block, Error_opt, message_opt);\n\nassert.throws = function(block, /*optional*/error, /*optional*/message) {\n  _throws.apply(this, [true].concat(pSlice.call(arguments)));\n};\n\n// EXTENSION! This is annoying to write outside this module.\nassert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {\n  _throws.apply(this, [false].concat(pSlice.call(arguments)));\n};\n\nassert.ifError = function(err) { if (err) {throw err;}};\n\n})()\n},{"buffer":17,"util":11}],29:[function(require,module,exports){\n(function(process){/* Copyright (c) 2013 Rod Vagg, MIT License */\n\nfunction AbstractIterator (db) {\n  this.db = db\n  this._ended = false\n  this._nexting = false\n}\n\nAbstractIterator.prototype.next = function (callback) {\n  var self = this\n\n  if (typeof callback != \'function\')\n    throw new Error(\'next() requires a callback argument\')\n\n  if (self._ended)\n    return callback(new Error(\'cannot call next() after end()\'))\n  if (self._nexting)\n    return callback(new Error(\'cannot call next() before previous next() has completed\'))\n\n  self._nexting = true\n  if (typeof self._next == \'function\') {\n    return self._next(function () {\n      self._nexting = false\n      callback.apply(null, arguments)\n    })\n  }\n\n  process.nextTick(function () {\n    self._nexting = false\n    callback()\n  })\n}\n\nAbstractIterator.prototype.end = function (callback) {\n  if (typeof callback != \'function\')\n    throw new Error(\'end() requires a callback argument\')\n\n  if (this._ended)\n    return callback(new Error(\'end() already called on iterator\'))\n\n  this._ended = true\n\n  if (typeof this._end == \'function\')\n    return this._end(callback)\n\n  process.nextTick(callback)\n}\n\nmodule.exports = AbstractIterator\n\n})(require("__browserify_process"))\n},{"__browserify_process":9}],30:[function(require,module,exports){\n(function(process){/* Copyright (c) 2013 Rod Vagg, MIT License */\n\nfunction AbstractChainedBatch (db) {\n  this._db         = db\n  this._operations = []\n  this._written    = false\n}\n\nAbstractChainedBatch.prototype._checkWritten = function () {\n  if (this._written)\n    throw new Error(\'write() already called on this batch\')\n}\n\nAbstractChainedBatch.prototype.put = function (key, value) {\n  this._checkWritten()\n\n  var err = this._db._checkKeyValue(key, \'key\', this._db._isBuffer)\n  if (err) throw err\n  err = this._db._checkKeyValue(value, \'value\', this._db._isBuffer)\n  if (err) throw err\n\n  if (!this._db._isBuffer(key)) key = String(key)\n  if (!this._db._isBuffer(value)) value = String(value)\n\n  if (typeof this._put == \'function\' )\n    this._put(key, value)\n  else\n    this._operations.push({ type: \'put\', key: key, value: value })\n\n  return this\n}\n\nAbstractChainedBatch.prototype.del = function (key) {\n  this._checkWritten()\n\n  var err = this._db._checkKeyValue(key, \'key\', this._db._isBuffer)\n  if (err) throw err\n\n  if (!this._db._isBuffer(key)) key = String(key)\n\n  if (typeof this._del == \'function\' )\n    this._del(key)\n  else\n    this._operations.push({ type: \'del\', key: key })\n\n  return this\n}\n\nAbstractChainedBatch.prototype.clear = function () {\n  this._checkWritten()\n\n  this._operations = []\n\n  if (typeof this._clear == \'function\' )\n    this._clear()\n\n  return this\n}\n\nAbstractChainedBatch.prototype.write = function (options, callback) {\n  this._checkWritten()\n\n  if (typeof options == \'function\')\n    callback = options\n  if (typeof callback != \'function\')\n    throw new Error(\'write() requires a callback argument\')\n  if (typeof options != \'object\')\n    options = {}\n\n  this._written = true\n\n  if (typeof this._write == \'function\' )\n    return this._write(callback)\n\n  if (typeof this._db._batch == \'function\')\n    return this._db._batch(this._operations, options, callback)\n\n  process.nextTick(callback)\n}\n\nmodule.exports = AbstractChainedBatch\n})(require("__browserify_process"))\n},{"__browserify_process":9}],20:[function(require,module,exports){\n/* Copyright (c) 2012-2013 LevelUP contributors\n * See list at <https://github.com/rvagg/node-levelup#contributing>\n * MIT +no-false-attribs License\n * <https://github.com/rvagg/node-levelup/blob/master/LICENSE>\n */\n\nvar createError   = require(\'errno\').create\n  , LevelUPError  = createError(\'LevelUPError\')\n  , NotFoundError = createError(\'NotFoundError\', LevelUPError)\n\nNotFoundError.prototype.notFound = true\nNotFoundError.prototype.status   = 404\n\nmodule.exports = {\n    LevelUPError        : LevelUPError\n  , InitializationError : createError(\'InitializationError\', LevelUPError)\n  , OpenError           : createError(\'OpenError\', LevelUPError)\n  , ReadError           : createError(\'ReadError\', LevelUPError)\n  , WriteError          : createError(\'WriteError\', LevelUPError)\n  , NotFoundError       : NotFoundError\n  , EncodingError       : createError(\'EncodingError\', LevelUPError)\n}\n},{"errno":31}],13:[function(require,module,exports){\n(function(process,Buffer){/* Copyright (c) 2013 Rod Vagg, MIT License */\n\nvar xtend                = require(\'xtend\')\n  , AbstractIterator     = require(\'./abstract-iterator\')\n  , AbstractChainedBatch = require(\'./abstract-chained-batch\')\n\nfunction AbstractLevelDOWN (location) {\n  if (!arguments.length || location === undefined)\n    throw new Error(\'constructor requires at least a location argument\')\n\n  if (typeof location != \'string\')\n    throw new Error(\'constructor requires a location string argument\')\n\n  this.location = location\n}\n\nAbstractLevelDOWN.prototype.open = function (options, callback) {\n  if (typeof options == \'function\')\n    callback = options\n\n  if (typeof callback != \'function\')\n    throw new Error(\'open() requires a callback argument\')\n\n  if (typeof options != \'object\')\n    options = {}\n\n  if (typeof this._open == \'function\')\n    return this._open(options, callback)\n\n  process.nextTick(callback)\n}\n\nAbstractLevelDOWN.prototype.close = function (callback) {\n  if (typeof callback != \'function\')\n    throw new Error(\'close() requires a callback argument\')\n\n  if (typeof this._close == \'function\')\n    return this._close(callback)\n\n  process.nextTick(callback)\n}\n\nAbstractLevelDOWN.prototype.get = function (key, options, callback) {\n  var err\n\n  if (typeof options == \'function\')\n    callback = options\n\n  if (typeof callback != \'function\')\n    throw new Error(\'get() requires a callback argument\')\n\n  if (err = this._checkKeyValue(key, \'key\', this._isBuffer))\n    return callback(err)\n\n  if (!this._isBuffer(key))\n    key = String(key)\n\n  if (typeof options != \'object\')\n    options = {}\n\n  if (typeof this._get == \'function\')\n    return this._get(key, options, callback)\n\n  process.nextTick(function () { callback(new Error(\'NotFound\')) })\n}\n\nAbstractLevelDOWN.prototype.put = function (key, value, options, callback) {\n  var err\n\n  if (typeof options == \'function\')\n    callback = options\n\n  if (typeof callback != \'function\')\n    throw new Error(\'put() requires a callback argument\')\n\n  if (err = this._checkKeyValue(key, \'key\', this._isBuffer))\n    return callback(err)\n\n  if (err = this._checkKeyValue(value, \'value\', this._isBuffer))\n    return callback(err)\n\n  if (!this._isBuffer(key))\n    key = String(key)\n\n  // coerce value to string in node, don\'t touch it in browser\n  // (indexeddb can store any JS type)\n  if (!this._isBuffer(value) && !process.browser)\n    value = String(value)\n\n  if (typeof options != \'object\')\n    options = {}\n\n  if (typeof this._put == \'function\')\n    return this._put(key, value, options, callback)\n\n  process.nextTick(callback)\n}\n\nAbstractLevelDOWN.prototype.del = function (key, options, callback) {\n  var err\n\n  if (typeof options == \'function\')\n    callback = options\n\n  if (typeof callback != \'function\')\n    throw new Error(\'del() requires a callback argument\')\n\n  if (err = this._checkKeyValue(key, \'key\', this._isBuffer))\n    return callback(err)\n\n  if (!this._isBuffer(key))\n    key = String(key)\n\n  if (typeof options != \'object\')\n    options = {}\n\n  if (typeof this._del == \'function\')\n    return this._del(key, options, callback)\n\n  process.nextTick(callback)\n}\n\nAbstractLevelDOWN.prototype.batch = function (array, options, callback) {\n  if (!arguments.length)\n    return this._chainedBatch()\n\n  if (typeof options == \'function\')\n    callback = options\n\n  if (typeof callback != \'function\')\n    throw new Error(\'batch(array) requires a callback argument\')\n\n  if (!Array.isArray(array))\n    return callback(new Error(\'batch(array) requires an array argument\'))\n\n  if (typeof options != \'object\')\n    options = {}\n\n  var i = 0\n    , l = array.length\n    , e\n    , err\n\n  for (; i < l; i++) {\n    e = array[i]\n    if (typeof e != \'object\')\n      continue\n\n    if (err = this._checkKeyValue(e.type, \'type\', this._isBuffer))\n      return callback(err)\n\n    if (err = this._checkKeyValue(e.key, \'key\', this._isBuffer))\n      return callback(err)\n\n    if (e.type == \'put\') {\n      if (err = this._checkKeyValue(e.value, \'value\', this._isBuffer))\n        return callback(err)\n    }\n  }\n\n  if (typeof this._batch == \'function\')\n    return this._batch(array, options, callback)\n\n  process.nextTick(callback)\n}\n\n//TODO: remove from here, not a necessary primitive\nAbstractLevelDOWN.prototype.approximateSize = function (start, end, callback) {\n  if (   start == null\n      || end == null\n      || typeof start == \'function\'\n      || typeof end == \'function\') {\n    throw new Error(\'approximateSize() requires valid `start`, `end` and `callback` arguments\')\n  }\n\n  if (typeof callback != \'function\')\n    throw new Error(\'approximateSize() requires a callback argument\')\n\n  if (!this._isBuffer(start))\n    start = String(start)\n\n  if (!this._isBuffer(end))\n    end = String(end)\n\n  if (typeof this._approximateSize == \'function\')\n    return this._approximateSize(start, end, callback)\n\n  process.nextTick(function () {\n    callback(null, 0)\n  })\n}\n\nAbstractLevelDOWN.prototype._setupIteratorOptions = function (options) {\n  var self = this\n\n  options = xtend(options)\n\n  ;[ \'start\', \'end\', \'gt\', \'gte\', \'lt\', \'lte\' ].forEach(function (o) {\n    if (options[o] && self._isBuffer(options[o]) && options[o].length === 0)\n      delete options[o]\n  })\n\n  options.reverse = !!options.reverse\n\n  // fix `start` so it takes into account gt, gte, lt, lte as appropriate\n  if (options.reverse && options.lt)\n    options.start = options.lt\n  if (options.reverse && options.lte)\n    options.start = options.lte\n  if (!options.reverse && options.gt)\n    options.start = options.gt\n  if (!options.reverse && options.gte)\n    options.start = options.gte\n\n  if ((options.reverse && options.lt && !options.lte)\n    || (!options.reverse && options.gt && !options.gte))\n    options.exclusiveStart = true // start should *not* include matching key\n\n  return options\n}\n\nAbstractLevelDOWN.prototype.iterator = function (options) {\n  if (typeof options != \'object\')\n    options = {}\n\n  options = this._setupIteratorOptions(options)\n\n  if (typeof this._iterator == \'function\')\n    return this._iterator(options)\n\n  return new AbstractIterator(this)\n}\n\nAbstractLevelDOWN.prototype._chainedBatch = function () {\n  return new AbstractChainedBatch(this)\n}\n\nAbstractLevelDOWN.prototype._isBuffer = function (obj) {\n  return Buffer.isBuffer(obj)\n}\n\nAbstractLevelDOWN.prototype._checkKeyValue = function (obj, type) {\n  if (obj === null || obj === undefined)\n    return new Error(type + \' cannot be `null` or `undefined`\')\n\n  if (obj === null || obj === undefined)\n    return new Error(type + \' cannot be `null` or `undefined`\')\n\n  if (this._isBuffer(obj)) {\n    if (obj.length === 0)\n      return new Error(type + \' cannot be an empty Buffer\')\n  } else if (String(obj) === \'\')\n    return new Error(type + \' cannot be an empty String\')\n}\n\nmodule.exports.AbstractLevelDOWN    = AbstractLevelDOWN\nmodule.exports.AbstractIterator     = AbstractIterator\nmodule.exports.AbstractChainedBatch = AbstractChainedBatch\n\n})(require("__browserify_process"),require("__browserify_buffer").Buffer)\n},{"./abstract-chained-batch":30,"./abstract-iterator":29,"__browserify_buffer":8,"__browserify_process":9,"xtend":32}],21:[function(require,module,exports){\n/* Copyright (c) 2012-2013 LevelUP contributors\n * See list at <https://github.com/rvagg/node-levelup#contributing>\n * MIT +no-false-attribs License <https://github.com/rvagg/node-levelup/blob/master/LICENSE>\n */\n\n// NOTE: we are fixed to readable-stream@1.0.x for now\n// for pure Streams2 across Node versions\nvar Readable      = require(\'readable-stream\').Readable\n  , inherits      = require(\'util\').inherits\n  , extend        = require(\'xtend\')\n  , EncodingError = require(\'./errors\').EncodingError\n  , util          = require(\'./util\')\n\n  , defaultOptions = { keys: true, values: true }\n\n  , makeKeyValueData = function (key, value) {\n      return {\n          key: util.decodeKey(key, this._options)\n        , value: util.decodeValue(value, this._options)\n      }\n    }\n  , makeKeyData = function (key) {\n      return util.decodeKey(key, this._options)\n    }\n  , makeValueData = function (_, value) {\n      return util.decodeValue(value, this._options)\n    }\n  , makeNoData = function () { return null }\n\nfunction ReadStream (options, db, iteratorFactory) {\n  if (!(this instanceof ReadStream))\n    return new ReadStream(options, db, iteratorFactory)\n\n  Readable.call(this, { objectMode: true, highWaterMark: options.highWaterMark })\n\n  // purely to keep `db` around until we\'re done so it\'s not GCed if the user doesn\'t keep a ref\n  this._db = db\n\n  options = this._options = extend(defaultOptions, options)\n\n  this._keyEncoding   = options.keyEncoding   || options.encoding\n  this._valueEncoding = options.valueEncoding || options.encoding\n\n  if (typeof this._options.start != \'undefined\')\n    this._options.start = util.encodeKey(this._options.start, this._options)\n  if (typeof this._options.end != \'undefined\')\n    this._options.end = util.encodeKey(this._options.end, this._options)\n  if (typeof this._options.limit != \'number\')\n    this._options.limit = -1\n\n  this._options.keyAsBuffer   = util.isKeyAsBuffer(this._options)\n\n  this._options.valueAsBuffer = util.isValueAsBuffer(this._options)\n\n  this._makeData = this._options.keys && this._options.values\n    ? makeKeyValueData : this._options.keys\n      ? makeKeyData : this._options.values\n        ? makeValueData : makeNoData\n\n  var self = this\n  if (!this._db.isOpen()) {\n    this._db.once(\'ready\', function () {\n      self._iterator = iteratorFactory(self._options)\n    })\n  } else\n    this._iterator = iteratorFactory(this._options)\n}\n\ninherits(ReadStream, Readable)\n\nReadStream.prototype._read = function read () {\n  var self = this\n  if (!self._db.isOpen()) {\n    return self._db.once(\'ready\', function () { read.call(self) })\n  }\n  if (self._destroyed)\n    return\n \n  self._iterator.next(function(err, key, value) {\n    if (err || (key === undefined && value === undefined)) {\n      if (!err && !self._destroyed)\n        self.push(null)\n      return self._cleanup(err)\n    }\n\n    try {\n      value = self._makeData(key, value)\n    } catch (e) {\n      return self._cleanup(new EncodingError(e))\n    }\n    if (!self._destroyed)\n      self.push(value)\n  })\n}\n\nReadStream.prototype._cleanup = function (err) {\n  if (this._destroyed)\n    return\n\n  this._destroyed = true\n\n  var self = this\n  if (err)\n    self.emit(\'error\', err)\n\n  self._iterator.end(function () {\n    self._iterator = null\n    self.emit(\'close\')\n  })\n}\n\nReadStream.prototype.destroy = function () {\n  this._cleanup()\n}\n\nReadStream.prototype.toString = function () {\n  return \'LevelUP.ReadStream\'\n}\n\nmodule.exports = ReadStream\n\n},{"./errors":20,"./util":19,"readable-stream":33,"util":11,"xtend":25}],19:[function(require,module,exports){\n/* Copyright (c) 2012-2013 LevelUP contributors\n * See list at <https://github.com/rvagg/node-levelup#contributing>\n * MIT +no-false-attribs License\n * <https://github.com/rvagg/node-levelup/blob/master/LICENSE>\n */\n\nvar extend        = require(\'xtend\')\n  , LevelUPError  = require(\'./errors\').LevelUPError\n  , bops          = require(\'bops\')\n\n  , encodingNames = [\n        \'hex\'\n      , \'utf8\'\n      , \'utf-8\'\n      , \'ascii\'\n      , \'binary\'\n      , \'base64\'\n      , \'ucs2\'\n      , \'ucs-2\'\n      , \'utf16le\'\n      , \'utf-16le\'\n    ]\n\n  , defaultOptions = {\n        createIfMissing : true\n      , errorIfExists   : false\n      , keyEncoding     : \'utf8\'\n      , valueEncoding   : \'utf8\'\n      , compression     : true\n    }\n\n  , leveldown\n\n  , encodings = (function () {\n      function isBinary (data) {\n        return data === undefined || data === null || bops.is(data)\n      }\n\n      var encodings = {}\n      encodings.utf8 = encodings[\'utf-8\'] = {\n          encode : function (data) {\n            return isBinary(data) ? data : String(data)\n          }\n        , decode : function (data) { return data }\n        , buffer : false\n        , type   : \'utf8\'\n      }\n      encodings.json = {\n          encode : JSON.stringify\n        , decode : JSON.parse\n        , buffer : false\n        , type   : \'json\'\n      }\n      encodingNames.forEach(function (type) {\n        if (encodings[type])\n          return\n        encodings[type] = {\n            encode : function (data) {\n              return isBinary(data) ? data : bops.from(data, type)\n            }\n          , decode : function (buffer) {\n              return bops.from(buffer, type)\n            }\n          , buffer : true\n          , type   : type // useful for debugging purposes\n        }\n      })\n      return encodings\n    })()\n\n  , encodingOpts = (function () {\n      var eo = {}\n      encodingNames.forEach(function (e) {\n        eo[e] = { valueEncoding : e }\n      })\n      return eo\n    }())\n\nfunction copy (srcdb, dstdb, callback) {\n  srcdb.readStream()\n    .pipe(dstdb.writeStream())\n    .on(\'close\', callback ? callback : function () {})\n    .on(\'error\', callback ? callback : function (err) { throw err })\n}\n\nfunction getOptions (levelup, options) {\n  var s = typeof options == \'string\' // just an encoding\n  if (!s && options && options.encoding && !options.valueEncoding)\n    options.valueEncoding = options.encoding\n  return extend(\n      (levelup && levelup.options) || {}\n    , s ? encodingOpts[options] || encodingOpts[defaultOptions.valueEncoding]\n        : options\n  )\n}\n\nfunction getLevelDOWN () {\n  if (leveldown)\n    return leveldown\n\n  var requiredVersion       = require(\'../package.json\').devDependencies.leveldown\n    , missingLevelDOWNError = \'Could not locate LevelDOWN, try `npm install leveldown`\'\n    , leveldownVersion\n\n  try {\n    leveldownVersion = require(\'leveldown/package\').version\n  } catch (e) {\n    throw new LevelUPError(missingLevelDOWNError)\n  }\n\n  if (!require(\'semver\').satisfies(leveldownVersion, requiredVersion)) {\n    throw new LevelUPError(\n        \'Installed version of LevelDOWN (\'\n      + leveldownVersion\n      + \') does not match required version (\'\n      + requiredVersion\n      + \')\'\n    )\n  }\n\n  try {\n    return leveldown = require(\'leveldown\')\n  } catch (e) {\n    throw new LevelUPError(missingLevelDOWNError)\n  }\n}\n\nfunction dispatchError (levelup, error, callback) {\n  return typeof callback == \'function\'\n    ? callback(error)\n    : levelup.emit(\'error\', error)\n}\n\nfunction getKeyEncoder (options, op) {\n  var type = ((op && op.keyEncoding) || options.keyEncoding) || \'utf8\'\n  return encodings[type] || type\n}\n\nfunction getValueEncoder (options, op) {\n  var type = (((op && (op.valueEncoding || op.encoding))\n      || options.valueEncoding || options.encoding)) || \'utf8\'\n  return encodings[type] || type\n}\n\nfunction encodeKey (key, options, op) {\n  return getKeyEncoder(options, op).encode(key)\n}\n\nfunction encodeValue (value, options, op) {\n  return getValueEncoder(options, op).encode(value)\n}\n\nfunction decodeKey (key, options) {\n  return getKeyEncoder(options).decode(key)\n}\n\nfunction decodeValue (value, options) {\n  return getValueEncoder(options).decode(value)\n}\n\nfunction isValueAsBuffer (options, op) {\n  return getValueEncoder(options, op).buffer\n}\n\nfunction isKeyAsBuffer (options, op) {\n  return getKeyEncoder(options, op).buffer\n}\n\nmodule.exports = {\n    defaultOptions  : defaultOptions\n  , copy            : copy\n  , getOptions      : getOptions\n  , getLevelDOWN    : getLevelDOWN\n  , dispatchError   : dispatchError\n  , encodeKey       : encodeKey\n  , encodeValue     : encodeValue\n  , isValueAsBuffer : isValueAsBuffer\n  , isKeyAsBuffer   : isKeyAsBuffer\n  , decodeValue     : decodeValue\n  , decodeKey       : decodeKey\n}\n\n},{"../package.json":26,"./errors":20,"bops":34,"leveldown":27,"leveldown/package":27,"semver":27,"xtend":25}],22:[function(require,module,exports){\n(function(process){/* Copyright (c) 2012-2013 LevelUP contributors\n * See list at <https://github.com/rvagg/node-levelup#contributing>\n * MIT +no-false-attribs License\n * <https://github.com/rvagg/node-levelup/blob/master/LICENSE>\n */\n\nvar Stream       = require(\'stream\').Stream\n  , inherits     = require(\'util\').inherits\n  , extend       = require(\'xtend\')\n  , concatStream = require(\'concat-stream\')\n\n  , setImmediate = process.nextTick\n\n  , getOptions   = require(\'./util\').getOptions\n\n  , defaultOptions = { type: \'put\' }\n\nfunction WriteStream (options, db) {\n  if (!(this instanceof WriteStream))\n    return new WriteStream(options, db)\n\n  Stream.call(this)\n  this._options = extend(defaultOptions, getOptions(db, options))\n  this._db      = db\n  this._buffer  = []\n  this._status  = \'init\'\n  this._end     = false\n  this.writable = true\n  this.readable = false\n\n  var self = this\n    , ready = function () {\n        if (!self.writable)\n          return\n        self._status = \'ready\'\n        self.emit(\'ready\')\n        self._process()\n      }\n\n  if (db.isOpen())\n    setImmediate(ready)\n  else\n    db.once(\'ready\', ready)\n}\n\ninherits(WriteStream, Stream)\n\nWriteStream.prototype.write = function (data) {\n  if (!this.writable)\n    return false\n  this._buffer.push(data)\n  if (this._status != \'init\')\n    this._processDelayed()\n  if (this._options.maxBufferLength &&\n      this._buffer.length > this._options.maxBufferLength) {\n    this._writeBlock = true\n    return false\n  }\n  return true\n}\n\nWriteStream.prototype.end = function (data) {\n  var self = this\n  if (data)\n    this.write(data)\n  setImmediate(function () {\n    self._end = true\n    self._process()\n  })\n}\n\nWriteStream.prototype.destroy = function () {\n  this.writable = false\n  this.end()\n}\n\nWriteStream.prototype.destroySoon = function () {\n  this.end()\n}\n\nWriteStream.prototype.add = function (entry) {\n  if (!entry.props)\n    return\n  if (entry.props.Directory)\n    entry.pipe(this._db.writeStream(this._options))\n  else if (entry.props.File || entry.File || entry.type == \'File\')\n    this._write(entry)\n  return true\n}\n\nWriteStream.prototype._processDelayed = function () {\n  var self = this\n  setImmediate(function () {\n    self._process()\n  })\n}\n\nWriteStream.prototype._process = function () {\n  var buffer\n    , self = this\n\n    , cb = function (err) {\n        if (!self.writable)\n          return\n        if (self._status != \'closed\')\n          self._status = \'ready\'\n        if (err) {\n          self.writable = false\n          return self.emit(\'error\', err)\n        }\n        self._process()\n      }\n\n  if (self._status != \'ready\' && self.writable) {\n    if (self._buffer.length && self._status != \'closed\')\n      self._processDelayed()\n    return\n  }\n\n  if (self._buffer.length && self.writable) {\n    self._status = \'writing\'\n    buffer       = self._buffer\n    self._buffer = []\n\n    self._db.batch(buffer.map(function (d) {\n      return {\n          type          : d.type || self._options.type\n        , key           : d.key\n        , value         : d.value\n        , keyEncoding   : d.keyEncoding || self._options.keyEncoding\n        , valueEncoding : d.valueEncoding\n            || d.encoding\n            || self._options.valueEncoding\n      }\n    }), cb)\n\n    if (self._writeBlock) {\n      self._writeBlock = false\n      self.emit(\'drain\')\n    }\n\n    // don\'t allow close until callback has returned\n    return\n  }\n\n  if (self._end && self._status != \'closed\') {\n    self._status  = \'closed\'\n    self.writable = false\n    self.emit(\'close\')\n  }\n}\n\nWriteStream.prototype._write = function (entry) {\n  var key = entry.path || entry.props.path\n    , self = this\n\n  if (!key)\n    return\n\n  entry.pipe(concatStream(function (err, data) {\n    if (err) {\n      self.writable = false\n      return self.emit(\'error\', err)\n    }\n\n    if (self._options.fstreamRoot &&\n        key.indexOf(self._options.fstreamRoot) > -1)\n      key = key.substr(self._options.fstreamRoot.length + 1)\n\n    self.write({ key: key, value: data })\n  }))\n}\n\nWriteStream.prototype.toString = function () {\n  return \'LevelUP.WriteStream\'\n}\n\nmodule.exports = WriteStream\n\n})(require("__browserify_process"))\n},{"./util":19,"__browserify_process":9,"concat-stream":35,"stream":16,"util":11,"xtend":25}],36:[function(require,module,exports){\nexports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {\n  var e, m,\n      eLen = nBytes * 8 - mLen - 1,\n      eMax = (1 << eLen) - 1,\n      eBias = eMax >> 1,\n      nBits = -7,\n      i = isBE ? 0 : (nBytes - 1),\n      d = isBE ? 1 : -1,\n      s = buffer[offset + i];\n\n  i += d;\n\n  e = s & ((1 << (-nBits)) - 1);\n  s >>= (-nBits);\n  nBits += eLen;\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);\n\n  m = e & ((1 << (-nBits)) - 1);\n  e >>= (-nBits);\n  nBits += mLen;\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);\n\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity);\n  } else {\n    m = m + Math.pow(2, mLen);\n    e = e - eBias;\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n};\n\nexports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {\n  var e, m, c,\n      eLen = nBytes * 8 - mLen - 1,\n      eMax = (1 << eLen) - 1,\n      eBias = eMax >> 1,\n      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),\n      i = isBE ? (nBytes - 1) : 0,\n      d = isBE ? -1 : 1,\n      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;\n\n  value = Math.abs(value);\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0;\n    e = eMax;\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2);\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * Math.pow(2, 1 - eBias);\n    }\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n      e = 0;\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);\n\n  e = (e << mLen) | m;\n  eLen += mLen;\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);\n\n  buffer[offset + i - d] |= s * 128;\n};\n\n},{}],17:[function(require,module,exports){\n(function(){var assert = require(\'assert\');\nexports.Buffer = Buffer;\nexports.SlowBuffer = Buffer;\nBuffer.poolSize = 8192;\nexports.INSPECT_MAX_BYTES = 50;\n\nfunction Buffer(subject, encoding, offset) {\n  if (!(this instanceof Buffer)) {\n    return new Buffer(subject, encoding, offset);\n  }\n  this.parent = this;\n  this.offset = 0;\n\n  var type;\n\n  // Are we slicing?\n  if (typeof offset === \'number\') {\n    this.length = coerce(encoding);\n    this.offset = offset;\n  } else {\n    // Find the length\n    switch (type = typeof subject) {\n      case \'number\':\n        this.length = coerce(subject);\n        break;\n\n      case \'string\':\n        this.length = Buffer.byteLength(subject, encoding);\n        break;\n\n      case \'object\': // Assume object is an array\n        this.length = coerce(subject.length);\n        break;\n\n      default:\n        throw new Error(\'First argument needs to be a number, \' +\n                        \'array or string.\');\n    }\n\n    // Treat array-ish objects as a byte array.\n    if (isArrayIsh(subject)) {\n      for (var i = 0; i < this.length; i++) {\n        if (subject instanceof Buffer) {\n          this[i] = subject.readUInt8(i);\n        }\n        else {\n          this[i] = subject[i];\n        }\n      }\n    } else if (type == \'string\') {\n      // We are a string\n      this.length = this.write(subject, 0, encoding);\n    } else if (type === \'number\') {\n      for (var i = 0; i < this.length; i++) {\n        this[i] = 0;\n      }\n    }\n  }\n}\n\nBuffer.prototype.get = function get(i) {\n  if (i < 0 || i >= this.length) throw new Error(\'oob\');\n  return this[i];\n};\n\nBuffer.prototype.set = function set(i, v) {\n  if (i < 0 || i >= this.length) throw new Error(\'oob\');\n  return this[i] = v;\n};\n\nBuffer.byteLength = function (str, encoding) {\n  switch (encoding || "utf8") {\n    case \'hex\':\n      return str.length / 2;\n\n    case \'utf8\':\n    case \'utf-8\':\n      return utf8ToBytes(str).length;\n\n    case \'ascii\':\n    case \'binary\':\n      return str.length;\n\n    case \'base64\':\n      return base64ToBytes(str).length;\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n};\n\nBuffer.prototype.utf8Write = function (string, offset, length) {\n  var bytes, pos;\n  return Buffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);\n};\n\nBuffer.prototype.asciiWrite = function (string, offset, length) {\n  var bytes, pos;\n  return Buffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);\n};\n\nBuffer.prototype.binaryWrite = Buffer.prototype.asciiWrite;\n\nBuffer.prototype.base64Write = function (string, offset, length) {\n  var bytes, pos;\n  return Buffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);\n};\n\nBuffer.prototype.base64Slice = function (start, end) {\n  var bytes = Array.prototype.slice.apply(this, arguments)\n  return require("base64-js").fromByteArray(bytes);\n};\n\nBuffer.prototype.utf8Slice = function () {\n  var bytes = Array.prototype.slice.apply(this, arguments);\n  var res = "";\n  var tmp = "";\n  var i = 0;\n  while (i < bytes.length) {\n    if (bytes[i] <= 0x7F) {\n      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);\n      tmp = "";\n    } else\n      tmp += "%" + bytes[i].toString(16);\n\n    i++;\n  }\n\n  return res + decodeUtf8Char(tmp);\n}\n\nBuffer.prototype.asciiSlice = function () {\n  var bytes = Array.prototype.slice.apply(this, arguments);\n  var ret = "";\n  for (var i = 0; i < bytes.length; i++)\n    ret += String.fromCharCode(bytes[i]);\n  return ret;\n}\n\nBuffer.prototype.binarySlice = Buffer.prototype.asciiSlice;\n\nBuffer.prototype.inspect = function() {\n  var out = [],\n      len = this.length;\n  for (var i = 0; i < len; i++) {\n    out[i] = toHex(this[i]);\n    if (i == exports.INSPECT_MAX_BYTES) {\n      out[i + 1] = \'...\';\n      break;\n    }\n  }\n  return \'<Buffer \' + out.join(\' \') + \'>\';\n};\n\n\nBuffer.prototype.hexSlice = function(start, end) {\n  var len = this.length;\n\n  if (!start || start < 0) start = 0;\n  if (!end || end < 0 || end > len) end = len;\n\n  var out = \'\';\n  for (var i = start; i < end; i++) {\n    out += toHex(this[i]);\n  }\n  return out;\n};\n\n\nBuffer.prototype.toString = function(encoding, start, end) {\n  encoding = String(encoding || \'utf8\').toLowerCase();\n  start = +start || 0;\n  if (typeof end == \'undefined\') end = this.length;\n\n  // Fastpath empty strings\n  if (+end == start) {\n    return \'\';\n  }\n\n  switch (encoding) {\n    case \'hex\':\n      return this.hexSlice(start, end);\n\n    case \'utf8\':\n    case \'utf-8\':\n      return this.utf8Slice(start, end);\n\n    case \'ascii\':\n      return this.asciiSlice(start, end);\n\n    case \'binary\':\n      return this.binarySlice(start, end);\n\n    case \'base64\':\n      return this.base64Slice(start, end);\n\n    case \'ucs2\':\n    case \'ucs-2\':\n      return this.ucs2Slice(start, end);\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n};\n\n\nBuffer.prototype.hexWrite = function(string, offset, length) {\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length;\n  if (strLen % 2) {\n    throw new Error(\'Invalid hex string\');\n  }\n  if (length > strLen / 2) {\n    length = strLen / 2;\n  }\n  for (var i = 0; i < length; i++) {\n    var byte = parseInt(string.substr(i * 2, 2), 16);\n    if (isNaN(byte)) throw new Error(\'Invalid hex string\');\n    this[offset + i] = byte;\n  }\n  Buffer._charsWritten = i * 2;\n  return i;\n};\n\n\nBuffer.prototype.write = function(string, offset, length, encoding) {\n  // Support both (string, offset, length, encoding)\n  // and the legacy (string, encoding, offset, length)\n  if (isFinite(offset)) {\n    if (!isFinite(length)) {\n      encoding = length;\n      length = undefined;\n    }\n  } else {  // legacy\n    var swap = encoding;\n    encoding = offset;\n    offset = length;\n    length = swap;\n  }\n\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n  encoding = String(encoding || \'utf8\').toLowerCase();\n\n  switch (encoding) {\n    case \'hex\':\n      return this.hexWrite(string, offset, length);\n\n    case \'utf8\':\n    case \'utf-8\':\n      return this.utf8Write(string, offset, length);\n\n    case \'ascii\':\n      return this.asciiWrite(string, offset, length);\n\n    case \'binary\':\n      return this.binaryWrite(string, offset, length);\n\n    case \'base64\':\n      return this.base64Write(string, offset, length);\n\n    case \'ucs2\':\n    case \'ucs-2\':\n      return this.ucs2Write(string, offset, length);\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n};\n\n\n// slice(start, end)\nBuffer.prototype.slice = function(start, end) {\n  if (end === undefined) end = this.length;\n\n  if (end > this.length) {\n    throw new Error(\'oob\');\n  }\n  if (start > end) {\n    throw new Error(\'oob\');\n  }\n\n  return new Buffer(this, end - start, +start);\n};\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function(target, target_start, start, end) {\n  var source = this;\n  start || (start = 0);\n  if (end === undefined || isNaN(end)) {\n    end = this.length;\n  }\n  target_start || (target_start = 0);\n\n  if (end < start) throw new Error(\'sourceEnd < sourceStart\');\n\n  // Copy 0 bytes; we\'re done\n  if (end === start) return 0;\n  if (target.length == 0 || source.length == 0) return 0;\n\n  if (target_start < 0 || target_start >= target.length) {\n    throw new Error(\'targetStart out of bounds\');\n  }\n\n  if (start < 0 || start >= source.length) {\n    throw new Error(\'sourceStart out of bounds\');\n  }\n\n  if (end < 0 || end > source.length) {\n    throw new Error(\'sourceEnd out of bounds\');\n  }\n\n  // Are we oob?\n  if (end > this.length) {\n    end = this.length;\n  }\n\n  if (target.length - target_start < end - start) {\n    end = target.length - target_start + start;\n  }\n\n  var temp = [];\n  for (var i=start; i<end; i++) {\n    assert.ok(typeof this[i] !== \'undefined\', "copying undefined buffer bytes!");\n    temp.push(this[i]);\n  }\n\n  for (var i=target_start; i<target_start+temp.length; i++) {\n    target[i] = temp[i-target_start];\n  }\n};\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function fill(value, start, end) {\n  value || (value = 0);\n  start || (start = 0);\n  end || (end = this.length);\n\n  if (typeof value === \'string\') {\n    value = value.charCodeAt(0);\n  }\n  if (!(typeof value === \'number\') || isNaN(value)) {\n    throw new Error(\'value is not a number\');\n  }\n\n  if (end < start) throw new Error(\'end < start\');\n\n  // Fill 0 bytes; we\'re done\n  if (end === start) return 0;\n  if (this.length == 0) return 0;\n\n  if (start < 0 || start >= this.length) {\n    throw new Error(\'start out of bounds\');\n  }\n\n  if (end < 0 || end > this.length) {\n    throw new Error(\'end out of bounds\');\n  }\n\n  for (var i = start; i < end; i++) {\n    this[i] = value;\n  }\n}\n\n// Static methods\nBuffer.isBuffer = function isBuffer(b) {\n  return b instanceof Buffer || b instanceof Buffer;\n};\n\nBuffer.concat = function (list, totalLength) {\n  if (!isArray(list)) {\n    throw new Error("Usage: Buffer.concat(list, [totalLength])\\n \\\n      list should be an Array.");\n  }\n\n  if (list.length === 0) {\n    return new Buffer(0);\n  } else if (list.length === 1) {\n    return list[0];\n  }\n\n  if (typeof totalLength !== \'number\') {\n    totalLength = 0;\n    for (var i = 0; i < list.length; i++) {\n      var buf = list[i];\n      totalLength += buf.length;\n    }\n  }\n\n  var buffer = new Buffer(totalLength);\n  var pos = 0;\n  for (var i = 0; i < list.length; i++) {\n    var buf = list[i];\n    buf.copy(buffer, pos);\n    pos += buf.length;\n  }\n  return buffer;\n};\n\n// helpers\n\nfunction coerce(length) {\n  // Coerce length to a number (possibly NaN), round up\n  // in case it\'s fractional (e.g. 123.456) then do a\n  // double negate to coerce a NaN to 0. Easy, right?\n  length = ~~Math.ceil(+length);\n  return length < 0 ? 0 : length;\n}\n\nfunction isArray(subject) {\n  return (Array.isArray ||\n    function(subject){\n      return {}.toString.apply(subject) == \'[object Array]\'\n    })\n    (subject)\n}\n\nfunction isArrayIsh(subject) {\n  return isArray(subject) || Buffer.isBuffer(subject) ||\n         subject && typeof subject === \'object\' &&\n         typeof subject.length === \'number\';\n}\n\nfunction toHex(n) {\n  if (n < 16) return \'0\' + n.toString(16);\n  return n.toString(16);\n}\n\nfunction utf8ToBytes(str) {\n  var byteArray = [];\n  for (var i = 0; i < str.length; i++)\n    if (str.charCodeAt(i) <= 0x7F)\n      byteArray.push(str.charCodeAt(i));\n    else {\n      var h = encodeURIComponent(str.charAt(i)).substr(1).split(\'%\');\n      for (var j = 0; j < h.length; j++)\n        byteArray.push(parseInt(h[j], 16));\n    }\n\n  return byteArray;\n}\n\nfunction asciiToBytes(str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++ )\n    // Node\'s code seems to be doing this and not & 0x7F..\n    byteArray.push( str.charCodeAt(i) & 0xFF );\n\n  return byteArray;\n}\n\nfunction base64ToBytes(str) {\n  return require("base64-js").toByteArray(str);\n}\n\nfunction blitBuffer(src, dst, offset, length) {\n  var pos, i = 0;\n  while (i < length) {\n    if ((i+offset >= dst.length) || (i >= src.length))\n      break;\n\n    dst[i + offset] = src[i];\n    i++;\n  }\n  return i;\n}\n\nfunction decodeUtf8Char(str) {\n  try {\n    return decodeURIComponent(str);\n  } catch (err) {\n    return String.fromCharCode(0xFFFD); // UTF 8 invalid char\n  }\n}\n\n// read/write bit-twiddling\n\nBuffer.prototype.readUInt8 = function(offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  if (offset >= buffer.length) return;\n\n  return buffer[offset];\n};\n\nfunction readUInt16(buffer, offset, isBigEndian, noAssert) {\n  var val = 0;\n\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 1 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  if (offset >= buffer.length) return 0;\n\n  if (isBigEndian) {\n    val = buffer[offset] << 8;\n    if (offset + 1 < buffer.length) {\n      val |= buffer[offset + 1];\n    }\n  } else {\n    val = buffer[offset];\n    if (offset + 1 < buffer.length) {\n      val |= buffer[offset + 1] << 8;\n    }\n  }\n\n  return val;\n}\n\nBuffer.prototype.readUInt16LE = function(offset, noAssert) {\n  return readUInt16(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readUInt16BE = function(offset, noAssert) {\n  return readUInt16(this, offset, true, noAssert);\n};\n\nfunction readUInt32(buffer, offset, isBigEndian, noAssert) {\n  var val = 0;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  if (offset >= buffer.length) return 0;\n\n  if (isBigEndian) {\n    if (offset + 1 < buffer.length)\n      val = buffer[offset + 1] << 16;\n    if (offset + 2 < buffer.length)\n      val |= buffer[offset + 2] << 8;\n    if (offset + 3 < buffer.length)\n      val |= buffer[offset + 3];\n    val = val + (buffer[offset] << 24 >>> 0);\n  } else {\n    if (offset + 2 < buffer.length)\n      val = buffer[offset + 2] << 16;\n    if (offset + 1 < buffer.length)\n      val |= buffer[offset + 1] << 8;\n    val |= buffer[offset];\n    if (offset + 3 < buffer.length)\n      val = val + (buffer[offset + 3] << 24 >>> 0);\n  }\n\n  return val;\n}\n\nBuffer.prototype.readUInt32LE = function(offset, noAssert) {\n  return readUInt32(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readUInt32BE = function(offset, noAssert) {\n  return readUInt32(this, offset, true, noAssert);\n};\n\n\n/*\n * Signed integer types, yay team! A reminder on how two\'s complement actually\n * works. The first bit is the signed bit, i.e. tells us whether or not the\n * number should be positive or negative. If the two\'s complement value is\n * positive, then we\'re done, as it\'s equivalent to the unsigned representation.\n *\n * Now if the number is positive, you\'re pretty much done, you can just leverage\n * the unsigned translations and return those. Unfortunately, negative numbers\n * aren\'t quite that straightforward.\n *\n * At first glance, one might be inclined to use the traditional formula to\n * translate binary numbers between the positive and negative values in two\'s\n * complement. (Though it doesn\'t quite work for the most negative value)\n * Mainly:\n *  - invert all the bits\n *  - add one to the result\n *\n * Of course, this doesn\'t quite work in Javascript. Take for example the value\n * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of\n * course, Javascript will do the following:\n *\n * > ~0xff80\n * -65409\n *\n * Whoh there, Javascript, that\'s not quite right. But wait, according to\n * Javascript that\'s perfectly correct. When Javascript ends up seeing the\n * constant 0xff80, it has no notion that it is actually a signed number. It\n * assumes that we\'ve input the unsigned value 0xff80. Thus, when it does the\n * binary negation, it casts it into a signed value, (positive 0xff80). Then\n * when you perform binary negation on that, it turns it into a negative number.\n *\n * Instead, we\'re going to have to use the following general formula, that works\n * in a rather Javascript friendly way. I\'m glad we don\'t support this kind of\n * weird numbering scheme in the kernel.\n *\n * (BIT-MAX - (unsigned)val + 1) * -1\n *\n * The astute observer, may think that this doesn\'t make sense for 8-bit numbers\n * (really it isn\'t necessary for them). However, when you get 16-bit numbers,\n * you do. Let\'s go back to our prior example and see how this will look:\n *\n * (0xffff - 0xff80 + 1) * -1\n * (0x007f + 1) * -1\n * (0x0080) * -1\n */\nBuffer.prototype.readInt8 = function(offset, noAssert) {\n  var buffer = this;\n  var neg;\n\n  if (!noAssert) {\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  if (offset >= buffer.length) return;\n\n  neg = buffer[offset] & 0x80;\n  if (!neg) {\n    return (buffer[offset]);\n  }\n\n  return ((0xff - buffer[offset] + 1) * -1);\n};\n\nfunction readInt16(buffer, offset, isBigEndian, noAssert) {\n  var neg, val;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 1 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  val = readUInt16(buffer, offset, isBigEndian, noAssert);\n  neg = val & 0x8000;\n  if (!neg) {\n    return val;\n  }\n\n  return (0xffff - val + 1) * -1;\n}\n\nBuffer.prototype.readInt16LE = function(offset, noAssert) {\n  return readInt16(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readInt16BE = function(offset, noAssert) {\n  return readInt16(this, offset, true, noAssert);\n};\n\nfunction readInt32(buffer, offset, isBigEndian, noAssert) {\n  var neg, val;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  val = readUInt32(buffer, offset, isBigEndian, noAssert);\n  neg = val & 0x80000000;\n  if (!neg) {\n    return (val);\n  }\n\n  return (0xffffffff - val + 1) * -1;\n}\n\nBuffer.prototype.readInt32LE = function(offset, noAssert) {\n  return readInt32(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readInt32BE = function(offset, noAssert) {\n  return readInt32(this, offset, true, noAssert);\n};\n\nfunction readFloat(buffer, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  return require(\'./buffer_ieee754\').readIEEE754(buffer, offset, isBigEndian,\n      23, 4);\n}\n\nBuffer.prototype.readFloatLE = function(offset, noAssert) {\n  return readFloat(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readFloatBE = function(offset, noAssert) {\n  return readFloat(this, offset, true, noAssert);\n};\n\nfunction readDouble(buffer, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset + 7 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  return require(\'./buffer_ieee754\').readIEEE754(buffer, offset, isBigEndian,\n      52, 8);\n}\n\nBuffer.prototype.readDoubleLE = function(offset, noAssert) {\n  return readDouble(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readDoubleBE = function(offset, noAssert) {\n  return readDouble(this, offset, true, noAssert);\n};\n\n\n/*\n * We have to make sure that the value is a valid integer. This means that it is\n * non-negative. It has no fractional component and that it does not exceed the\n * maximum allowed value.\n *\n *      value           The number to check for validity\n *\n *      max             The maximum value\n */\nfunction verifuint(value, max) {\n  assert.ok(typeof (value) == \'number\',\n      \'cannot write a non-number as a number\');\n\n  assert.ok(value >= 0,\n      \'specified a negative value for writing an unsigned value\');\n\n  assert.ok(value <= max, \'value is larger than maximum value for type\');\n\n  assert.ok(Math.floor(value) === value, \'value has a fractional component\');\n}\n\nBuffer.prototype.writeUInt8 = function(value, offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset < buffer.length,\n        \'trying to write beyond buffer length\');\n\n    verifuint(value, 0xff);\n  }\n\n  if (offset < buffer.length) {\n    buffer[offset] = value;\n  }\n};\n\nfunction writeUInt16(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 1 < buffer.length,\n        \'trying to write beyond buffer length\');\n\n    verifuint(value, 0xffff);\n  }\n\n  for (var i = 0; i < Math.min(buffer.length - offset, 2); i++) {\n    buffer[offset + i] =\n        (value & (0xff << (8 * (isBigEndian ? 1 - i : i)))) >>>\n            (isBigEndian ? 1 - i : i) * 8;\n  }\n\n}\n\nBuffer.prototype.writeUInt16LE = function(value, offset, noAssert) {\n  writeUInt16(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeUInt16BE = function(value, offset, noAssert) {\n  writeUInt16(this, value, offset, true, noAssert);\n};\n\nfunction writeUInt32(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'trying to write beyond buffer length\');\n\n    verifuint(value, 0xffffffff);\n  }\n\n  for (var i = 0; i < Math.min(buffer.length - offset, 4); i++) {\n    buffer[offset + i] =\n        (value >>> (isBigEndian ? 3 - i : i) * 8) & 0xff;\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function(value, offset, noAssert) {\n  writeUInt32(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeUInt32BE = function(value, offset, noAssert) {\n  writeUInt32(this, value, offset, true, noAssert);\n};\n\n\n/*\n * We now move onto our friends in the signed number category. Unlike unsigned\n * numbers, we\'re going to have to worry a bit more about how we put values into\n * arrays. Since we are only worrying about signed 32-bit values, we\'re in\n * slightly better shape. Unfortunately, we really can\'t do our favorite binary\n * & in this system. It really seems to do the wrong thing. For example:\n *\n * > -32 & 0xff\n * 224\n *\n * What\'s happening above is really: 0xe0 & 0xff = 0xe0. However, the results of\n * this aren\'t treated as a signed number. Ultimately a bad thing.\n *\n * What we\'re going to want to do is basically create the unsigned equivalent of\n * our representation and pass that off to the wuint* functions. To do that\n * we\'re going to do the following:\n *\n *  - if the value is positive\n *      we can pass it directly off to the equivalent wuint\n *  - if the value is negative\n *      we do the following computation:\n *         mb + val + 1, where\n *         mb   is the maximum unsigned value in that byte size\n *         val  is the Javascript negative integer\n *\n *\n * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If\n * you do out the computations:\n *\n * 0xffff - 128 + 1\n * 0xffff - 127\n * 0xff80\n *\n * You can then encode this value as the signed version. This is really rather\n * hacky, but it should work and get the job done which is our goal here.\n */\n\n/*\n * A series of checks to make sure we actually have a signed 32-bit number\n */\nfunction verifsint(value, max, min) {\n  assert.ok(typeof (value) == \'number\',\n      \'cannot write a non-number as a number\');\n\n  assert.ok(value <= max, \'value larger than maximum allowed value\');\n\n  assert.ok(value >= min, \'value smaller than minimum allowed value\');\n\n  assert.ok(Math.floor(value) === value, \'value has a fractional component\');\n}\n\nfunction verifIEEE754(value, max, min) {\n  assert.ok(typeof (value) == \'number\',\n      \'cannot write a non-number as a number\');\n\n  assert.ok(value <= max, \'value larger than maximum allowed value\');\n\n  assert.ok(value >= min, \'value smaller than minimum allowed value\');\n}\n\nBuffer.prototype.writeInt8 = function(value, offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifsint(value, 0x7f, -0x80);\n  }\n\n  if (value >= 0) {\n    buffer.writeUInt8(value, offset, noAssert);\n  } else {\n    buffer.writeUInt8(0xff + value + 1, offset, noAssert);\n  }\n};\n\nfunction writeInt16(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 1 < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifsint(value, 0x7fff, -0x8000);\n  }\n\n  if (value >= 0) {\n    writeUInt16(buffer, value, offset, isBigEndian, noAssert);\n  } else {\n    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);\n  }\n}\n\nBuffer.prototype.writeInt16LE = function(value, offset, noAssert) {\n  writeInt16(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeInt16BE = function(value, offset, noAssert) {\n  writeInt16(this, value, offset, true, noAssert);\n};\n\nfunction writeInt32(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifsint(value, 0x7fffffff, -0x80000000);\n  }\n\n  if (value >= 0) {\n    writeUInt32(buffer, value, offset, isBigEndian, noAssert);\n  } else {\n    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);\n  }\n}\n\nBuffer.prototype.writeInt32LE = function(value, offset, noAssert) {\n  writeInt32(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeInt32BE = function(value, offset, noAssert) {\n  writeInt32(this, value, offset, true, noAssert);\n};\n\nfunction writeFloat(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);\n  }\n\n  require(\'./buffer_ieee754\').writeIEEE754(buffer, value, offset, isBigEndian,\n      23, 4);\n}\n\nBuffer.prototype.writeFloatLE = function(value, offset, noAssert) {\n  writeFloat(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeFloatBE = function(value, offset, noAssert) {\n  writeFloat(this, value, offset, true, noAssert);\n};\n\nfunction writeDouble(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 7 < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);\n  }\n\n  require(\'./buffer_ieee754\').writeIEEE754(buffer, value, offset, isBigEndian,\n      52, 8);\n}\n\nBuffer.prototype.writeDoubleLE = function(value, offset, noAssert) {\n  writeDouble(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeDoubleBE = function(value, offset, noAssert) {\n  writeDouble(this, value, offset, true, noAssert);\n};\n\n})()\n},{"./buffer_ieee754":36,"assert":28,"base64-js":37}],38:[function(require,module,exports){\nmodule.exports = hasKeys\n\nfunction hasKeys(source) {\n    return source !== null &&\n        (typeof source === "object" ||\n        typeof source === "function")\n}\n\n},{}],24:[function(require,module,exports){\n(function(process){var util              = require(\'util\')\n  , bops              = require(\'bops\')\n  , AbstractLevelDOWN = require(\'abstract-leveldown\').AbstractLevelDOWN\n\nfunction DeferredLevelDOWN (location) {\n  AbstractLevelDOWN.call(this, typeof location == \'string\' ? location : \'\') // optional location, who cares?\n  this._db         = undefined\n  this._operations = []\n}\n\nutil.inherits(DeferredLevelDOWN, AbstractLevelDOWN)\n\n// called by LevelUP when we have a real DB to take its place\nDeferredLevelDOWN.prototype.setDb = function (db) {\n  this._db = db\n  this._operations.forEach(function (op) {\n    db[op.method].apply(db, op.args)\n  })\n}\n\nDeferredLevelDOWN.prototype._open = function (options, callback) {\n  return process.nextTick(callback)\n}\n\n// queue a new deferred operation\nDeferredLevelDOWN.prototype._operation = function (method, args) {\n  if (this._db)\n    return this._db[method].apply(this._db, args)\n  this._operations.push({ method: method, args: args })\n}\n\n// deferrables\n\'put get del batch approximateSize\'.split(\' \').forEach(function (m) {\n  DeferredLevelDOWN.prototype[\'_\' + m] = function () {\n    this._operation(m, arguments)\n  }\n})\n\nDeferredLevelDOWN.prototype._isBuffer = function (obj) {\n  return bops.is(obj)\n}\n\n// don\'t need to implement this as LevelUP\'s ReadStream checks for \'ready\' state\nDeferredLevelDOWN.prototype._iterator = function () {\n  throw new TypeError(\'not implemented\')\n}\n\nmodule.exports = DeferredLevelDOWN\n})(require("__browserify_process"))\n},{"__browserify_process":9,"abstract-leveldown":39,"bops":40,"util":11}],35:[function(require,module,exports){\n(function(Buffer){var stream = require(\'stream\')\nvar util = require(\'util\')\n\nfunction ConcatStream(cb) {\n  stream.Stream.call(this)\n  this.writable = true\n  if (cb) this.cb = cb\n  this.body = []\n  this.on(\'error\', function(err) {\n    if (this.cb) this.cb(err)\n  })\n}\n\nutil.inherits(ConcatStream, stream.Stream)\n\nConcatStream.prototype.write = function(chunk) {\n  this.body.push(chunk)\n}\n\nConcatStream.prototype.destroy = function() {}\n\nConcatStream.prototype.arrayConcat = function(arrs) {\n  if (arrs.length === 0) return []\n  if (arrs.length === 1) return arrs[0]\n  return arrs.reduce(function (a, b) { return a.concat(b) })\n}\n\nConcatStream.prototype.isArray = function(arr) {\n  return Array.isArray(arr)\n}\n\nConcatStream.prototype.getBody = function () {\n  if (this.body.length === 0) return\n  if (typeof(this.body[0]) === "string") return this.body.join(\'\')\n  if (this.isArray(this.body[0])) return this.arrayConcat(this.body)\n  if (typeof(Buffer) !== "undefined" && Buffer.isBuffer(this.body[0])) {\n    return Buffer.concat(this.body)\n  }\n  return this.body\n}\n\nConcatStream.prototype.end = function() {\n  if (this.cb) this.cb(false, this.getBody())\n}\n\nmodule.exports = function(cb) {\n  return new ConcatStream(cb)\n}\n\nmodule.exports.ConcatStream = ConcatStream\n\n})(require("__browserify_buffer").Buffer)\n},{"__browserify_buffer":8,"stream":16,"util":11}],25:[function(require,module,exports){\nvar Keys = require("object-keys")\nvar hasKeys = require("./has-keys")\n\nmodule.exports = extend\n\nfunction extend() {\n    var target = {}\n\n    for (var i = 0; i < arguments.length; i++) {\n        var source = arguments[i]\n\n        if (!hasKeys(source)) {\n            continue\n        }\n\n        var keys = Keys(source)\n\n        for (var j = 0; j < keys.length; j++) {\n            var name = keys[j]\n            target[name] = source[name]\n        }\n    }\n\n    return target\n}\n\n},{"./has-keys":38,"object-keys":41}],37:[function(require,module,exports){\n(function (exports) {\n\t\'use strict\';\n\n\tvar lookup = \'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\';\n\n\tfunction b64ToByteArray(b64) {\n\t\tvar i, j, l, tmp, placeHolders, arr;\n\t\n\t\tif (b64.length % 4 > 0) {\n\t\t\tthrow \'Invalid string. Length must be a multiple of 4\';\n\t\t}\n\n\t\t// the number of equal signs (place holders)\n\t\t// if there are two placeholders, than the two characters before it\n\t\t// represent one byte\n\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t// this is just a cheap hack to not do indexOf twice\n\t\tplaceHolders = b64.indexOf(\'=\');\n\t\tplaceHolders = placeHolders > 0 ? b64.length - placeHolders : 0;\n\n\t\t// base64 is 4/3 + up to two characters of the original data\n\t\tarr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);\n\n\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length;\n\n\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);\n\t\t\tarr.push((tmp & 0xFF0000) >> 16);\n\t\t\tarr.push((tmp & 0xFF00) >> 8);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t}\n\n\t\tif (placeHolders === 2) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t} else if (placeHolders === 1) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);\n\t\t\tarr.push((tmp >> 8) & 0xFF);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t}\n\n\t\treturn arr;\n\t}\n\n\tfunction uint8ToBase64(uint8) {\n\t\tvar i,\n\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\toutput = "",\n\t\t\ttemp, length;\n\n\t\tfunction tripletToBase64 (num) {\n\t\t\treturn lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n\t\t};\n\n\t\t// go through the array every three bytes, we\'ll deal with trailing stuff later\n\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);\n\t\t\toutput += tripletToBase64(temp);\n\t\t}\n\n\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\tswitch (extraBytes) {\n\t\t\tcase 1:\n\t\t\t\ttemp = uint8[uint8.length - 1];\n\t\t\t\toutput += lookup[temp >> 2];\n\t\t\t\toutput += lookup[(temp << 4) & 0x3F];\n\t\t\t\toutput += \'==\';\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);\n\t\t\t\toutput += lookup[temp >> 10];\n\t\t\t\toutput += lookup[(temp >> 4) & 0x3F];\n\t\t\t\toutput += lookup[(temp << 2) & 0x3F];\n\t\t\t\toutput += \'=\';\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn output;\n\t}\n\n\tmodule.exports.toByteArray = b64ToByteArray;\n\tmodule.exports.fromByteArray = uint8ToBase64;\n}());\n\n},{}],33:[function(require,module,exports){\nexports = module.exports = require(\'./lib/_stream_readable.js\');\nexports.Readable = exports;\nexports.Writable = require(\'./lib/_stream_writable.js\');\nexports.Duplex = require(\'./lib/_stream_duplex.js\');\nexports.Transform = require(\'./lib/_stream_transform.js\');\nexports.PassThrough = require(\'./lib/_stream_passthrough.js\');\n\n},{"./lib/_stream_duplex.js":44,"./lib/_stream_passthrough.js":46,"./lib/_stream_readable.js":42,"./lib/_stream_transform.js":45,"./lib/_stream_writable.js":43}],34:[function(require,module,exports){\nvar proto = {}\nmodule.exports = proto\n\nproto.from = require(\'./from.js\')\nproto.to = require(\'./to.js\')\nproto.is = require(\'./is.js\')\nproto.subarray = require(\'./subarray.js\')\nproto.join = require(\'./join.js\')\nproto.copy = require(\'./copy.js\')\nproto.create = require(\'./create.js\')\n\nmix(require(\'./read.js\'), proto)\nmix(require(\'./write.js\'), proto)\n\nfunction mix(from, into) {\n  for(var key in from) {\n    into[key] = from[key]\n  }\n}\n\n},{"./copy.js":52,"./create.js":53,"./from.js":48,"./is.js":49,"./join.js":51,"./read.js":54,"./subarray.js":50,"./to.js":47,"./write.js":55}],31:[function(require,module,exports){\n(function(){var all = module.exports.all = [\n {\n  "errno": -1,\n  "code": "UNKNOWN",\n  "description": "unknown error"\n },\n {\n  "errno": 0,\n  "code": "OK",\n  "description": "success"\n },\n {\n  "errno": 1,\n  "code": "EOF",\n  "description": "end of file"\n },\n {\n  "errno": 2,\n  "code": "EADDRINFO",\n  "description": "getaddrinfo error"\n },\n {\n  "errno": 3,\n  "code": "EACCES",\n  "description": "permission denied"\n },\n {\n  "errno": 4,\n  "code": "EAGAIN",\n  "description": "resource temporarily unavailable"\n },\n {\n  "errno": 5,\n  "code": "EADDRINUSE",\n  "description": "address already in use"\n },\n {\n  "errno": 6,\n  "code": "EADDRNOTAVAIL",\n  "description": "address not available"\n },\n {\n  "errno": 7,\n  "code": "EAFNOSUPPORT",\n  "description": "address family not supported"\n },\n {\n  "errno": 8,\n  "code": "EALREADY",\n  "description": "connection already in progress"\n },\n {\n  "errno": 9,\n  "code": "EBADF",\n  "description": "bad file descriptor"\n },\n {\n  "errno": 10,\n  "code": "EBUSY",\n  "description": "resource busy or locked"\n },\n {\n  "errno": 11,\n  "code": "ECONNABORTED",\n  "description": "software caused connection abort"\n },\n {\n  "errno": 12,\n  "code": "ECONNREFUSED",\n  "description": "connection refused"\n },\n {\n  "errno": 13,\n  "code": "ECONNRESET",\n  "description": "connection reset by peer"\n },\n {\n  "errno": 14,\n  "code": "EDESTADDRREQ",\n  "description": "destination address required"\n },\n {\n  "errno": 15,\n  "code": "EFAULT",\n  "description": "bad address in system call argument"\n },\n {\n  "errno": 16,\n  "code": "EHOSTUNREACH",\n  "description": "host is unreachable"\n },\n {\n  "errno": 17,\n  "code": "EINTR",\n  "description": "interrupted system call"\n },\n {\n  "errno": 18,\n  "code": "EINVAL",\n  "description": "invalid argument"\n },\n {\n  "errno": 19,\n  "code": "EISCONN",\n  "description": "socket is already connected"\n },\n {\n  "errno": 20,\n  "code": "EMFILE",\n  "description": "too many open files"\n },\n {\n  "errno": 21,\n  "code": "EMSGSIZE",\n  "description": "message too long"\n },\n {\n  "errno": 22,\n  "code": "ENETDOWN",\n  "description": "network is down"\n },\n {\n  "errno": 23,\n  "code": "ENETUNREACH",\n  "description": "network is unreachable"\n },\n {\n  "errno": 24,\n  "code": "ENFILE",\n  "description": "file table overflow"\n },\n {\n  "errno": 25,\n  "code": "ENOBUFS",\n  "description": "no buffer space available"\n },\n {\n  "errno": 26,\n  "code": "ENOMEM",\n  "description": "not enough memory"\n },\n {\n  "errno": 27,\n  "code": "ENOTDIR",\n  "description": "not a directory"\n },\n {\n  "errno": 28,\n  "code": "EISDIR",\n  "description": "illegal operation on a directory"\n },\n {\n  "errno": 29,\n  "code": "ENONET",\n  "description": "machine is not on the network"\n },\n {\n  "errno": 31,\n  "code": "ENOTCONN",\n  "description": "socket is not connected"\n },\n {\n  "errno": 32,\n  "code": "ENOTSOCK",\n  "description": "socket operation on non-socket"\n },\n {\n  "errno": 33,\n  "code": "ENOTSUP",\n  "description": "operation not supported on socket"\n },\n {\n  "errno": 34,\n  "code": "ENOENT",\n  "description": "no such file or directory"\n },\n {\n  "errno": 35,\n  "code": "ENOSYS",\n  "description": "function not implemented"\n },\n {\n  "errno": 36,\n  "code": "EPIPE",\n  "description": "broken pipe"\n },\n {\n  "errno": 37,\n  "code": "EPROTO",\n  "description": "protocol error"\n },\n {\n  "errno": 38,\n  "code": "EPROTONOSUPPORT",\n  "description": "protocol not supported"\n },\n {\n  "errno": 39,\n  "code": "EPROTOTYPE",\n  "description": "protocol wrong type for socket"\n },\n {\n  "errno": 40,\n  "code": "ETIMEDOUT",\n  "description": "connection timed out"\n },\n {\n  "errno": 41,\n  "code": "ECHARSET",\n  "description": "invalid Unicode character"\n },\n {\n  "errno": 42,\n  "code": "EAIFAMNOSUPPORT",\n  "description": "address family for hostname not supported"\n },\n {\n  "errno": 44,\n  "code": "EAISERVICE",\n  "description": "servname not supported for ai_socktype"\n },\n {\n  "errno": 45,\n  "code": "EAISOCKTYPE",\n  "description": "ai_socktype not supported"\n },\n {\n  "errno": 46,\n  "code": "ESHUTDOWN",\n  "description": "cannot send after transport endpoint shutdown"\n },\n {\n  "errno": 47,\n  "code": "EEXIST",\n  "description": "file already exists"\n },\n {\n  "errno": 48,\n  "code": "ESRCH",\n  "description": "no such process"\n },\n {\n  "errno": 49,\n  "code": "ENAMETOOLONG",\n  "description": "name too long"\n },\n {\n  "errno": 50,\n  "code": "EPERM",\n  "description": "operation not permitted"\n },\n {\n  "errno": 51,\n  "code": "ELOOP",\n  "description": "too many symbolic links encountered"\n },\n {\n  "errno": 52,\n  "code": "EXDEV",\n  "description": "cross-device link not permitted"\n },\n {\n  "errno": 53,\n  "code": "ENOTEMPTY",\n  "description": "directory not empty"\n },\n {\n  "errno": 54,\n  "code": "ENOSPC",\n  "description": "no space left on device"\n },\n {\n  "errno": 55,\n  "code": "EIO",\n  "description": "i/o error"\n },\n {\n  "errno": 56,\n  "code": "EROFS",\n  "description": "read-only file system"\n },\n {\n  "errno": 57,\n  "code": "ENODEV",\n  "description": "no such device"\n },\n {\n  "errno": 58,\n  "code": "ESPIPE",\n  "description": "invalid seek"\n },\n {\n  "errno": 59,\n  "code": "ECANCELED",\n  "description": "operation canceled"\n }\n]\n\n\nmodule.exports.errno = {\n    \'-1\': all[0]\n  , \'0\': all[1]\n  , \'1\': all[2]\n  , \'2\': all[3]\n  , \'3\': all[4]\n  , \'4\': all[5]\n  , \'5\': all[6]\n  , \'6\': all[7]\n  , \'7\': all[8]\n  , \'8\': all[9]\n  , \'9\': all[10]\n  , \'10\': all[11]\n  , \'11\': all[12]\n  , \'12\': all[13]\n  , \'13\': all[14]\n  , \'14\': all[15]\n  , \'15\': all[16]\n  , \'16\': all[17]\n  , \'17\': all[18]\n  , \'18\': all[19]\n  , \'19\': all[20]\n  , \'20\': all[21]\n  , \'21\': all[22]\n  , \'22\': all[23]\n  , \'23\': all[24]\n  , \'24\': all[25]\n  , \'25\': all[26]\n  , \'26\': all[27]\n  , \'27\': all[28]\n  , \'28\': all[29]\n  , \'29\': all[30]\n  , \'31\': all[31]\n  , \'32\': all[32]\n  , \'33\': all[33]\n  , \'34\': all[34]\n  , \'35\': all[35]\n  , \'36\': all[36]\n  , \'37\': all[37]\n  , \'38\': all[38]\n  , \'39\': all[39]\n  , \'40\': all[40]\n  , \'41\': all[41]\n  , \'42\': all[42]\n  , \'44\': all[43]\n  , \'45\': all[44]\n  , \'46\': all[45]\n  , \'47\': all[46]\n  , \'48\': all[47]\n  , \'49\': all[48]\n  , \'50\': all[49]\n  , \'51\': all[50]\n  , \'52\': all[51]\n  , \'53\': all[52]\n  , \'54\': all[53]\n  , \'55\': all[54]\n  , \'56\': all[55]\n  , \'57\': all[56]\n  , \'58\': all[57]\n  , \'59\': all[58]\n}\n\n\nmodule.exports.code = {\n    \'UNKNOWN\': all[0]\n  , \'OK\': all[1]\n  , \'EOF\': all[2]\n  , \'EADDRINFO\': all[3]\n  , \'EACCES\': all[4]\n  , \'EAGAIN\': all[5]\n  , \'EADDRINUSE\': all[6]\n  , \'EADDRNOTAVAIL\': all[7]\n  , \'EAFNOSUPPORT\': all[8]\n  , \'EALREADY\': all[9]\n  , \'EBADF\': all[10]\n  , \'EBUSY\': all[11]\n  , \'ECONNABORTED\': all[12]\n  , \'ECONNREFUSED\': all[13]\n  , \'ECONNRESET\': all[14]\n  , \'EDESTADDRREQ\': all[15]\n  , \'EFAULT\': all[16]\n  , \'EHOSTUNREACH\': all[17]\n  , \'EINTR\': all[18]\n  , \'EINVAL\': all[19]\n  , \'EISCONN\': all[20]\n  , \'EMFILE\': all[21]\n  , \'EMSGSIZE\': all[22]\n  , \'ENETDOWN\': all[23]\n  , \'ENETUNREACH\': all[24]\n  , \'ENFILE\': all[25]\n  , \'ENOBUFS\': all[26]\n  , \'ENOMEM\': all[27]\n  , \'ENOTDIR\': all[28]\n  , \'EISDIR\': all[29]\n  , \'ENONET\': all[30]\n  , \'ENOTCONN\': all[31]\n  , \'ENOTSOCK\': all[32]\n  , \'ENOTSUP\': all[33]\n  , \'ENOENT\': all[34]\n  , \'ENOSYS\': all[35]\n  , \'EPIPE\': all[36]\n  , \'EPROTO\': all[37]\n  , \'EPROTONOSUPPORT\': all[38]\n  , \'EPROTOTYPE\': all[39]\n  , \'ETIMEDOUT\': all[40]\n  , \'ECHARSET\': all[41]\n  , \'EAIFAMNOSUPPORT\': all[42]\n  , \'EAISERVICE\': all[43]\n  , \'EAISOCKTYPE\': all[44]\n  , \'ESHUTDOWN\': all[45]\n  , \'EEXIST\': all[46]\n  , \'ESRCH\': all[47]\n  , \'ENAMETOOLONG\': all[48]\n  , \'EPERM\': all[49]\n  , \'ELOOP\': all[50]\n  , \'EXDEV\': all[51]\n  , \'ENOTEMPTY\': all[52]\n  , \'ENOSPC\': all[53]\n  , \'EIO\': all[54]\n  , \'EROFS\': all[55]\n  , \'ENODEV\': all[56]\n  , \'ESPIPE\': all[57]\n  , \'ECANCELED\': all[58]\n}\n\n\nmodule.exports.custom = require("./custom")(module.exports)\nmodule.exports.create = module.exports.custom.createError\n})()\n},{"./custom":56}],49:[function(require,module,exports){\n\nmodule.exports = function(buffer) {\n  return buffer instanceof Uint8Array;\n}\n\n},{}],50:[function(require,module,exports){\nmodule.exports = subarray\n\nfunction subarray(buf, from, to) {\n  return buf.subarray(from || 0, to || buf.length)\n}\n\n},{}],51:[function(require,module,exports){\nmodule.exports = join\n\nfunction join(targets, hint) {\n  if(!targets.length) {\n    return new Uint8Array(0)\n  }\n\n  var len = hint !== undefined ? hint : get_length(targets)\n    , out = new Uint8Array(len)\n    , cur = targets[0]\n    , curlen = cur.length\n    , curidx = 0\n    , curoff = 0\n    , i = 0\n\n  while(i < len) {\n    if(curoff === curlen) {\n      curoff = 0\n      ++curidx\n      cur = targets[curidx]\n      curlen = cur && cur.length\n      continue\n    }\n    out[i++] = cur[curoff++] \n  }\n\n  return out\n}\n\nfunction get_length(targets) {\n  var size = 0\n  for(var i = 0, len = targets.length; i < len; ++i) {\n    size += targets[i].byteLength\n  }\n  return size\n}\n\n},{}],52:[function(require,module,exports){\nmodule.exports = copy\n\nvar slice = [].slice\n\nfunction copy(source, target, target_start, source_start, source_end) {\n  target_start = arguments.length < 3 ? 0 : target_start\n  source_start = arguments.length < 4 ? 0 : source_start\n  source_end = arguments.length < 5 ? source.length : source_end\n\n  if(source_end === source_start) {\n    return\n  }\n\n  if(target.length === 0 || source.length === 0) {\n    return\n  }\n\n  if(source_end > source.length) {\n    source_end = source.length\n  }\n\n  if(target.length - target_start < source_end - source_start) {\n    source_end = target.length - target_start + source_start\n  }\n\n  if(source.buffer !== target.buffer) {\n    return fast_copy(source, target, target_start, source_start, source_end)\n  }\n  return slow_copy(source, target, target_start, source_start, source_end)\n}\n\nfunction fast_copy(source, target, target_start, source_start, source_end) {\n  var len = (source_end - source_start) + target_start\n\n  for(var i = target_start, j = source_start;\n      i < len;\n      ++i,\n      ++j) {\n    target[i] = source[j]\n  }\n}\n\nfunction slow_copy(from, to, j, i, jend) {\n  // the buffers could overlap.\n  var iend = jend + i\n    , tmp = new Uint8Array(slice.call(from, i, iend))\n    , x = 0\n\n  for(; i < iend; ++i, ++x) {\n    to[j++] = tmp[x]\n  }\n}\n\n},{}],53:[function(require,module,exports){\nmodule.exports = function(size) {\n  return new Uint8Array(size)\n}\n\n},{}],40:[function(require,module,exports){\nvar proto = {}\nmodule.exports = proto\n\nproto.from = require(\'./from.js\')\nproto.to = require(\'./to.js\')\nproto.is = require(\'./is.js\')\nproto.subarray = require(\'./subarray.js\')\nproto.join = require(\'./join.js\')\nproto.copy = require(\'./copy.js\')\nproto.create = require(\'./create.js\')\n\nmix(require(\'./read.js\'), proto)\nmix(require(\'./write.js\'), proto)\n\nfunction mix(from, into) {\n  for(var key in from) {\n    into[key] = from[key]\n  }\n}\n\n},{"./copy.js":62,"./create.js":63,"./from.js":57,"./is.js":59,"./join.js":61,"./read.js":64,"./subarray.js":60,"./to.js":58,"./write.js":65}],66:[function(require,module,exports){\nmodule.exports = hasKeys\n\nfunction hasKeys(source) {\n    return source !== null &&\n        (typeof source === "object" ||\n        typeof source === "function")\n}\n\n},{}],39:[function(require,module,exports){\n(function(process,Buffer){/* Copyright (c) 2013 Rod Vagg, MIT License */\n\nvar AbstractIterator     = require(\'./abstract-iterator\')\n  , AbstractChainedBatch = require(\'./abstract-chained-batch\')\n\nfunction AbstractLevelDOWN (location) {\n  if (!arguments.length || location === undefined)\n    throw new Error(\'constructor requires at least a location argument\')\n\n  if (typeof location != \'string\')\n    throw new Error(\'constructor requires a location string argument\')\n\n  this.location = location\n}\n\nAbstractLevelDOWN.prototype.open = function (options, callback) {\n  if (typeof options == \'function\')\n    callback = options\n  if (typeof callback != \'function\')\n    throw new Error(\'open() requires a callback argument\')\n  if (typeof options != \'object\')\n    options = {}\n\n  if (typeof this._open == \'function\')\n    return this._open(options, callback)\n\n  process.nextTick(callback)\n}\n\nAbstractLevelDOWN.prototype.close = function (callback) {\n  if (typeof callback != \'function\')\n    throw new Error(\'close() requires a callback argument\')\n\n  if (typeof this._close == \'function\')\n    return this._close(callback)\n\n  process.nextTick(callback)\n}\n\nAbstractLevelDOWN.prototype.get = function (key, options, callback) {\n  var self = this\n  if (typeof options == \'function\')\n    callback = options\n  if (typeof callback != \'function\')\n    throw new Error(\'get() requires a callback argument\')\n  var err = self._checkKeyValue(key, \'key\', self._isBuffer)\n  if (err) return callback(err)\n  if (!self._isBuffer(key)) key = String(key)\n  if (typeof options != \'object\')\n    options = {}\n\n  if (typeof self._get == \'function\')\n    return self._get(key, options, callback)\n\n  process.nextTick(function () { callback(new Error(\'NotFound\')) })\n}\n\nAbstractLevelDOWN.prototype.put = function (key, value, options, callback) {\n  if (typeof options == \'function\')\n    callback = options\n  if (typeof callback != \'function\')\n    throw new Error(\'put() requires a callback argument\')\n  var err = this._checkKeyValue(key, \'key\', this._isBuffer)\n  if (err) return callback(err)\n  err = this._checkKeyValue(value, \'value\', this._isBuffer)\n  if (err) return callback(err)\n  if (!this._isBuffer(key)) key = String(key)\n  // coerce value to string in node, dont touch it in browser\n  // (indexeddb can store any JS type)\n  if (!this._isBuffer(value) && !process.browser) value = String(value)\n  if (typeof options != \'object\')\n    options = {}\n  if (typeof this._put == \'function\')\n    return this._put(key, value, options, callback)\n\n  process.nextTick(callback)\n}\n\nAbstractLevelDOWN.prototype.del = function (key, options, callback) {\n  if (typeof options == \'function\')\n    callback = options\n  if (typeof callback != \'function\')\n    throw new Error(\'del() requires a callback argument\')\n  var err = this._checkKeyValue(key, \'key\', this._isBuffer)\n  if (err) return callback(err)\n  if (!this._isBuffer(key)) key = String(key)\n  if (typeof options != \'object\')\n    options = {}\n\n\n  if (typeof this._del == \'function\')\n    return this._del(key, options, callback)\n\n  process.nextTick(callback)\n}\n\nAbstractLevelDOWN.prototype.batch = function (array, options, callback) {\n  if (!arguments.length)\n    return this._chainedBatch()\n\n  if (typeof options == \'function\')\n    callback = options\n  if (typeof callback != \'function\')\n    throw new Error(\'batch(array) requires a callback argument\')\n  if (!Array.isArray(array))\n    return callback(new Error(\'batch(array) requires an array argument\'))\n  if (typeof options != \'object\')\n    options = {}\n\n  var i = 0\n    , l = array.length\n    , e\n    , err\n\n  for (; i < l; i++) {\n    e = array[i]\n    if (typeof e != \'object\') continue;\n\n    err = this._checkKeyValue(e.type, \'type\', this._isBuffer)\n    if (err) return callback(err)\n\n    err = this._checkKeyValue(e.key, \'key\', this._isBuffer)\n    if (err) return callback(err)\n\n    if (e.type == \'put\') {\n      err = this._checkKeyValue(e.value, \'value\', this._isBuffer)\n      if (err) return callback(err)\n    }\n  }\n\n  if (typeof this._batch == \'function\')\n    return this._batch(array, options, callback)\n\n  process.nextTick(callback)\n}\n\nAbstractLevelDOWN.prototype.approximateSize = function (start, end, callback) {\n  if (start == null || end == null || typeof start == \'function\' || typeof end == \'function\')\n    throw new Error(\'approximateSize() requires valid `start`, `end` and `callback` arguments\')\n  if (typeof callback != \'function\')\n    throw new Error(\'approximateSize() requires a callback argument\')\n\n  if (!this._isBuffer(start)) start = String(start)\n  if (!this._isBuffer(end)) end = String(end)\n  if (typeof this._approximateSize == \'function\')\n    return this._approximateSize(start, end, callback)\n\n  process.nextTick(function () { callback(null, 0) })\n}\n\nAbstractLevelDOWN.prototype.iterator = function (options) {\n  if (typeof options != \'object\')\n    options = {}\n\n  if (typeof this._iterator == \'function\')\n    return this._iterator(options)\n\n  return new AbstractIterator(this)\n}\n\nAbstractLevelDOWN.prototype._chainedBatch = function () {\n  return new AbstractChainedBatch(this)\n}\n\nAbstractLevelDOWN.prototype._isBuffer = function (obj) {\n  return Buffer.isBuffer(obj)\n}\n\nAbstractLevelDOWN.prototype._checkKeyValue = function (obj, type) {\n  if (obj === null || obj === undefined)\n    return new Error(type + \' cannot be `null` or `undefined`\')\n  if (obj === null || obj === undefined)\n    return new Error(type + \' cannot be `null` or `undefined`\')\n  if (this._isBuffer(obj)) {\n    if (obj.length === 0)\n      return new Error(type + \' cannot be an empty Buffer\')\n  } else if (String(obj) === \'\')\n    return new Error(type + \' cannot be an empty String\')\n}\n\nmodule.exports.AbstractLevelDOWN    = AbstractLevelDOWN\nmodule.exports.AbstractIterator     = AbstractIterator\nmodule.exports.AbstractChainedBatch = AbstractChainedBatch\n\n})(require("__browserify_process"),require("__browserify_buffer").Buffer)\n},{"./abstract-chained-batch":68,"./abstract-iterator":67,"__browserify_buffer":8,"__browserify_process":9}],41:[function(require,module,exports){\nmodule.exports = Object.keys || require(\'./shim\');\n\n\n},{"./shim":69}],32:[function(require,module,exports){\nvar Keys = require("object-keys")\nvar hasKeys = require("./has-keys")\n\nmodule.exports = extend\n\nfunction extend() {\n    var target = {}\n\n    for (var i = 0; i < arguments.length; i++) {\n        var source = arguments[i]\n\n        if (!hasKeys(source)) {\n            continue\n        }\n\n        var keys = Keys(source)\n\n        for (var j = 0; j < keys.length; j++) {\n            var name = keys[j]\n            target[name] = source[name]\n        }\n    }\n\n    return target\n}\n\n},{"./has-keys":66,"object-keys":70}],59:[function(require,module,exports){\n\nmodule.exports = function(buffer) {\n  return buffer instanceof Uint8Array;\n}\n\n},{}],60:[function(require,module,exports){\nmodule.exports = subarray\n\nfunction subarray(buf, from, to) {\n  return buf.subarray(from || 0, to || buf.length)\n}\n\n},{}],61:[function(require,module,exports){\nmodule.exports = join\n\nfunction join(targets, hint) {\n  if(!targets.length) {\n    return new Uint8Array(0)\n  }\n\n  var len = hint !== undefined ? hint : get_length(targets)\n    , out = new Uint8Array(len)\n    , cur = targets[0]\n    , curlen = cur.length\n    , curidx = 0\n    , curoff = 0\n    , i = 0\n\n  while(i < len) {\n    if(curoff === curlen) {\n      curoff = 0\n      ++curidx\n      cur = targets[curidx]\n      curlen = cur && cur.length\n      continue\n    }\n    out[i++] = cur[curoff++] \n  }\n\n  return out\n}\n\nfunction get_length(targets) {\n  var size = 0\n  for(var i = 0, len = targets.length; i < len; ++i) {\n    size += targets[i].byteLength\n  }\n  return size\n}\n\n},{}],62:[function(require,module,exports){\nmodule.exports = copy\n\nvar slice = [].slice\n\nfunction copy(source, target, target_start, source_start, source_end) {\n  target_start = arguments.length < 3 ? 0 : target_start\n  source_start = arguments.length < 4 ? 0 : source_start\n  source_end = arguments.length < 5 ? source.length : source_end\n\n  if(source_end === source_start) {\n    return\n  }\n\n  if(target.length === 0 || source.length === 0) {\n    return\n  }\n\n  if(source_end > source.length) {\n    source_end = source.length\n  }\n\n  if(target.length - target_start < source_end - source_start) {\n    source_end = target.length - target_start + source_start\n  }\n\n  if(source.buffer !== target.buffer) {\n    return fast_copy(source, target, target_start, source_start, source_end)\n  }\n  return slow_copy(source, target, target_start, source_start, source_end)\n}\n\nfunction fast_copy(source, target, target_start, source_start, source_end) {\n  var len = (source_end - source_start) + target_start\n\n  for(var i = target_start, j = source_start;\n      i < len;\n      ++i,\n      ++j) {\n    target[i] = source[j]\n  }\n}\n\nfunction slow_copy(from, to, j, i, jend) {\n  // the buffers could overlap.\n  var iend = jend + i\n    , tmp = new Uint8Array(slice.call(from, i, iend))\n    , x = 0\n\n  for(; i < iend; ++i, ++x) {\n    to[j++] = tmp[x]\n  }\n}\n\n},{}],63:[function(require,module,exports){\nmodule.exports = function(size) {\n  return new Uint8Array(size)\n}\n\n},{}],67:[function(require,module,exports){\n(function(process){/* Copyright (c) 2013 Rod Vagg, MIT License */\n\nfunction AbstractIterator (db) {\n  this.db = db\n  this._ended = false\n  this._nexting = false\n}\n\nAbstractIterator.prototype.next = function (callback) {\n  var self = this\n\n  if (typeof callback != \'function\')\n    throw new Error(\'next() requires a callback argument\')\n\n  if (self._ended)\n    return callback(new Error(\'cannot call next() after end()\'))\n  if (self._nexting)\n    return callback(new Error(\'cannot call next() before previous next() has completed\'))\n\n  self._nexting = true\n  if (typeof self._next == \'function\') {\n    return self._next(function () {\n      self._nexting = false\n      callback.apply(null, arguments)\n    })\n  }\n\n  process.nextTick(function () {\n    self._nexting = false\n    callback()\n  })\n}\n\nAbstractIterator.prototype.end = function (callback) {\n  if (typeof callback != \'function\')\n    throw new Error(\'end() requires a callback argument\')\n\n  if (this._ended)\n    return callback(new Error(\'end() already called on iterator\'))\n\n  this._ended = true\n\n  if (typeof this._end == \'function\')\n    return this._end(callback)\n\n  process.nextTick(callback)\n}\n\nmodule.exports = AbstractIterator\n\n})(require("__browserify_process"))\n},{"__browserify_process":9}],68:[function(require,module,exports){\n(function(process){/* Copyright (c) 2013 Rod Vagg, MIT License */\n\nfunction AbstractChainedBatch (db) {\n  this._db         = db\n  this._operations = []\n  this._written    = false\n}\n\nAbstractChainedBatch.prototype._checkWritten = function () {\n  if (this._written)\n    throw new Error(\'write() already called on this batch\')\n}\n\nAbstractChainedBatch.prototype.put = function (key, value) {\n  this._checkWritten()\n\n  var err = this._db._checkKeyValue(key, \'key\', this._db._isBuffer)\n  if (err) throw err\n  err = this._db._checkKeyValue(value, \'value\', this._db._isBuffer)\n  if (err) throw err\n\n  if (!this._db._isBuffer(key)) key = String(key)\n  if (!this._db._isBuffer(value)) value = String(value)\n\n  if (typeof this._put == \'function\' )\n    this._put(key, value)\n  else\n    this._operations.push({ type: \'put\', key: key, value: value })\n\n  return this\n}\n\nAbstractChainedBatch.prototype.del = function (key) {\n  this._checkWritten()\n\n  var err = this._db._checkKeyValue(key, \'key\', this._db._isBuffer)\n  if (err) throw err\n\n  if (!this._db._isBuffer(key)) key = String(key)\n\n  if (typeof this._del == \'function\' )\n    this._del(key)\n  else\n    this._operations.push({ type: \'del\', key: key })\n\n  return this\n}\n\nAbstractChainedBatch.prototype.clear = function () {\n  this._checkWritten()\n\n  this._operations = []\n\n  if (typeof this._clear == \'function\' )\n    this._clear()\n\n  return this\n}\n\nAbstractChainedBatch.prototype.write = function (options, callback) {\n  this._checkWritten()\n\n  if (typeof options == \'function\')\n    callback = options\n  if (typeof callback != \'function\')\n    throw new Error(\'write() requires a callback argument\')\n  if (typeof options != \'object\')\n    options = {}\n\n  this._written = true\n\n  if (typeof this._write == \'function\' )\n    return this._write(callback)\n\n  if (typeof this._db._batch == \'function\')\n    return this._db._batch(this._operations, options, callback)\n\n  process.nextTick(callback)\n}\n\nmodule.exports = AbstractChainedBatch\n})(require("__browserify_process"))\n},{"__browserify_process":9}],54:[function(require,module,exports){\nmodule.exports = {\n    readUInt8:      read_uint8\n  , readInt8:       read_int8\n  , readUInt16LE:   read_uint16_le\n  , readUInt32LE:   read_uint32_le\n  , readInt16LE:    read_int16_le\n  , readInt32LE:    read_int32_le\n  , readFloatLE:    read_float_le\n  , readDoubleLE:   read_double_le\n  , readUInt16BE:   read_uint16_be\n  , readUInt32BE:   read_uint32_be\n  , readInt16BE:    read_int16_be\n  , readInt32BE:    read_int32_be\n  , readFloatBE:    read_float_be\n  , readDoubleBE:   read_double_be\n}\n\nvar map = require(\'./mapped.js\')\n\nfunction read_uint8(target, at) {\n  return target[at]\n}\n\nfunction read_int8(target, at) {\n  var v = target[at];\n  return v < 0x80 ? v : v - 0x100\n}\n\nfunction read_uint16_le(target, at) {\n  var dv = map.get(target);\n  return dv.getUint16(at + target.byteOffset, true)\n}\n\nfunction read_uint32_le(target, at) {\n  var dv = map.get(target);\n  return dv.getUint32(at + target.byteOffset, true)\n}\n\nfunction read_int16_le(target, at) {\n  var dv = map.get(target);\n  return dv.getInt16(at + target.byteOffset, true)\n}\n\nfunction read_int32_le(target, at) {\n  var dv = map.get(target);\n  return dv.getInt32(at + target.byteOffset, true)\n}\n\nfunction read_float_le(target, at) {\n  var dv = map.get(target);\n  return dv.getFloat32(at + target.byteOffset, true)\n}\n\nfunction read_double_le(target, at) {\n  var dv = map.get(target);\n  return dv.getFloat64(at + target.byteOffset, true)\n}\n\nfunction read_uint16_be(target, at) {\n  var dv = map.get(target);\n  return dv.getUint16(at + target.byteOffset, false)\n}\n\nfunction read_uint32_be(target, at) {\n  var dv = map.get(target);\n  return dv.getUint32(at + target.byteOffset, false)\n}\n\nfunction read_int16_be(target, at) {\n  var dv = map.get(target);\n  return dv.getInt16(at + target.byteOffset, false)\n}\n\nfunction read_int32_be(target, at) {\n  var dv = map.get(target);\n  return dv.getInt32(at + target.byteOffset, false)\n}\n\nfunction read_float_be(target, at) {\n  var dv = map.get(target);\n  return dv.getFloat32(at + target.byteOffset, false)\n}\n\nfunction read_double_be(target, at) {\n  var dv = map.get(target);\n  return dv.getFloat64(at + target.byteOffset, false)\n}\n\n},{"./mapped.js":71}],55:[function(require,module,exports){\nmodule.exports = {\n    writeUInt8:      write_uint8\n  , writeInt8:       write_int8\n  , writeUInt16LE:   write_uint16_le\n  , writeUInt32LE:   write_uint32_le\n  , writeInt16LE:    write_int16_le\n  , writeInt32LE:    write_int32_le\n  , writeFloatLE:    write_float_le\n  , writeDoubleLE:   write_double_le\n  , writeUInt16BE:   write_uint16_be\n  , writeUInt32BE:   write_uint32_be\n  , writeInt16BE:    write_int16_be\n  , writeInt32BE:    write_int32_be\n  , writeFloatBE:    write_float_be\n  , writeDoubleBE:   write_double_be\n}\n\nvar map = require(\'./mapped.js\')\n\nfunction write_uint8(target, value, at) {\n  return target[at] = value\n}\n\nfunction write_int8(target, value, at) {\n  return target[at] = value < 0 ? value + 0x100 : value\n}\n\nfunction write_uint16_le(target, value, at) {\n  var dv = map.get(target);\n  return dv.setUint16(at + target.byteOffset, value, true)\n}\n\nfunction write_uint32_le(target, value, at) {\n  var dv = map.get(target);\n  return dv.setUint32(at + target.byteOffset, value, true)\n}\n\nfunction write_int16_le(target, value, at) {\n  var dv = map.get(target);\n  return dv.setInt16(at + target.byteOffset, value, true)\n}\n\nfunction write_int32_le(target, value, at) {\n  var dv = map.get(target);\n  return dv.setInt32(at + target.byteOffset, value, true)\n}\n\nfunction write_float_le(target, value, at) {\n  var dv = map.get(target);\n  return dv.setFloat32(at + target.byteOffset, value, true)\n}\n\nfunction write_double_le(target, value, at) {\n  var dv = map.get(target);\n  return dv.setFloat64(at + target.byteOffset, value, true)\n}\n\nfunction write_uint16_be(target, value, at) {\n  var dv = map.get(target);\n  return dv.setUint16(at + target.byteOffset, value, false)\n}\n\nfunction write_uint32_be(target, value, at) {\n  var dv = map.get(target);\n  return dv.setUint32(at + target.byteOffset, value, false)\n}\n\nfunction write_int16_be(target, value, at) {\n  var dv = map.get(target);\n  return dv.setInt16(at + target.byteOffset, value, false)\n}\n\nfunction write_int32_be(target, value, at) {\n  var dv = map.get(target);\n  return dv.setInt32(at + target.byteOffset, value, false)\n}\n\nfunction write_float_be(target, value, at) {\n  var dv = map.get(target);\n  return dv.setFloat32(at + target.byteOffset, value, false)\n}\n\nfunction write_double_be(target, value, at) {\n  var dv = map.get(target);\n  return dv.setFloat64(at + target.byteOffset, value, false)\n}\n\n},{"./mapped.js":71}],43:[function(require,module,exports){\n(function(process,Buffer){// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, cb), and it\'ll handle all\n// the drain event emission and buffering.\n\nmodule.exports = Writable;\nWritable.WritableState = WritableState;\n\nvar util = require(\'util\');\nvar assert = require(\'assert\');\nvar Stream = require(\'stream\');\n\nutil.inherits(Writable, Stream);\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n}\n\nfunction WritableState(options, stream) {\n  options = options || {};\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  // cast to ints.\n  this.highWaterMark = ~~this.highWaterMark;\n\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when \'finish\' is emitted\n  this.finished = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is \'binary\' so we have to make this configurable.\n  // Everything else in the universe uses \'utf8\', though.\n  this.defaultEncoding = options.defaultEncoding || \'utf8\';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we\'re waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we\'re in the middle of a write.\n  this.writing = false;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, becuase any\n  // actions that shouldn\'t happen until "later" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we\'re processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don\'t\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that\'s passed to _write(chunk,cb)\n  this.onwrite = function(er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.buffer = [];\n}\n\nfunction Writable(options) {\n  // Writable ctor is applied to Duplexes, though they\'re not\n  // instanceof Writable, they\'re instanceof Readable.\n  if (!(this instanceof Writable) && !(this instanceof require(\'./_stream_duplex\')))\n    return new Writable(options);\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function() {\n  this.emit(\'error\', new Error(\'Cannot pipe. Not readable.\'));\n};\n\n\nfunction writeAfterEnd(stream, state, cb) {\n  var er = new Error(\'write after end\');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit(\'error\', er);\n  process.nextTick(function() {\n    cb(er);\n  });\n}\n\n// If we get something that is not a buffer, string, null, or undefined,\n// and we\'re not in objectMode, then that\'s an error.\n// Otherwise stream chunks are all considered to be of length=1, and the\n// watermarks determine how many objects to keep in the buffer, rather than\n// how many bytes or characters.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  if (!Buffer.isBuffer(chunk) &&\n      \'string\' !== typeof chunk &&\n      chunk !== null &&\n      chunk !== undefined &&\n      !state.objectMode) {\n    var er = new TypeError(\'Invalid non-string/buffer chunk\');\n    stream.emit(\'error\', er);\n    process.nextTick(function() {\n      cb(er);\n    });\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function(chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  if (typeof encoding === \'function\') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (Buffer.isBuffer(chunk))\n    encoding = \'buffer\';\n  else if (!encoding)\n    encoding = state.defaultEncoding;\n\n  if (typeof cb !== \'function\')\n    cb = function() {};\n\n  if (state.ended)\n    writeAfterEnd(this, state, cb);\n  else if (validChunk(this, state, chunk, cb))\n    ret = writeOrBuffer(this, state, chunk, encoding, cb);\n\n  return ret;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode &&\n      state.decodeStrings !== false &&\n      typeof chunk === \'string\') {\n    chunk = new Buffer(chunk, encoding);\n  }\n  return chunk;\n}\n\n// if we\'re already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, chunk, encoding, cb) {\n  chunk = decodeChunk(state, chunk, encoding);\n  if (Buffer.isBuffer(chunk))\n    encoding = \'buffer\';\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret)\n    state.needDrain = true;\n\n  if (state.writing)\n    state.buffer.push(new WriteReq(chunk, encoding, cb));\n  else\n    doWrite(stream, state, len, chunk, encoding, cb);\n\n  return ret;\n}\n\nfunction doWrite(stream, state, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  if (sync)\n    process.nextTick(function() {\n      cb(er);\n    });\n  else\n    cb(er);\n\n  stream.emit(\'error\', er);\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er)\n    onwriteError(stream, state, sync, er, cb);\n  else {\n    // Check if we\'re actually ready to finish, but don\'t emit yet\n    var finished = needFinish(stream, state);\n\n    if (!finished && !state.bufferProcessing && state.buffer.length)\n      clearBuffer(stream, state);\n\n    if (sync) {\n      process.nextTick(function() {\n        afterWrite(stream, state, finished, cb);\n      });\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished)\n    onwriteDrain(stream, state);\n  cb();\n  if (finished)\n    finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don\'t\n// emit \'drain\' before the write() consumer gets the \'false\' return\n// value, and has a chance to attach a \'drain\' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit(\'drain\');\n  }\n}\n\n\n// if there\'s something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n\n  for (var c = 0; c < state.buffer.length; c++) {\n    var entry = state.buffer[c];\n    var chunk = entry.chunk;\n    var encoding = entry.encoding;\n    var cb = entry.callback;\n    var len = state.objectMode ? 1 : chunk.length;\n\n    doWrite(stream, state, len, chunk, encoding, cb);\n\n    // if we didn\'t call the onwrite immediately, then\n    // it means that we need to wait until it does.\n    // also, that means that the chunk and cb are currently\n    // being processed, so move the buffer counter past them.\n    if (state.writing) {\n      c++;\n      break;\n    }\n  }\n\n  state.bufferProcessing = false;\n  if (c < state.buffer.length)\n    state.buffer = state.buffer.slice(c);\n  else\n    state.buffer.length = 0;\n}\n\nWritable.prototype._write = function(chunk, encoding, cb) {\n  cb(new Error(\'not implemented\'));\n};\n\nWritable.prototype.end = function(chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === \'function\') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === \'function\') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (typeof chunk !== \'undefined\' && chunk !== null)\n    this.write(chunk, encoding);\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished)\n    endWritable(this, state, cb);\n};\n\n\nfunction needFinish(stream, state) {\n  return (state.ending &&\n          state.length === 0 &&\n          !state.finished &&\n          !state.writing);\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(stream, state);\n  if (need) {\n    state.finished = true;\n    stream.emit(\'finish\');\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished)\n      process.nextTick(cb);\n    else\n      stream.once(\'finish\', cb);\n  }\n  state.ended = true;\n}\n\n})(require("__browserify_process"),require("__browserify_buffer").Buffer)\n},{"./_stream_duplex":44,"__browserify_buffer":8,"__browserify_process":9,"assert":28,"stream":16,"util":11}],44:[function(require,module,exports){\n(function(process){// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn\'t have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\nmodule.exports = Duplex;\nvar util = require(\'util\');\nvar Readable = require(\'./_stream_readable\');\nvar Writable = require(\'./_stream_writable\');\n\nutil.inherits(Duplex, Readable);\n\nObject.keys(Writable.prototype).forEach(function(method) {\n  if (!Duplex.prototype[method])\n    Duplex.prototype[method] = Writable.prototype[method];\n});\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex))\n    return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false)\n    this.readable = false;\n\n  if (options && options.writable === false)\n    this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false)\n    this.allowHalfOpen = false;\n\n  this.once(\'end\', onend);\n}\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we\'re ok.\n  if (this.allowHalfOpen || this._writableState.ended)\n    return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  process.nextTick(this.end.bind(this));\n}\n\n})(require("__browserify_process"))\n},{"./_stream_readable":42,"./_stream_writable":43,"__browserify_process":9,"util":11}],45:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it\'s called a "filter",\n// but that\'s not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it\'s not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here\'s how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there\'s a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there\'s enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb\'s as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit \'readable\' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there\'d be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\nmodule.exports = Transform;\n\nvar Duplex = require(\'./_stream_duplex\');\nvar util = require(\'util\');\nutil.inherits(Transform, Duplex);\n\n\nfunction TransformState(options, stream) {\n  this.afterTransform = function(er, data) {\n    return afterTransform(stream, er, data);\n  };\n\n  this.needTransform = false;\n  this.transforming = false;\n  this.writecb = null;\n  this.writechunk = null;\n}\n\nfunction afterTransform(stream, er, data) {\n  var ts = stream._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb)\n    return stream.emit(\'error\', new Error(\'no writecb in Transform class\'));\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data !== null && data !== undefined)\n    stream.push(data);\n\n  if (cb)\n    cb(er);\n\n  var rs = stream._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    stream._read(rs.highWaterMark);\n  }\n}\n\n\nfunction Transform(options) {\n  if (!(this instanceof Transform))\n    return new Transform(options);\n\n  Duplex.call(this, options);\n\n  var ts = this._transformState = new TransformState(options, this);\n\n  // when the writable side finishes, then flush out anything remaining.\n  var stream = this;\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  this.once(\'finish\', function() {\n    if (\'function\' === typeof this._flush)\n      this._flush(function(er) {\n        done(stream, er);\n      });\n    else\n      done(stream);\n  });\n}\n\nTransform.prototype.push = function(chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// \'chunk\' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call \'push\' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that\'ll put the hurt on the whole operation.  If you\n// never call cb(), then you\'ll never get another chunk.\nTransform.prototype._transform = function(chunk, encoding, cb) {\n  throw new Error(\'not implemented\');\n};\n\nTransform.prototype._write = function(chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform ||\n        rs.needReadable ||\n        rs.length < rs.highWaterMark)\n      this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn\'t matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function(n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we\'ve asked for it.\n    ts.needTransform = true;\n  }\n};\n\n\nfunction done(stream, er) {\n  if (er)\n    return stream.emit(\'error\', er);\n\n  // if there\'s nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  var ws = stream._writableState;\n  var rs = stream._readableState;\n  var ts = stream._transformState;\n\n  if (ws.length)\n    throw new Error(\'calling transform done when ws.length != 0\');\n\n  if (ts.transforming)\n    throw new Error(\'calling transform done when still transforming\');\n\n  return stream.push(null);\n}\n\n},{"./_stream_duplex":44,"util":11}],46:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\nmodule.exports = PassThrough;\n\nvar Transform = require(\'./_stream_transform\');\nvar util = require(\'util\');\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough))\n    return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function(chunk, encoding, cb) {\n  cb(null, chunk);\n};\n\n},{"./_stream_transform":45,"util":11}],71:[function(require,module,exports){\nvar proto\n  , map\n\nmodule.exports = proto = {}\n\nmap = typeof WeakMap === \'undefined\' ? null : new WeakMap\n\nproto.get = !map ? no_weakmap_get : get\n\nfunction no_weakmap_get(target) {\n  return new DataView(target.buffer, 0)\n}\n\nfunction get(target) {\n  var out = map.get(target.buffer)\n  if(!out) {\n    map.set(target.buffer, out = new DataView(target.buffer, 0))\n  }\n  return out\n}\n\n},{}],64:[function(require,module,exports){\nmodule.exports = {\n    readUInt8:      read_uint8\n  , readInt8:       read_int8\n  , readUInt16LE:   read_uint16_le\n  , readUInt32LE:   read_uint32_le\n  , readInt16LE:    read_int16_le\n  , readInt32LE:    read_int32_le\n  , readFloatLE:    read_float_le\n  , readDoubleLE:   read_double_le\n  , readUInt16BE:   read_uint16_be\n  , readUInt32BE:   read_uint32_be\n  , readInt16BE:    read_int16_be\n  , readInt32BE:    read_int32_be\n  , readFloatBE:    read_float_be\n  , readDoubleBE:   read_double_be\n}\n\nvar map = require(\'./mapped.js\')\n\nfunction read_uint8(target, at) {\n  return target[at]\n}\n\nfunction read_int8(target, at) {\n  var v = target[at];\n  return v < 0x80 ? v : v - 0x100\n}\n\nfunction read_uint16_le(target, at) {\n  var dv = map.get(target);\n  return dv.getUint16(at + target.byteOffset, true)\n}\n\nfunction read_uint32_le(target, at) {\n  var dv = map.get(target);\n  return dv.getUint32(at + target.byteOffset, true)\n}\n\nfunction read_int16_le(target, at) {\n  var dv = map.get(target);\n  return dv.getInt16(at + target.byteOffset, true)\n}\n\nfunction read_int32_le(target, at) {\n  var dv = map.get(target);\n  return dv.getInt32(at + target.byteOffset, true)\n}\n\nfunction read_float_le(target, at) {\n  var dv = map.get(target);\n  return dv.getFloat32(at + target.byteOffset, true)\n}\n\nfunction read_double_le(target, at) {\n  var dv = map.get(target);\n  return dv.getFloat64(at + target.byteOffset, true)\n}\n\nfunction read_uint16_be(target, at) {\n  var dv = map.get(target);\n  return dv.getUint16(at + target.byteOffset, false)\n}\n\nfunction read_uint32_be(target, at) {\n  var dv = map.get(target);\n  return dv.getUint32(at + target.byteOffset, false)\n}\n\nfunction read_int16_be(target, at) {\n  var dv = map.get(target);\n  return dv.getInt16(at + target.byteOffset, false)\n}\n\nfunction read_int32_be(target, at) {\n  var dv = map.get(target);\n  return dv.getInt32(at + target.byteOffset, false)\n}\n\nfunction read_float_be(target, at) {\n  var dv = map.get(target);\n  return dv.getFloat32(at + target.byteOffset, false)\n}\n\nfunction read_double_be(target, at) {\n  var dv = map.get(target);\n  return dv.getFloat64(at + target.byteOffset, false)\n}\n\n},{"./mapped.js":72}],65:[function(require,module,exports){\nmodule.exports = {\n    writeUInt8:      write_uint8\n  , writeInt8:       write_int8\n  , writeUInt16LE:   write_uint16_le\n  , writeUInt32LE:   write_uint32_le\n  , writeInt16LE:    write_int16_le\n  , writeInt32LE:    write_int32_le\n  , writeFloatLE:    write_float_le\n  , writeDoubleLE:   write_double_le\n  , writeUInt16BE:   write_uint16_be\n  , writeUInt32BE:   write_uint32_be\n  , writeInt16BE:    write_int16_be\n  , writeInt32BE:    write_int32_be\n  , writeFloatBE:    write_float_be\n  , writeDoubleBE:   write_double_be\n}\n\nvar map = require(\'./mapped.js\')\n\nfunction write_uint8(target, value, at) {\n  return target[at] = value\n}\n\nfunction write_int8(target, value, at) {\n  return target[at] = value < 0 ? value + 0x100 : value\n}\n\nfunction write_uint16_le(target, value, at) {\n  var dv = map.get(target);\n  return dv.setUint16(at + target.byteOffset, value, true)\n}\n\nfunction write_uint32_le(target, value, at) {\n  var dv = map.get(target);\n  return dv.setUint32(at + target.byteOffset, value, true)\n}\n\nfunction write_int16_le(target, value, at) {\n  var dv = map.get(target);\n  return dv.setInt16(at + target.byteOffset, value, true)\n}\n\nfunction write_int32_le(target, value, at) {\n  var dv = map.get(target);\n  return dv.setInt32(at + target.byteOffset, value, true)\n}\n\nfunction write_float_le(target, value, at) {\n  var dv = map.get(target);\n  return dv.setFloat32(at + target.byteOffset, value, true)\n}\n\nfunction write_double_le(target, value, at) {\n  var dv = map.get(target);\n  return dv.setFloat64(at + target.byteOffset, value, true)\n}\n\nfunction write_uint16_be(target, value, at) {\n  var dv = map.get(target);\n  return dv.setUint16(at + target.byteOffset, value, false)\n}\n\nfunction write_uint32_be(target, value, at) {\n  var dv = map.get(target);\n  return dv.setUint32(at + target.byteOffset, value, false)\n}\n\nfunction write_int16_be(target, value, at) {\n  var dv = map.get(target);\n  return dv.setInt16(at + target.byteOffset, value, false)\n}\n\nfunction write_int32_be(target, value, at) {\n  var dv = map.get(target);\n  return dv.setInt32(at + target.byteOffset, value, false)\n}\n\nfunction write_float_be(target, value, at) {\n  var dv = map.get(target);\n  return dv.setFloat32(at + target.byteOffset, value, false)\n}\n\nfunction write_double_be(target, value, at) {\n  var dv = map.get(target);\n  return dv.setFloat64(at + target.byteOffset, value, false)\n}\n\n},{"./mapped.js":72}],69:[function(require,module,exports){\n(function () {\n\t"use strict";\n\n\t// modified from https://github.com/kriskowal/es5-shim\n\tvar has = Object.prototype.hasOwnProperty,\n\t\ttoString = Object.prototype.toString,\n\t\tforEach = require(\'./foreach\'),\n\t\tisArgs = require(\'./isArguments\'),\n\t\thasDontEnumBug = !({\'toString\': null}).propertyIsEnumerable(\'toString\'),\n\t\thasProtoEnumBug = (function () {}).propertyIsEnumerable(\'prototype\'),\n\t\tdontEnums = [\n\t\t\t"toString",\n\t\t\t"toLocaleString",\n\t\t\t"valueOf",\n\t\t\t"hasOwnProperty",\n\t\t\t"isPrototypeOf",\n\t\t\t"propertyIsEnumerable",\n\t\t\t"constructor"\n\t\t],\n\t\tkeysShim;\n\n\tkeysShim = function keys(object) {\n\t\tvar isObject = object !== null && typeof object === \'object\',\n\t\t\tisFunction = toString.call(object) === \'[object Function]\',\n\t\t\tisArguments = isArgs(object),\n\t\t\ttheKeys = [];\n\n\t\tif (!isObject && !isFunction && !isArguments) {\n\t\t\tthrow new TypeError("Object.keys called on a non-object");\n\t\t}\n\n\t\tif (isArguments) {\n\t\t\tforEach(object, function (value) {\n\t\t\t\ttheKeys.push(value);\n\t\t\t});\n\t\t} else {\n\t\t\tvar name,\n\t\t\t\tskipProto = hasProtoEnumBug && isFunction;\n\n\t\t\tfor (name in object) {\n\t\t\t\tif (!(skipProto && name === \'prototype\') && has.call(object, name)) {\n\t\t\t\t\ttheKeys.push(name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (hasDontEnumBug) {\n\t\t\tvar ctor = object.constructor,\n\t\t\t\tskipConstructor = ctor && ctor.prototype === object;\n\n\t\t\tforEach(dontEnums, function (dontEnum) {\n\t\t\t\tif (!(skipConstructor && dontEnum === \'constructor\') && has.call(object, dontEnum)) {\n\t\t\t\t\ttheKeys.push(dontEnum);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn theKeys;\n\t};\n\n\tmodule.exports = keysShim;\n}());\n\n\n},{"./foreach":73,"./isArguments":74}],70:[function(require,module,exports){\nmodule.exports = Object.keys || require(\'./shim\');\n\n\n},{"./shim":75}],72:[function(require,module,exports){\nvar proto\n  , map\n\nmodule.exports = proto = {}\n\nmap = typeof WeakMap === \'undefined\' ? null : new WeakMap\n\nproto.get = !map ? no_weakmap_get : get\n\nfunction no_weakmap_get(target) {\n  return new DataView(target.buffer, 0)\n}\n\nfunction get(target) {\n  var out = map.get(target.buffer)\n  if(!out) {\n    map.set(target.buffer, out = new DataView(target.buffer, 0))\n  }\n  return out\n}\n\n},{}],73:[function(require,module,exports){\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toString = Object.prototype.toString;\n\nvar isFunction = function (fn) {\n\tvar isFunc = (typeof fn === \'function\' && !(fn instanceof RegExp)) || toString.call(fn) === \'[object Function]\';\n\tif (!isFunc && typeof window !== \'undefined\') {\n\t\tisFunc = fn === window.setTimeout || fn === window.alert || fn === window.confirm || fn === window.prompt;\n\t}\n\treturn isFunc;\n};\n\nmodule.exports = function forEach(obj, fn) {\n\tif (!isFunction(fn)) {\n\t\tthrow new TypeError(\'iterator must be a function\');\n\t}\n\tvar i, k,\n\t\tisString = typeof obj === \'string\',\n\t\tl = obj.length,\n\t\tcontext = arguments.length > 2 ? arguments[2] : null;\n\tif (l === +l) {\n\t\tfor (i = 0; i < l; i++) {\n\t\t\tif (context === null) {\n\t\t\t\tfn(isString ? obj.charAt(i) : obj[i], i, obj);\n\t\t\t} else {\n\t\t\t\tfn.call(context, isString ? obj.charAt(i) : obj[i], i, obj);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (k in obj) {\n\t\t\tif (hasOwn.call(obj, k)) {\n\t\t\t\tif (context === null) {\n\t\t\t\t\tfn(obj[k], k, obj);\n\t\t\t\t} else {\n\t\t\t\t\tfn.call(context, obj[k], k, obj);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n\n},{}],74:[function(require,module,exports){\nvar toString = Object.prototype.toString;\n\nmodule.exports = function isArguments(value) {\n\tvar str = toString.call(value);\n\tvar isArguments = str === \'[object Arguments]\';\n\tif (!isArguments) {\n\t\tisArguments = str !== \'[object Array]\'\n\t\t\t&& value !== null\n\t\t\t&& typeof value === \'object\'\n\t\t\t&& typeof value.length === \'number\'\n\t\t\t&& value.length >= 0\n\t\t\t&& toString.call(value.callee) === \'[object Function]\';\n\t}\n\treturn isArguments;\n};\n\n\n},{}],56:[function(require,module,exports){\nconst prr = require(\'prr\')\n\nfunction init (type, message, cause) {\n  prr(this, {\n      type    : type\n    , name    : type\n      // can be passed just a \'cause\'\n    , cause   : typeof message != \'string\' ? message : cause\n    , message : !!message && typeof message != \'string\' ? message.message : message\n\n  }, \'ewr\')\n}\n\n// generic prototype, not intended to be actually used - helpful for `instanceof`\nfunction CustomError (message, cause) {\n  Error.call(this)\n  if (Error.captureStackTrace)\n    Error.captureStackTrace(this, arguments.callee)\n  init.call(this, \'CustomError\', message, cause)\n}\n\nCustomError.prototype = new Error()\n\nfunction createError (errno, type, proto) {\n  var err = function (message, cause) {\n    init.call(this, type, message, cause)\n    //TODO: the specificity here is stupid, errno should be available everywhere\n    if (type == \'FilesystemError\') {\n      this.code    = this.cause.code\n      this.path    = this.cause.path\n      this.errno   = this.cause.errno\n      this.message =\n        (errno.errno[this.cause.errno]\n          ? errno.errno[this.cause.errno].description\n          : this.cause.message)\n        + (this.cause.path ? \' [\' + this.cause.path + \']\' : \'\')\n    }\n    Error.call(this)\n    if (Error.captureStackTrace)\n      Error.captureStackTrace(this, arguments.callee)\n  }\n  err.prototype = !!proto ? new proto() : new CustomError()\n  return err\n}\n\nmodule.exports = function (errno) {\n  var ce = function (type, proto) {\n    return createError(errno, type, proto)\n  }\n  return {\n      CustomError     : CustomError\n    , FilesystemError : ce(\'FilesystemError\')\n    , createError     : ce\n  }\n}\n\n},{"prr":23}],42:[function(require,module,exports){\n(function(process,Buffer){// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Readable;\nReadable.ReadableState = ReadableState;\n\nvar EE = require(\'events\').EventEmitter;\nif (!EE.listenerCount) EE.listenerCount = function(emitter, type) {\n  return emitter.listeners(type).length;\n};\nvar Stream = require(\'stream\');\nvar util = require(\'util\');\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nfunction ReadableState(options, stream) {\n  options = options || {};\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means "don\'t call _read preemptively ever"\n  var hwm = options.highWaterMark;\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;\n\n  // cast to ints.\n  this.highWaterMark = ~~this.highWaterMark;\n\n  this.buffer = [];\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = false;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // In streams that never have any data, and do push(null) right away,\n  // the consumer can miss the \'end\' event if they do some I/O before\n  // consuming the stream.  So, we don\'t emit(\'end\') until some reading\n  // happens.\n  this.calledRead = false;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, becuase any\n  // actions that shouldn\'t happen until "later" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we\'re awaiting a \'readable\' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is \'binary\' so we have to make this configurable.\n  // Everything else in the universe uses \'utf8\', though.\n  this.defaultEncoding = options.defaultEncoding || \'utf8\';\n\n  // when piping, we only care about \'readable\' events that happen\n  // after read()ing all the bytes and not getting any pushback.\n  this.ranOut = false;\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder)\n      StringDecoder = require(\'string_decoder/\').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  if (!(this instanceof Readable))\n    return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  Stream.call(this);\n}\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function(chunk, encoding) {\n  var state = this._readableState;\n\n  if (typeof chunk === \'string\' && !state.objectMode) {\n    encoding = encoding || state.defaultEncoding;\n    if (encoding !== state.encoding) {\n      chunk = new Buffer(chunk, encoding);\n      encoding = \'\';\n    }\n  }\n\n  return readableAddChunk(this, state, chunk, encoding, false);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function(chunk) {\n  var state = this._readableState;\n  return readableAddChunk(this, state, chunk, \'\', true);\n};\n\nfunction readableAddChunk(stream, state, chunk, encoding, addToFront) {\n  var er = chunkInvalid(state, chunk);\n  if (er) {\n    stream.emit(\'error\', er);\n  } else if (chunk === null || chunk === undefined) {\n    state.reading = false;\n    if (!state.ended)\n      onEofChunk(stream, state);\n  } else if (state.objectMode || chunk && chunk.length > 0) {\n    if (state.ended && !addToFront) {\n      var e = new Error(\'stream.push() after EOF\');\n      stream.emit(\'error\', e);\n    } else if (state.endEmitted && addToFront) {\n      var e = new Error(\'stream.unshift() after end event\');\n      stream.emit(\'error\', e);\n    } else {\n      if (state.decoder && !addToFront && !encoding)\n        chunk = state.decoder.write(chunk);\n\n      // update the buffer info.\n      state.length += state.objectMode ? 1 : chunk.length;\n      if (addToFront) {\n        state.buffer.unshift(chunk);\n      } else {\n        state.reading = false;\n        state.buffer.push(chunk);\n      }\n\n      if (state.needReadable)\n        emitReadable(stream);\n\n      maybeReadMore(stream, state);\n    }\n  } else if (!addToFront) {\n    state.reading = false;\n  }\n\n  return needMoreData(state);\n}\n\n\n\n// if it\'s past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// \'readable\' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended &&\n         (state.needReadable ||\n          state.length < state.highWaterMark ||\n          state.length === 0);\n}\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function(enc) {\n  if (!StringDecoder)\n    StringDecoder = require(\'string_decoder/\').StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n};\n\n// Don\'t raise the hwm > 128MB\nvar MAX_HWM = 0x800000;\nfunction roundUpToNextPowerOf2(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2\n    n--;\n    for (var p = 1; p < 32; p <<= 1) n |= n >> p;\n    n++;\n  }\n  return n;\n}\n\nfunction howMuchToRead(n, state) {\n  if (state.length === 0 && state.ended)\n    return 0;\n\n  if (state.objectMode)\n    return n === 0 ? 0 : 1;\n\n  if (isNaN(n) || n === null) {\n    // only flow one buffer at a time\n    if (state.flowing && state.buffer.length)\n      return state.buffer[0].length;\n    else\n      return state.length;\n  }\n\n  if (n <= 0)\n    return 0;\n\n  // If we\'re asking for more than the target buffer level,\n  // then raise the water mark.  Bump up to the next highest\n  // power of 2, to prevent increasing it excessively in tiny\n  // amounts.\n  if (n > state.highWaterMark)\n    state.highWaterMark = roundUpToNextPowerOf2(n);\n\n  // don\'t have that much.  return null, unless we\'ve ended.\n  if (n > state.length) {\n    if (!state.ended) {\n      state.needReadable = true;\n      return 0;\n    } else\n      return state.length;\n  }\n\n  return n;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function(n) {\n  var state = this._readableState;\n  state.calledRead = true;\n  var nOrig = n;\n\n  if (typeof n !== \'number\' || n > 0)\n    state.emittedReadable = false;\n\n  // if we\'re doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the \'readable\' event and move on.\n  if (n === 0 &&\n      state.needReadable &&\n      (state.length >= state.highWaterMark || state.ended)) {\n    emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we\'ve ended, and we\'re now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0)\n      endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn\'t mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it\'s safe to emit\n  // \'readable\' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length - n <= state.highWaterMark)\n    doRead = true;\n\n  // however, if we\'ve ended, then there\'s no point, and if we\'re already\n  // reading, then it\'s unnecessary.\n  if (state.ended || state.reading)\n    doRead = false;\n\n  if (doRead) {\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0)\n      state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n  }\n\n  // If _read called its callback synchronously, then `reading`\n  // will be false, and we need to re-evaluate how much data we\n  // can return to the user.\n  if (doRead && !state.reading)\n    n = howMuchToRead(nOrig, state);\n\n  var ret;\n  if (n > 0)\n    ret = fromList(n, state);\n  else\n    ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  }\n\n  state.length -= n;\n\n  // If we have nothing in the buffer, then we want to know\n  // as soon as we *do* get something into the buffer.\n  if (state.length === 0 && !state.ended)\n    state.needReadable = true;\n\n  // If we happened to read() exactly the remaining amount in the\n  // buffer, and the EOF has been seen at this point, then make sure\n  // that we emit \'end\' on the very next tick.\n  if (state.ended && !state.endEmitted && state.length === 0)\n    endReadable(this);\n\n  return ret;\n};\n\nfunction chunkInvalid(state, chunk) {\n  var er = null;\n  if (!Buffer.isBuffer(chunk) &&\n      \'string\' !== typeof chunk &&\n      chunk !== null &&\n      chunk !== undefined &&\n      !state.objectMode &&\n      !er) {\n    er = new TypeError(\'Invalid non-string/buffer chunk\');\n  }\n  return er;\n}\n\n\nfunction onEofChunk(stream, state) {\n  if (state.decoder && !state.ended) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // if we\'ve ended and we have some data left, then emit\n  // \'readable\' now to make sure it gets picked up.\n  if (state.length > 0)\n    emitReadable(stream);\n  else\n    endReadable(stream);\n}\n\n// Don\'t emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that\'s not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (state.emittedReadable)\n    return;\n\n  state.emittedReadable = true;\n  if (state.sync)\n    process.nextTick(function() {\n      emitReadable_(stream);\n    });\n  else\n    emitReadable_(stream);\n}\n\nfunction emitReadable_(stream) {\n  stream.emit(\'readable\');\n}\n\n\n// at this point, the user has presumably seen the \'readable\' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it\'s in progress.\n// However, if we\'re not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(function() {\n      maybeReadMore_(stream, state);\n    });\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended &&\n         state.length < state.highWaterMark) {\n    stream.read(0);\n    if (len === state.length)\n      // didn\'t get any data, stop spinning.\n      break;\n    else\n      len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, "length" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function(n) {\n  this.emit(\'error\', new Error(\'not implemented\'));\n};\n\nReadable.prototype.pipe = function(dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&\n              dest !== process.stdout &&\n              dest !== process.stderr;\n\n  var endFn = doEnd ? onend : cleanup;\n  if (state.endEmitted)\n    process.nextTick(endFn);\n  else\n    src.once(\'end\', endFn);\n\n  dest.on(\'unpipe\', onunpipe);\n  function onunpipe(readable) {\n    if (readable !== src) return;\n    cleanup();\n  }\n\n  function onend() {\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on(\'drain\', ondrain);\n\n  function cleanup() {\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener(\'close\', onclose);\n    dest.removeListener(\'finish\', onfinish);\n    dest.removeListener(\'drain\', ondrain);\n    dest.removeListener(\'error\', onerror);\n    dest.removeListener(\'unpipe\', onunpipe);\n    src.removeListener(\'end\', onend);\n    src.removeListener(\'end\', cleanup);\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don\'t know, then assume that we are waiting for one.\n    if (!dest._writableState || dest._writableState.needDrain)\n      ondrain();\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don\'t suppress the throwing behavior for this.\n  function onerror(er) {\n    unpipe();\n    dest.removeListener(\'error\', onerror);\n    if (EE.listenerCount(dest, \'error\') === 0)\n      dest.emit(\'error\', er);\n  }\n  // This is a brutally ugly hack to make sure that our error handler\n  // is attached before any userland ones.  NEVER DO THIS.\n  if (!dest._events || !dest._events.error)\n    dest.on(\'error\', onerror);\n  else if (Array.isArray(dest._events.error))\n    dest._events.error.unshift(onerror);\n  else\n    dest._events.error = [onerror, dest._events.error];\n\n\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener(\'finish\', onfinish);\n    unpipe();\n  }\n  dest.once(\'close\', onclose);\n  function onfinish() {\n    dest.removeListener(\'close\', onclose);\n    unpipe();\n  }\n  dest.once(\'finish\', onfinish);\n\n  function unpipe() {\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it\'s being piped to\n  dest.emit(\'pipe\', src);\n\n  // start the flow if it hasn\'t been started already.\n  if (!state.flowing) {\n    // the handler that waits for readable events after all\n    // the data gets sucked out in flow.\n    // This would be easier to follow with a .once() handler\n    // in flow(), but that is too slow.\n    this.on(\'readable\', pipeOnReadable);\n\n    state.flowing = true;\n    process.nextTick(function() {\n      flow(src);\n    });\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function() {\n    var dest = this;\n    var state = src._readableState;\n    state.awaitDrain--;\n    if (state.awaitDrain === 0)\n      flow(src);\n  };\n}\n\nfunction flow(src) {\n  var state = src._readableState;\n  var chunk;\n  state.awaitDrain = 0;\n\n  function write(dest, i, list) {\n    var written = dest.write(chunk);\n    if (false === written) {\n      state.awaitDrain++;\n    }\n  }\n\n  while (state.pipesCount && null !== (chunk = src.read())) {\n\n    if (state.pipesCount === 1)\n      write(state.pipes, 0, null);\n    else\n      state.pipes.forEach(write);\n\n    src.emit(\'data\', chunk);\n\n    // if anyone needs a drain, then we have to wait for that.\n    if (state.awaitDrain > 0)\n      return;\n  }\n\n  // if every destination was unpiped, either before entering this\n  // function, or in the while loop, then stop flowing.\n  //\n  // NB: This is a pretty rare edge case.\n  if (state.pipesCount === 0) {\n    state.flowing = false;\n\n    // if there were data event listeners added, then switch to old mode.\n    if (EE.listenerCount(src, \'data\') > 0)\n      emitDataEvents(src);\n    return;\n  }\n\n  // at this point, no one needed a drain, so we just ran out of data\n  // on the next readable event, start it over again.\n  state.ranOut = true;\n}\n\nfunction pipeOnReadable() {\n  if (this._readableState.ranOut) {\n    this._readableState.ranOut = false;\n    flow(this);\n  }\n}\n\n\nReadable.prototype.unpipe = function(dest) {\n  var state = this._readableState;\n\n  // if we\'re not piping anywhere, then do nothing.\n  if (state.pipesCount === 0)\n    return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it\'s not the right one.\n    if (dest && dest !== state.pipes)\n      return this;\n\n    if (!dest)\n      dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    this.removeListener(\'readable\', pipeOnReadable);\n    state.flowing = false;\n    if (dest)\n      dest.emit(\'unpipe\', this);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    this.removeListener(\'readable\', pipeOnReadable);\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++)\n      dests[i].emit(\'unpipe\', this);\n    return this;\n  }\n\n  // try to find the right one.\n  var i = state.pipes.indexOf(dest);\n  if (i === -1)\n    return this;\n\n  state.pipes.splice(i, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1)\n    state.pipes = state.pipes[0];\n\n  dest.emit(\'unpipe\', this);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function(ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  if (ev === \'data\' && !this._readableState.flowing)\n    emitDataEvents(this);\n\n  if (ev === \'readable\' && this.readable) {\n    var state = this._readableState;\n    if (!state.readableListening) {\n      state.readableListening = true;\n      state.emittedReadable = false;\n      state.needReadable = true;\n      if (!state.reading) {\n        this.read(0);\n      } else if (state.length) {\n        emitReadable(this, state);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function() {\n  emitDataEvents(this);\n  this.read(0);\n  this.emit(\'resume\');\n};\n\nReadable.prototype.pause = function() {\n  emitDataEvents(this, true);\n  this.emit(\'pause\');\n};\n\nfunction emitDataEvents(stream, startPaused) {\n  var state = stream._readableState;\n\n  if (state.flowing) {\n    // https://github.com/isaacs/readable-stream/issues/16\n    throw new Error(\'Cannot switch to old mode now.\');\n  }\n\n  var paused = startPaused || false;\n  var readable = false;\n\n  // convert to an old-style stream.\n  stream.readable = true;\n  stream.pipe = Stream.prototype.pipe;\n  stream.on = stream.addListener = Stream.prototype.on;\n\n  stream.on(\'readable\', function() {\n    readable = true;\n\n    var c;\n    while (!paused && (null !== (c = stream.read())))\n      stream.emit(\'data\', c);\n\n    if (c === null) {\n      readable = false;\n      stream._readableState.needReadable = true;\n    }\n  });\n\n  stream.pause = function() {\n    paused = true;\n    this.emit(\'pause\');\n  };\n\n  stream.resume = function() {\n    paused = false;\n    if (readable)\n      process.nextTick(function() {\n        stream.emit(\'readable\');\n      });\n    else\n      this.read(0);\n    this.emit(\'resume\');\n  };\n\n  // now make it start, just in case it hadn\'t already.\n  stream.emit(\'readable\');\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function(stream) {\n  var state = this._readableState;\n  var paused = false;\n\n  var self = this;\n  stream.on(\'end\', function() {\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length)\n        self.push(chunk);\n    }\n\n    self.push(null);\n  });\n\n  stream.on(\'data\', function(chunk) {\n    if (state.decoder)\n      chunk = state.decoder.write(chunk);\n    if (!chunk || !state.objectMode && !chunk.length)\n      return;\n\n    var ret = self.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (typeof stream[i] === \'function\' &&\n        typeof this[i] === \'undefined\') {\n      this[i] = function(method) { return function() {\n        return stream[method].apply(stream, arguments);\n      }}(i);\n    }\n  }\n\n  // proxy certain important events.\n  var events = [\'error\', \'close\', \'destroy\', \'pause\', \'resume\'];\n  events.forEach(function(ev) {\n    stream.on(ev, self.emit.bind(self, ev));\n  });\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  self._read = function(n) {\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return self;\n};\n\n\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\nfunction fromList(n, state) {\n  var list = state.buffer;\n  var length = state.length;\n  var stringMode = !!state.decoder;\n  var objectMode = !!state.objectMode;\n  var ret;\n\n  // nothing in the list, definitely empty.\n  if (list.length === 0)\n    return null;\n\n  if (length === 0)\n    ret = null;\n  else if (objectMode)\n    ret = list.shift();\n  else if (!n || n >= length) {\n    // read it all, truncate the array.\n    if (stringMode)\n      ret = list.join(\'\');\n    else\n      ret = Buffer.concat(list, length);\n    list.length = 0;\n  } else {\n    // read just some of it.\n    if (n < list[0].length) {\n      // just take a part of the first list item.\n      // slice is the same for buffers and strings.\n      var buf = list[0];\n      ret = buf.slice(0, n);\n      list[0] = buf.slice(n);\n    } else if (n === list[0].length) {\n      // first list is a perfect match\n      ret = list.shift();\n    } else {\n      // complex case.\n      // we have enough to cover it, but it spans past the first buffer.\n      if (stringMode)\n        ret = \'\';\n      else\n        ret = new Buffer(n);\n\n      var c = 0;\n      for (var i = 0, l = list.length; i < l && c < n; i++) {\n        var buf = list[0];\n        var cpy = Math.min(n - c, buf.length);\n\n        if (stringMode)\n          ret += buf.slice(0, cpy);\n        else\n          buf.copy(ret, c, 0, cpy);\n\n        if (cpy < buf.length)\n          list[0] = buf.slice(cpy);\n        else\n          list.shift();\n\n        c += cpy;\n      }\n    }\n  }\n\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0)\n    throw new Error(\'endReadable called on non-empty stream\');\n\n  if (!state.endEmitted && state.calledRead) {\n    state.ended = true;\n    process.nextTick(function() {\n      // Check that we didn\'t get one last unshift.\n      if (!state.endEmitted && state.length === 0) {\n        state.endEmitted = true;\n        stream.readable = false;\n        stream.emit(\'end\');\n      }\n    });\n  }\n}\n\n})(require("__browserify_process"),require("__browserify_buffer").Buffer)\n},{"__browserify_buffer":8,"__browserify_process":9,"events":10,"stream":16,"string_decoder/":76,"util":11}],47:[function(require,module,exports){\nmodule.exports = to\n\nvar base64 = require(\'base64-js\')\n  , toutf8 = require(\'to-utf8\')\n\nvar encoders = {\n    hex: to_hex\n  , utf8: to_utf\n  , base64: to_base64\n}\n\nfunction to(buf, encoding) {\n  return encoders[encoding || \'utf8\'](buf)\n}\n\nfunction to_hex(buf) {\n  var str = \'\'\n    , byt\n\n  for(var i = 0, len = buf.length; i < len; ++i) {\n    byt = buf[i]\n    str += ((byt & 0xF0) >>> 4).toString(16)\n    str += (byt & 0x0F).toString(16)\n  }\n\n  return str\n}\n\nfunction to_utf(buf) {\n  return toutf8(buf)\n}\n\nfunction to_base64(buf) {\n  return base64.fromByteArray(buf)\n}\n\n\n},{"base64-js":77,"to-utf8":78}],48:[function(require,module,exports){\nmodule.exports = from\n\nvar base64 = require(\'base64-js\')\n\nvar decoders = {\n    hex: from_hex\n  , utf8: from_utf\n  , base64: from_base64\n}\n\nfunction from(source, encoding) {\n  if(Array.isArray(source)) {\n    return new Uint8Array(source)\n  }\n\n  return decoders[encoding || \'utf8\'](source)\n}\n\nfunction from_hex(str) {\n  var size = str.length / 2\n    , buf = new Uint8Array(size)\n    , character = \'\'\n\n  for(var i = 0, len = str.length; i < len; ++i) {\n    character += str.charAt(i)\n\n    if(i > 0 && (i % 2) === 1) {\n      buf[i>>>1] = parseInt(character, 16)\n      character = \'\' \n    }\n  }\n\n  return buf \n}\n\nfunction from_utf(str) {\n  var arr = []\n    , code\n\n  for(var i = 0, len = str.length; i < len; ++i) {\n    code = fixed_cca(str, i)\n\n    if(code === false) {\n      continue\n    }\n\n    if(code < 0x80) {\n      arr[arr.length] = code\n\n      continue\n    }\n\n    codepoint_to_bytes(arr, code)\n  }\n\n  return new Uint8Array(arr)\n}\n\nfunction codepoint_to_bytes(arr, code) {\n  // find MSB, use that to determine byte count\n  var copy_code = code\n    , bit_count = 0\n    , byte_count\n    , prefix\n    , _byte\n    , pos\n\n  do {\n    ++bit_count\n  } while(copy_code >>>= 1)\n\n  byte_count = Math.ceil((bit_count - 1) / 5) | 0\n  prefix = [0, 0, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc][byte_count]\n  pos = [0, 0, 3, 4, 5, 6, 7][byte_count]\n\n  _byte |= prefix\n\n  bit_count = (7 - pos) + 6 * (byte_count - 1)\n\n  while(bit_count) {\n    _byte |= +!!(code & (1 << bit_count)) << (7 - pos)\n    ++pos\n\n    if(pos % 8 === 0) {\n      arr[arr.length] = _byte\n      _byte = 0x80\n      pos = 2\n    }\n\n    --bit_count\n  }\n\n  if(pos) {\n    _byte |= +!!(code & 1) << (7 - pos)\n    arr[arr.length] = _byte\n  }\n}\n\nfunction pad(str) {\n  while(str.length < 8) {\n    str = \'0\' + str\n  }\n\n  return str\n}\n\nfunction fixed_cca(str, idx) {\n  idx = idx || 0\n\n  var code = str.charCodeAt(idx)\n    , lo\n    , hi\n\n  if(0xD800 <= code && code <= 0xDBFF) {\n    lo = str.charCodeAt(idx + 1)\n    hi = code\n\n    if(isNaN(lo)) {\n      throw new Error(\'High surrogate not followed by low surrogate\')\n    }\n\n    return ((hi - 0xD800) * 0x400) + (lo - 0xDC00) + 0x10000\n  }\n\n  if(0xDC00 <= code && code <= 0xDFFF) {\n    return false\n  }\n\n  return code\n}\n\nfunction from_base64(str) {\n  return new Uint8Array(base64.toByteArray(str)) \n}\n\n},{"base64-js":77}],76:[function(require,module,exports){\n(function(){// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar Buffer = require(\'buffer\').Buffer;\n\nvar isBufferEncoding = Buffer.isEncoding\n  || function(encoding) {\n       switch (encoding && encoding.toLowerCase()) {\n         case \'hex\': case \'utf8\': case \'utf-8\': case \'ascii\': case \'binary\': case \'base64\': case \'ucs2\': case \'ucs-2\': case \'utf16le\': case \'utf-16le\': case \'raw\': return true;\n         default: return false;\n       }\n     }\n\n\nfunction assertEncoding(encoding) {\n  if (encoding && !isBufferEncoding(encoding)) {\n    throw new Error(\'Unknown encoding: \' + encoding);\n  }\n}\n\nvar StringDecoder = exports.StringDecoder = function(encoding) {\n  this.encoding = (encoding || \'utf8\').toLowerCase().replace(/[-_]/, \'\');\n  assertEncoding(encoding);\n  switch (this.encoding) {\n    case \'utf8\':\n      // CESU-8 represents each of Surrogate Pair by 3-bytes\n      this.surrogateSize = 3;\n      break;\n    case \'ucs2\':\n    case \'utf16le\':\n      // UTF-16 represents each of Surrogate Pair by 2-bytes\n      this.surrogateSize = 2;\n      this.detectIncompleteChar = utf16DetectIncompleteChar;\n      break;\n    case \'base64\':\n      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.\n      this.surrogateSize = 3;\n      this.detectIncompleteChar = base64DetectIncompleteChar;\n      break;\n    default:\n      this.write = passThroughWrite;\n      return;\n  }\n\n  this.charBuffer = new Buffer(6);\n  this.charReceived = 0;\n  this.charLength = 0;\n};\n\n\nStringDecoder.prototype.write = function(buffer) {\n  var charStr = \'\';\n  var offset = 0;\n\n  // if our last write ended with an incomplete multibyte character\n  while (this.charLength) {\n    // determine how many remaining bytes this buffer has to offer for this char\n    var i = (buffer.length >= this.charLength - this.charReceived) ?\n                this.charLength - this.charReceived :\n                buffer.length;\n\n    // add the new bytes to the char buffer\n    buffer.copy(this.charBuffer, this.charReceived, offset, i);\n    this.charReceived += (i - offset);\n    offset = i;\n\n    if (this.charReceived < this.charLength) {\n      // still not enough chars in this buffer? wait for more ...\n      return \'\';\n    }\n\n    // get the character that was split\n    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);\n\n    // lead surrogate (D800-DBFF) is also the incomplete character\n    var charCode = charStr.charCodeAt(charStr.length - 1);\n    if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n      this.charLength += this.surrogateSize;\n      charStr = \'\';\n      continue;\n    }\n    this.charReceived = this.charLength = 0;\n\n    // if there are no more bytes in this buffer, just emit our char\n    if (i == buffer.length) return charStr;\n\n    // otherwise cut off the characters end from the beginning of this buffer\n    buffer = buffer.slice(i, buffer.length);\n    break;\n  }\n\n  var lenIncomplete = this.detectIncompleteChar(buffer);\n\n  var end = buffer.length;\n  if (this.charLength) {\n    // buffer the incomplete character bytes we got\n    buffer.copy(this.charBuffer, 0, buffer.length - lenIncomplete, end);\n    this.charReceived = lenIncomplete;\n    end -= lenIncomplete;\n  }\n\n  charStr += buffer.toString(this.encoding, 0, end);\n\n  var end = charStr.length - 1;\n  var charCode = charStr.charCodeAt(end);\n  // lead surrogate (D800-DBFF) is also the incomplete character\n  if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n    var size = this.surrogateSize;\n    this.charLength += size;\n    this.charReceived += size;\n    this.charBuffer.copy(this.charBuffer, size, 0, size);\n    this.charBuffer.write(charStr.charAt(charStr.length - 1), this.encoding);\n    return charStr.substring(0, end);\n  }\n\n  // or just emit the charStr\n  return charStr;\n};\n\nStringDecoder.prototype.detectIncompleteChar = function(buffer) {\n  // determine how many bytes we have to check at the end of this buffer\n  var i = (buffer.length >= 3) ? 3 : buffer.length;\n\n  // Figure out if one of the last i bytes of our buffer announces an\n  // incomplete char.\n  for (; i > 0; i--) {\n    var c = buffer[buffer.length - i];\n\n    // See http://en.wikipedia.org/wiki/UTF-8#Description\n\n    // 110XXXXX\n    if (i == 1 && c >> 5 == 0x06) {\n      this.charLength = 2;\n      break;\n    }\n\n    // 1110XXXX\n    if (i <= 2 && c >> 4 == 0x0E) {\n      this.charLength = 3;\n      break;\n    }\n\n    // 11110XXX\n    if (i <= 3 && c >> 3 == 0x1E) {\n      this.charLength = 4;\n      break;\n    }\n  }\n\n  return i;\n};\n\nStringDecoder.prototype.end = function(buffer) {\n  var res = \'\';\n  if (buffer && buffer.length)\n    res = this.write(buffer);\n\n  if (this.charReceived) {\n    var cr = this.charReceived;\n    var buf = this.charBuffer;\n    var enc = this.encoding;\n    res += buf.slice(0, cr).toString(enc);\n  }\n\n  return res;\n};\n\nfunction passThroughWrite(buffer) {\n  return buffer.toString(this.encoding);\n}\n\nfunction utf16DetectIncompleteChar(buffer) {\n  var incomplete = this.charReceived = buffer.length % 2;\n  this.charLength = incomplete ? 2 : 0;\n  return incomplete;\n}\n\nfunction base64DetectIncompleteChar(buffer) {\n  var incomplete = this.charReceived = buffer.length % 3;\n  this.charLength = incomplete ? 3 : 0;\n  return incomplete;\n}\n\n})()\n},{"buffer":17}],77:[function(require,module,exports){\n(function (exports) {\n\t\'use strict\';\n\n\tvar lookup = \'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\';\n\n\tfunction b64ToByteArray(b64) {\n\t\tvar i, j, l, tmp, placeHolders, arr;\n\t\n\t\tif (b64.length % 4 > 0) {\n\t\t\tthrow \'Invalid string. Length must be a multiple of 4\';\n\t\t}\n\n\t\t// the number of equal signs (place holders)\n\t\t// if there are two placeholders, than the two characters before it\n\t\t// represent one byte\n\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t// this is just a cheap hack to not do indexOf twice\n\t\tplaceHolders = b64.indexOf(\'=\');\n\t\tplaceHolders = placeHolders > 0 ? b64.length - placeHolders : 0;\n\n\t\t// base64 is 4/3 + up to two characters of the original data\n\t\tarr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);\n\n\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length;\n\n\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);\n\t\t\tarr.push((tmp & 0xFF0000) >> 16);\n\t\t\tarr.push((tmp & 0xFF00) >> 8);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t}\n\n\t\tif (placeHolders === 2) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t} else if (placeHolders === 1) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);\n\t\t\tarr.push((tmp >> 8) & 0xFF);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t}\n\n\t\treturn arr;\n\t}\n\n\tfunction uint8ToBase64(uint8) {\n\t\tvar i,\n\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\toutput = "",\n\t\t\ttemp, length;\n\n\t\tfunction tripletToBase64 (num) {\n\t\t\treturn lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n\t\t};\n\n\t\t// go through the array every three bytes, we\'ll deal with trailing stuff later\n\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);\n\t\t\toutput += tripletToBase64(temp);\n\t\t}\n\n\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\tswitch (extraBytes) {\n\t\t\tcase 1:\n\t\t\t\ttemp = uint8[uint8.length - 1];\n\t\t\t\toutput += lookup[temp >> 2];\n\t\t\t\toutput += lookup[(temp << 4) & 0x3F];\n\t\t\t\toutput += \'==\';\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);\n\t\t\t\toutput += lookup[temp >> 10];\n\t\t\t\toutput += lookup[(temp >> 4) & 0x3F];\n\t\t\t\toutput += lookup[(temp << 2) & 0x3F];\n\t\t\t\toutput += \'=\';\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn output;\n\t}\n\n\tmodule.exports.toByteArray = b64ToByteArray;\n\tmodule.exports.fromByteArray = uint8ToBase64;\n}());\n\n},{}],78:[function(require,module,exports){\nmodule.exports = to_utf8\n\nvar out = []\n  , col = []\n  , fcc = String.fromCharCode\n  , mask = [0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01]\n  , unmask = [\n      0x00\n    , 0x01\n    , 0x02 | 0x01\n    , 0x04 | 0x02 | 0x01\n    , 0x08 | 0x04 | 0x02 | 0x01\n    , 0x10 | 0x08 | 0x04 | 0x02 | 0x01\n    , 0x20 | 0x10 | 0x08 | 0x04 | 0x02 | 0x01\n    , 0x40 | 0x20 | 0x10 | 0x08 | 0x04 | 0x02 | 0x01\n  ]\n\nfunction to_utf8(bytes, start, end) {\n  start = start === undefined ? 0 : start\n  end = end === undefined ? bytes.length : end\n\n  var idx = 0\n    , hi = 0x80\n    , collecting = 0\n    , pos\n    , by\n\n  col.length =\n  out.length = 0\n\n  while(idx < bytes.length) {\n    by = bytes[idx]\n    if(!collecting && by & hi) {\n      pos = find_pad_position(by)\n      collecting += pos\n      if(pos < 8) {\n        col[col.length] = by & unmask[6 - pos]\n      }\n    } else if(collecting) {\n      col[col.length] = by & unmask[6]\n      --collecting\n      if(!collecting && col.length) {\n        out[out.length] = fcc(reduced(col, pos))\n        col.length = 0\n      }\n    } else { \n      out[out.length] = fcc(by)\n    }\n    ++idx\n  }\n  if(col.length && !collecting) {\n    out[out.length] = fcc(reduced(col, pos))\n    col.length = 0\n  }\n  return out.join(\'\')\n}\n\nfunction find_pad_position(byt) {\n  for(var i = 0; i < 7; ++i) {\n    if(!(byt & mask[i])) {\n      break\n    }\n  }\n  return i\n}\n\nfunction reduced(list) {\n  var out = 0\n  for(var i = 0, len = list.length; i < len; ++i) {\n    out |= list[i] << ((len - i - 1) * 6)\n  }\n  return out\n}\n\n},{}],57:[function(require,module,exports){\nmodule.exports = from\n\nvar base64 = require(\'base64-js\')\n\nvar decoders = {\n    hex: from_hex\n  , utf8: from_utf\n  , base64: from_base64\n}\n\nfunction from(source, encoding) {\n  if(Array.isArray(source)) {\n    return new Uint8Array(source)\n  }\n\n  return decoders[encoding || \'utf8\'](source)\n}\n\nfunction from_hex(str) {\n  var size = str.length / 2\n    , buf = new Uint8Array(size)\n    , character = \'\'\n\n  for(var i = 0, len = str.length; i < len; ++i) {\n    character += str.charAt(i)\n\n    if(i > 0 && (i % 2) === 1) {\n      buf[i>>>1] = parseInt(character, 16)\n      character = \'\' \n    }\n  }\n\n  return buf \n}\n\nfunction from_utf(str) {\n  var bytes = []\n    , tmp\n    , ch\n\n  for(var i = 0, len = str.length; i < len; ++i) {\n    ch = str.charCodeAt(i)\n    if(ch & 0x80) {\n      tmp = encodeURIComponent(str.charAt(i)).substr(1).split(\'%\')\n      for(var j = 0, jlen = tmp.length; j < jlen; ++j) {\n        bytes[bytes.length] = parseInt(tmp[j], 16)\n      }\n    } else {\n      bytes[bytes.length] = ch \n    }\n  }\n\n  return new Uint8Array(bytes)\n}\n\nfunction from_base64(str) {\n  return new Uint8Array(base64.toByteArray(str)) \n}\n\n},{"base64-js":79}],58:[function(require,module,exports){\nmodule.exports = to\n\nvar base64 = require(\'base64-js\')\n  , toutf8 = require(\'to-utf8\')\n\nvar encoders = {\n    hex: to_hex\n  , utf8: to_utf\n  , base64: to_base64\n}\n\nfunction to(buf, encoding) {\n  return encoders[encoding || \'utf8\'](buf)\n}\n\nfunction to_hex(buf) {\n  var str = \'\'\n    , byt\n\n  for(var i = 0, len = buf.length; i < len; ++i) {\n    byt = buf[i]\n    str += ((byt & 0xF0) >>> 4).toString(16)\n    str += (byt & 0x0F).toString(16)\n  }\n\n  return str\n}\n\nfunction to_utf(buf) {\n  return toutf8(buf)\n}\n\nfunction to_base64(buf) {\n  return base64.fromByteArray(buf)\n}\n\n\n},{"base64-js":79,"to-utf8":80}],75:[function(require,module,exports){\n(function () {\n\t"use strict";\n\n\t// modified from https://github.com/kriskowal/es5-shim\n\tvar has = Object.prototype.hasOwnProperty,\n\t\ttoString = Object.prototype.toString,\n\t\tforEach = require(\'./foreach\'),\n\t\tisArgs = require(\'./isArguments\'),\n\t\thasDontEnumBug = !({\'toString\': null}).propertyIsEnumerable(\'toString\'),\n\t\thasProtoEnumBug = (function () {}).propertyIsEnumerable(\'prototype\'),\n\t\tdontEnums = [\n\t\t\t"toString",\n\t\t\t"toLocaleString",\n\t\t\t"valueOf",\n\t\t\t"hasOwnProperty",\n\t\t\t"isPrototypeOf",\n\t\t\t"propertyIsEnumerable",\n\t\t\t"constructor"\n\t\t],\n\t\tkeysShim;\n\n\tkeysShim = function keys(object) {\n\t\tvar isObject = object !== null && typeof object === \'object\',\n\t\t\tisFunction = toString.call(object) === \'[object Function]\',\n\t\t\tisArguments = isArgs(object),\n\t\t\ttheKeys = [];\n\n\t\tif (!isObject && !isFunction && !isArguments) {\n\t\t\tthrow new TypeError("Object.keys called on a non-object");\n\t\t}\n\n\t\tif (isArguments) {\n\t\t\tforEach(object, function (value) {\n\t\t\t\ttheKeys.push(value);\n\t\t\t});\n\t\t} else {\n\t\t\tvar name,\n\t\t\t\tskipProto = hasProtoEnumBug && isFunction;\n\n\t\t\tfor (name in object) {\n\t\t\t\tif (!(skipProto && name === \'prototype\') && has.call(object, name)) {\n\t\t\t\t\ttheKeys.push(name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (hasDontEnumBug) {\n\t\t\tvar ctor = object.constructor,\n\t\t\t\tskipConstructor = ctor && ctor.prototype === object;\n\n\t\t\tforEach(dontEnums, function (dontEnum) {\n\t\t\t\tif (!(skipConstructor && dontEnum === \'constructor\') && has.call(object, dontEnum)) {\n\t\t\t\t\ttheKeys.push(dontEnum);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn theKeys;\n\t};\n\n\tmodule.exports = keysShim;\n}());\n\n\n},{"./foreach":81,"./isArguments":82}],79:[function(require,module,exports){\n(function (exports) {\n\t\'use strict\';\n\n\tvar lookup = \'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\';\n\n\tfunction b64ToByteArray(b64) {\n\t\tvar i, j, l, tmp, placeHolders, arr;\n\t\n\t\tif (b64.length % 4 > 0) {\n\t\t\tthrow \'Invalid string. Length must be a multiple of 4\';\n\t\t}\n\n\t\t// the number of equal signs (place holders)\n\t\t// if there are two placeholders, than the two characters before it\n\t\t// represent one byte\n\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t// this is just a cheap hack to not do indexOf twice\n\t\tplaceHolders = b64.indexOf(\'=\');\n\t\tplaceHolders = placeHolders > 0 ? b64.length - placeHolders : 0;\n\n\t\t// base64 is 4/3 + up to two characters of the original data\n\t\tarr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);\n\n\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length;\n\n\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);\n\t\t\tarr.push((tmp & 0xFF0000) >> 16);\n\t\t\tarr.push((tmp & 0xFF00) >> 8);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t}\n\n\t\tif (placeHolders === 2) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t} else if (placeHolders === 1) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);\n\t\t\tarr.push((tmp >> 8) & 0xFF);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t}\n\n\t\treturn arr;\n\t}\n\n\tfunction uint8ToBase64(uint8) {\n\t\tvar i,\n\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\toutput = "",\n\t\t\ttemp, length;\n\n\t\tfunction tripletToBase64 (num) {\n\t\t\treturn lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n\t\t};\n\n\t\t// go through the array every three bytes, we\'ll deal with trailing stuff later\n\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);\n\t\t\toutput += tripletToBase64(temp);\n\t\t}\n\n\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\tswitch (extraBytes) {\n\t\t\tcase 1:\n\t\t\t\ttemp = uint8[uint8.length - 1];\n\t\t\t\toutput += lookup[temp >> 2];\n\t\t\t\toutput += lookup[(temp << 4) & 0x3F];\n\t\t\t\toutput += \'==\';\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);\n\t\t\t\toutput += lookup[temp >> 10];\n\t\t\t\toutput += lookup[(temp >> 4) & 0x3F];\n\t\t\t\toutput += lookup[(temp << 2) & 0x3F];\n\t\t\t\toutput += \'=\';\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn output;\n\t}\n\n\tmodule.exports.toByteArray = b64ToByteArray;\n\tmodule.exports.fromByteArray = uint8ToBase64;\n}());\n\n},{}],80:[function(require,module,exports){\nmodule.exports = to_utf8\n\nvar out = []\n  , col = []\n  , fcc = String.fromCharCode\n  , mask = [0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01]\n  , unmask = [\n      0x00\n    , 0x01\n    , 0x02 | 0x01\n    , 0x04 | 0x02 | 0x01\n    , 0x08 | 0x04 | 0x02 | 0x01\n    , 0x10 | 0x08 | 0x04 | 0x02 | 0x01\n    , 0x20 | 0x10 | 0x08 | 0x04 | 0x02 | 0x01\n    , 0x40 | 0x20 | 0x10 | 0x08 | 0x04 | 0x02 | 0x01\n  ]\n\nfunction to_utf8(bytes, start, end) {\n  start = start === undefined ? 0 : start\n  end = end === undefined ? bytes.length : end\n\n  var idx = 0\n    , hi = 0x80\n    , collecting = 0\n    , pos\n    , by\n\n  col.length =\n  out.length = 0\n\n  while(idx < bytes.length) {\n    by = bytes[idx]\n    if(!collecting && by & hi) {\n      pos = find_pad_position(by)\n      collecting += pos\n      if(pos < 8) {\n        col[col.length] = by & unmask[6 - pos]\n      }\n    } else if(collecting) {\n      col[col.length] = by & unmask[6]\n      --collecting\n      if(!collecting && col.length) {\n        out[out.length] = fcc(reduced(col, pos))\n        col.length = 0\n      }\n    } else { \n      out[out.length] = fcc(by)\n    }\n    ++idx\n  }\n  if(col.length && !collecting) {\n    out[out.length] = fcc(reduced(col, pos))\n    col.length = 0\n  }\n  return out.join(\'\')\n}\n\nfunction find_pad_position(byt) {\n  for(var i = 0; i < 7; ++i) {\n    if(!(byt & mask[i])) {\n      break\n    }\n  }\n  return i\n}\n\nfunction reduced(list) {\n  var out = 0\n  for(var i = 0, len = list.length; i < len; ++i) {\n    out |= list[i] << ((len - i - 1) * 6)\n  }\n  return out\n}\n\n},{}],81:[function(require,module,exports){\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toString = Object.prototype.toString;\n\nvar isFunction = function (fn) {\n\tvar isFunc = (typeof fn === \'function\' && !(fn instanceof RegExp)) || toString.call(fn) === \'[object Function]\';\n\tif (!isFunc && typeof window !== \'undefined\') {\n\t\tisFunc = fn === window.setTimeout || fn === window.alert || fn === window.confirm || fn === window.prompt;\n\t}\n\treturn isFunc;\n};\n\nmodule.exports = function forEach(obj, fn) {\n\tif (!isFunction(fn)) {\n\t\tthrow new TypeError(\'iterator must be a function\');\n\t}\n\tvar i, k,\n\t\tisString = typeof obj === \'string\',\n\t\tl = obj.length,\n\t\tcontext = arguments.length > 2 ? arguments[2] : null;\n\tif (l === +l) {\n\t\tfor (i = 0; i < l; i++) {\n\t\t\tif (context === null) {\n\t\t\t\tfn(isString ? obj.charAt(i) : obj[i], i, obj);\n\t\t\t} else {\n\t\t\t\tfn.call(context, isString ? obj.charAt(i) : obj[i], i, obj);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (k in obj) {\n\t\t\tif (hasOwn.call(obj, k)) {\n\t\t\t\tif (context === null) {\n\t\t\t\t\tfn(obj[k], k, obj);\n\t\t\t\t} else {\n\t\t\t\t\tfn.call(context, obj[k], k, obj);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n\n},{}],82:[function(require,module,exports){\nvar toString = Object.prototype.toString;\n\nmodule.exports = function isArguments(value) {\n\tvar str = toString.call(value);\n\tvar isArguments = str === \'[object Arguments]\';\n\tif (!isArguments) {\n\t\tisArguments = str !== \'[object Array]\'\n\t\t\t&& value !== null\n\t\t\t&& typeof value === \'object\'\n\t\t\t&& typeof value.length === \'number\'\n\t\t\t&& value.length >= 0\n\t\t\t&& toString.call(value.callee) === \'[object Function]\';\n\t}\n\treturn isArguments;\n};\n\n\n},{}]},{},[1])\n;'],{type:"text/javascript"})));

    var repoPort = new MessageChannel()
    ndn.r.postMessage({uri: opts.prefix }, [repoPort.port1])
    nfd.postMessage({port: "repoPort"}, [repoPort.port2])
    app()
  }
  ndn.keygen.init(keyPort.port1, xinit);

}

ndn.initport = initmc.port2


window.control = ndn

ndn.tangle = function(remote, prefix) {
  var ms = new MessageChannel()
  var msg = {
    port: "modulePort",
    prefix: prefix
  }
  nfd.postMessage(msg, [ms.port1])
  remote.postMessage('connect', [ms.port2])
}


module.exports = ndn;

ndn.init({prefix: 'wiki'})




},{"./ndn-cache.js":18,"./ndn-dc.js":19,"./ndn-io.js":20,"./ndn-keygen.js":22,"./ndn-rtc.js":23,"./ndn-x.js":25,"./utils.js":26,"ndn-browser-shim":128}],13:[function(require,module,exports){
var ndn = require('ndn-browser-shim');
ndn.Faces = require('./ndn-Faces.js')
var strategy = require('./ndn-strategy.js');

var idb = require('idb-wrapper');


var FIB = {};

var fib = new idb({
  storeName: "FIB",
  dbVersion: 1,
  indexes: [
    {name: "faceID"},
    {name: "faceHash"},
    {name: "prefixURI"}
  ]
})

FIB.put = function(forwardingEntry) {
  console.log(forwardingEntry, ndn.Faces.list)
  if ((forwardingEntry.faceID == null) || (ndn.Faces.list[forwardingEntry.faceID].ndndid.toString() != forwardingEntry.ndndID.toString())) {
    for(i = 0; i < ndn.Faces.list.length; i++ ){
      if ((ndn.Faces.list[i].ndndid.toString() == forwardingEntry.ndndID.toString())) {
        forwardingEntry.faceID == i;
        var cromulent = true
        continue
      }
    }
  } else {
    var cromulent = true
  }

  if (cromulent) {

    var FIBEntry = {
      faceID: forwardingEntry.faceID,
      faceHash: forwardingEntry.ndndID.toString('hex'),
      prefixURI: forwardingEntry.prefixName.toUri()
    }
    fib.put(FIBEntry, function onSuccess(id){
      console.log('put FIBEntry at id: ', id)
    }, function onError(err){
      console.log('error inserting FIBEntry : ', FIBEntry, err)
    })
  }
}

FIB.lookupByName = function(name, onMatches) {
  var prefixes = [];

  function getAllPrefixes(name){
    var prefix = name.getPrefix(-1)
    prefixes.push(prefix.toUri())
    if (prefix.components.length > 0) {
      getAllPrefixes(prefix)
    }
  }

  var keyRanges = [];

  getAllPrefixes(name)

  for (var i = 0; i < prefixes.length; i++ ){
    var r = fib.makeKeyRange({
      only: prefixes[i]
    })
    keyRanges.push(r)
  }

  var allMatches = []

  function getMatchingEntries (keyRanges) {
    var range = keyRanges.pop()
    fib.query(function onSuccess(matches){
      allMatches = allMatches.concat(matches)
      if (keyRanges.length > 0){
        getMatchingEntries(keyRanges)
      } else {
        onMatches(allMatches)
      }
    },{
      index: "prefixURI",
      keyRange: range
    })
  }

  getMatchingEntries(keyRanges)
}


module.exports = FIB

},{"./ndn-Faces.js":14,"./ndn-strategy.js":24,"idb-wrapper":27,"ndn-browser-shim":128}],14:[function(require,module,exports){

var ndn = require('ndn-browser-shim');
ndn.globalKeyManager = require('./ndn-keyManager.js');

var Faces = {};

Faces.list = []

Faces.add = function(face){
  if (face.ndndid == undefined){
    face.ndndid = ndn.globalKeyManager.getKey().publicKeyDigest
  }
  Faces.list.push(face)
  face.id = Faces.list.length - 1
  return face.id
}


module.exports = Faces;

},{"./ndn-keyManager.js":21,"ndn-browser-shim":128}],15:[function(require,module,exports){
var ndn = require('ndn-browser-shim');
var BinaryXmlElementReader = ndn.BinaryXmlElementReader;
var ndnbuf = ndn.ndnbuf;
var Name = ndn.Name
var Data = ndn.Data
var LOG = require('./LOG.js')
var local = {}

local.transport = function (port) {
  this.port = port
};


/**
 * Connect to the host and port in face.  This replaces a previous connection and sets connectedHost
 *   and connectedPort.  Once connected, call onopenCallback().
 * Listen on the port to read an entire binary XML encoded element and call
 *    face.onReceivedElement(element).
 */
local.transport.prototype.connect = function(face, onopenCallback)
{
  this.elementReader = new BinaryXmlElementReader(face);
  var self = this;
  this.port.onmessage = function(ev) {
    //console.log('RecvHandle called on local face', result);

    if (ev.data == null || ev.data == undefined || ev.data == "") {
      console.log('INVALID ANSWER');
    }
    else if (ev.data instanceof ArrayBuffer) {
      var bytearray = new ndnbuf(ev.data);

      if (LOG > 3) console.log('BINARY RESPONSE IS ' + bytearray.toString('hex'));

      try {
        // Find the end of the binary XML element and call face.onReceivedElement.
        self.elementReader.onReceivedData(bytearray);
      } catch (ex) {
        console.log("NDN.ws.onmessage exception: " + ex);
        return;
      }
      // garbage collect arraybuffer
      //var ms = new MessageChannel()
      //ms.port1.postMessage(ev.data, [ev.data])
    }
  };

  onopenCallback();

};

/**
 * Send the Uint8Array data.
 */
local.transport.prototype.send = function(data)
{
  if (true) {
        // If we directly use data.buffer to feed ws.send(),
        // WebSocket may end up sending a packet with 10000 bytes of data.
        // That is, WebSocket will flush the entire buffer
        // regardless of the offset of the Uint8Array. So we have to create
        // a new Uint8Array buffer with just the right size and copy the
        // content from binaryInterest to the new buffer.
        //    ---Wentao
        var bytearray = new Uint8Array(data.length);
        bytearray.set(data);
        this.port.postMessage(bytearray.buffer);

        //garbage collect
        //var ms = new MessageChannel();
        //ms.port1.postMessage(bytearray.buffer, [bytearray.buffer])
        //ms.port1.postMessage(data.buffer, [data.buffer])
    console.log('local.send() returned.');
  }
  else
    console.log('local connection is not established.');
};

module.exports = local;

},{"./LOG.js":11,"ndn-browser-shim":128}],16:[function(require,module,exports){
var ndn = require('ndn-browser-shim');
ndn.Faces = require('./ndn-Faces.js')
var strategy = require('./ndn-strategy.js');

var idb = require('idb-wrapper');

var pit = new idb({
  storeName: "PITable",
  dbVersion: 1,
  keyPath: 'nonce',
  autoIncrement: false,
  indexes: [
    {name: "faceID"},
    {name: "uri"},
    {name: "prefixURIs", multiEntry: true},
    {name: "publisherPublicKeyDigest"},
    {name: "facePubKeyDigest"},
    {name: "expirationAbsoluteMsec"}
  ]
}, function(){
  console.log('PITable Ready, clearing out Interests that expired while we were gone...');
  var keyRange = pit.makeKeyRange({
    upper: Date.now(),
    lower: 0
  })

  pit.query(function onSuccess(matchArray){
    var toRemove = []
    for (var i = 0; i < matchArray.length; i++){
      toRemove.push(matchArray[i].nonce)
    }
    pit.removeBatch(toRemove, function onSuccess(){
      console.log('successfully garbage collected old PITEntrys')
    }, function onError(err){
      console.log('something went wrong removing old PITEntrys ', err)
    })
  }, {
    index: "expirationAbsoluteMsec",
    keyRange: keyRange,
    onError: function(err){
      console.log(err)
    }
  } )

  var setTimeoutKeyRange = pit.makeKeyRange({
    lower: Date.now()
  })

  pit.query(function onSuccess(matchArray){
    function clearEntry (nonce){
      pit.remove(nonce, function onSuccess(bool){
        console.log('remove Timeout PITEntry: ', bool)
      }, function onError(err){
        console.log('error removing timed out Pitentry, ', err)
      })
    }
    for (var i = 0; i < matchArray.length; i++){
      var time = matchArray[i].expirationAbsoluteMsec - Date.now()
      setTimeout(clearEntry, time, matchArray[i].nonce)
    }
  },{
    index: "expirationAbsoluteMsec",
    keyRange: setTimeoutKeyRange,
    onError: function(err){
      console.log(err)
    }
  })
})

var PIT = {};

PIT.put = function(face, interestObj, interestBytes, forward){

  var prefixes = [];

  function getAllPrefixes(name){
    var prefix = name.getPrefix(-1)
    prefixes.push(prefix.toUri())
    if (prefix.components.length > 0) {
      getAllPrefixes(prefix)
    }
  }
  getAllPrefixes(interestObj.name)
  if (interestObj.publisherPublicKeyDigest) {
    var pubKeyDig = interestObj.publisherPublicKeyDigest.toString('hex')
  }
  var PITEntry = {
    nonce: interestObj.nonce.toString(),
    faceID: face.id,
    faceHash: face.ndndid.toString('hex'),
    publisherPublicKeyDigest: pubKeyDig || 'any',
    expirationAbsoluteMsec: (Date.now() + interestObj.interestLifetime),
    prefixURIs: prefixes,
    uri: interestObj.name.toUri(),
    encodedInterest: interestBytes
  }

  pit.put(PITEntry, function onSuccess(nonce){
    forward(face, interestBytes, interestObj)
    console.log(interestObj.interestLifetime, nonce, PITEntry, interestObj)
    function clearEntry (){
      pit.remove(nonce, function onSuccess(bool){
        console.log('remove Timeout PITEntry: ', bool)
      }, function onError(err){
        console.log('error removing timed out Pitentry, ', err)
      })
    }
    setTimeout(clearEntry, interestObj.interestLifetime)
  }, function onError(err){
    console.log('error inserting PITEntry', PITEntry, err)
  })



}

PIT.lookupData = function(data, bytes, onAck) {
  console.log('got data, looking up in PIT')
  function evaluatePitEntrys(PITEntrys){
    if (PITEntrys.length > 0) {
      onAck(data)
    }
    var sent = []
    for (var i = 0; i < PITEntrys.length; i++){
      var entry = PITEntrys[i]
      var faceID = entry.faceID
      var faceHash = entry.faceHash
      var inst = new ndn.Interest()
      inst.decode(PITEntrys[i].encodedInterest)
      try {
        console.log(inst.matchesName(data.name) , (sent[faceID] == undefined) , (ndn.Faces.list[faceID].ndndid.toString('hex') == faceHash))
        if (inst.matchesName(data.name) && (sent[faceID] == undefined) && (ndn.Faces.list[faceID].ndndid.toString('hex') == faceHash)) {
          ndn.Faces.list[faceID].transport.send(bytes)
          sent[faceID] == true
          pit.remove(entry.nonce)
        }
      } catch (err) {
        // this is where we would do some voodoo for long standing, delay tolerant stuff
        console.log(err)
      }
    }
  }


  var pubKeyRange = pit.makeKeyRange({
    only: data.signedInfo.publisher.publisherPublicKeyDigest.toString('hex')
  })

  pit.query(function onSuccess(matchPubKey){
    var anyPublisherKeyRange = pit.makeKeyRange({
      only: "any"
    })
    pit.query(function onSuccess(matchAny){
      var possiblePitEntrys = matchPubKey.concat(matchAny)
      evaluatePitEntrys(possiblePitEntrys);
    },{
      index: "publisherPublicKeyDigest",
      keyRange: anyPublisherKeyRange
    })
  }, {
    index: "publisherPublicKeyDigest",
    keyRange: pubKeyRange
  })
}

PIT.lookupName = function(name, callback){
  var keyRange = pit.makeKeyRange({
    only: name.toUri()
  })
  console.log('looking up name', name.toUri())

  pit.query(function onSuccess(matches){
    console.log('found matches, ', matches)
    callback(matches)
  }, {
    index: "prefixURIs",
    keyRange: keyRange
  })
}



module.exports = PIT;

},{"./ndn-Faces.js":14,"./ndn-strategy.js":24,"idb-wrapper":27,"ndn-browser-shim":128}],17:[function(require,module,exports){
var channelWrapper = function(dataChannel) {
  var ms = new MessageChannel()
  var backlog = []
  ms.port1.onmessage = function(e) {
    //console.log('got message from daemon bound for rtc', e)
    if (dataChannel.readyState == 'open') {
      dataChannel.send(e.data);
    } else {
      backlog.push(e)
    }

  }

  dataChannel.onmessage = function(e) {
    //console.log('got message from rtc bound for daemon', e)
    var result = e.data;
    ms.port1.postMessage(e.data);
  }

  dataChannel.onopen = function() {
    for (var i = backlog.length - 1; i >= 0; i--){
      ms.port1.onmessage(backlog.pop())
    }
  }

  var obj = {};
  obj.dc = dataChannel;
  obj.port = ms.port2;
  return obj
}

module.exports = channelWrapper

},{}],18:[function(require,module,exports){
var utils = require('./utils.js')
var ndn = require('ndn-browser-shim');

var level = require('levelup');
var memdown = require('memdown')
var sublevel = require('level-sublevel');
var superlevel = require('level-superlevel');
var ttl = require('level-ttl');
var db = sublevel(superlevel(ttl(level('cache',{db: memdown}))));



var cache = {}
cache.db = db

cache.check = function(interest,element, transport, onhit, onmiss) {
  var uri = interest.name.toUri(),
      contentKey = utils.initSegment(0),
      reverse;
      if ((interest.childSelector == 0) || (interest.childSelector == undefined)) {
        reverse = false;
      } else {
        reverse = true;
      };

  if (utils.endsWithSegmentNumber(interest.name)) {
    // A specific segment of a data object is being requested, so don't bother querying for loose matches, just return or drop
    var level = interest.name.getPrefix(-1).append(contentKey).toUri(),
        segmentNumber = utils.getSegmentInteger(interest.name);

    if (db.sublevels[level] != undefined) {
      db.sublevels[level].get(segmentNumber, function(err, data) {
        if (err == undefined) {
          onhit(data, transport)
        } else {
          onmiss(element, interest )
        }
      })
    } else {
      onmiss(element,interest)
    }
  } else {
    // A general interest. Interpret according to selectors and return the first segment of the best matching dataset
    var suffixIndex = 0;
    var hit = false
    function crawl(q, lastfail) {
      var cursor, start, end;
      //console.log(q)
      if (db.sublevels[q] != undefined) {
        cursor = db.sublevels[q]
        if (lastfail && (reverse == true)) {
          var tmp = lastfail[lastfail.length - 1]
          lastfail[lastfail.length - 1] = tmp - 1
          end = lastfail
        } else if (lastfail) {
          var tmp = lastfail[lastfail.length - 1]
          lastfail[lastfail.length - 1] = tmp + 1
          start = lastfail
        }
        var read = false
        cursor.createReadStream({start: start, end: end, reverse: reverse, limit: 1}).on('data', function(data) {
          read = true
          if ((interest.exclude == null) || (!interest.exclude.matches(new ndn.Name.Component(data.key)))) {
            console.log('Suffix is not excluded');
            if (data.key == contentKey) {
              console.log('got to data');
              if ((interest.minSuffixComponents == null) || (suffixIndex >= interest.minSuffixComponents )) {
                console.log('more than minimum suffix components');
                db.sublevels[data.value].get(0, function(err, data){
                  if (interest.publisherPublicKeyDigest != undefined) {
                    var d = new ndn.Data()
                    d.decode(data)
                    if (ndn.DataUtils.arraysEqual(d.signedInfo.publisher.publisherPublicKeyDigest, interest.publisherPublicKeyDigest.publisherPublicKeyDigest)) {
                      onhit(data, transport)
                    } else {
                      crawl(q, contentKey)
                    }
                  } else {
                    onhit(data, transport)
                  }
                })
              } else {
                console.log('not enough suffix')
                crawl(q, contentKey)
              }
            } else {
              console.log('keep crawling')

              if ((interest.maxSuffixComponents == null) || (suffixIndex  < interest.maxSuffixComponents)) {
                suffixIndex++
                crawl(data.value)
              } else {
                console.log('reached max suffix');
                crawl(q,  data.key)
              }
            }

          } else {
            console.log('name component is excluded in interest,')
            crawl(q, data.key)
          }
        }).on('end', function(err,data){
          if ((read == false) && ((interest.minSuffixComponents == null) || (suffixIndex > interest.minSuffixComponents ))) {
            //we've exhasted this depth, need to go up a level, and we have the leeway from minSuffix to allow
            var comps = q.split('/')
            var fail = comps.pop()
            var newQ = '/' + comps.join('/')
            crawl(newQ, new ndn.Name.Component(fail).value)
          }

        })
      } else {
        onmiss(element,interest)
      }
    }
  crawl(uri)
  }
}


cache.data = function(data, element) {
  var segmentNumber = utils.getSegmentInteger(data.name),
      contentKey = utils.initSegment(0),
      levelName = data.name.getPrefix(-1).append(contentKey),
      level = levelName.toUri(),
      ttl;
  if (data.signedInfo.freshnessSeconds != undefined || 0) {
      ttl = data.signedInfo.freshnessSeconds * 1000
  }
  //console.log(level, segmentNumber, 'put in cache')
  db.sublevel(level).put(segmentNumber, element)
  var comps = level.split('/')
  //construct tree
  for (var i = comps.length - 1; i > 0; i-- ) {
    console.log(comps)
    var value = comps.join('/')
    var keyComp = comps.pop()
    if (keyComp == '%00') {
      var key = contentKey
    } else {
      var key = new ndn.Name.Component(keyComp).value
    }

    var slevel = comps.join('/') || '/'
    db.sublevel(slevel).put(key, value)

  }
}


module.exports = cache;

},{"./utils.js":26,"level-sublevel":29,"level-superlevel":41,"level-ttl":43,"levelup":53,"memdown":105,"ndn-browser-shim":128}],19:[function(require,module,exports){
var ndn = require('ndn-browser-shim');
var rtc = require('./ndn-rtc.js')
ndn.x = require('./ndn-x.js')
var FIB = require('./ndn-FIB.js')
//var Faces = require('./ndn-faces.js')
var rtcChannelWrapper = require('./ndn-RTCWorkerChannel.js')
var ndndc = {}

ndndc.accessDaemon = function(daemon) {
  this.daemon = daemon;
}

ndndc.add = function(uri, arg2, arg3, arg4) {
  // instead of TCP/UDP, we have available websockets (to wsproxy server) or webRTC dataChannels (to other browsers)
  var prefix = new ndn.Name(uri)
  if (arg2 == "rtc") {
    var ndndid = arg3
    var dataChannel = rtc.createDataChannel(ndndid, ndn.x.face) // we have to discover host and port via ICE etc. so use arg3 should contain the ndndid of the target to bootstrap signaling
    var wrapper = new rtcChannelWrapper(dataChannel);
    this.daemon.postMessage({port: "RTCPort", prefix: prefix, ndndid: ndndid}, [wrapper.port])

  } else if (arg2 == "th") {
    // asking for a telehash connection, arg3 = hashname (same as ndndid)
  } else if (typeof arg2 == "face") {
    var face = Faces[arg3]
    face.registerPrefix(new ndn.Name(uri))

  }

}


ndndc.registerPrefix = function (uri, targetID) {
  this.daemon.postMessage({command: "reqReg", uri: uri, ndndid: targetID})
}

ndndc.destroyFace = function(faceID) {
  Faces[faceID].transport.ws.close()
  delete Faces[faceID]
  for (var i = FIB.length - 1; i >= 0; i--) {
    if (FIB[i].faceID = faceID) {FIB.splice(i, 1)}
  }
}


module.exports = ndndc

},{"./ndn-FIB.js":13,"./ndn-RTCWorkerChannel.js":17,"./ndn-rtc.js":23,"./ndn-x.js":25,"ndn-browser-shim":128}],20:[function(require,module,exports){
var io = {};
var ndn = require('ndn-browser-shim')
io.worker = new Worker(window.URL.createObjectURL(new Blob([';(function(e,t,n){function i(n,s){if(!t[n]){if(!e[n]){var o=typeof require=="function"&&require;if(!s&&o)return o(n,!0);if(r)return r(n,!0);throw new Error("Cannot find module \'"+n+"\'")}var u=t[n]={exports:{}};e[n][0].call(u.exports,function(t){var r=e[n][1][t];return i(r?r:t)},u,u.exports)}return t[n].exports}var r=typeof require=="function"&&require;for(var s=0;s<n.length;s++)i(n[s]);return i})({1:[function(require,module,exports){\nvar ndn = require(\'ndn-browser-shim\');\nndn.globalKeyMangager = require(\'./ndn-keyManager.js\')\nvar utils = require(\'./utils.js\');\nvar channelTransport = require(\'./ndn-MessageChannelTransport.js\');\nvar io = {};\n\nonmessage = function(e){\n  if (e.data.port) {\n    if (e.data.port == "daemonPort") {\n      self.face = new ndn.Face({host:1,port:1,getTransport: function(){return new channelTransport.transport(e.ports[0])}})\n      self.face.transport.connect(self.face, function(){console.log("io face is connected to daemon")})\n    }\n  } else if (e.data.cert){\n    //console.log(\'setting keys\', e.data.cert, e.data.pubPem, e.data.priPem)\n    ndn.globalKeyManager.certificate = e.data.cert\n    ndn.globalKeyManager.publicKey = e.data.pubPem\n    ndn.globalKeyManager.privateKey = e.data.priPem\n    console.log(ndn.globalKeyManager)\n  } else if (e.data.command) {\n    if (e.data.command == "fetch") {\n      io.fetch(e.data)\n    } else if (e.data.command == "publish") {\n      io.publish(e.data)\n    } else if (e.data.command == "makeEncoded"){\n      io.makeEncoded(e.data)\n    }\n\n  }\n}\n\nio.makeEncoded = function(data) {\n  var d = new ndn.Data(new ndn.Name(data.uri), new ndn.SignedInfo(), data.bytes)\n  d.signedInfo.setFields()\n  d.sign()\n  var encoded = d.encode()\n  self.postMessage({responseTo: "makeEncoded", id: data.id, encoded: encoded})\n}\nio.fetch = function(opts) {\n\n  var interestsInFlight = 0;\n  var windowSize = 4;\n  var t0 = new Date().getTime()\n  var segmentRequested = [];\n  var whenNotGottenTriggered = false\n\n  var name = new ndn.Name(opts.uri)\n\n  if (opts.version) {\n    utils.appendVersion(name, opts.version);\n  }\n\n\n  var contentArray = [];\n\n  var recievedSegments = 0;\n\n  segmentRequested[interestsInFlight] = 0;\n\n  var masterInterest = new ndn.Interest(name)\n\n\n  if (opts.selectors != undefined) {\n    if (opts.selectors.publisherPublicKeyDigest != undefined) {\n      masterInterest.publisherPublicKeyDigest = new ndn.PublisherPublicKeyDigest(opts.selectors.publisherPublicKeyDigest)\n    }\n    if (opts.selectors.exclude != undefined) {\n      var comps = []\n      for (var i = 0; i < opts.selectors.exclude.length; i++) {\n        comps[i] = new ndn.Name.Component(opts.selectors.exclude[i])\n      }\n      masterInterest.exclude = new ndn.Exclude(comps)\n    }\n    if (opts.selectors.interestLifetime != undefined) {\n      masterInterest.interestLifetime = opts.selectors.interestLifetime;\n    }\n\n  }\n\n  var interest = new ndn.Interest(masterInterest);\n  utils.setNonce(interest)\n  var firstCo;\n  var onData = function(interest, co) {\n    interestsInFlight--;\n    console.log(interest)\n\n    var segmentNumber = utils.getSegmentInteger(co.name)\n    if (segmentNumber == 0) {\n      firstCo = co\n    }\n    var finalSegmentNumber = 1 + ndn.DataUtils.bigEndianToUnsignedInt(co.signedInfo.finalBlockID);\n    //console.log(segmentNumber, co.name.toUri());\n    if (contentArray[segmentNumber] == undefined) {\n      if (opts.type == \'object\') {\n        contentArray[segmentNumber] = (ndn.DataUtils.toString(co.content));\n      } else if (opts.type == \'blob\' || \'file\'){\n        contentArray[segmentNumber] = co.content;\n      }\n\n      recievedSegments++;\n    }\n\n    //console.log(recievedSegments, finalSegmentNumber, interestsInFlight);\n    if (recievedSegments == finalSegmentNumber) {\n        console.log(\'got all segment\', contentArray.length);\n        var t1 = new Date().getTime()\n        console.log(t1 - t0)\n        if (opts.type == "object") {\n          assembleObject(name);\n        } else if (opts.type == "blob" || "file") {\n          assembleBlob(name)\n        };\n\n    } else {\n      if (interestsInFlight < windowSize) {\n        for (var i = 0; i < finalSegmentNumber; i++) {\n          if ((contentArray[i] == undefined) && (segmentRequested[i] == undefined)) {\n            var newInterest = new ndn.Interest(masterInterest)\n            newInterest.name = new ndn.Name(co.name.getPrefix(-1).appendSegment(i))\n            utils.setNonce(newInterest)\n            self.face.expressInterest(newInterest, onData, onTimeout)\n            segmentRequested[i] = 0;\n            interestsInFlight++\n            if (interestsInFlight == windowSize) {\n              //stop iterating\n              i = finalSegmentNumber;\n            };\n          };\n        };\n      };\n    };\n  };\n  var onTimeout = function(interest) {\n    var seg = utils.getSegmentInteger(interest.name)\n    if (segmentRequested[seg] < 4) {\n      segmentRequested[seg]++\n      var newInterest = new ndn.Interest(interest);\n      utils.setNonce(newInterest)\n      self.face.expressInterest(newInterest, onData, onTimeout)\n\n    } else if ((whenNotGottenTriggered == false)) {\n      whenNotGottenTriggered = true;\n      console.log(segmentRequested)\n      self.postMessage({responseTo: "fetch", success: false, uri: name.toUri()})\n    }\n  };\n\n  var assembleBlob = function(name) {\n    var mime = name.components[2].toEscapedString() + \'/\' + name.components[3].toEscapedString()\n    var blob = new Blob(contentArray, {type: mime})\n    self.postMessage({responseTo: "fetch", success: true, uri: opts.uri, thing: blob, firstCo: firstCo});\n  };\n\n  var assembleObject = function(name) {\n    var string = "";\n    for (var i = 0; i < contentArray.length; i++) {\n      string += contentArray[i];\n    };\n    var obj = JSON.parse(string);\n    self.postMessage({responseTo: "fetch", success: true, uri: opts.uri, thing: obj, firstCo: firstCo});\n  };\n\n\n  //console.log(interest.name.toUri())\n\n  self.face.expressInterest(interest, onData, onTimeout);\n\n\n};\n\nio.publishFile = function(opts) {\n  //console.log( opts.thing)\n  var chunkSize = 7000,\n      fileSize = (opts.thing.size - 1),\n      totalSegments = Math.ceil(opts.thing.size / chunkSize),\n      name = new ndn.Name(opts.uri)\n\n\n  function getSlice(file, segment, transport) {\n    //console.log(file)\n    var fr = new FileReader(),\n        chunks = totalSegments,\n        start = segment * chunkSize,\n        end = start + chunkSize >= file.size ? file.size : start + chunkSize,\n        blob = file.slice(start,end);\n\n    fr.onloadend = function(e) {\n      var buff = new ndn.ndnbuf(e.target.result),\n          segmentName = (new ndn.Name(name)).appendSegment(segment),\n          data = new ndn.Data(segmentName, new ndn.SignedInfo(), buff),\n          encodedData;\n\n        data.signedInfo.setFields();\n        data.signedInfo.finalBlockID = utils.initSegment(totalSegments - 1);\n        data.sign();\n        encodedData = data.encode();\n\n        transport.send(encodedData);\n        var ms = new MessageChannel()\n        ms.port1.postMessage(e.target.result, [e.target.result])\n        //ms.port1.postMessage(buff.buffer, [buff.buffer])\n        if (segment == totalSegments -1) {\n          //remove closure from registeredPrefixTable\n          for (var i = 0; i < ndn.Face.registeredPrefixTable.length; i++) {\n            if (ndn.Face.registeredPrefixTable[i].prefix.match(new ndn.Name(name))) {\n              ndn.Face.registeredPrefixTable.splice(i,1);\n            }\n          }\n        }\n    };\n    //console.log("about to read as array buffer")\n    fr.readAsArrayBuffer(blob, (end - start))\n\n\n  };\n  //console.log(\'y u crashing?\')\n  function onInterest(prefix, interest, transport) {\n    //console.log("onInterest called.", opts);\n    if (!utils.endsWithSegmentNumber(interest.name)) {\n      interest.name.appendSegment(0);\n    };\n    var segment = ndn.DataUtils.bigEndianToUnsignedInt(interest.name.components[interest.name.components.length - 1].value);\n\n    getSlice(opts.thing, segment, transport)\n\n  };\n  //console.log(\'when u crashing?\')\n  function sendWriteCommand() {\n    var onTimeout = function (interest) {\n      console.log("timeout", interest);\n    };\n    var onData = function(data) {\n      console.log(data)\n    };\n    //console.log(name.toUri())\n    var command = name.getPrefix(- 1).append(new ndn.Name.Component([0xc1, 0x2e, 0x52, 0x2e, 0x73, 0x77])).append(utils.getSuffix(name, name.components.length - 1 ))\n    var interest = new ndn.Interest(command)\n    interest.interestLifetime = 4000\n    utils.setNonce(interest)\n    //console.log("did this time correctly?", command.toUri())\n    self.face.expressInterest(interest, onData, onTimeout);\n\n  };\n  var prefix = name\n  //console.log(name.toUri())\n  var closure = new ndn.Face.CallbackClosure(null, null, onInterest, prefix, self.face.transport);\n  ndn.Face.registeredPrefixTable.push(new RegisteredPrefix(prefix, closure));\n  console.log("publish defined")\n  setTimeout(sendWriteCommand, 0)\n\n};\n\nio.publishObject = function(opts) {\n  var returns = utils.chunkArbitraryData(opts)\n  var name = returns.name\n  var ndnArray = returns.array\n\n  var onInterest = function(prefix, interest, transport) {\n    var requestedSegment = utils.getSegmentInteger(interest.name)\n    console.log("got object interest", interest)\n    transport.send(ndnArray[requestedSegment])\n  };\n  var prefix = name\n\n  function sendWriteCommand() {\n    var onTimeout = function (interest) {\n      console.log("timeout", interest);\n    };\n    var onData = function(data) {\n      console.log(data)\n    };\n    var closure = new ndn.Face.CallbackClosure(null, null, onInterest, prefix, self.face.transport);\n    ndn.Face.registeredPrefixTable.push(new RegisteredPrefix(prefix, closure));\n\n    var command = name.getPrefix(- 1).append(new ndn.Name.Component([0xc1, 0x2e, 0x52, 0x2e, 0x73, 0x77])).append(utils.getSuffix(name, name.components.length - 1 ))\n    var interest = new ndn.Interest(command)\n    utils.setNonce(interest)\n    //console.log("did this time correctly?", command.toUri())\n    self.face.expressInterest(interest, onData, onTimeout);\n\n  };\n  setTimeout(sendWriteCommand, 0)\n};\n\nio.publish = function (opts) {\n  if (opts.type== "object") {\n    io.publishObject(opts)\n  } else if (opts.type == "file" || "blob" ) {\n    io.publishFile(opts)\n  }\n}\n\nfunction cb() {\n  var keyName = new ndn.Name(\'/%C1.M.S.localhost/%C1.M.SRV/ndnd/KEY\')\n  var inst = new ndn.Interest(keyName)\n\n}\nvar RegisteredPrefix = function RegisteredPrefix(prefix, closure)\n{\n  this.prefix = prefix;        // String\n  this.closure = closure;  // Closure\n};\n\n\nmodule.exports = io;\n\n\n\n},{"./ndn-MessageChannelTransport.js":4,"./ndn-keyManager.js":2,"./utils.js":3,"ndn-browser-shim":5}],6:[function(require,module,exports){\nvar LOG = 0\nmodule.exports = LOG;\n\n},{}],7:[function(require,module,exports){\nrequire=(function(e,t,n,r){function i(r){if(!n[r]){if(!t[r]){if(e)return e(r);throw new Error("Cannot find module \'"+r+"\'")}var s=n[r]={exports:{}};t[r][0](function(e){var n=t[r][1][e];return i(n?n:e)},s,s.exports)}return n[r].exports}for(var s=0;s<r.length;s++)i(r[s]);return i})(typeof require!=="undefined"&&require,{1:[function(require,module,exports){\nexports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {\n  var e, m,\n      eLen = nBytes * 8 - mLen - 1,\n      eMax = (1 << eLen) - 1,\n      eBias = eMax >> 1,\n      nBits = -7,\n      i = isBE ? 0 : (nBytes - 1),\n      d = isBE ? 1 : -1,\n      s = buffer[offset + i];\n\n  i += d;\n\n  e = s & ((1 << (-nBits)) - 1);\n  s >>= (-nBits);\n  nBits += eLen;\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);\n\n  m = e & ((1 << (-nBits)) - 1);\n  e >>= (-nBits);\n  nBits += mLen;\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);\n\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity);\n  } else {\n    m = m + Math.pow(2, mLen);\n    e = e - eBias;\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n};\n\nexports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {\n  var e, m, c,\n      eLen = nBytes * 8 - mLen - 1,\n      eMax = (1 << eLen) - 1,\n      eBias = eMax >> 1,\n      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),\n      i = isBE ? (nBytes - 1) : 0,\n      d = isBE ? -1 : 1,\n      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;\n\n  value = Math.abs(value);\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0;\n    e = eMax;\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2);\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * Math.pow(2, 1 - eBias);\n    }\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n      e = 0;\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);\n\n  e = (e << mLen) | m;\n  eLen += mLen;\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);\n\n  buffer[offset + i - d] |= s * 128;\n};\n\n},{}],2:[function(require,module,exports){\n(function(){// UTILITY\nvar util = require(\'util\');\nvar Buffer = require("buffer").Buffer;\nvar pSlice = Array.prototype.slice;\n\nfunction objectKeys(object) {\n  if (Object.keys) return Object.keys(object);\n  var result = [];\n  for (var name in object) {\n    if (Object.prototype.hasOwnProperty.call(object, name)) {\n      result.push(name);\n    }\n  }\n  return result;\n}\n\n// 1. The assert module provides functions that throw\n// AssertionError\'s when particular conditions are not met. The\n// assert module must conform to the following interface.\n\nvar assert = module.exports = ok;\n\n// 2. The AssertionError is defined in assert.\n// new assert.AssertionError({ message: message,\n//                             actual: actual,\n//                             expected: expected })\n\nassert.AssertionError = function AssertionError(options) {\n  this.name = \'AssertionError\';\n  this.message = options.message;\n  this.actual = options.actual;\n  this.expected = options.expected;\n  this.operator = options.operator;\n  var stackStartFunction = options.stackStartFunction || fail;\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, stackStartFunction);\n  }\n};\nutil.inherits(assert.AssertionError, Error);\n\nfunction replacer(key, value) {\n  if (value === undefined) {\n    return \'\' + value;\n  }\n  if (typeof value === \'number\' && (isNaN(value) || !isFinite(value))) {\n    return value.toString();\n  }\n  if (typeof value === \'function\' || value instanceof RegExp) {\n    return value.toString();\n  }\n  return value;\n}\n\nfunction truncate(s, n) {\n  if (typeof s == \'string\') {\n    return s.length < n ? s : s.slice(0, n);\n  } else {\n    return s;\n  }\n}\n\nassert.AssertionError.prototype.toString = function() {\n  if (this.message) {\n    return [this.name + \':\', this.message].join(\' \');\n  } else {\n    return [\n      this.name + \':\',\n      truncate(JSON.stringify(this.actual, replacer), 128),\n      this.operator,\n      truncate(JSON.stringify(this.expected, replacer), 128)\n    ].join(\' \');\n  }\n};\n\n// assert.AssertionError instanceof Error\n\nassert.AssertionError.__proto__ = Error.prototype;\n\n// At present only the three keys mentioned above are used and\n// understood by the spec. Implementations or sub modules can pass\n// other keys to the AssertionError\'s constructor - they will be\n// ignored.\n\n// 3. All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided.  All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n\nfunction fail(actual, expected, message, operator, stackStartFunction) {\n  throw new assert.AssertionError({\n    message: message,\n    actual: actual,\n    expected: expected,\n    operator: operator,\n    stackStartFunction: stackStartFunction\n  });\n}\n\n// EXTENSION! allows for well behaved errors defined elsewhere.\nassert.fail = fail;\n\n// 4. Pure assertion tests whether a value is truthy, as determined\n// by !!guard.\n// assert.ok(guard, message_opt);\n// This statement is equivalent to assert.equal(true, guard,\n// message_opt);. To test strictly for the value true, use\n// assert.strictEqual(true, guard, message_opt);.\n\nfunction ok(value, message) {\n  if (!!!value) fail(value, true, message, \'==\', assert.ok);\n}\nassert.ok = ok;\n\n// 5. The equality assertion tests shallow, coercive equality with\n// ==.\n// assert.equal(actual, expected, message_opt);\n\nassert.equal = function equal(actual, expected, message) {\n  if (actual != expected) fail(actual, expected, message, \'==\', assert.equal);\n};\n\n// 6. The non-equality assertion tests for whether two objects are not equal\n// with != assert.notEqual(actual, expected, message_opt);\n\nassert.notEqual = function notEqual(actual, expected, message) {\n  if (actual == expected) {\n    fail(actual, expected, message, \'!=\', assert.notEqual);\n  }\n};\n\n// 7. The equivalence assertion tests a deep equality relation.\n// assert.deepEqual(actual, expected, message_opt);\n\nassert.deepEqual = function deepEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected)) {\n    fail(actual, expected, message, \'deepEqual\', assert.deepEqual);\n  }\n};\n\nfunction _deepEqual(actual, expected) {\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n\n  } else if (Buffer.isBuffer(actual) && Buffer.isBuffer(expected)) {\n    if (actual.length != expected.length) return false;\n\n    for (var i = 0; i < actual.length; i++) {\n      if (actual[i] !== expected[i]) return false;\n    }\n\n    return true;\n\n  // 7.2. If the expected value is a Date object, the actual value is\n  // equivalent if it is also a Date object that refers to the same time.\n  } else if (actual instanceof Date && expected instanceof Date) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3. Other pairs that do not both pass typeof value == \'object\',\n  // equivalence is determined by ==.\n  } else if (typeof actual != \'object\' && typeof expected != \'object\') {\n    return actual == expected;\n\n  // 7.4. For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical \'prototype\' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else {\n    return objEquiv(actual, expected);\n  }\n}\n\nfunction isUndefinedOrNull(value) {\n  return value === null || value === undefined;\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) == \'[object Arguments]\';\n}\n\nfunction objEquiv(a, b) {\n  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))\n    return false;\n  // an identical \'prototype\' property.\n  if (a.prototype !== b.prototype) return false;\n  //~~~I\'ve managed to break Object.keys through screwy arguments passing.\n  //   Converting to array solves the problem.\n  if (isArguments(a)) {\n    if (!isArguments(b)) {\n      return false;\n    }\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return _deepEqual(a, b);\n  }\n  try {\n    var ka = objectKeys(a),\n        kb = objectKeys(b),\n        key, i;\n  } catch (e) {//happens when one is a string literal and the other isn\'t\n    return false;\n  }\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length != kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!_deepEqual(a[key], b[key])) return false;\n  }\n  return true;\n}\n\n// 8. The non-equivalence assertion tests for any deep inequality.\n// assert.notDeepEqual(actual, expected, message_opt);\n\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected)) {\n    fail(actual, expected, message, \'notDeepEqual\', assert.notDeepEqual);\n  }\n};\n\n// 9. The strict equality assertion tests strict equality, as determined by ===.\n// assert.strictEqual(actual, expected, message_opt);\n\nassert.strictEqual = function strictEqual(actual, expected, message) {\n  if (actual !== expected) {\n    fail(actual, expected, message, \'===\', assert.strictEqual);\n  }\n};\n\n// 10. The strict non-equality assertion tests for strict inequality, as\n// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);\n\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n  if (actual === expected) {\n    fail(actual, expected, message, \'!==\', assert.notStrictEqual);\n  }\n};\n\nfunction expectedException(actual, expected) {\n  if (!actual || !expected) {\n    return false;\n  }\n\n  if (expected instanceof RegExp) {\n    return expected.test(actual);\n  } else if (actual instanceof expected) {\n    return true;\n  } else if (expected.call({}, actual) === true) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction _throws(shouldThrow, block, expected, message) {\n  var actual;\n\n  if (typeof expected === \'string\') {\n    message = expected;\n    expected = null;\n  }\n\n  try {\n    block();\n  } catch (e) {\n    actual = e;\n  }\n\n  message = (expected && expected.name ? \' (\' + expected.name + \').\' : \'.\') +\n            (message ? \' \' + message : \'.\');\n\n  if (shouldThrow && !actual) {\n    fail(\'Missing expected exception\' + message);\n  }\n\n  if (!shouldThrow && expectedException(actual, expected)) {\n    fail(\'Got unwanted exception\' + message);\n  }\n\n  if ((shouldThrow && actual && expected &&\n      !expectedException(actual, expected)) || (!shouldThrow && actual)) {\n    throw actual;\n  }\n}\n\n// 11. Expected to throw an error:\n// assert.throws(block, Error_opt, message_opt);\n\nassert.throws = function(block, /*optional*/error, /*optional*/message) {\n  _throws.apply(this, [true].concat(pSlice.call(arguments)));\n};\n\n// EXTENSION! This is annoying to write outside this module.\nassert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {\n  _throws.apply(this, [false].concat(pSlice.call(arguments)));\n};\n\nassert.ifError = function(err) { if (err) {throw err;}};\n\n})()\n},{"util":3,"buffer":4}],"buffer-browserify":[function(require,module,exports){\nmodule.exports=require(\'q9TxCC\');\n},{}],"q9TxCC":[function(require,module,exports){\n(function(){function SlowBuffer (size) {\n    this.length = size;\n};\n\nvar assert = require(\'assert\');\n\nexports.INSPECT_MAX_BYTES = 50;\n\n\nfunction toHex(n) {\n  if (n < 16) return \'0\' + n.toString(16);\n  return n.toString(16);\n}\n\nfunction utf8ToBytes(str) {\n  var byteArray = [];\n  for (var i = 0; i < str.length; i++)\n    if (str.charCodeAt(i) <= 0x7F)\n      byteArray.push(str.charCodeAt(i));\n    else {\n      var h = encodeURIComponent(str.charAt(i)).substr(1).split(\'%\');\n      for (var j = 0; j < h.length; j++)\n        byteArray.push(parseInt(h[j], 16));\n    }\n\n  return byteArray;\n}\n\nfunction asciiToBytes(str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++ )\n    // Node\'s code seems to be doing this and not & 0x7F..\n    byteArray.push( str.charCodeAt(i) & 0xFF );\n\n  return byteArray;\n}\n\nfunction base64ToBytes(str) {\n  return require("base64-js").toByteArray(str);\n}\n\nSlowBuffer.byteLength = function (str, encoding) {\n  switch (encoding || "utf8") {\n    case \'hex\':\n      return str.length / 2;\n\n    case \'utf8\':\n    case \'utf-8\':\n      return utf8ToBytes(str).length;\n\n    case \'ascii\':\n    case \'binary\':\n      return str.length;\n\n    case \'base64\':\n      return base64ToBytes(str).length;\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n};\n\nfunction blitBuffer(src, dst, offset, length) {\n  var pos, i = 0;\n  while (i < length) {\n    if ((i+offset >= dst.length) || (i >= src.length))\n      break;\n\n    dst[i + offset] = src[i];\n    i++;\n  }\n  return i;\n}\n\nSlowBuffer.prototype.utf8Write = function (string, offset, length) {\n  var bytes, pos;\n  return SlowBuffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);\n};\n\nSlowBuffer.prototype.asciiWrite = function (string, offset, length) {\n  var bytes, pos;\n  return SlowBuffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);\n};\n\nSlowBuffer.prototype.binaryWrite = SlowBuffer.prototype.asciiWrite;\n\nSlowBuffer.prototype.base64Write = function (string, offset, length) {\n  var bytes, pos;\n  return SlowBuffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);\n};\n\nSlowBuffer.prototype.base64Slice = function (start, end) {\n  var bytes = Array.prototype.slice.apply(this, arguments)\n  return require("base64-js").fromByteArray(bytes);\n}\n\nfunction decodeUtf8Char(str) {\n  try {\n    return decodeURIComponent(str);\n  } catch (err) {\n    return String.fromCharCode(0xFFFD); // UTF 8 invalid char\n  }\n}\n\nSlowBuffer.prototype.utf8Slice = function () {\n  var bytes = Array.prototype.slice.apply(this, arguments);\n  var res = "";\n  var tmp = "";\n  var i = 0;\n  while (i < bytes.length) {\n    if (bytes[i] <= 0x7F) {\n      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);\n      tmp = "";\n    } else\n      tmp += "%" + bytes[i].toString(16);\n\n    i++;\n  }\n\n  return res + decodeUtf8Char(tmp);\n}\n\nSlowBuffer.prototype.asciiSlice = function () {\n  var bytes = Array.prototype.slice.apply(this, arguments);\n  var ret = "";\n  for (var i = 0; i < bytes.length; i++)\n    ret += String.fromCharCode(bytes[i]);\n  return ret;\n}\n\nSlowBuffer.prototype.binarySlice = SlowBuffer.prototype.asciiSlice;\n\nSlowBuffer.prototype.inspect = function() {\n  var out = [],\n      len = this.length;\n  for (var i = 0; i < len; i++) {\n    out[i] = toHex(this[i]);\n    if (i == exports.INSPECT_MAX_BYTES) {\n      out[i + 1] = \'...\';\n      break;\n    }\n  }\n  return \'<SlowBuffer \' + out.join(\' \') + \'>\';\n};\n\n\nSlowBuffer.prototype.hexSlice = function(start, end) {\n  var len = this.length;\n\n  if (!start || start < 0) start = 0;\n  if (!end || end < 0 || end > len) end = len;\n\n  var out = \'\';\n  for (var i = start; i < end; i++) {\n    out += toHex(this[i]);\n  }\n  return out;\n};\n\n\nSlowBuffer.prototype.toString = function(encoding, start, end) {\n  encoding = String(encoding || \'utf8\').toLowerCase();\n  start = +start || 0;\n  if (typeof end == \'undefined\') end = this.length;\n\n  // Fastpath empty strings\n  if (+end == start) {\n    return \'\';\n  }\n\n  switch (encoding) {\n    case \'hex\':\n      return this.hexSlice(start, end);\n\n    case \'utf8\':\n    case \'utf-8\':\n      return this.utf8Slice(start, end);\n\n    case \'ascii\':\n      return this.asciiSlice(start, end);\n\n    case \'binary\':\n      return this.binarySlice(start, end);\n\n    case \'base64\':\n      return this.base64Slice(start, end);\n\n    case \'ucs2\':\n    case \'ucs-2\':\n      return this.ucs2Slice(start, end);\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n};\n\n\nSlowBuffer.prototype.hexWrite = function(string, offset, length) {\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length;\n  if (strLen % 2) {\n    throw new Error(\'Invalid hex string\');\n  }\n  if (length > strLen / 2) {\n    length = strLen / 2;\n  }\n  for (var i = 0; i < length; i++) {\n    var byte = parseInt(string.substr(i * 2, 2), 16);\n    if (isNaN(byte)) throw new Error(\'Invalid hex string\');\n    this[offset + i] = byte;\n  }\n  SlowBuffer._charsWritten = i * 2;\n  return i;\n};\n\n\nSlowBuffer.prototype.write = function(string, offset, length, encoding) {\n  // Support both (string, offset, length, encoding)\n  // and the legacy (string, encoding, offset, length)\n  if (isFinite(offset)) {\n    if (!isFinite(length)) {\n      encoding = length;\n      length = undefined;\n    }\n  } else {  // legacy\n    var swap = encoding;\n    encoding = offset;\n    offset = length;\n    length = swap;\n  }\n\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n  encoding = String(encoding || \'utf8\').toLowerCase();\n\n  switch (encoding) {\n    case \'hex\':\n      return this.hexWrite(string, offset, length);\n\n    case \'utf8\':\n    case \'utf-8\':\n      return this.utf8Write(string, offset, length);\n\n    case \'ascii\':\n      return this.asciiWrite(string, offset, length);\n\n    case \'binary\':\n      return this.binaryWrite(string, offset, length);\n\n    case \'base64\':\n      return this.base64Write(string, offset, length);\n\n    case \'ucs2\':\n    case \'ucs-2\':\n      return this.ucs2Write(string, offset, length);\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n};\n\n\n// slice(start, end)\nSlowBuffer.prototype.slice = function(start, end) {\n  if (end === undefined) end = this.length;\n\n  if (end > this.length) {\n    throw new Error(\'oob\');\n  }\n  if (start > end) {\n    throw new Error(\'oob\');\n  }\n\n  return new Buffer(this, end - start, +start);\n};\n\nSlowBuffer.prototype.copy = function(target, targetstart, sourcestart, sourceend) {\n  var temp = [];\n  for (var i=sourcestart; i<sourceend; i++) {\n    assert.ok(typeof this[i] !== \'undefined\', "copying undefined buffer bytes!");\n    temp.push(this[i]);\n  }\n\n  for (var i=targetstart; i<targetstart+temp.length; i++) {\n    target[i] = temp[i-targetstart];\n  }\n};\n\nSlowBuffer.prototype.fill = function(value, start, end) {\n  if (end > this.length) {\n    throw new Error(\'oob\');\n  }\n  if (start > end) {\n    throw new Error(\'oob\');\n  }\n\n  for (var i = start; i < end; i++) {\n    this[i] = value;\n  }\n}\n\nfunction coerce(length) {\n  // Coerce length to a number (possibly NaN), round up\n  // in case it\'s fractional (e.g. 123.456) then do a\n  // double negate to coerce a NaN to 0. Easy, right?\n  length = ~~Math.ceil(+length);\n  return length < 0 ? 0 : length;\n}\n\n\n// Buffer\n\nfunction Buffer(subject, encoding, offset) {\n  if (!(this instanceof Buffer)) {\n    return new Buffer(subject, encoding, offset);\n  }\n\n  var type;\n\n  // Are we slicing?\n  if (typeof offset === \'number\') {\n    this.length = coerce(encoding);\n    this.parent = subject;\n    this.offset = offset;\n  } else {\n    // Find the length\n    switch (type = typeof subject) {\n      case \'number\':\n        this.length = coerce(subject);\n        break;\n\n      case \'string\':\n        this.length = Buffer.byteLength(subject, encoding);\n        break;\n\n      case \'object\': // Assume object is an array\n        this.length = coerce(subject.length);\n        break;\n\n      default:\n        throw new Error(\'First argument needs to be a number, \' +\n                        \'array or string.\');\n    }\n\n    if (this.length > Buffer.poolSize) {\n      // Big buffer, just alloc one.\n      this.parent = new SlowBuffer(this.length);\n      this.offset = 0;\n\n    } else {\n      // Small buffer.\n      if (!pool || pool.length - pool.used < this.length) allocPool();\n      this.parent = pool;\n      this.offset = pool.used;\n      pool.used += this.length;\n    }\n\n    // Treat array-ish objects as a byte array.\n    if (isArrayIsh(subject)) {\n      for (var i = 0; i < this.length; i++) {\n        if (subject instanceof Buffer) {\n          this.parent[i + this.offset] = subject.readUInt8(i);\n        }\n        else {\n          this.parent[i + this.offset] = subject[i];\n        }\n      }\n    } else if (type == \'string\') {\n      // We are a string\n      this.length = this.write(subject, 0, encoding);\n    }\n  }\n\n}\n\nfunction isArrayIsh(subject) {\n  return Array.isArray(subject) || Buffer.isBuffer(subject) ||\n         subject && typeof subject === \'object\' &&\n         typeof subject.length === \'number\';\n}\n\nexports.SlowBuffer = SlowBuffer;\nexports.Buffer = Buffer;\n\nBuffer.poolSize = 8 * 1024;\nvar pool;\n\nfunction allocPool() {\n  pool = new SlowBuffer(Buffer.poolSize);\n  pool.used = 0;\n}\n\n\n// Static methods\nBuffer.isBuffer = function isBuffer(b) {\n  return b instanceof Buffer || b instanceof SlowBuffer;\n};\n\nBuffer.concat = function (list, totalLength) {\n  if (!Array.isArray(list)) {\n    throw new Error("Usage: Buffer.concat(list, [totalLength])\\n \\\n      list should be an Array.");\n  }\n\n  if (list.length === 0) {\n    return new Buffer(0);\n  } else if (list.length === 1) {\n    return list[0];\n  }\n\n  if (typeof totalLength !== \'number\') {\n    totalLength = 0;\n    for (var i = 0; i < list.length; i++) {\n      var buf = list[i];\n      totalLength += buf.length;\n    }\n  }\n\n  var buffer = new Buffer(totalLength);\n  var pos = 0;\n  for (var i = 0; i < list.length; i++) {\n    var buf = list[i];\n    buf.copy(buffer, pos);\n    pos += buf.length;\n  }\n  return buffer;\n};\n\n// Inspect\nBuffer.prototype.inspect = function inspect() {\n  var out = [],\n      len = this.length;\n\n  for (var i = 0; i < len; i++) {\n    out[i] = toHex(this.parent[i + this.offset]);\n    if (i == exports.INSPECT_MAX_BYTES) {\n      out[i + 1] = \'...\';\n      break;\n    }\n  }\n\n  return \'<Buffer \' + out.join(\' \') + \'>\';\n};\n\n\nBuffer.prototype.get = function get(i) {\n  if (i < 0 || i >= this.length) throw new Error(\'oob\');\n  return this.parent[this.offset + i];\n};\n\n\nBuffer.prototype.set = function set(i, v) {\n  if (i < 0 || i >= this.length) throw new Error(\'oob\');\n  return this.parent[this.offset + i] = v;\n};\n\n\n// write(string, offset = 0, length = buffer.length-offset, encoding = \'utf8\')\nBuffer.prototype.write = function(string, offset, length, encoding) {\n  // Support both (string, offset, length, encoding)\n  // and the legacy (string, encoding, offset, length)\n  if (isFinite(offset)) {\n    if (!isFinite(length)) {\n      encoding = length;\n      length = undefined;\n    }\n  } else {  // legacy\n    var swap = encoding;\n    encoding = offset;\n    offset = length;\n    length = swap;\n  }\n\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n  encoding = String(encoding || \'utf8\').toLowerCase();\n\n  var ret;\n  switch (encoding) {\n    case \'hex\':\n      ret = this.parent.hexWrite(string, this.offset + offset, length);\n      break;\n\n    case \'utf8\':\n    case \'utf-8\':\n      ret = this.parent.utf8Write(string, this.offset + offset, length);\n      break;\n\n    case \'ascii\':\n      ret = this.parent.asciiWrite(string, this.offset + offset, length);\n      break;\n\n    case \'binary\':\n      ret = this.parent.binaryWrite(string, this.offset + offset, length);\n      break;\n\n    case \'base64\':\n      // Warning: maxLength not taken into account in base64Write\n      ret = this.parent.base64Write(string, this.offset + offset, length);\n      break;\n\n    case \'ucs2\':\n    case \'ucs-2\':\n      ret = this.parent.ucs2Write(string, this.offset + offset, length);\n      break;\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n\n  Buffer._charsWritten = SlowBuffer._charsWritten;\n\n  return ret;\n};\n\n\n// toString(encoding, start=0, end=buffer.length)\nBuffer.prototype.toString = function(encoding, start, end) {\n  encoding = String(encoding || \'utf8\').toLowerCase();\n\n  if (typeof start == \'undefined\' || start < 0) {\n    start = 0;\n  } else if (start > this.length) {\n    start = this.length;\n  }\n\n  if (typeof end == \'undefined\' || end > this.length) {\n    end = this.length;\n  } else if (end < 0) {\n    end = 0;\n  }\n\n  start = start + this.offset;\n  end = end + this.offset;\n\n  switch (encoding) {\n    case \'hex\':\n      return this.parent.hexSlice(start, end);\n\n    case \'utf8\':\n    case \'utf-8\':\n      return this.parent.utf8Slice(start, end);\n\n    case \'ascii\':\n      return this.parent.asciiSlice(start, end);\n\n    case \'binary\':\n      return this.parent.binarySlice(start, end);\n\n    case \'base64\':\n      return this.parent.base64Slice(start, end);\n\n    case \'ucs2\':\n    case \'ucs-2\':\n      return this.parent.ucs2Slice(start, end);\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n};\n\n\n// byteLength\nBuffer.byteLength = SlowBuffer.byteLength;\n\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function fill(value, start, end) {\n  value || (value = 0);\n  start || (start = 0);\n  end || (end = this.length);\n\n  if (typeof value === \'string\') {\n    value = value.charCodeAt(0);\n  }\n  if (!(typeof value === \'number\') || isNaN(value)) {\n    throw new Error(\'value is not a number\');\n  }\n\n  if (end < start) throw new Error(\'end < start\');\n\n  // Fill 0 bytes; we\'re done\n  if (end === start) return 0;\n  if (this.length == 0) return 0;\n\n  if (start < 0 || start >= this.length) {\n    throw new Error(\'start out of bounds\');\n  }\n\n  if (end < 0 || end > this.length) {\n    throw new Error(\'end out of bounds\');\n  }\n\n  return this.parent.fill(value,\n                          start + this.offset,\n                          end + this.offset);\n};\n\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function(target, target_start, start, end) {\n  var source = this;\n  start || (start = 0);\n  end || (end = this.length);\n  target_start || (target_start = 0);\n\n  if (end < start) throw new Error(\'sourceEnd < sourceStart\');\n\n  // Copy 0 bytes; we\'re done\n  if (end === start) return 0;\n  if (target.length == 0 || source.length == 0) return 0;\n\n  if (target_start < 0 || target_start >= target.length) {\n    throw new Error(\'targetStart out of bounds\');\n  }\n\n  if (start < 0 || start >= source.length) {\n    throw new Error(\'sourceStart out of bounds\');\n  }\n\n  if (end < 0 || end > source.length) {\n    throw new Error(\'sourceEnd out of bounds\');\n  }\n\n  // Are we oob?\n  if (end > this.length) {\n    end = this.length;\n  }\n\n  if (target.length - target_start < end - start) {\n    end = target.length - target_start + start;\n  }\n\n  return this.parent.copy(target.parent,\n                          target_start + target.offset,\n                          start + this.offset,\n                          end + this.offset);\n};\n\n\n// slice(start, end)\nBuffer.prototype.slice = function(start, end) {\n  if (end === undefined) end = this.length;\n  if (end > this.length) throw new Error(\'oob\');\n  if (start > end) throw new Error(\'oob\');\n\n  return new Buffer(this.parent, end - start, +start + this.offset);\n};\n\n\n// Legacy methods for backwards compatibility.\n\nBuffer.prototype.utf8Slice = function(start, end) {\n  return this.toString(\'utf8\', start, end);\n};\n\nBuffer.prototype.binarySlice = function(start, end) {\n  return this.toString(\'binary\', start, end);\n};\n\nBuffer.prototype.asciiSlice = function(start, end) {\n  return this.toString(\'ascii\', start, end);\n};\n\nBuffer.prototype.utf8Write = function(string, offset) {\n  return this.write(string, offset, \'utf8\');\n};\n\nBuffer.prototype.binaryWrite = function(string, offset) {\n  return this.write(string, offset, \'binary\');\n};\n\nBuffer.prototype.asciiWrite = function(string, offset) {\n  return this.write(string, offset, \'ascii\');\n};\n\nBuffer.prototype.readUInt8 = function(offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  if (offset >= buffer.length) return;\n\n  return buffer.parent[buffer.offset + offset];\n};\n\nfunction readUInt16(buffer, offset, isBigEndian, noAssert) {\n  var val = 0;\n\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 1 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  if (offset >= buffer.length) return 0;\n\n  if (isBigEndian) {\n    val = buffer.parent[buffer.offset + offset] << 8;\n    if (offset + 1 < buffer.length) {\n      val |= buffer.parent[buffer.offset + offset + 1];\n    }\n  } else {\n    val = buffer.parent[buffer.offset + offset];\n    if (offset + 1 < buffer.length) {\n      val |= buffer.parent[buffer.offset + offset + 1] << 8;\n    }\n  }\n\n  return val;\n}\n\nBuffer.prototype.readUInt16LE = function(offset, noAssert) {\n  return readUInt16(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readUInt16BE = function(offset, noAssert) {\n  return readUInt16(this, offset, true, noAssert);\n};\n\nfunction readUInt32(buffer, offset, isBigEndian, noAssert) {\n  var val = 0;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  if (offset >= buffer.length) return 0;\n\n  if (isBigEndian) {\n    if (offset + 1 < buffer.length)\n      val = buffer.parent[buffer.offset + offset + 1] << 16;\n    if (offset + 2 < buffer.length)\n      val |= buffer.parent[buffer.offset + offset + 2] << 8;\n    if (offset + 3 < buffer.length)\n      val |= buffer.parent[buffer.offset + offset + 3];\n    val = val + (buffer.parent[buffer.offset + offset] << 24 >>> 0);\n  } else {\n    if (offset + 2 < buffer.length)\n      val = buffer.parent[buffer.offset + offset + 2] << 16;\n    if (offset + 1 < buffer.length)\n      val |= buffer.parent[buffer.offset + offset + 1] << 8;\n    val |= buffer.parent[buffer.offset + offset];\n    if (offset + 3 < buffer.length)\n      val = val + (buffer.parent[buffer.offset + offset + 3] << 24 >>> 0);\n  }\n\n  return val;\n}\n\nBuffer.prototype.readUInt32LE = function(offset, noAssert) {\n  return readUInt32(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readUInt32BE = function(offset, noAssert) {\n  return readUInt32(this, offset, true, noAssert);\n};\n\n\n/*\n * Signed integer types, yay team! A reminder on how two\'s complement actually\n * works. The first bit is the signed bit, i.e. tells us whether or not the\n * number should be positive or negative. If the two\'s complement value is\n * positive, then we\'re done, as it\'s equivalent to the unsigned representation.\n *\n * Now if the number is positive, you\'re pretty much done, you can just leverage\n * the unsigned translations and return those. Unfortunately, negative numbers\n * aren\'t quite that straightforward.\n *\n * At first glance, one might be inclined to use the traditional formula to\n * translate binary numbers between the positive and negative values in two\'s\n * complement. (Though it doesn\'t quite work for the most negative value)\n * Mainly:\n *  - invert all the bits\n *  - add one to the result\n *\n * Of course, this doesn\'t quite work in Javascript. Take for example the value\n * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of\n * course, Javascript will do the following:\n *\n * > ~0xff80\n * -65409\n *\n * Whoh there, Javascript, that\'s not quite right. But wait, according to\n * Javascript that\'s perfectly correct. When Javascript ends up seeing the\n * constant 0xff80, it has no notion that it is actually a signed number. It\n * assumes that we\'ve input the unsigned value 0xff80. Thus, when it does the\n * binary negation, it casts it into a signed value, (positive 0xff80). Then\n * when you perform binary negation on that, it turns it into a negative number.\n *\n * Instead, we\'re going to have to use the following general formula, that works\n * in a rather Javascript friendly way. I\'m glad we don\'t support this kind of\n * weird numbering scheme in the kernel.\n *\n * (BIT-MAX - (unsigned)val + 1) * -1\n *\n * The astute observer, may think that this doesn\'t make sense for 8-bit numbers\n * (really it isn\'t necessary for them). However, when you get 16-bit numbers,\n * you do. Let\'s go back to our prior example and see how this will look:\n *\n * (0xffff - 0xff80 + 1) * -1\n * (0x007f + 1) * -1\n * (0x0080) * -1\n */\nBuffer.prototype.readInt8 = function(offset, noAssert) {\n  var buffer = this;\n  var neg;\n\n  if (!noAssert) {\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  if (offset >= buffer.length) return;\n\n  neg = buffer.parent[buffer.offset + offset] & 0x80;\n  if (!neg) {\n    return (buffer.parent[buffer.offset + offset]);\n  }\n\n  return ((0xff - buffer.parent[buffer.offset + offset] + 1) * -1);\n};\n\nfunction readInt16(buffer, offset, isBigEndian, noAssert) {\n  var neg, val;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 1 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  val = readUInt16(buffer, offset, isBigEndian, noAssert);\n  neg = val & 0x8000;\n  if (!neg) {\n    return val;\n  }\n\n  return (0xffff - val + 1) * -1;\n}\n\nBuffer.prototype.readInt16LE = function(offset, noAssert) {\n  return readInt16(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readInt16BE = function(offset, noAssert) {\n  return readInt16(this, offset, true, noAssert);\n};\n\nfunction readInt32(buffer, offset, isBigEndian, noAssert) {\n  var neg, val;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  val = readUInt32(buffer, offset, isBigEndian, noAssert);\n  neg = val & 0x80000000;\n  if (!neg) {\n    return (val);\n  }\n\n  return (0xffffffff - val + 1) * -1;\n}\n\nBuffer.prototype.readInt32LE = function(offset, noAssert) {\n  return readInt32(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readInt32BE = function(offset, noAssert) {\n  return readInt32(this, offset, true, noAssert);\n};\n\nfunction readFloat(buffer, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  return require(\'./buffer_ieee754\').readIEEE754(buffer, offset, isBigEndian,\n      23, 4);\n}\n\nBuffer.prototype.readFloatLE = function(offset, noAssert) {\n  return readFloat(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readFloatBE = function(offset, noAssert) {\n  return readFloat(this, offset, true, noAssert);\n};\n\nfunction readDouble(buffer, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset + 7 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  return require(\'./buffer_ieee754\').readIEEE754(buffer, offset, isBigEndian,\n      52, 8);\n}\n\nBuffer.prototype.readDoubleLE = function(offset, noAssert) {\n  return readDouble(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readDoubleBE = function(offset, noAssert) {\n  return readDouble(this, offset, true, noAssert);\n};\n\n\n/*\n * We have to make sure that the value is a valid integer. This means that it is\n * non-negative. It has no fractional component and that it does not exceed the\n * maximum allowed value.\n *\n *      value           The number to check for validity\n *\n *      max             The maximum value\n */\nfunction verifuint(value, max) {\n  assert.ok(typeof (value) == \'number\',\n      \'cannot write a non-number as a number\');\n\n  assert.ok(value >= 0,\n      \'specified a negative value for writing an unsigned value\');\n\n  assert.ok(value <= max, \'value is larger than maximum value for type\');\n\n  assert.ok(Math.floor(value) === value, \'value has a fractional component\');\n}\n\nBuffer.prototype.writeUInt8 = function(value, offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset < buffer.length,\n        \'trying to write beyond buffer length\');\n\n    verifuint(value, 0xff);\n  }\n\n  if (offset < buffer.length) {\n    buffer.parent[buffer.offset + offset] = value;\n  }\n};\n\nfunction writeUInt16(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 1 < buffer.length,\n        \'trying to write beyond buffer length\');\n\n    verifuint(value, 0xffff);\n  }\n\n  for (var i = 0; i < Math.min(buffer.length - offset, 2); i++) {\n    buffer.parent[buffer.offset + offset + i] =\n        (value & (0xff << (8 * (isBigEndian ? 1 - i : i)))) >>>\n            (isBigEndian ? 1 - i : i) * 8;\n  }\n\n}\n\nBuffer.prototype.writeUInt16LE = function(value, offset, noAssert) {\n  writeUInt16(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeUInt16BE = function(value, offset, noAssert) {\n  writeUInt16(this, value, offset, true, noAssert);\n};\n\nfunction writeUInt32(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'trying to write beyond buffer length\');\n\n    verifuint(value, 0xffffffff);\n  }\n\n  for (var i = 0; i < Math.min(buffer.length - offset, 4); i++) {\n    buffer.parent[buffer.offset + offset + i] =\n        (value >>> (isBigEndian ? 3 - i : i) * 8) & 0xff;\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function(value, offset, noAssert) {\n  writeUInt32(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeUInt32BE = function(value, offset, noAssert) {\n  writeUInt32(this, value, offset, true, noAssert);\n};\n\n\n/*\n * We now move onto our friends in the signed number category. Unlike unsigned\n * numbers, we\'re going to have to worry a bit more about how we put values into\n * arrays. Since we are only worrying about signed 32-bit values, we\'re in\n * slightly better shape. Unfortunately, we really can\'t do our favorite binary\n * & in this system. It really seems to do the wrong thing. For example:\n *\n * > -32 & 0xff\n * 224\n *\n * What\'s happening above is really: 0xe0 & 0xff = 0xe0. However, the results of\n * this aren\'t treated as a signed number. Ultimately a bad thing.\n *\n * What we\'re going to want to do is basically create the unsigned equivalent of\n * our representation and pass that off to the wuint* functions. To do that\n * we\'re going to do the following:\n *\n *  - if the value is positive\n *      we can pass it directly off to the equivalent wuint\n *  - if the value is negative\n *      we do the following computation:\n *         mb + val + 1, where\n *         mb   is the maximum unsigned value in that byte size\n *         val  is the Javascript negative integer\n *\n *\n * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If\n * you do out the computations:\n *\n * 0xffff - 128 + 1\n * 0xffff - 127\n * 0xff80\n *\n * You can then encode this value as the signed version. This is really rather\n * hacky, but it should work and get the job done which is our goal here.\n */\n\n/*\n * A series of checks to make sure we actually have a signed 32-bit number\n */\nfunction verifsint(value, max, min) {\n  assert.ok(typeof (value) == \'number\',\n      \'cannot write a non-number as a number\');\n\n  assert.ok(value <= max, \'value larger than maximum allowed value\');\n\n  assert.ok(value >= min, \'value smaller than minimum allowed value\');\n\n  assert.ok(Math.floor(value) === value, \'value has a fractional component\');\n}\n\nfunction verifIEEE754(value, max, min) {\n  assert.ok(typeof (value) == \'number\',\n      \'cannot write a non-number as a number\');\n\n  assert.ok(value <= max, \'value larger than maximum allowed value\');\n\n  assert.ok(value >= min, \'value smaller than minimum allowed value\');\n}\n\nBuffer.prototype.writeInt8 = function(value, offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifsint(value, 0x7f, -0x80);\n  }\n\n  if (value >= 0) {\n    buffer.writeUInt8(value, offset, noAssert);\n  } else {\n    buffer.writeUInt8(0xff + value + 1, offset, noAssert);\n  }\n};\n\nfunction writeInt16(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 1 < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifsint(value, 0x7fff, -0x8000);\n  }\n\n  if (value >= 0) {\n    writeUInt16(buffer, value, offset, isBigEndian, noAssert);\n  } else {\n    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);\n  }\n}\n\nBuffer.prototype.writeInt16LE = function(value, offset, noAssert) {\n  writeInt16(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeInt16BE = function(value, offset, noAssert) {\n  writeInt16(this, value, offset, true, noAssert);\n};\n\nfunction writeInt32(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifsint(value, 0x7fffffff, -0x80000000);\n  }\n\n  if (value >= 0) {\n    writeUInt32(buffer, value, offset, isBigEndian, noAssert);\n  } else {\n    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);\n  }\n}\n\nBuffer.prototype.writeInt32LE = function(value, offset, noAssert) {\n  writeInt32(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeInt32BE = function(value, offset, noAssert) {\n  writeInt32(this, value, offset, true, noAssert);\n};\n\nfunction writeFloat(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);\n  }\n\n  require(\'./buffer_ieee754\').writeIEEE754(buffer, value, offset, isBigEndian,\n      23, 4);\n}\n\nBuffer.prototype.writeFloatLE = function(value, offset, noAssert) {\n  writeFloat(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeFloatBE = function(value, offset, noAssert) {\n  writeFloat(this, value, offset, true, noAssert);\n};\n\nfunction writeDouble(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 7 < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);\n  }\n\n  require(\'./buffer_ieee754\').writeIEEE754(buffer, value, offset, isBigEndian,\n      52, 8);\n}\n\nBuffer.prototype.writeDoubleLE = function(value, offset, noAssert) {\n  writeDouble(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeDoubleBE = function(value, offset, noAssert) {\n  writeDouble(this, value, offset, true, noAssert);\n};\n\nSlowBuffer.prototype.readUInt8 = Buffer.prototype.readUInt8;\nSlowBuffer.prototype.readUInt16LE = Buffer.prototype.readUInt16LE;\nSlowBuffer.prototype.readUInt16BE = Buffer.prototype.readUInt16BE;\nSlowBuffer.prototype.readUInt32LE = Buffer.prototype.readUInt32LE;\nSlowBuffer.prototype.readUInt32BE = Buffer.prototype.readUInt32BE;\nSlowBuffer.prototype.readInt8 = Buffer.prototype.readInt8;\nSlowBuffer.prototype.readInt16LE = Buffer.prototype.readInt16LE;\nSlowBuffer.prototype.readInt16BE = Buffer.prototype.readInt16BE;\nSlowBuffer.prototype.readInt32LE = Buffer.prototype.readInt32LE;\nSlowBuffer.prototype.readInt32BE = Buffer.prototype.readInt32BE;\nSlowBuffer.prototype.readFloatLE = Buffer.prototype.readFloatLE;\nSlowBuffer.prototype.readFloatBE = Buffer.prototype.readFloatBE;\nSlowBuffer.prototype.readDoubleLE = Buffer.prototype.readDoubleLE;\nSlowBuffer.prototype.readDoubleBE = Buffer.prototype.readDoubleBE;\nSlowBuffer.prototype.writeUInt8 = Buffer.prototype.writeUInt8;\nSlowBuffer.prototype.writeUInt16LE = Buffer.prototype.writeUInt16LE;\nSlowBuffer.prototype.writeUInt16BE = Buffer.prototype.writeUInt16BE;\nSlowBuffer.prototype.writeUInt32LE = Buffer.prototype.writeUInt32LE;\nSlowBuffer.prototype.writeUInt32BE = Buffer.prototype.writeUInt32BE;\nSlowBuffer.prototype.writeInt8 = Buffer.prototype.writeInt8;\nSlowBuffer.prototype.writeInt16LE = Buffer.prototype.writeInt16LE;\nSlowBuffer.prototype.writeInt16BE = Buffer.prototype.writeInt16BE;\nSlowBuffer.prototype.writeInt32LE = Buffer.prototype.writeInt32LE;\nSlowBuffer.prototype.writeInt32BE = Buffer.prototype.writeInt32BE;\nSlowBuffer.prototype.writeFloatLE = Buffer.prototype.writeFloatLE;\nSlowBuffer.prototype.writeFloatBE = Buffer.prototype.writeFloatBE;\nSlowBuffer.prototype.writeDoubleLE = Buffer.prototype.writeDoubleLE;\nSlowBuffer.prototype.writeDoubleBE = Buffer.prototype.writeDoubleBE;\n\n})()\n},{"assert":2,"./buffer_ieee754":1,"base64-js":5}],3:[function(require,module,exports){\nvar events = require(\'events\');\n\nexports.isArray = isArray;\nexports.isDate = function(obj){return Object.prototype.toString.call(obj) === \'[object Date]\'};\nexports.isRegExp = function(obj){return Object.prototype.toString.call(obj) === \'[object RegExp]\'};\n\n\nexports.print = function () {};\nexports.puts = function () {};\nexports.debug = function() {};\n\nexports.inspect = function(obj, showHidden, depth, colors) {\n  var seen = [];\n\n  var stylize = function(str, styleType) {\n    // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\n    var styles =\n        { \'bold\' : [1, 22],\n          \'italic\' : [3, 23],\n          \'underline\' : [4, 24],\n          \'inverse\' : [7, 27],\n          \'white\' : [37, 39],\n          \'grey\' : [90, 39],\n          \'black\' : [30, 39],\n          \'blue\' : [34, 39],\n          \'cyan\' : [36, 39],\n          \'green\' : [32, 39],\n          \'magenta\' : [35, 39],\n          \'red\' : [31, 39],\n          \'yellow\' : [33, 39] };\n\n    var style =\n        { \'special\': \'cyan\',\n          \'number\': \'blue\',\n          \'boolean\': \'yellow\',\n          \'undefined\': \'grey\',\n          \'null\': \'bold\',\n          \'string\': \'green\',\n          \'date\': \'magenta\',\n          // "name": intentionally not styling\n          \'regexp\': \'red\' }[styleType];\n\n    if (style) {\n      return \'\\033[\' + styles[style][0] + \'m\' + str +\n             \'\\033[\' + styles[style][1] + \'m\';\n    } else {\n      return str;\n    }\n  };\n  if (! colors) {\n    stylize = function(str, styleType) { return str; };\n  }\n\n  function format(value, recurseTimes) {\n    // Provide a hook for user-specified inspect functions.\n    // Check that value is an object with an inspect function on it\n    if (value && typeof value.inspect === \'function\' &&\n        // Filter out the util module, it\'s inspect function is special\n        value !== exports &&\n        // Also filter out any prototype objects using the circular check.\n        !(value.constructor && value.constructor.prototype === value)) {\n      return value.inspect(recurseTimes);\n    }\n\n    // Primitive types cannot have properties\n    switch (typeof value) {\n      case \'undefined\':\n        return stylize(\'undefined\', \'undefined\');\n\n      case \'string\':\n        var simple = \'\\\'\' + JSON.stringify(value).replace(/^"|"$/g, \'\')\n                                                 .replace(/\'/g, "\\\\\'")\n                                                 .replace(/\\\\"/g, \'"\') + \'\\\'\';\n        return stylize(simple, \'string\');\n\n      case \'number\':\n        return stylize(\'\' + value, \'number\');\n\n      case \'boolean\':\n        return stylize(\'\' + value, \'boolean\');\n    }\n    // For some reason typeof null is "object", so special case here.\n    if (value === null) {\n      return stylize(\'null\', \'null\');\n    }\n\n    // Look up the keys of the object.\n    var visible_keys = Object_keys(value);\n    var keys = showHidden ? Object_getOwnPropertyNames(value) : visible_keys;\n\n    // Functions without properties can be shortcutted.\n    if (typeof value === \'function\' && keys.length === 0) {\n      if (isRegExp(value)) {\n        return stylize(\'\' + value, \'regexp\');\n      } else {\n        var name = value.name ? \': \' + value.name : \'\';\n        return stylize(\'[Function\' + name + \']\', \'special\');\n      }\n    }\n\n    // Dates without properties can be shortcutted\n    if (isDate(value) && keys.length === 0) {\n      return stylize(value.toUTCString(), \'date\');\n    }\n\n    var base, type, braces;\n    // Determine the object type\n    if (isArray(value)) {\n      type = \'Array\';\n      braces = [\'[\', \']\'];\n    } else {\n      type = \'Object\';\n      braces = [\'{\', \'}\'];\n    }\n\n    // Make functions say that they are functions\n    if (typeof value === \'function\') {\n      var n = value.name ? \': \' + value.name : \'\';\n      base = (isRegExp(value)) ? \' \' + value : \' [Function\' + n + \']\';\n    } else {\n      base = \'\';\n    }\n\n    // Make dates with properties first say the date\n    if (isDate(value)) {\n      base = \' \' + value.toUTCString();\n    }\n\n    if (keys.length === 0) {\n      return braces[0] + base + braces[1];\n    }\n\n    if (recurseTimes < 0) {\n      if (isRegExp(value)) {\n        return stylize(\'\' + value, \'regexp\');\n      } else {\n        return stylize(\'[Object]\', \'special\');\n      }\n    }\n\n    seen.push(value);\n\n    var output = keys.map(function(key) {\n      var name, str;\n      if (value.__lookupGetter__) {\n        if (value.__lookupGetter__(key)) {\n          if (value.__lookupSetter__(key)) {\n            str = stylize(\'[Getter/Setter]\', \'special\');\n          } else {\n            str = stylize(\'[Getter]\', \'special\');\n          }\n        } else {\n          if (value.__lookupSetter__(key)) {\n            str = stylize(\'[Setter]\', \'special\');\n          }\n        }\n      }\n      if (visible_keys.indexOf(key) < 0) {\n        name = \'[\' + key + \']\';\n      }\n      if (!str) {\n        if (seen.indexOf(value[key]) < 0) {\n          if (recurseTimes === null) {\n            str = format(value[key]);\n          } else {\n            str = format(value[key], recurseTimes - 1);\n          }\n          if (str.indexOf(\'\\n\') > -1) {\n            if (isArray(value)) {\n              str = str.split(\'\\n\').map(function(line) {\n                return \'  \' + line;\n              }).join(\'\\n\').substr(2);\n            } else {\n              str = \'\\n\' + str.split(\'\\n\').map(function(line) {\n                return \'   \' + line;\n              }).join(\'\\n\');\n            }\n          }\n        } else {\n          str = stylize(\'[Circular]\', \'special\');\n        }\n      }\n      if (typeof name === \'undefined\') {\n        if (type === \'Array\' && key.match(/^\\d+$/)) {\n          return str;\n        }\n        name = JSON.stringify(\'\' + key);\n        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {\n          name = name.substr(1, name.length - 2);\n          name = stylize(name, \'name\');\n        } else {\n          name = name.replace(/\'/g, "\\\\\'")\n                     .replace(/\\\\"/g, \'"\')\n                     .replace(/(^"|"$)/g, "\'");\n          name = stylize(name, \'string\');\n        }\n      }\n\n      return name + \': \' + str;\n    });\n\n    seen.pop();\n\n    var numLinesEst = 0;\n    var length = output.reduce(function(prev, cur) {\n      numLinesEst++;\n      if (cur.indexOf(\'\\n\') >= 0) numLinesEst++;\n      return prev + cur.length + 1;\n    }, 0);\n\n    if (length > 50) {\n      output = braces[0] +\n               (base === \'\' ? \'\' : base + \'\\n \') +\n               \' \' +\n               output.join(\',\\n  \') +\n               \' \' +\n               braces[1];\n\n    } else {\n      output = braces[0] + base + \' \' + output.join(\', \') + \' \' + braces[1];\n    }\n\n    return output;\n  }\n  return format(obj, (typeof depth === \'undefined\' ? 2 : depth));\n};\n\n\nfunction isArray(ar) {\n  return ar instanceof Array ||\n         Array.isArray(ar) ||\n         (ar && ar !== Object.prototype && isArray(ar.__proto__));\n}\n\n\nfunction isRegExp(re) {\n  return re instanceof RegExp ||\n    (typeof re === \'object\' && Object.prototype.toString.call(re) === \'[object RegExp]\');\n}\n\n\nfunction isDate(d) {\n  if (d instanceof Date) return true;\n  if (typeof d !== \'object\') return false;\n  var properties = Date.prototype && Object_getOwnPropertyNames(Date.prototype);\n  var proto = d.__proto__ && Object_getOwnPropertyNames(d.__proto__);\n  return JSON.stringify(proto) === JSON.stringify(properties);\n}\n\nfunction pad(n) {\n  return n < 10 ? \'0\' + n.toString(10) : n.toString(10);\n}\n\nvar months = [\'Jan\', \'Feb\', \'Mar\', \'Apr\', \'May\', \'Jun\', \'Jul\', \'Aug\', \'Sep\',\n              \'Oct\', \'Nov\', \'Dec\'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(\':\');\n  return [d.getDate(), months[d.getMonth()], time].join(\' \');\n}\n\nexports.log = function (msg) {};\n\nexports.pump = null;\n\nvar Object_keys = Object.keys || function (obj) {\n    var res = [];\n    for (var key in obj) res.push(key);\n    return res;\n};\n\nvar Object_getOwnPropertyNames = Object.getOwnPropertyNames || function (obj) {\n    var res = [];\n    for (var key in obj) {\n        if (Object.hasOwnProperty.call(obj, key)) res.push(key);\n    }\n    return res;\n};\n\nvar Object_create = Object.create || function (prototype, properties) {\n    // from es5-shim\n    var object;\n    if (prototype === null) {\n        object = { \'__proto__\' : null };\n    }\n    else {\n        if (typeof prototype !== \'object\') {\n            throw new TypeError(\n                \'typeof prototype[\' + (typeof prototype) + \'] != \\\'object\\\'\'\n            );\n        }\n        var Type = function () {};\n        Type.prototype = prototype;\n        object = new Type();\n        object.__proto__ = prototype;\n    }\n    if (typeof properties !== \'undefined\' && Object.defineProperties) {\n        Object.defineProperties(object, properties);\n    }\n    return object;\n};\n\nexports.inherits = function(ctor, superCtor) {\n  ctor.super_ = superCtor;\n  ctor.prototype = Object_create(superCtor.prototype, {\n    constructor: {\n      value: ctor,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n};\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (typeof f !== \'string\') {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(exports.inspect(arguments[i]));\n    }\n    return objects.join(\' \');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === \'%%\') return \'%\';\n    if (i >= len) return x;\n    switch (x) {\n      case \'%s\': return String(args[i++]);\n      case \'%d\': return Number(args[i++]);\n      case \'%j\': return JSON.stringify(args[i++]);\n      default:\n        return x;\n    }\n  });\n  for(var x = args[i]; i < len; x = args[++i]){\n    if (x === null || typeof x !== \'object\') {\n      str += \' \' + x;\n    } else {\n      str += \' \' + exports.inspect(x);\n    }\n  }\n  return str;\n};\n\n},{"events":6}],5:[function(require,module,exports){\n(function (exports) {\n\t\'use strict\';\n\n\tvar lookup = \'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\';\n\n\tfunction b64ToByteArray(b64) {\n\t\tvar i, j, l, tmp, placeHolders, arr;\n\t\n\t\tif (b64.length % 4 > 0) {\n\t\t\tthrow \'Invalid string. Length must be a multiple of 4\';\n\t\t}\n\n\t\t// the number of equal signs (place holders)\n\t\t// if there are two placeholders, than the two characters before it\n\t\t// represent one byte\n\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t// this is just a cheap hack to not do indexOf twice\n\t\tplaceHolders = b64.indexOf(\'=\');\n\t\tplaceHolders = placeHolders > 0 ? b64.length - placeHolders : 0;\n\n\t\t// base64 is 4/3 + up to two characters of the original data\n\t\tarr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);\n\n\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length;\n\n\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);\n\t\t\tarr.push((tmp & 0xFF0000) >> 16);\n\t\t\tarr.push((tmp & 0xFF00) >> 8);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t}\n\n\t\tif (placeHolders === 2) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t} else if (placeHolders === 1) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);\n\t\t\tarr.push((tmp >> 8) & 0xFF);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t}\n\n\t\treturn arr;\n\t}\n\n\tfunction uint8ToBase64(uint8) {\n\t\tvar i,\n\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\toutput = "",\n\t\t\ttemp, length;\n\n\t\tfunction tripletToBase64 (num) {\n\t\t\treturn lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n\t\t};\n\n\t\t// go through the array every three bytes, we\'ll deal with trailing stuff later\n\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);\n\t\t\toutput += tripletToBase64(temp);\n\t\t}\n\n\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\tswitch (extraBytes) {\n\t\t\tcase 1:\n\t\t\t\ttemp = uint8[uint8.length - 1];\n\t\t\t\toutput += lookup[temp >> 2];\n\t\t\t\toutput += lookup[(temp << 4) & 0x3F];\n\t\t\t\toutput += \'==\';\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);\n\t\t\t\toutput += lookup[temp >> 10];\n\t\t\t\toutput += lookup[(temp >> 4) & 0x3F];\n\t\t\t\toutput += lookup[(temp << 2) & 0x3F];\n\t\t\t\toutput += \'=\';\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn output;\n\t}\n\n\tmodule.exports.toByteArray = b64ToByteArray;\n\tmodule.exports.fromByteArray = uint8ToBase64;\n}());\n\n},{}],7:[function(require,module,exports){\nexports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {\n  var e, m,\n      eLen = nBytes * 8 - mLen - 1,\n      eMax = (1 << eLen) - 1,\n      eBias = eMax >> 1,\n      nBits = -7,\n      i = isBE ? 0 : (nBytes - 1),\n      d = isBE ? 1 : -1,\n      s = buffer[offset + i];\n\n  i += d;\n\n  e = s & ((1 << (-nBits)) - 1);\n  s >>= (-nBits);\n  nBits += eLen;\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);\n\n  m = e & ((1 << (-nBits)) - 1);\n  e >>= (-nBits);\n  nBits += mLen;\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);\n\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity);\n  } else {\n    m = m + Math.pow(2, mLen);\n    e = e - eBias;\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n};\n\nexports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {\n  var e, m, c,\n      eLen = nBytes * 8 - mLen - 1,\n      eMax = (1 << eLen) - 1,\n      eBias = eMax >> 1,\n      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),\n      i = isBE ? (nBytes - 1) : 0,\n      d = isBE ? -1 : 1,\n      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;\n\n  value = Math.abs(value);\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0;\n    e = eMax;\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2);\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * Math.pow(2, 1 - eBias);\n    }\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n      e = 0;\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);\n\n  e = (e << mLen) | m;\n  eLen += mLen;\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);\n\n  buffer[offset + i - d] |= s * 128;\n};\n\n},{}],8:[function(require,module,exports){\n// shim for using process in browser\n\nvar process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== \'undefined\'\n    && window.setImmediate;\n    var canPost = typeof window !== \'undefined\'\n    && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    if (canPost) {\n        var queue = [];\n        window.addEventListener(\'message\', function (ev) {\n            if (ev.source === window && ev.data === \'process-tick\') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage(\'process-tick\', \'*\');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = \'browser\';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nprocess.binding = function (name) {\n    throw new Error(\'process.binding is not supported\');\n}\n\n// TODO(shtylman)\nprocess.cwd = function () { return \'/\' };\nprocess.chdir = function (dir) {\n    throw new Error(\'process.chdir is not supported\');\n};\n\n},{}],6:[function(require,module,exports){\n(function(process){if (!process.EventEmitter) process.EventEmitter = function () {};\n\nvar EventEmitter = exports.EventEmitter = process.EventEmitter;\nvar isArray = typeof Array.isArray === \'function\'\n    ? Array.isArray\n    : function (xs) {\n        return Object.prototype.toString.call(xs) === \'[object Array]\'\n    }\n;\nfunction indexOf (xs, x) {\n    if (xs.indexOf) return xs.indexOf(x);\n    for (var i = 0; i < xs.length; i++) {\n        if (x === xs[i]) return i;\n    }\n    return -1;\n}\n\n// By default EventEmitters will print a warning if more than\n// 10 listeners are added to it. This is a useful default which\n// helps finding memory leaks.\n//\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nvar defaultMaxListeners = 10;\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!this._events) this._events = {};\n  this._events.maxListeners = n;\n};\n\n\nEventEmitter.prototype.emit = function(type) {\n  // If there is no \'error\' event listener then throw.\n  if (type === \'error\') {\n    if (!this._events || !this._events.error ||\n        (isArray(this._events.error) && !this._events.error.length))\n    {\n      if (arguments[1] instanceof Error) {\n        throw arguments[1]; // Unhandled \'error\' event\n      } else {\n        throw new Error("Uncaught, unspecified \'error\' event.");\n      }\n      return false;\n    }\n  }\n\n  if (!this._events) return false;\n  var handler = this._events[type];\n  if (!handler) return false;\n\n  if (typeof handler == \'function\') {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        var args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n    return true;\n\n  } else if (isArray(handler)) {\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    var listeners = handler.slice();\n    for (var i = 0, l = listeners.length; i < l; i++) {\n      listeners[i].apply(this, args);\n    }\n    return true;\n\n  } else {\n    return false;\n  }\n};\n\n// EventEmitter is defined in src/node_events.cc\n// EventEmitter.prototype.emit() is also defined there.\nEventEmitter.prototype.addListener = function(type, listener) {\n  if (\'function\' !== typeof listener) {\n    throw new Error(\'addListener only takes instances of Function\');\n  }\n\n  if (!this._events) this._events = {};\n\n  // To avoid recursion in the case that type == "newListeners"! Before\n  // adding it to the listeners, first emit "newListeners".\n  this.emit(\'newListener\', type, listener);\n\n  if (!this._events[type]) {\n    // Optimize the case of one listener. Don\'t need the extra array object.\n    this._events[type] = listener;\n  } else if (isArray(this._events[type])) {\n\n    // Check for listener leak\n    if (!this._events[type].warned) {\n      var m;\n      if (this._events.maxListeners !== undefined) {\n        m = this._events.maxListeners;\n      } else {\n        m = defaultMaxListeners;\n      }\n\n      if (m && m > 0 && this._events[type].length > m) {\n        this._events[type].warned = true;\n        console.error(\'(node) warning: possible EventEmitter memory \' +\n                      \'leak detected. %d listeners added. \' +\n                      \'Use emitter.setMaxListeners() to increase limit.\',\n                      this._events[type].length);\n        console.trace();\n      }\n    }\n\n    // If we\'ve already got an array, just append.\n    this._events[type].push(listener);\n  } else {\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  var self = this;\n  self.on(type, function g() {\n    self.removeListener(type, g);\n    listener.apply(this, arguments);\n  });\n\n  return this;\n};\n\nEventEmitter.prototype.removeListener = function(type, listener) {\n  if (\'function\' !== typeof listener) {\n    throw new Error(\'removeListener only takes instances of Function\');\n  }\n\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (!this._events || !this._events[type]) return this;\n\n  var list = this._events[type];\n\n  if (isArray(list)) {\n    var i = indexOf(list, listener);\n    if (i < 0) return this;\n    list.splice(i, 1);\n    if (list.length == 0)\n      delete this._events[type];\n  } else if (this._events[type] === listener) {\n    delete this._events[type];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  if (arguments.length === 0) {\n    this._events = {};\n    return this;\n  }\n\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (type && this._events && this._events[type]) this._events[type] = null;\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  if (!this._events) this._events = {};\n  if (!this._events[type]) this._events[type] = [];\n  if (!isArray(this._events[type])) {\n    this._events[type] = [this._events[type]];\n  }\n  return this._events[type];\n};\n\n})(require("__browserify_process"))\n},{"__browserify_process":8}],4:[function(require,module,exports){\n(function(){function SlowBuffer (size) {\n    this.length = size;\n};\n\nvar assert = require(\'assert\');\n\nexports.INSPECT_MAX_BYTES = 50;\n\n\nfunction toHex(n) {\n  if (n < 16) return \'0\' + n.toString(16);\n  return n.toString(16);\n}\n\nfunction utf8ToBytes(str) {\n  var byteArray = [];\n  for (var i = 0; i < str.length; i++)\n    if (str.charCodeAt(i) <= 0x7F)\n      byteArray.push(str.charCodeAt(i));\n    else {\n      var h = encodeURIComponent(str.charAt(i)).substr(1).split(\'%\');\n      for (var j = 0; j < h.length; j++)\n        byteArray.push(parseInt(h[j], 16));\n    }\n\n  return byteArray;\n}\n\nfunction asciiToBytes(str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++ )\n    // Node\'s code seems to be doing this and not & 0x7F..\n    byteArray.push( str.charCodeAt(i) & 0xFF );\n\n  return byteArray;\n}\n\nfunction base64ToBytes(str) {\n  return require("base64-js").toByteArray(str);\n}\n\nSlowBuffer.byteLength = function (str, encoding) {\n  switch (encoding || "utf8") {\n    case \'hex\':\n      return str.length / 2;\n\n    case \'utf8\':\n    case \'utf-8\':\n      return utf8ToBytes(str).length;\n\n    case \'ascii\':\n      return str.length;\n\n    case \'base64\':\n      return base64ToBytes(str).length;\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n};\n\nfunction blitBuffer(src, dst, offset, length) {\n  var pos, i = 0;\n  while (i < length) {\n    if ((i+offset >= dst.length) || (i >= src.length))\n      break;\n\n    dst[i + offset] = src[i];\n    i++;\n  }\n  return i;\n}\n\nSlowBuffer.prototype.utf8Write = function (string, offset, length) {\n  var bytes, pos;\n  return SlowBuffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);\n};\n\nSlowBuffer.prototype.asciiWrite = function (string, offset, length) {\n  var bytes, pos;\n  return SlowBuffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);\n};\n\nSlowBuffer.prototype.base64Write = function (string, offset, length) {\n  var bytes, pos;\n  return SlowBuffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);\n};\n\nSlowBuffer.prototype.base64Slice = function (start, end) {\n  var bytes = Array.prototype.slice.apply(this, arguments)\n  return require("base64-js").fromByteArray(bytes);\n}\n\nfunction decodeUtf8Char(str) {\n  try {\n    return decodeURIComponent(str);\n  } catch (err) {\n    return String.fromCharCode(0xFFFD); // UTF 8 invalid char\n  }\n}\n\nSlowBuffer.prototype.utf8Slice = function () {\n  var bytes = Array.prototype.slice.apply(this, arguments);\n  var res = "";\n  var tmp = "";\n  var i = 0;\n  while (i < bytes.length) {\n    if (bytes[i] <= 0x7F) {\n      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);\n      tmp = "";\n    } else\n      tmp += "%" + bytes[i].toString(16);\n\n    i++;\n  }\n\n  return res + decodeUtf8Char(tmp);\n}\n\nSlowBuffer.prototype.asciiSlice = function () {\n  var bytes = Array.prototype.slice.apply(this, arguments);\n  var ret = "";\n  for (var i = 0; i < bytes.length; i++)\n    ret += String.fromCharCode(bytes[i]);\n  return ret;\n}\n\nSlowBuffer.prototype.inspect = function() {\n  var out = [],\n      len = this.length;\n  for (var i = 0; i < len; i++) {\n    out[i] = toHex(this[i]);\n    if (i == exports.INSPECT_MAX_BYTES) {\n      out[i + 1] = \'...\';\n      break;\n    }\n  }\n  return \'<SlowBuffer \' + out.join(\' \') + \'>\';\n};\n\n\nSlowBuffer.prototype.hexSlice = function(start, end) {\n  var len = this.length;\n\n  if (!start || start < 0) start = 0;\n  if (!end || end < 0 || end > len) end = len;\n\n  var out = \'\';\n  for (var i = start; i < end; i++) {\n    out += toHex(this[i]);\n  }\n  return out;\n};\n\n\nSlowBuffer.prototype.toString = function(encoding, start, end) {\n  encoding = String(encoding || \'utf8\').toLowerCase();\n  start = +start || 0;\n  if (typeof end == \'undefined\') end = this.length;\n\n  // Fastpath empty strings\n  if (+end == start) {\n    return \'\';\n  }\n\n  switch (encoding) {\n    case \'hex\':\n      return this.hexSlice(start, end);\n\n    case \'utf8\':\n    case \'utf-8\':\n      return this.utf8Slice(start, end);\n\n    case \'ascii\':\n      return this.asciiSlice(start, end);\n\n    case \'binary\':\n      return this.binarySlice(start, end);\n\n    case \'base64\':\n      return this.base64Slice(start, end);\n\n    case \'ucs2\':\n    case \'ucs-2\':\n      return this.ucs2Slice(start, end);\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n};\n\n\nSlowBuffer.prototype.hexWrite = function(string, offset, length) {\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length;\n  if (strLen % 2) {\n    throw new Error(\'Invalid hex string\');\n  }\n  if (length > strLen / 2) {\n    length = strLen / 2;\n  }\n  for (var i = 0; i < length; i++) {\n    var byte = parseInt(string.substr(i * 2, 2), 16);\n    if (isNaN(byte)) throw new Error(\'Invalid hex string\');\n    this[offset + i] = byte;\n  }\n  SlowBuffer._charsWritten = i * 2;\n  return i;\n};\n\n\nSlowBuffer.prototype.write = function(string, offset, length, encoding) {\n  // Support both (string, offset, length, encoding)\n  // and the legacy (string, encoding, offset, length)\n  if (isFinite(offset)) {\n    if (!isFinite(length)) {\n      encoding = length;\n      length = undefined;\n    }\n  } else {  // legacy\n    var swap = encoding;\n    encoding = offset;\n    offset = length;\n    length = swap;\n  }\n\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n  encoding = String(encoding || \'utf8\').toLowerCase();\n\n  switch (encoding) {\n    case \'hex\':\n      return this.hexWrite(string, offset, length);\n\n    case \'utf8\':\n    case \'utf-8\':\n      return this.utf8Write(string, offset, length);\n\n    case \'ascii\':\n      return this.asciiWrite(string, offset, length);\n\n    case \'binary\':\n      return this.binaryWrite(string, offset, length);\n\n    case \'base64\':\n      return this.base64Write(string, offset, length);\n\n    case \'ucs2\':\n    case \'ucs-2\':\n      return this.ucs2Write(string, offset, length);\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n};\n\n\n// slice(start, end)\nSlowBuffer.prototype.slice = function(start, end) {\n  if (end === undefined) end = this.length;\n\n  if (end > this.length) {\n    throw new Error(\'oob\');\n  }\n  if (start > end) {\n    throw new Error(\'oob\');\n  }\n\n  return new Buffer(this, end - start, +start);\n};\n\nSlowBuffer.prototype.copy = function(target, targetstart, sourcestart, sourceend) {\n  var temp = [];\n  for (var i=sourcestart; i<sourceend; i++) {\n    assert.ok(typeof this[i] !== \'undefined\', "copying undefined buffer bytes!");\n    temp.push(this[i]);\n  }\n\n  for (var i=targetstart; i<targetstart+temp.length; i++) {\n    target[i] = temp[i-targetstart];\n  }\n};\n\nfunction coerce(length) {\n  // Coerce length to a number (possibly NaN), round up\n  // in case it\'s fractional (e.g. 123.456) then do a\n  // double negate to coerce a NaN to 0. Easy, right?\n  length = ~~Math.ceil(+length);\n  return length < 0 ? 0 : length;\n}\n\n\n// Buffer\n\nfunction Buffer(subject, encoding, offset) {\n  if (!(this instanceof Buffer)) {\n    return new Buffer(subject, encoding, offset);\n  }\n\n  var type;\n\n  // Are we slicing?\n  if (typeof offset === \'number\') {\n    this.length = coerce(encoding);\n    this.parent = subject;\n    this.offset = offset;\n  } else {\n    // Find the length\n    switch (type = typeof subject) {\n      case \'number\':\n        this.length = coerce(subject);\n        break;\n\n      case \'string\':\n        this.length = Buffer.byteLength(subject, encoding);\n        break;\n\n      case \'object\': // Assume object is an array\n        this.length = coerce(subject.length);\n        break;\n\n      default:\n        throw new Error(\'First argument needs to be a number, \' +\n                        \'array or string.\');\n    }\n\n    if (this.length > Buffer.poolSize) {\n      // Big buffer, just alloc one.\n      this.parent = new SlowBuffer(this.length);\n      this.offset = 0;\n\n    } else {\n      // Small buffer.\n      if (!pool || pool.length - pool.used < this.length) allocPool();\n      this.parent = pool;\n      this.offset = pool.used;\n      pool.used += this.length;\n    }\n\n    // Treat array-ish objects as a byte array.\n    if (isArrayIsh(subject)) {\n      for (var i = 0; i < this.length; i++) {\n        this.parent[i + this.offset] = subject[i];\n      }\n    } else if (type == \'string\') {\n      // We are a string\n      this.length = this.write(subject, 0, encoding);\n    }\n  }\n\n}\n\nfunction isArrayIsh(subject) {\n  return Array.isArray(subject) || Buffer.isBuffer(subject) ||\n         subject && typeof subject === \'object\' &&\n         typeof subject.length === \'number\';\n}\n\nexports.SlowBuffer = SlowBuffer;\nexports.Buffer = Buffer;\n\nBuffer.poolSize = 8 * 1024;\nvar pool;\n\nfunction allocPool() {\n  pool = new SlowBuffer(Buffer.poolSize);\n  pool.used = 0;\n}\n\n\n// Static methods\nBuffer.isBuffer = function isBuffer(b) {\n  return b instanceof Buffer || b instanceof SlowBuffer;\n};\n\nBuffer.concat = function (list, totalLength) {\n  if (!Array.isArray(list)) {\n    throw new Error("Usage: Buffer.concat(list, [totalLength])\\n \\\n      list should be an Array.");\n  }\n\n  if (list.length === 0) {\n    return new Buffer(0);\n  } else if (list.length === 1) {\n    return list[0];\n  }\n\n  if (typeof totalLength !== \'number\') {\n    totalLength = 0;\n    for (var i = 0; i < list.length; i++) {\n      var buf = list[i];\n      totalLength += buf.length;\n    }\n  }\n\n  var buffer = new Buffer(totalLength);\n  var pos = 0;\n  for (var i = 0; i < list.length; i++) {\n    var buf = list[i];\n    buf.copy(buffer, pos);\n    pos += buf.length;\n  }\n  return buffer;\n};\n\n// Inspect\nBuffer.prototype.inspect = function inspect() {\n  var out = [],\n      len = this.length;\n\n  for (var i = 0; i < len; i++) {\n    out[i] = toHex(this.parent[i + this.offset]);\n    if (i == exports.INSPECT_MAX_BYTES) {\n      out[i + 1] = \'...\';\n      break;\n    }\n  }\n\n  return \'<Buffer \' + out.join(\' \') + \'>\';\n};\n\n\nBuffer.prototype.get = function get(i) {\n  if (i < 0 || i >= this.length) throw new Error(\'oob\');\n  return this.parent[this.offset + i];\n};\n\n\nBuffer.prototype.set = function set(i, v) {\n  if (i < 0 || i >= this.length) throw new Error(\'oob\');\n  return this.parent[this.offset + i] = v;\n};\n\n\n// write(string, offset = 0, length = buffer.length-offset, encoding = \'utf8\')\nBuffer.prototype.write = function(string, offset, length, encoding) {\n  // Support both (string, offset, length, encoding)\n  // and the legacy (string, encoding, offset, length)\n  if (isFinite(offset)) {\n    if (!isFinite(length)) {\n      encoding = length;\n      length = undefined;\n    }\n  } else {  // legacy\n    var swap = encoding;\n    encoding = offset;\n    offset = length;\n    length = swap;\n  }\n\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n  encoding = String(encoding || \'utf8\').toLowerCase();\n\n  var ret;\n  switch (encoding) {\n    case \'hex\':\n      ret = this.parent.hexWrite(string, this.offset + offset, length);\n      break;\n\n    case \'utf8\':\n    case \'utf-8\':\n      ret = this.parent.utf8Write(string, this.offset + offset, length);\n      break;\n\n    case \'ascii\':\n      ret = this.parent.asciiWrite(string, this.offset + offset, length);\n      break;\n\n    case \'binary\':\n      ret = this.parent.binaryWrite(string, this.offset + offset, length);\n      break;\n\n    case \'base64\':\n      // Warning: maxLength not taken into account in base64Write\n      ret = this.parent.base64Write(string, this.offset + offset, length);\n      break;\n\n    case \'ucs2\':\n    case \'ucs-2\':\n      ret = this.parent.ucs2Write(string, this.offset + offset, length);\n      break;\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n\n  Buffer._charsWritten = SlowBuffer._charsWritten;\n\n  return ret;\n};\n\n\n// toString(encoding, start=0, end=buffer.length)\nBuffer.prototype.toString = function(encoding, start, end) {\n  encoding = String(encoding || \'utf8\').toLowerCase();\n\n  if (typeof start == \'undefined\' || start < 0) {\n    start = 0;\n  } else if (start > this.length) {\n    start = this.length;\n  }\n\n  if (typeof end == \'undefined\' || end > this.length) {\n    end = this.length;\n  } else if (end < 0) {\n    end = 0;\n  }\n\n  start = start + this.offset;\n  end = end + this.offset;\n\n  switch (encoding) {\n    case \'hex\':\n      return this.parent.hexSlice(start, end);\n\n    case \'utf8\':\n    case \'utf-8\':\n      return this.parent.utf8Slice(start, end);\n\n    case \'ascii\':\n      return this.parent.asciiSlice(start, end);\n\n    case \'binary\':\n      return this.parent.binarySlice(start, end);\n\n    case \'base64\':\n      return this.parent.base64Slice(start, end);\n\n    case \'ucs2\':\n    case \'ucs-2\':\n      return this.parent.ucs2Slice(start, end);\n\n    default:\n      throw new Error(\'Unknown encoding\');\n  }\n};\n\n\n// byteLength\nBuffer.byteLength = SlowBuffer.byteLength;\n\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function fill(value, start, end) {\n  value || (value = 0);\n  start || (start = 0);\n  end || (end = this.length);\n\n  if (typeof value === \'string\') {\n    value = value.charCodeAt(0);\n  }\n  if (!(typeof value === \'number\') || isNaN(value)) {\n    throw new Error(\'value is not a number\');\n  }\n\n  if (end < start) throw new Error(\'end < start\');\n\n  // Fill 0 bytes; we\'re done\n  if (end === start) return 0;\n  if (this.length == 0) return 0;\n\n  if (start < 0 || start >= this.length) {\n    throw new Error(\'start out of bounds\');\n  }\n\n  if (end < 0 || end > this.length) {\n    throw new Error(\'end out of bounds\');\n  }\n\n  return this.parent.fill(value,\n                          start + this.offset,\n                          end + this.offset);\n};\n\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function(target, target_start, start, end) {\n  var source = this;\n  start || (start = 0);\n  end || (end = this.length);\n  target_start || (target_start = 0);\n\n  if (end < start) throw new Error(\'sourceEnd < sourceStart\');\n\n  // Copy 0 bytes; we\'re done\n  if (end === start) return 0;\n  if (target.length == 0 || source.length == 0) return 0;\n\n  if (target_start < 0 || target_start >= target.length) {\n    throw new Error(\'targetStart out of bounds\');\n  }\n\n  if (start < 0 || start >= source.length) {\n    throw new Error(\'sourceStart out of bounds\');\n  }\n\n  if (end < 0 || end > source.length) {\n    throw new Error(\'sourceEnd out of bounds\');\n  }\n\n  // Are we oob?\n  if (end > this.length) {\n    end = this.length;\n  }\n\n  if (target.length - target_start < end - start) {\n    end = target.length - target_start + start;\n  }\n\n  return this.parent.copy(target.parent,\n                          target_start + target.offset,\n                          start + this.offset,\n                          end + this.offset);\n};\n\n\n// slice(start, end)\nBuffer.prototype.slice = function(start, end) {\n  if (end === undefined) end = this.length;\n  if (end > this.length) throw new Error(\'oob\');\n  if (start > end) throw new Error(\'oob\');\n\n  return new Buffer(this.parent, end - start, +start + this.offset);\n};\n\n\n// Legacy methods for backwards compatibility.\n\nBuffer.prototype.utf8Slice = function(start, end) {\n  return this.toString(\'utf8\', start, end);\n};\n\nBuffer.prototype.binarySlice = function(start, end) {\n  return this.toString(\'binary\', start, end);\n};\n\nBuffer.prototype.asciiSlice = function(start, end) {\n  return this.toString(\'ascii\', start, end);\n};\n\nBuffer.prototype.utf8Write = function(string, offset) {\n  return this.write(string, offset, \'utf8\');\n};\n\nBuffer.prototype.binaryWrite = function(string, offset) {\n  return this.write(string, offset, \'binary\');\n};\n\nBuffer.prototype.asciiWrite = function(string, offset) {\n  return this.write(string, offset, \'ascii\');\n};\n\nBuffer.prototype.readUInt8 = function(offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  return buffer.parent[buffer.offset + offset];\n};\n\nfunction readUInt16(buffer, offset, isBigEndian, noAssert) {\n  var val = 0;\n\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 1 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  if (isBigEndian) {\n    val = buffer.parent[buffer.offset + offset] << 8;\n    val |= buffer.parent[buffer.offset + offset + 1];\n  } else {\n    val = buffer.parent[buffer.offset + offset];\n    val |= buffer.parent[buffer.offset + offset + 1] << 8;\n  }\n\n  return val;\n}\n\nBuffer.prototype.readUInt16LE = function(offset, noAssert) {\n  return readUInt16(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readUInt16BE = function(offset, noAssert) {\n  return readUInt16(this, offset, true, noAssert);\n};\n\nfunction readUInt32(buffer, offset, isBigEndian, noAssert) {\n  var val = 0;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  if (isBigEndian) {\n    val = buffer.parent[buffer.offset + offset + 1] << 16;\n    val |= buffer.parent[buffer.offset + offset + 2] << 8;\n    val |= buffer.parent[buffer.offset + offset + 3];\n    val = val + (buffer.parent[buffer.offset + offset] << 24 >>> 0);\n  } else {\n    val = buffer.parent[buffer.offset + offset + 2] << 16;\n    val |= buffer.parent[buffer.offset + offset + 1] << 8;\n    val |= buffer.parent[buffer.offset + offset];\n    val = val + (buffer.parent[buffer.offset + offset + 3] << 24 >>> 0);\n  }\n\n  return val;\n}\n\nBuffer.prototype.readUInt32LE = function(offset, noAssert) {\n  return readUInt32(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readUInt32BE = function(offset, noAssert) {\n  return readUInt32(this, offset, true, noAssert);\n};\n\n\n/*\n * Signed integer types, yay team! A reminder on how two\'s complement actually\n * works. The first bit is the signed bit, i.e. tells us whether or not the\n * number should be positive or negative. If the two\'s complement value is\n * positive, then we\'re done, as it\'s equivalent to the unsigned representation.\n *\n * Now if the number is positive, you\'re pretty much done, you can just leverage\n * the unsigned translations and return those. Unfortunately, negative numbers\n * aren\'t quite that straightforward.\n *\n * At first glance, one might be inclined to use the traditional formula to\n * translate binary numbers between the positive and negative values in two\'s\n * complement. (Though it doesn\'t quite work for the most negative value)\n * Mainly:\n *  - invert all the bits\n *  - add one to the result\n *\n * Of course, this doesn\'t quite work in Javascript. Take for example the value\n * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of\n * course, Javascript will do the following:\n *\n * > ~0xff80\n * -65409\n *\n * Whoh there, Javascript, that\'s not quite right. But wait, according to\n * Javascript that\'s perfectly correct. When Javascript ends up seeing the\n * constant 0xff80, it has no notion that it is actually a signed number. It\n * assumes that we\'ve input the unsigned value 0xff80. Thus, when it does the\n * binary negation, it casts it into a signed value, (positive 0xff80). Then\n * when you perform binary negation on that, it turns it into a negative number.\n *\n * Instead, we\'re going to have to use the following general formula, that works\n * in a rather Javascript friendly way. I\'m glad we don\'t support this kind of\n * weird numbering scheme in the kernel.\n *\n * (BIT-MAX - (unsigned)val + 1) * -1\n *\n * The astute observer, may think that this doesn\'t make sense for 8-bit numbers\n * (really it isn\'t necessary for them). However, when you get 16-bit numbers,\n * you do. Let\'s go back to our prior example and see how this will look:\n *\n * (0xffff - 0xff80 + 1) * -1\n * (0x007f + 1) * -1\n * (0x0080) * -1\n */\nBuffer.prototype.readInt8 = function(offset, noAssert) {\n  var buffer = this;\n  var neg;\n\n  if (!noAssert) {\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  neg = buffer.parent[buffer.offset + offset] & 0x80;\n  if (!neg) {\n    return (buffer.parent[buffer.offset + offset]);\n  }\n\n  return ((0xff - buffer.parent[buffer.offset + offset] + 1) * -1);\n};\n\nfunction readInt16(buffer, offset, isBigEndian, noAssert) {\n  var neg, val;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 1 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  val = readUInt16(buffer, offset, isBigEndian, noAssert);\n  neg = val & 0x8000;\n  if (!neg) {\n    return val;\n  }\n\n  return (0xffff - val + 1) * -1;\n}\n\nBuffer.prototype.readInt16LE = function(offset, noAssert) {\n  return readInt16(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readInt16BE = function(offset, noAssert) {\n  return readInt16(this, offset, true, noAssert);\n};\n\nfunction readInt32(buffer, offset, isBigEndian, noAssert) {\n  var neg, val;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  val = readUInt32(buffer, offset, isBigEndian, noAssert);\n  neg = val & 0x80000000;\n  if (!neg) {\n    return (val);\n  }\n\n  return (0xffffffff - val + 1) * -1;\n}\n\nBuffer.prototype.readInt32LE = function(offset, noAssert) {\n  return readInt32(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readInt32BE = function(offset, noAssert) {\n  return readInt32(this, offset, true, noAssert);\n};\n\nfunction readFloat(buffer, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  return require(\'./buffer_ieee754\').readIEEE754(buffer, offset, isBigEndian,\n      23, 4);\n}\n\nBuffer.prototype.readFloatLE = function(offset, noAssert) {\n  return readFloat(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readFloatBE = function(offset, noAssert) {\n  return readFloat(this, offset, true, noAssert);\n};\n\nfunction readDouble(buffer, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset + 7 < buffer.length,\n        \'Trying to read beyond buffer length\');\n  }\n\n  return require(\'./buffer_ieee754\').readIEEE754(buffer, offset, isBigEndian,\n      52, 8);\n}\n\nBuffer.prototype.readDoubleLE = function(offset, noAssert) {\n  return readDouble(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readDoubleBE = function(offset, noAssert) {\n  return readDouble(this, offset, true, noAssert);\n};\n\n\n/*\n * We have to make sure that the value is a valid integer. This means that it is\n * non-negative. It has no fractional component and that it does not exceed the\n * maximum allowed value.\n *\n *      value           The number to check for validity\n *\n *      max             The maximum value\n */\nfunction verifuint(value, max) {\n  assert.ok(typeof (value) == \'number\',\n      \'cannot write a non-number as a number\');\n\n  assert.ok(value >= 0,\n      \'specified a negative value for writing an unsigned value\');\n\n  assert.ok(value <= max, \'value is larger than maximum value for type\');\n\n  assert.ok(Math.floor(value) === value, \'value has a fractional component\');\n}\n\nBuffer.prototype.writeUInt8 = function(value, offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset < buffer.length,\n        \'trying to write beyond buffer length\');\n\n    verifuint(value, 0xff);\n  }\n\n  buffer.parent[buffer.offset + offset] = value;\n};\n\nfunction writeUInt16(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 1 < buffer.length,\n        \'trying to write beyond buffer length\');\n\n    verifuint(value, 0xffff);\n  }\n\n  if (isBigEndian) {\n    buffer.parent[buffer.offset + offset] = (value & 0xff00) >>> 8;\n    buffer.parent[buffer.offset + offset + 1] = value & 0x00ff;\n  } else {\n    buffer.parent[buffer.offset + offset + 1] = (value & 0xff00) >>> 8;\n    buffer.parent[buffer.offset + offset] = value & 0x00ff;\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function(value, offset, noAssert) {\n  writeUInt16(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeUInt16BE = function(value, offset, noAssert) {\n  writeUInt16(this, value, offset, true, noAssert);\n};\n\nfunction writeUInt32(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'trying to write beyond buffer length\');\n\n    verifuint(value, 0xffffffff);\n  }\n\n  if (isBigEndian) {\n    buffer.parent[buffer.offset + offset] = (value >>> 24) & 0xff;\n    buffer.parent[buffer.offset + offset + 1] = (value >>> 16) & 0xff;\n    buffer.parent[buffer.offset + offset + 2] = (value >>> 8) & 0xff;\n    buffer.parent[buffer.offset + offset + 3] = value & 0xff;\n  } else {\n    buffer.parent[buffer.offset + offset + 3] = (value >>> 24) & 0xff;\n    buffer.parent[buffer.offset + offset + 2] = (value >>> 16) & 0xff;\n    buffer.parent[buffer.offset + offset + 1] = (value >>> 8) & 0xff;\n    buffer.parent[buffer.offset + offset] = value & 0xff;\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function(value, offset, noAssert) {\n  writeUInt32(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeUInt32BE = function(value, offset, noAssert) {\n  writeUInt32(this, value, offset, true, noAssert);\n};\n\n\n/*\n * We now move onto our friends in the signed number category. Unlike unsigned\n * numbers, we\'re going to have to worry a bit more about how we put values into\n * arrays. Since we are only worrying about signed 32-bit values, we\'re in\n * slightly better shape. Unfortunately, we really can\'t do our favorite binary\n * & in this system. It really seems to do the wrong thing. For example:\n *\n * > -32 & 0xff\n * 224\n *\n * What\'s happening above is really: 0xe0 & 0xff = 0xe0. However, the results of\n * this aren\'t treated as a signed number. Ultimately a bad thing.\n *\n * What we\'re going to want to do is basically create the unsigned equivalent of\n * our representation and pass that off to the wuint* functions. To do that\n * we\'re going to do the following:\n *\n *  - if the value is positive\n *      we can pass it directly off to the equivalent wuint\n *  - if the value is negative\n *      we do the following computation:\n *         mb + val + 1, where\n *         mb   is the maximum unsigned value in that byte size\n *         val  is the Javascript negative integer\n *\n *\n * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If\n * you do out the computations:\n *\n * 0xffff - 128 + 1\n * 0xffff - 127\n * 0xff80\n *\n * You can then encode this value as the signed version. This is really rather\n * hacky, but it should work and get the job done which is our goal here.\n */\n\n/*\n * A series of checks to make sure we actually have a signed 32-bit number\n */\nfunction verifsint(value, max, min) {\n  assert.ok(typeof (value) == \'number\',\n      \'cannot write a non-number as a number\');\n\n  assert.ok(value <= max, \'value larger than maximum allowed value\');\n\n  assert.ok(value >= min, \'value smaller than minimum allowed value\');\n\n  assert.ok(Math.floor(value) === value, \'value has a fractional component\');\n}\n\nfunction verifIEEE754(value, max, min) {\n  assert.ok(typeof (value) == \'number\',\n      \'cannot write a non-number as a number\');\n\n  assert.ok(value <= max, \'value larger than maximum allowed value\');\n\n  assert.ok(value >= min, \'value smaller than minimum allowed value\');\n}\n\nBuffer.prototype.writeInt8 = function(value, offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifsint(value, 0x7f, -0x80);\n  }\n\n  if (value >= 0) {\n    buffer.writeUInt8(value, offset, noAssert);\n  } else {\n    buffer.writeUInt8(0xff + value + 1, offset, noAssert);\n  }\n};\n\nfunction writeInt16(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 1 < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifsint(value, 0x7fff, -0x8000);\n  }\n\n  if (value >= 0) {\n    writeUInt16(buffer, value, offset, isBigEndian, noAssert);\n  } else {\n    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);\n  }\n}\n\nBuffer.prototype.writeInt16LE = function(value, offset, noAssert) {\n  writeInt16(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeInt16BE = function(value, offset, noAssert) {\n  writeInt16(this, value, offset, true, noAssert);\n};\n\nfunction writeInt32(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifsint(value, 0x7fffffff, -0x80000000);\n  }\n\n  if (value >= 0) {\n    writeUInt32(buffer, value, offset, isBigEndian, noAssert);\n  } else {\n    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);\n  }\n}\n\nBuffer.prototype.writeInt32LE = function(value, offset, noAssert) {\n  writeInt32(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeInt32BE = function(value, offset, noAssert) {\n  writeInt32(this, value, offset, true, noAssert);\n};\n\nfunction writeFloat(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 3 < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);\n  }\n\n  require(\'./buffer_ieee754\').writeIEEE754(buffer, value, offset, isBigEndian,\n      23, 4);\n}\n\nBuffer.prototype.writeFloatLE = function(value, offset, noAssert) {\n  writeFloat(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeFloatBE = function(value, offset, noAssert) {\n  writeFloat(this, value, offset, true, noAssert);\n};\n\nfunction writeDouble(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        \'missing value\');\n\n    assert.ok(typeof (isBigEndian) === \'boolean\',\n        \'missing or invalid endian\');\n\n    assert.ok(offset !== undefined && offset !== null,\n        \'missing offset\');\n\n    assert.ok(offset + 7 < buffer.length,\n        \'Trying to write beyond buffer length\');\n\n    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);\n  }\n\n  require(\'./buffer_ieee754\').writeIEEE754(buffer, value, offset, isBigEndian,\n      52, 8);\n}\n\nBuffer.prototype.writeDoubleLE = function(value, offset, noAssert) {\n  writeDouble(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeDoubleBE = function(value, offset, noAssert) {\n  writeDouble(this, value, offset, true, noAssert);\n};\n\nSlowBuffer.prototype.readUInt8 = Buffer.prototype.readUInt8;\nSlowBuffer.prototype.readUInt16LE = Buffer.prototype.readUInt16LE;\nSlowBuffer.prototype.readUInt16BE = Buffer.prototype.readUInt16BE;\nSlowBuffer.prototype.readUInt32LE = Buffer.prototype.readUInt32LE;\nSlowBuffer.prototype.readUInt32BE = Buffer.prototype.readUInt32BE;\nSlowBuffer.prototype.readInt8 = Buffer.prototype.readInt8;\nSlowBuffer.prototype.readInt16LE = Buffer.prototype.readInt16LE;\nSlowBuffer.prototype.readInt16BE = Buffer.prototype.readInt16BE;\nSlowBuffer.prototype.readInt32LE = Buffer.prototype.readInt32LE;\nSlowBuffer.prototype.readInt32BE = Buffer.prototype.readInt32BE;\nSlowBuffer.prototype.readFloatLE = Buffer.prototype.readFloatLE;\nSlowBuffer.prototype.readFloatBE = Buffer.prototype.readFloatBE;\nSlowBuffer.prototype.readDoubleLE = Buffer.prototype.readDoubleLE;\nSlowBuffer.prototype.readDoubleBE = Buffer.prototype.readDoubleBE;\nSlowBuffer.prototype.writeUInt8 = Buffer.prototype.writeUInt8;\nSlowBuffer.prototype.writeUInt16LE = Buffer.prototype.writeUInt16LE;\nSlowBuffer.prototype.writeUInt16BE = Buffer.prototype.writeUInt16BE;\nSlowBuffer.prototype.writeUInt32LE = Buffer.prototype.writeUInt32LE;\nSlowBuffer.prototype.writeUInt32BE = Buffer.prototype.writeUInt32BE;\nSlowBuffer.prototype.writeInt8 = Buffer.prototype.writeInt8;\nSlowBuffer.prototype.writeInt16LE = Buffer.prototype.writeInt16LE;\nSlowBuffer.prototype.writeInt16BE = Buffer.prototype.writeInt16BE;\nSlowBuffer.prototype.writeInt32LE = Buffer.prototype.writeInt32LE;\nSlowBuffer.prototype.writeInt32BE = Buffer.prototype.writeInt32BE;\nSlowBuffer.prototype.writeFloatLE = Buffer.prototype.writeFloatLE;\nSlowBuffer.prototype.writeFloatBE = Buffer.prototype.writeFloatBE;\nSlowBuffer.prototype.writeDoubleLE = Buffer.prototype.writeDoubleLE;\nSlowBuffer.prototype.writeDoubleBE = Buffer.prototype.writeDoubleBE;\n\n})()\n},{"assert":2,"./buffer_ieee754":7,"base64-js":9}],9:[function(require,module,exports){\n(function (exports) {\n\t\'use strict\';\n\n\tvar lookup = \'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\';\n\n\tfunction b64ToByteArray(b64) {\n\t\tvar i, j, l, tmp, placeHolders, arr;\n\t\n\t\tif (b64.length % 4 > 0) {\n\t\t\tthrow \'Invalid string. Length must be a multiple of 4\';\n\t\t}\n\n\t\t// the number of equal signs (place holders)\n\t\t// if there are two placeholders, than the two characters before it\n\t\t// represent one byte\n\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t// this is just a cheap hack to not do indexOf twice\n\t\tplaceHolders = b64.indexOf(\'=\');\n\t\tplaceHolders = placeHolders > 0 ? b64.length - placeHolders : 0;\n\n\t\t// base64 is 4/3 + up to two characters of the original data\n\t\tarr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);\n\n\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length;\n\n\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);\n\t\t\tarr.push((tmp & 0xFF0000) >> 16);\n\t\t\tarr.push((tmp & 0xFF00) >> 8);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t}\n\n\t\tif (placeHolders === 2) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t} else if (placeHolders === 1) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);\n\t\t\tarr.push((tmp >> 8) & 0xFF);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t}\n\n\t\treturn arr;\n\t}\n\n\tfunction uint8ToBase64(uint8) {\n\t\tvar i,\n\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\toutput = "",\n\t\t\ttemp, length;\n\n\t\tfunction tripletToBase64 (num) {\n\t\t\treturn lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n\t\t};\n\n\t\t// go through the array every three bytes, we\'ll deal with trailing stuff later\n\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);\n\t\t\toutput += tripletToBase64(temp);\n\t\t}\n\n\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\tswitch (extraBytes) {\n\t\t\tcase 1:\n\t\t\t\ttemp = uint8[uint8.length - 1];\n\t\t\t\toutput += lookup[temp >> 2];\n\t\t\t\toutput += lookup[(temp << 4) & 0x3F];\n\t\t\t\toutput += \'==\';\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);\n\t\t\t\toutput += lookup[temp >> 10];\n\t\t\t\toutput += lookup[(temp >> 4) & 0x3F];\n\t\t\t\toutput += lookup[(temp << 2) & 0x3F];\n\t\t\t\toutput += \'=\';\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn output;\n\t}\n\n\tmodule.exports.toByteArray = b64ToByteArray;\n\tmodule.exports.fromByteArray = uint8ToBase64;\n}());\n\n},{}]},{},[])\n;;module.exports=require("buffer-browserify")\n\n},{}],5:[function(require,module,exports){\n(function(Buffer){/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Wentao Shang\n * See COPYING for copyright and distribution information.\n */\n\n// Library namespace\nvar ndn = ndn || {};\n\nvar exports = ndn;\n\n\n// Factory method to create node.js compatible ndnbuf objects\nvar ndnbuf = function ndnbuf(data, format)\n{\n  var obj;\n\n  if (typeof data == \'number\')\n    obj = new Uint8Array(data);\n  else if (typeof data == \'string\') {\n    if (format == null || format == \'utf8\') {\n      var utf8 = ndnbuf.str2rstr_utf8(data);\n      obj = new Uint8Array(utf8.length);\n      for (var i = 0; i < utf8.length; i++)\n        obj[i] = utf8.charCodeAt(i);\n    }\n    else if (format == \'binary\') {\n      obj = new Uint8Array(data.length);\n      for (var i = 0; i < data.length; i++)\n        obj[i] = data.charCodeAt(i);\n    }\n    else if (format == \'hex\') {\n      obj = new Uint8Array(Math.floor(data.length / 2));\n      var i = 0;\n      data.replace(/(..)/g, function(ss) {\n        obj[i++] = parseInt(ss, 16);\n      });\n    }\n    else if (format == \'base64\') {\n      var hex = b64tohex(data);\n      obj = new Uint8Array(Math.floor(hex.length / 2));\n      var i = 0;\n      hex.replace(/(..)/g, function(ss) {\n        obj[i++] = parseInt(ss, 16);\n      });\n    }\n    else\n      throw new Error(\'Buffer: unknown encoding format \' + format);\n  }\n  else if (typeof data == \'object\' && (data instanceof Uint8Array || data instanceof ndnbuf)) {\n    // The second argument is a boolean for "copy", default true.\n    if (format == false)\n      obj = data.subarray(0);\n    else\n      obj = new Uint8Array(data);\n  }\n  else if (typeof data == \'object\' && data instanceof ArrayBuffer)\n    // Copy.\n    obj = new Uint8Array(data);\n  else if (typeof data == \'object\')\n    // Assume component is a byte array.  We can\'t check instanceof Array because\n    //   this doesn\'t work in JavaScript if the array comes from a different module.\n    obj = new Uint8Array(data);\n  else\n    throw new Error(\'Buffer: unknown data type.\');\n\n  try {\n    obj.__proto__ = ndnbuf.prototype;\n  } catch(ex) {\n    throw new Error("Buffer: Set obj.__proto__ exception: " + ex);\n  }\n\n  obj.__proto__.toString = function(encoding) {\n    if (encoding == null) {\n      var ret = "";\n      for (var i = 0; i < this.length; i++)\n        ret += String.fromCharCode(this[i]);\n      return ret;\n    }\n\n    var ret = "";\n    for (var i = 0; i < this.length; i++)\n      ret += (this[i] < 16 ? "0" : "") + this[i].toString(16);\n\n    if (encoding == \'hex\')\n      return ret;\n    else if (encoding == \'base64\')\n      return hex2b64(ret);\n    else\n      throw new Error(\'ndnbuf.toString: unknown encoding format \' + encoding);\n  };\n\n  obj.__proto__.slice = function(begin, end) {\n    if (end !== undefined)\n      return new ndnbuf(this.subarray(begin, end), false);\n    else\n      return new ndnbuf(this.subarray(begin), false);\n  };\n\n  obj.__proto__.copy = function(target, targetStart) {\n    if (targetStart !== undefined)\n      target.set(this, targetStart);\n    else\n      target.set(this);\n  };\n\n  return obj;\n};\n\nndnbuf.prototype = Uint8Array.prototype;\n\nndnbuf.concat = function(arrays)\n{\n  var totalLength = 0;\n  for (var i = 0; i < arrays.length; ++i)\n    totalLength += arrays[i].length;\n\n  var result = new ndnbuf(totalLength);\n  var offset = 0;\n  for (var i = 0; i < arrays.length; ++i) {\n    result.set(arrays[i], offset);\n    offset += arrays[i].length;\n  }\n  return result;\n};\n\nndnbuf.str2rstr_utf8 = function(input)\n{\n  var output = "";\n  var i = -1;\n  var x, y;\n\n  while (++i < input.length)\n  {\n    // Decode utf-16 surrogate pairs\n    x = input.charCodeAt(i);\n    y = i + 1 < input.length ? input.charCodeAt(i + 1) : 0;\n    if (0xD800 <= x && x <= 0xDBFF && 0xDC00 <= y && y <= 0xDFFF)\n    {\n      x = 0x10000 + ((x & 0x03FF) << 10) + (y & 0x03FF);\n      i++;\n    }\n\n    // Encode output as utf-8\n    if (x <= 0x7F)\n      output += String.fromCharCode(x);\n    else if (x <= 0x7FF)\n      output += String.fromCharCode(0xC0 | ((x >>> 6 ) & 0x1F),\n                                    0x80 | ( x         & 0x3F));\n    else if (x <= 0xFFFF)\n      output += String.fromCharCode(0xE0 | ((x >>> 12) & 0x0F),\n                                    0x80 | ((x >>> 6 ) & 0x3F),\n                                    0x80 | ( x         & 0x3F));\n    else if (x <= 0x1FFFFF)\n      output += String.fromCharCode(0xF0 | ((x >>> 18) & 0x07),\n                                    0x80 | ((x >>> 12) & 0x3F),\n                                    0x80 | ((x >>> 6 ) & 0x3F),\n                                    0x80 | ( x         & 0x3F));\n  }\n  return output;\n};\n\nexports.ndnbuf = ndnbuf\n\n// Factory method to create hasher objects\nndn.createHash = function(alg)\n{\n  if (alg != \'sha256\')\n    throw new Error(\'createHash: unsupported algorithm.\');\n\n  var obj = {};\n\n  obj.md = new KJUR.crypto.MessageDigest({alg: "sha256", prov: "cryptojs"});\n\n  obj.update = function(buf) {\n    this.md.updateHex(buf.toString(\'hex\'));\n  };\n\n  obj.digest = function() {\n    return new ndnbuf(this.md.digest(), \'hex\');\n  };\n\n  return obj;\n};\n\n// Factory method to create RSA signer objects\nndn.createSign = function(alg)\n{\n  if (alg != \'RSA-SHA256\')\n    throw new Error(\'createSign: unsupported algorithm.\');\n\n  var obj = {};\n\n  obj.arr = [];\n\n  obj.update = function(buf) {\n    this.arr.push(buf);\n  };\n\n  obj.sign = function(keypem) {\n    var rsa = new RSAKey();\n    rsa.readPrivateKeyFromPEMString(keypem);\n    var signer = new KJUR.crypto.Signature({alg: "SHA256withRSA", prov: "cryptojs/jsrsa"});\n    signer.initSign(rsa);\n    for (var i = 0; i < this.arr.length; ++i)\n      signer.updateHex(this.arr[i].toString(\'hex\'));\n\n    return new ndnbuf(signer.sign(), \'hex\');\n  };\n\n  return obj;\n};\n\n// Factory method to create RSA verifier objects\nndn.createVerify = function(alg)\n{\n  if (alg != \'RSA-SHA256\')\n    throw new Error(\'createSign: unsupported algorithm.\');\n\n  var obj = {};\n\n  obj.arr = [];\n\n  obj.update = function(buf) {\n    this.arr.push(buf);\n  };\n\n  var getSubjectPublicKeyPosFromHex = function(hPub) {\n    var a = ASN1HEX.getPosArrayOfChildren_AtObj(hPub, 0);\n    if (a.length != 2)\n      return -1;\n    var pBitString = a[1];\n    if (hPub.substring(pBitString, pBitString + 2) != \'03\')\n      return -1;\n    var pBitStringV = ASN1HEX.getStartPosOfV_AtObj(hPub, pBitString);\n    if (hPub.substring(pBitStringV, pBitStringV + 2) != \'00\')\n      return -1;\n    return pBitStringV + 2;\n  };\n\n  var readPublicDER = function(pub_der) {\n    var hex = pub_der.toString(\'hex\');\n    var p = getSubjectPublicKeyPosFromHex(hex);\n    var a = ASN1HEX.getPosArrayOfChildren_AtObj(hex, p);\n    if (a.length != 2)\n      return null;\n    var hN = ASN1HEX.getHexOfV_AtObj(hex, a[0]);\n    var hE = ASN1HEX.getHexOfV_AtObj(hex, a[1]);\n    var rsaKey = new RSAKey();\n    rsaKey.setPublic(hN, hE);\n    return rsaKey;\n  };\n\n  obj.verify = function(keypem, sig) {\n    var key = new ndn.Key();\n    key.fromPemString(keypem);\n\n    var rsa = readPublicDER(key.publicToDER());\n    var signer = new KJUR.crypto.Signature({alg: "SHA256withRSA", prov: "cryptojs/jsrsa"});\n    signer.initVerifyByPublicKey(rsa);\n    for (var i = 0; i < this.arr.length; i++)\n      signer.updateHex(this.arr[i].toString(\'hex\'));\n    var hSig = sig.toString(\'hex\');\n    return signer.verify(hSig);\n  };\n\n  return obj;\n};\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\n/**\n * The Log class holds the global static variable LOG.\n */\nvar Log = function Log()\n{\n}\n\nexports.Log = Log;\n\n/**\n * LOG is the level for logging debugging statements.  0 means no log messages.\n * @type Number\n */\nvar LOG = 0;\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class contains all NDNx tags\n */\n\n\nvar NDNProtocolDTags = {\n\n  /**\n   * Note if you add one of these, add it to the reverse string map as well.\n   * Emphasize getting the work done at compile time over trying to make something\n   * flexible and developer error-proof.\n   */\n\n   Any : 13,\n   Name : 14,\n   Component : 15,\n   Certificate : 16,\n   Collection : 17,\n   CompleteName : 18,\n   Content : 19,\n   SignedInfo : 20,\n   ContentDigest : 21,\n   ContentHash : 22,\n   Count : 24,\n   Header : 25,\n   Interest : 26,  /* 20090915 */\n   Key : 27,\n   KeyLocator : 28,\n   KeyName : 29,\n   Length : 30,\n   Link : 31,\n   LinkAuthenticator : 32,\n   NameComponentCount : 33,  /* DeprecatedInInterest */\n   RootDigest : 36,\n   Signature : 37,\n   Start : 38,\n   Timestamp : 39,\n   Type : 40,\n   Nonce : 41,\n   Scope : 42,\n   Exclude : 43,\n   Bloom : 44,\n   BloomSeed : 45,\n   AnswerOriginKind : 47,\n   InterestLifetime : 48,\n   Witness : 53,\n   SignatureBits : 54,\n   DigestAlgorithm : 55,\n   BlockSize : 56,\n   FreshnessSeconds : 58,\n   FinalBlockID : 59,\n   PublisherPublicKeyDigest : 60,\n   PublisherCertificateDigest : 61,\n   PublisherIssuerKeyDigest : 62,\n   PublisherIssuerCertificateDigest : 63,\n   Data : 64,  /* 20090915 */\n   WrappedKey : 65,\n   WrappingKeyIdentifier : 66,\n   WrapAlgorithm : 67,\n   KeyAlgorithm : 68,\n   Label : 69,\n   EncryptedKey : 70,\n   EncryptedNonceKey : 71,\n   WrappingKeyName : 72,\n   Action : 73,\n   FaceID : 74,\n   IPProto : 75,\n   Host : 76,\n   Port : 77,\n   MulticastInterface : 78,\n   ForwardingFlags : 79,\n   FaceInstance : 80,\n   ForwardingEntry : 81,\n   MulticastTTL : 82,\n   MinSuffixComponents : 83,\n   MaxSuffixComponents : 84,\n   ChildSelector : 85,\n   RepositoryInfo : 86,\n   Version : 87,\n   RepositoryVersion : 88,\n   GlobalPrefix : 89,\n   LocalName : 90,\n   Policy : 91,\n   Namespace : 92,\n   GlobalPrefixName : 93,\n   PolicyVersion : 94,\n   KeyValueSet : 95,\n   KeyValuePair : 96,\n   IntegerValue : 97,\n   DecimalValue : 98,\n   StringValue : 99,\n   BinaryValue : 100,\n   NameValue : 101,\n   Entry : 102,\n   ACL : 103,\n   ParameterizedName : 104,\n   Prefix : 105,\n   Suffix : 106,\n   Root : 107,\n   ProfileName : 108,\n   Parameters : 109,\n   InfoString : 110,\n  // 111 unallocated\n   StatusResponse : 112,\n   StatusCode : 113,\n   StatusText : 114,\n\n  // Sync protocol\n   SyncNode : 115,\n   SyncNodeKind : 116,\n   SyncNodeElement : 117,\n   SyncVersion : 118,\n   SyncNodeElements : 119,\n   SyncContentHash : 120,\n   SyncLeafCount : 121,\n   SyncTreeDepth : 122,\n   SyncByteCount : 123,\n   ConfigSlice : 124,\n   ConfigSliceList : 125,\n   ConfigSliceOp : 126,\n\n  // Remember to keep in sync with schema/tagnames.csvsdict\n   NDNProtocolDataUnit : 17702112,\n   NDNPROTOCOL_DATA_UNIT : "NDNProtocolDataUnit"\n};\n\nexports.NDNProtocolDTags = NDNProtocolDTags;\n\nvar NDNProtocolDTagsStrings = [\n  null, null, null, null, null, null, null, null, null, null, null,\n  null, null,\n  "Any", "Name", "Component", "Certificate", "Collection", "CompleteName",\n  "Content", "SignedInfo", "ContentDigest", "ContentHash", null, "Count", "Header",\n  "Interest", "Key", "KeyLocator", "KeyName", "Length", "Link", "LinkAuthenticator",\n  "NameComponentCount", null, null, "RootDigest", "Signature", "Start", "Timestamp", "Type",\n  "Nonce", "Scope", "Exclude", "Bloom", "BloomSeed", null, "AnswerOriginKind",\n  "InterestLifetime", null, null, null, null, "Witness", "SignatureBits", "DigestAlgorithm", "BlockSize",\n  null, "FreshnessSeconds", "FinalBlockID", "PublisherPublicKeyDigest", "PublisherCertificateDigest",\n  "PublisherIssuerKeyDigest", "PublisherIssuerCertificateDigest", "Data",\n  "WrappedKey", "WrappingKeyIdentifier", "WrapAlgorithm", "KeyAlgorithm", "Label",\n  "EncryptedKey", "EncryptedNonceKey", "WrappingKeyName", "Action", "FaceID", "IPProto",\n  "Host", "Port", "MulticastInterface", "ForwardingFlags", "FaceInstance",\n  "ForwardingEntry", "MulticastTTL", "MinSuffixComponents", "MaxSuffixComponents", "ChildSelector",\n  "RepositoryInfo", "Version", "RepositoryVersion", "GlobalPrefix", "LocalName",\n  "Policy", "Namespace", "GlobalPrefixName", "PolicyVersion", "KeyValueSet", "KeyValuePair",\n  "IntegerValue", "DecimalValue", "StringValue", "BinaryValue", "NameValue", "Entry",\n  "ACL", "ParameterizedName", "Prefix", "Suffix", "Root", "ProfileName", "Parameters",\n  "InfoString", null,\n    "StatusResponse", "StatusCode", "StatusText", "SyncNode", "SyncNodeKind", "SyncNodeElement",\n    "SyncVersion", "SyncNodeElements", "SyncContentHash", "SyncLeafCount", "SyncTreeDepth", "SyncByteCount",\n    "ConfigSlice", "ConfigSliceList", "ConfigSliceOp" ];\n\nexports.NDNProtocolDTagsStrings = NDNProtocolDTagsStrings;\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class represents NDNTime Objects\n */\n\n\n/**\n * @constructor\n */\nvar NDNTime = function NDNTime(input)\n{\n  this.NANOS_MAX = 999877929;\n\n  if (typeof input ==\'number\')\n    this.msec = input;\n  else {\n    if (LOG > 1) console.log(\'UNRECOGNIZED TYPE FOR TIME\');\n  }\n};\n\nexports.NDNTime = NDNTime;\n\nNDNTime.prototype.getJavascriptDate = function()\n{\n  var d = new Date();\n  d.setTime(this.msec);\n  return d\n};\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * This is the closure class for use in expressInterest to re express with exponential falloff.\n */\n\n\n/**\n * Create a new ExponentialReExpressClosure where upcall responds to UPCALL_INTEREST_TIMED_OUT\n *   by expressing the interest again with double the interestLifetime. If the interesLifetime goes\n *   over maxInterestLifetime, then call callerClosure.upcall with UPCALL_INTEREST_TIMED_OUT.\n * When upcall is not UPCALL_INTEREST_TIMED_OUT, just call callerClosure.upcall.\n * @constructor\n * @param {Closure} callerClosure\n * @param {Object} settings if not null, an associative array with the following defaults:\n * {\n *   maxInterestLifetime: 16000 // milliseconds\n * }\n */\nvar ExponentialReExpressClosure = function ExponentialReExpressClosure(callerClosure, settings)\n{\n  // Inherit from Closure.\n  Closure.call(this);\n\n  this.callerClosure = callerClosure;\n  settings = (settings || {});\n  this.maxInterestLifetime = (settings.maxInterestLifetime || 16000);\n};\n\nexports.ExponentialReExpressClosure = ExponentialReExpressClosure;\n\n/**\n * Wrap this.callerClosure to responds to UPCALL_INTEREST_TIMED_OUT\n *   by expressing the interest again as described in the constructor.\n */\nExponentialReExpressClosure.prototype.upcall = function(kind, upcallInfo)\n{\n  try {\n    if (kind == Closure.UPCALL_INTEREST_TIMED_OUT) {\n      var interestLifetime = upcallInfo.interest.interestLifetime;\n      if (interestLifetime == null)\n        return this.callerClosure.upcall(Closure.UPCALL_INTEREST_TIMED_OUT, upcallInfo);\n\n      var nextInterestLifetime = interestLifetime * 2;\n      if (nextInterestLifetime > this.maxInterestLifetime)\n        return this.callerClosure.upcall(Closure.UPCALL_INTEREST_TIMED_OUT, upcallInfo);\n\n      var nextInterest = upcallInfo.interest.clone();\n      nextInterest.interestLifetime = nextInterestLifetime;\n      // TODO: Use expressInterest with callbacks, not Closure.\n      upcallInfo.face.expressInterest(nextInterest.name, this, nextInterest);\n      return Closure.RESULT_OK;\n    }\n    else\n      return this.callerClosure.upcall(kind, upcallInfo);\n  } catch (ex) {\n    console.log("ExponentialReExpressClosure.upcall exception: " + ex);\n    return Closure.RESULT_ERR;\n  }\n};\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * Encapsulate a ndnbuf and support dynamic reallocation.\n */\n\n/**\n * Create a DynamicBuffer where this.array is a ndnbuf of size length.\n * The methods will update this.length.\n * To access the array, use this.array or call slice.\n * @constructor\n * @param {number} length the initial length of the array.  If null, use a default.\n */\nvar DynamicBuffer = function DynamicBuffer(length)\n{\n  if (!length)\n    length = 16;\n\n  this.array = new ndnbuf(length);\n  this.length = length;\n};\n\nexports.DynamicBuffer = DynamicBuffer;\n\n/**\n * Ensure that this.array has the length, reallocate and copy if necessary.\n * Update this.length which may be greater than length.\n */\nDynamicBuffer.prototype.ensureLength = function(length)\n{\n  if (this.array.length >= length)\n    return;\n\n  // See if double is enough.\n  var newLength = this.array.length * 2;\n  if (length > newLength)\n    // The needed length is much greater, so use it.\n    newLength = length;\n\n  var newArray = new ndnbuf(newLength);\n  this.array.copy(newArray);\n  this.array = newArray;\n  this.length = newLength;\n};\n\n/**\n * Copy the value to this.array at offset, reallocating if necessary.\n */\nDynamicBuffer.prototype.set = function(value, offset)\n{\n  this.ensureLength(value.length + offset);\n\n  if (typeof value == \'object\' && value instanceof ndnbuf)\n    value.copy(this.array, offset);\n  else\n    // Need to make value a ndnbuf to copy.\n    new ndnbuf(value).copy(this.array, offset);\n};\n\n/**\n * Return this.array.slice(begin, end);\n */\nDynamicBuffer.prototype.slice = function(begin, end)\n{\n  return this.array.slice(begin, end);\n};\n/**\n * This class contains utilities to help parse the data\n *\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Meki Cheraoui\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\n/**\n * A DataUtils has static methods for converting data.\n * @constructor\n */\nvar DataUtils = function DataUtils()\n{\n};\n\nexports.DataUtils = DataUtils;\n\n/*\n * NOTE THIS IS CURRENTLY NOT BEING USED\n *\n */\n\nDataUtils.keyStr = "ABCDEFGHIJKLMNOP" +\n                   "QRSTUVWXYZabcdef" +\n                   "ghijklmnopqrstuv" +\n                   "wxyz0123456789+/" +\n                   "=";\n\n/**\n * Raw String to Base 64\n */\nDataUtils.stringtoBase64 = function stringtoBase64(input)\n{\n   //input = escape(input);\n   var output = "";\n   var chr1, chr2, chr3 = "";\n   var enc1, enc2, enc3, enc4 = "";\n   var i = 0;\n\n   do {\n    chr1 = input.charCodeAt(i++);\n    chr2 = input.charCodeAt(i++);\n    chr3 = input.charCodeAt(i++);\n\n    enc1 = chr1 >> 2;\n    enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\n    enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\n    enc4 = chr3 & 63;\n\n    if (isNaN(chr2))\n       enc3 = enc4 = 64;\n    else if (isNaN(chr3))\n       enc4 = 64;\n\n    output = output +\n       DataUtils.keyStr.charAt(enc1) +\n       DataUtils.keyStr.charAt(enc2) +\n       DataUtils.keyStr.charAt(enc3) +\n       DataUtils.keyStr.charAt(enc4);\n    chr1 = chr2 = chr3 = "";\n    enc1 = enc2 = enc3 = enc4 = "";\n   } while (i < input.length);\n\n   return output;\n};\n\n/**\n * Base 64 to Raw String\n */\nDataUtils.base64toString = function base64toString(input)\n{\n  var output = "";\n  var chr1, chr2, chr3 = "";\n  var enc1, enc2, enc3, enc4 = "";\n  var i = 0;\n\n  // remove all characters that are not A-Z, a-z, 0-9, +, /, or =\n  var base64test = /[^A-Za-z0-9\\+\\/\\=]/g;\n  /* Test for invalid characters. */\n  if (base64test.exec(input)) {\n    alert("There were invalid base64 characters in the input text.\\n" +\n          "Valid base64 characters are A-Z, a-z, 0-9, \'+\', \'/\',and \'=\'\\n" +\n          "Expect errors in decoding.");\n  }\n\n  input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, "");\n\n  do {\n    enc1 = DataUtils.keyStr.indexOf(input.charAt(i++));\n    enc2 = DataUtils.keyStr.indexOf(input.charAt(i++));\n    enc3 = DataUtils.keyStr.indexOf(input.charAt(i++));\n    enc4 = DataUtils.keyStr.indexOf(input.charAt(i++));\n\n    chr1 = (enc1 << 2) | (enc2 >> 4);\n    chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);\n    chr3 = ((enc3 & 3) << 6) | enc4;\n\n    output = output + String.fromCharCode(chr1);\n\n    if (enc3 != 64)\n      output = output + String.fromCharCode(chr2);\n\n    if (enc4 != 64)\n      output = output + String.fromCharCode(chr3);\n\n    chr1 = chr2 = chr3 = "";\n    enc1 = enc2 = enc3 = enc4 = "";\n  } while (i < input.length);\n\n  return output;\n};\n\n/**\n * ndnbuf to Hex String\n */\nDataUtils.toHex = function(ndnbuf)\n{\n  return ndnbuf.toString(\'hex\');\n};\n\n/**\n * Raw string to hex string.\n */\nDataUtils.stringToHex = function(args)\n{\n  var ret = "";\n  for (var i = 0; i < args.length; ++i) {\n    var value = args.charCodeAt(i);\n    ret += (value < 16 ? "0" : "") + value.toString(16);\n  }\n  return ret;\n};\n\n/**\n * ndnbuf to raw string.\n */\nDataUtils.toString = function(ndnbuf)\n{\n  return ndnbuf.toString();\n};\n\n/**\n * Hex String to ndnbuf.\n */\nDataUtils.toNumbers = function(str)\n{\n  return new ndnbuf(str, \'hex\');\n};\n\n/**\n * Hex String to raw string.\n */\nDataUtils.hexToRawString = function(str)\n{\n  if (typeof str ==\'string\') {\n  var ret = "";\n  str.replace(/(..)/g, function(s) {\n    ret += String.fromCharCode(parseInt(s, 16));\n  });\n  return ret;\n  }\n};\n\n/**\n * Raw String to ndnbuf.\n */\nDataUtils.toNumbersFromString = function(str)\n{\n  return new ndnbuf(str, \'binary\');\n};\n\n/**\n * Encode str as utf8 and return as ndnbuf.\n */\nDataUtils.stringToUtf8Array = function(str)\n{\n  return new ndnbuf(str, \'utf8\');\n};\n\n/**\n * arrays is an array of ndnbuf. Return a new ndnbuf which is the concatenation of all.\n */\nDataUtils.concatArrays = function(arrays)\n{\n  return ndnbuf.concat(arrays);\n};\n\n// TODO: Take ndnbuf and use TextDecoder when available.\nDataUtils.decodeUtf8 = function(utftext)\n{\n  var string = "";\n  var i = 0;\n  var c = 0;\n    var c1 = 0;\n    var c2 = 0;\n\n  while (i < utftext.length) {\n    c = utftext.charCodeAt(i);\n\n    if (c < 128) {\n      string += String.fromCharCode(c);\n      i++;\n    }\n    else if (c > 191 && c < 224) {\n      c2 = utftext.charCodeAt(i + 1);\n      string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));\n      i += 2;\n    }\n    else {\n      c2 = utftext.charCodeAt(i+1);\n      var c3 = utftext.charCodeAt(i+2);\n      string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));\n      i += 3;\n    }\n  }\n\n  return string;\n};\n\n/**\n * Return true if a1 and a2 are the same length with equal elements.\n */\nDataUtils.arraysEqual = function(a1, a2)\n{\n  // A simple sanity check that it is an array.\n  if (!a1.slice)\n    throw new Error("DataUtils.arraysEqual: a1 is not an array");\n  if (!a2.slice)\n    throw new Error("DataUtils.arraysEqual: a2 is not an array");\n\n  if (a1.length != a2.length)\n    return false;\n\n  for (var i = 0; i < a1.length; ++i) {\n    if (a1[i] != a2[i])\n      return false;\n  }\n\n  return true;\n};\n\n/**\n * Convert the big endian ndnbuf to an unsigned int.\n * Don\'t check for overflow.\n */\nDataUtils.bigEndianToUnsignedInt = function(bytes)\n{\n  var result = 0;\n  for (var i = 0; i < bytes.length; ++i) {\n    result <<= 8;\n    result += bytes[i];\n  }\n  return result;\n};\n\n/**\n * Convert the int value to a new big endian ndnbuf and return.\n * If value is 0 or negative, return new ndnbuf(0).\n */\nDataUtils.nonNegativeIntToBigEndian = function(value)\n{\n  value = Math.round(value);\n  if (value <= 0)\n    return new ndnbuf(0);\n\n  // Assume value is not over 64 bits.\n  var size = 8;\n  var result = new ndnbuf(size);\n  var i = 0;\n  while (value != 0) {\n    ++i;\n    result[size - i] = value & 0xff;\n    value >>= 8;\n  }\n  return result.slice(size - i, size);\n};\n\n/**\n * Modify array to randomly shuffle the elements.\n */\nDataUtils.shuffle = function(array)\n{\n  for (var i = array.length - 1; i >= 1; --i) {\n    // j is from 0 to i.\n    var j = Math.floor(Math.random() * (i + 1));\n    var temp = array[i];\n    array[i] = array[j];\n    array[j] = temp;\n  }\n};\n/*\n * Date Format 1.2.3\n * (c) 2007-2009 Steven Levithan <stevenlevithan.com>\n * MIT license\n *\n * Includes enhancements by Scott Trenda <scott.trenda.net>\n * and Kris Kowal <cixar.com/~kris.kowal/>\n *\n * Accepts a date, a mask, or a date and a mask.\n * Returns a formatted version of the given date.\n * The date defaults to the current date/time.\n * The mask defaults to dateFormat.masks.default.\n */\n\nvar DateFormat = function()\n{\n  var  token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\\1?|[LloSZ]|"[^"]*"|\'[^\']*\'/g,\n    timezone = /\\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\\d{4})?)\\b/g,\n    timezoneClip = /[^-+\\dA-Z]/g,\n    pad = function(val, len) {\n      val = String(val);\n      len = len || 2;\n      while (val.length < len) val = "0" + val;\n      return val;\n    };\n\n  // Regexes and supporting functions are cached through closure\n  return function(date, mask, utc) {\n    var dF = dateFormat;\n\n    // You can\'t provide utc if you skip other args (use the "UTC:" mask prefix)\n    if (arguments.length == 1 && Object.prototype.toString.call(date) == "[object String]" && !/\\d/.test(date)) {\n      mask = date;\n      date = undefined;\n    }\n\n    // Passing date through Date applies Date.parse, if necessary\n    date = date ? new Date(date) : new Date;\n    if (isNaN(date)) throw SyntaxError("invalid date");\n\n    mask = String(dF.masks[mask] || mask || dF.masks["default"]);\n\n    // Allow setting the utc argument via the mask\n    if (mask.slice(0, 4) == "UTC:") {\n      mask = mask.slice(4);\n      utc = true;\n    }\n\n    var  _ = utc ? "getUTC" : "get",\n      d = date[_ + "Date"](),\n      D = date[_ + "Day"](),\n      m = date[_ + "Month"](),\n      y = date[_ + "FullYear"](),\n      H = date[_ + "Hours"](),\n      M = date[_ + "Minutes"](),\n      s = date[_ + "Seconds"](),\n      L = date[_ + "Milliseconds"](),\n      o = utc ? 0 : date.getTimezoneOffset(),\n      flags = {\n        d:    d,\n        dd:   pad(d),\n        ddd:  dF.i18n.dayNames[D],\n        dddd: dF.i18n.dayNames[D + 7],\n        m:    m + 1,\n        mm:   pad(m + 1),\n        mmm:  dF.i18n.monthNames[m],\n        mmmm: dF.i18n.monthNames[m + 12],\n        yy:   String(y).slice(2),\n        yyyy: y,\n        h:    H % 12 || 12,\n        hh:   pad(H % 12 || 12),\n        H:    H,\n        HH:   pad(H),\n        M:    M,\n        MM:   pad(M),\n        s:    s,\n        ss:   pad(s),\n        l:    pad(L, 3),\n        L:    pad(L > 99 ? Math.round(L / 10) : L),\n        t:    H < 12 ? "a"  : "p",\n        tt:   H < 12 ? "am" : "pm",\n        T:    H < 12 ? "A"  : "P",\n        TT:   H < 12 ? "AM" : "PM",\n        Z:    utc ? "UTC" : (String(date).match(timezone) || [""]).pop().replace(timezoneClip, ""),\n        o:    (o > 0 ? "-" : "+") + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),\n        S:    ["th", "st", "nd", "rd"][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10]\n      };\n\n    return mask.replace(token, function($0) {\n      return $0 in flags ? flags[$0] : $0.slice(1, $0.length - 1);\n    });\n  };\n}();\n\n// Some common format strings\nDateFormat.masks = {\n  "default":      "ddd mmm dd yyyy HH:MM:ss",\n  shortDate:      "m/d/yy",\n  mediumDate:     "mmm d, yyyy",\n  longDate:       "mmmm d, yyyy",\n  fullDate:       "dddd, mmmm d, yyyy",\n  shortTime:      "h:MM TT",\n  mediumTime:     "h:MM:ss TT",\n  longTime:       "h:MM:ss TT Z",\n  isoDate:        "yyyy-mm-dd",\n  isoTime:        "HH:MM:ss",\n  isoDateTime:    "yyyy-mm-dd\'T\'HH:MM:ss",\n  isoUtcDateTime: "UTC:yyyy-mm-dd\'T\'HH:MM:ss\'Z\'"\n};\n\n// Internationalization strings\nDateFormat.i18n = {\n  dayNames: [\n    "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat",\n    "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"\n  ],\n  monthNames: [\n    "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",\n    "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"\n  ]\n};\n\n// For convenience...\nDate.prototype.format = function(mask, utc) {\n  return dateFormat(this, mask, utc);\n};\n/**\n * This class is used to encode ndnb binary elements (blob, type/value pairs).\n *\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n */\n\n\nvar XML_EXT = 0x00;\n\nvar XML_TAG = 0x01;\n\nvar XML_DTAG = 0x02;\n\nvar XML_ATTR = 0x03;\n\nvar XML_DATTR = 0x04;\n\nvar XML_BLOB = 0x05;\n\nvar XML_UDATA = 0x06;\n\nvar XML_CLOSE = 0x0;\n\nvar XML_SUBTYPE_PROCESSING_INSTRUCTIONS = 16;\n\n\nvar XML_TT_BITS = 3;\nvar XML_TT_MASK = ((1 << XML_TT_BITS) - 1);\nvar XML_TT_VAL_BITS = XML_TT_BITS + 1;\nvar XML_TT_VAL_MASK = ((1 << (XML_TT_VAL_BITS)) - 1);\nvar XML_REG_VAL_BITS = 7;\nvar XML_REG_VAL_MASK = ((1 << XML_REG_VAL_BITS) - 1);\nvar XML_TT_NO_MORE = (1 << XML_REG_VAL_BITS); // 0x80\nvar BYTE_MASK = 0xFF;\nvar LONG_BYTES = 8;\nvar LONG_BITS = 64;\n\nvar bits_11 = 0x0000007FF;\nvar bits_18 = 0x00003FFFF;\nvar bits_32 = 0x0FFFFFFFF;\n\n/**\n * @constructor\n */\nvar BinaryXMLEncoder = function BinaryXMLEncoder(initiaLength)\n{\n  if (!initiaLength)\n    initiaLength = 16;\n\n  this.ostream = new DynamicBuffer(initiaLength);\n  this.offset = 0;\n  this.CODEC_NAME = "Binary";\n};\n\nexports.BinaryXMLEncoder = BinaryXMLEncoder;\n\n/**\n * Encode utf8Content as utf8 and write to the output ndnbuf as a UDATA.\n * @param {string} utf8Content The string to convert to utf8.\n */\nBinaryXMLEncoder.prototype.writeUString = function(utf8Content)\n{\n  this.encodeUString(utf8Content, XML_UDATA);\n};\n\nBinaryXMLEncoder.prototype.writeBlob = function(\n    /*Buffer*/ binaryContent)\n{\n  if (LOG >3) console.log(binaryContent);\n\n  this.encodeBlob(binaryContent, binaryContent.length);\n};\n\n/**\n * Write an element start header using DTAG with the tag to the output ndnbuf.\n * @param {number} tag The DTAG tag.\n */\nBinaryXMLEncoder.prototype.writeElementStartDTag = function(tag)\n{\n  this.encodeTypeAndVal(XML_DTAG, tag);\n};\n\n/**\n * @deprecated Use writeElementStartDTag.  Binary XML string tags and attributes are not used by any NDN encodings and\n * support is not maintained in the code base.\n */\nBinaryXMLEncoder.prototype.writeStartElement = function(\n  /*String*/ tag,\n  /*TreeMap<String,String>*/ attributes)\n{\n  /*Long*/ var dictionaryVal = tag; //stringToTag(tag);\n\n  if (null == dictionaryVal)\n    this.encodeUString(tag, XML_TAG);\n  else\n    this.encodeTypeAndVal(XML_DTAG, dictionaryVal);\n\n  if (null != attributes)\n    this.writeAttributes(attributes);\n};\n\n/**\n * Write an element close to the output ndnbuf.\n */\nBinaryXMLEncoder.prototype.writeElementClose = function()\n{\n  this.ostream.ensureLength(this.offset + 1);\n  this.ostream.array[this.offset] = XML_CLOSE;\n  this.offset += 1;\n};\n\n/**\n * @deprecated Use writeElementClose.\n */\nBinaryXMLEncoder.prototype.writeEndElement = function()\n{\n  this.writeElementClose();\n};\n\n/**\n * @deprecated Binary XML string tags and attributes are not used by any NDN encodings and support is not maintained in the code base.\n */\nBinaryXMLEncoder.prototype.writeAttributes = function(/*TreeMap<String,String>*/ attributes)\n{\n  if (null == attributes)\n    return;\n\n  // the keySet of a TreeMap is sorted.\n\n  for (var i = 0; i< attributes.length;i++) {\n    var strAttr = attributes[i].k;\n    var strValue = attributes[i].v;\n\n    var dictionaryAttr = stringToTag(strAttr);\n    if (null == dictionaryAttr)\n      // not in dictionary, encode as attr\n      // compressed format wants length of tag represented as length-1\n      // to save that extra bit, as tag cannot be 0 length.\n      // encodeUString knows to do that.\n      this.encodeUString(strAttr, XML_ATTR);\n    else\n      this.encodeTypeAndVal(XML_DATTR, dictionaryAttr);\n\n    // Write value\n    this.encodeUString(strValue);\n  }\n};\n\n//returns a string\nstringToTag = function(/*long*/ tagVal)\n{\n  if (tagVal >= 0 && tagVal < NDNProtocolDTagsStrings.length)\n    return NDNProtocolDTagsStrings[tagVal];\n  else if (tagVal == NDNProtocolDTags.NDNProtocolDataUnit)\n    return NDNProtocolDTags.NDNPROTOCOL_DATA_UNIT;\n\n  return null;\n};\n\n//returns a Long\ntagToString =  function(/*String*/ tagName)\n{\n  // the slow way, but right now we don\'t care.... want a static lookup for the forward direction\n  for (var i = 0; i < NDNProtocolDTagsStrings.length; ++i) {\n    if (null != NDNProtocolDTagsStrings[i] && NDNProtocolDTagsStrings[i] == tagName)\n      return i;\n  }\n\n  if (NDNProtocolDTags.NDNPROTOCOL_DATA_UNIT == tagName)\n    return NDNProtocolDTags.NDNProtocolDataUnit;\n\n  return null;\n};\n\n/**\n * Write an element start header using DTAG with the tag to the output ndnbuf, then the content as explained below,\n * then an element close.\n * @param {number} tag The DTAG tag.\n * @param {number|string|Buffer} content If contentis a number, convert it to a string and call writeUString.  If content is a string,\n * call writeUString.  Otherwise, call writeBlob.\n */\nBinaryXMLEncoder.prototype.writeDTagElement = function(tag, content)\n{\n  this.writeElementStartDTag(tag);\n\n  if (typeof content === \'number\')\n    this.writeUString(content.toString());\n  else if (typeof content === \'string\')\n    this.writeUString(content);\n  else\n    this.writeBlob(content);\n\n  this.writeElementClose();\n};\n\n/**\n * @deprecated Use writeDTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and\n * support is not maintained in the code base.\n * If Content is a string, then encode as utf8 and write UDATA.\n */\nBinaryXMLEncoder.prototype.writeElement = function(\n    //long\n    tag,\n    //byte[]\n    Content,\n    //TreeMap<String, String>\n    attributes)\n{\n  this.writeStartElement(tag, attributes);\n  // Will omit if 0-length\n\n  if (typeof Content === \'number\') {\n    if (LOG > 4) console.log(\'GOING TO WRITE THE NUMBER .charCodeAt(0) \' + Content.toString().charCodeAt(0));\n    if (LOG > 4) console.log(\'GOING TO WRITE THE NUMBER \' + Content.toString());\n    if (LOG > 4) console.log(\'type of number is \' + typeof Content.toString());\n\n    this.writeUString(Content.toString());\n  }\n  else if (typeof Content === \'string\') {\n    if (LOG > 4) console.log(\'GOING TO WRITE THE STRING  \' + Content);\n    if (LOG > 4) console.log(\'type of STRING is \' + typeof Content);\n\n    this.writeUString(Content);\n  }\n  else {\n    if (LOG > 4) console.log(\'GOING TO WRITE A BLOB  \' + Content);\n\n    this.writeBlob(Content);\n  }\n\n  this.writeElementClose();\n};\n\nvar TypeAndVal = function TypeAndVal(_type,_val)\n{\n  this.type = _type;\n  this.val = _val;\n};\n\nBinaryXMLEncoder.prototype.encodeTypeAndVal = function(\n    //int\n    type,\n    //long\n    val)\n{\n  if (LOG > 4) console.log(\'Encoding type \'+ type+ \' and value \'+ val);\n\n  if (LOG > 4) console.log(\'OFFSET IS \' + this.offset);\n\n  if (type > XML_UDATA || type < 0 || val < 0)\n    throw new Error("Tag and value must be positive, and tag valid.");\n\n  // Encode backwards. Calculate how many bytes we need:\n  var numEncodingBytes = this.numEncodingBytes(val);\n  this.ostream.ensureLength(this.offset + numEncodingBytes);\n\n  // Bottom 4 bits of val go in last byte with tag.\n  this.ostream.array[this.offset + numEncodingBytes - 1] =\n    //(byte)\n      (BYTE_MASK &\n          (((XML_TT_MASK & type) |\n           ((XML_TT_VAL_MASK & val) << XML_TT_BITS))) |\n           XML_TT_NO_MORE); // set top bit for last byte\n  val = val >>> XML_TT_VAL_BITS;\n\n  // Rest of val goes into preceding bytes, 7 bits per byte, top bit\n  // is "more" flag.\n  var i = this.offset + numEncodingBytes - 2;\n  while (0 != val && i >= this.offset) {\n    this.ostream.array[i] = //(byte)\n        (BYTE_MASK & (val & XML_REG_VAL_MASK)); // leave top bit unset\n    val = val >>> XML_REG_VAL_BITS;\n    --i;\n  }\n\n  if (val != 0)\n    throw new Error("This should not happen: miscalculated encoding");\n\n  this.offset+= numEncodingBytes;\n\n  return numEncodingBytes;\n};\n\n/**\n * Encode ustring as utf8.\n */\nBinaryXMLEncoder.prototype.encodeUString = function(\n    //String\n    ustring,\n    //byte\n    type)\n{\n  if (null == ustring)\n    return;\n  if (type == XML_TAG || type == XML_ATTR && ustring.length == 0)\n    return;\n\n  if (LOG > 3) console.log("The string to write is ");\n  if (LOG > 3) console.log(ustring);\n\n  var strBytes = DataUtils.stringToUtf8Array(ustring);\n\n  this.encodeTypeAndVal(type,\n            (((type == XML_TAG) || (type == XML_ATTR)) ?\n                (strBytes.length-1) :\n                strBytes.length));\n\n  if (LOG > 3) console.log("THE string to write is ");\n\n  if (LOG > 3) console.log(strBytes);\n\n  this.writeString(strBytes);\n  this.offset+= strBytes.length;\n};\n\n\nBinaryXMLEncoder.prototype.encodeBlob = function(\n    //Buffer\n    blob,\n    //int\n    length)\n{\n  if (null == blob)\n    return;\n\n  if (LOG > 4) console.log(\'LENGTH OF XML_BLOB IS \'+length);\n\n  this.encodeTypeAndVal(XML_BLOB, length);\n  this.writeBlobArray(blob);\n  this.offset += length;\n};\n\nvar ENCODING_LIMIT_1_BYTE = ((1 << (XML_TT_VAL_BITS)) - 1);\nvar ENCODING_LIMIT_2_BYTES = ((1 << (XML_TT_VAL_BITS + XML_REG_VAL_BITS)) - 1);\nvar ENCODING_LIMIT_3_BYTES = ((1 << (XML_TT_VAL_BITS + 2 * XML_REG_VAL_BITS)) - 1);\n\nBinaryXMLEncoder.prototype.numEncodingBytes = function(\n    //long\n    x)\n{\n  if (x <= ENCODING_LIMIT_1_BYTE) return (1);\n  if (x <= ENCODING_LIMIT_2_BYTES) return (2);\n  if (x <= ENCODING_LIMIT_3_BYTES) return (3);\n\n  var numbytes = 1;\n\n  // Last byte gives you XML_TT_VAL_BITS\n  // Remainder each give you XML_REG_VAL_BITS\n  x = x >>> XML_TT_VAL_BITS;\n  while (x != 0) {\n        numbytes++;\n    x = x >>> XML_REG_VAL_BITS;\n  }\n  return (numbytes);\n};\n\n/**\n * Write an element start header using DTAG with the tag to the output ndnbuf, then the dateTime\n   * as a big endian BLOB converted to 4096 ticks per second, then an element close.\n * @param {number} tag The DTAG tag.\n * @param {NDNTime} dateTime\n */\nBinaryXMLEncoder.prototype.writeDateTimeDTagElement = function(tag, dateTime)\n{\n  //parse to hex\n  var binarydate =  Math.round((dateTime.msec/1000) * 4096).toString(16)  ;\n  if (binarydate.length % 2 == 1)\n    binarydate = \'0\' + binarydate;\n\n  this.writeDTagElement(tag, DataUtils.toNumbers(binarydate));\n};\n\n/**\n * @deprecated Use writeDateTimeDTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and\n * support is not maintained in the code base.\n */\nBinaryXMLEncoder.prototype.writeDateTime = function(\n    //String\n    tag,\n    //NDNTime\n    dateTime)\n{\n  //parse to hex\n  var binarydate =  Math.round((dateTime.msec/1000) * 4096).toString(16)  ;\n  if (binarydate.length % 2 == 1)\n    binarydate = \'0\' + binarydate;\n\n  this.writeElement(tag, DataUtils.toNumbers(binarydate));\n};\n\n// This does not update this.offset.\nBinaryXMLEncoder.prototype.writeString = function(input)\n{\n  if (typeof input === \'string\') {\n    if (LOG > 4) console.log(\'GOING TO WRITE A STRING\');\n    if (LOG > 4) console.log(input);\n\n    this.ostream.ensureLength(this.offset + input.length);\n    for (var i = 0; i < input.length; i++) {\n      if (LOG > 4) console.log(\'input.charCodeAt(i)=\' + input.charCodeAt(i));\n      this.ostream.array[this.offset + i] = (input.charCodeAt(i));\n    }\n  }\n  else\n  {\n    if (LOG > 4) console.log(\'GOING TO WRITE A STRING IN BINARY FORM\');\n    if (LOG > 4) console.log(input);\n\n    this.writeBlobArray(input);\n  }\n};\n\nBinaryXMLEncoder.prototype.writeBlobArray = function(\n    //Buffer\n    blob)\n{\n  if (LOG > 4) console.log(\'GOING TO WRITE A BLOB\');\n\n  this.ostream.set(blob, this.offset);\n};\n\nBinaryXMLEncoder.prototype.getReducedOstream = function()\n{\n  return this.ostream.slice(0, this.offset);\n};\n/**\n * This class is used to decode ndnb binary elements (blob, type/value pairs).\n *\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n */\n\n\nvar XML_EXT = 0x00;\n\nvar XML_TAG = 0x01;\n\nvar XML_DTAG = 0x02;\n\nvar XML_ATTR = 0x03;\n\nvar XML_DATTR = 0x04;\n\nvar XML_BLOB = 0x05;\n\nvar XML_UDATA = 0x06;\n\nvar XML_CLOSE = 0x0;\n\nvar XML_SUBTYPE_PROCESSING_INSTRUCTIONS = 16;\n\n\nvar XML_TT_BITS = 3;\nvar XML_TT_MASK = ((1 << XML_TT_BITS) - 1);\nvar XML_TT_VAL_BITS = XML_TT_BITS + 1;\nvar XML_TT_VAL_MASK = ((1 << (XML_TT_VAL_BITS)) - 1);\nvar XML_REG_VAL_BITS = 7;\nvar XML_REG_VAL_MASK = ((1 << XML_REG_VAL_BITS) - 1);\nvar XML_TT_NO_MORE = (1 << XML_REG_VAL_BITS); // 0x80\nvar BYTE_MASK = 0xFF;\nvar LONG_BYTES = 8;\nvar LONG_BITS = 64;\n\nvar bits_11 = 0x0000007FF;\nvar bits_18 = 0x00003FFFF;\nvar bits_32 = 0x0FFFFFFFF;\n\n\n\n//returns a string\ntagToString = function(/*long*/ tagVal)\n{\n  if (tagVal >= 0 && tagVal < NDNProtocolDTagsStrings.length) {\n    return NDNProtocolDTagsStrings[tagVal];\n  }\n  else if (tagVal == NDNProtocolDTags.NDNProtocolDataUnit) {\n    return NDNProtocolDTags.NDNPROTOCOL_DATA_UNIT;\n  }\n\n  return null;\n};\n\n//returns a Long\nstringToTag =  function(/*String*/ tagName)\n{\n  // the slow way, but right now we don\'t care.... want a static lookup for the forward direction\n  for (var i=0; i < NDNProtocolDTagsStrings.length; ++i) {\n    if (null != NDNProtocolDTagsStrings[i] && NDNProtocolDTagsStrings[i] == tagName)\n      return i;\n  }\n  if (NDNProtocolDTags.NDNPROTOCOL_DATA_UNIT == tagName) {\n    return NDNProtocolDTags.NDNProtocolDataUnit;\n  }\n\n  return null;\n};\n\n/**\n * @constructor\n */\nvar BinaryXMLDecoder = function BinaryXMLDecoder(input)\n{\n  var MARK_LEN=512;\n  var DEBUG_MAX_LEN =  32768;\n\n  this.input = input;\n  this.offset = 0;\n  // peekDTag sets and checks this, and readElementStartDTag uses it to avoid reading again.\n  this.previouslyPeekedDTagStartOffset = -1;\n};\n\nexports.BinaryXMLDecoder = BinaryXMLDecoder;\n\n/**\n * Decode the header from the input starting at its position, expecting the type to be DTAG and the value to be expectedTag.\n   * Update the input\'s offset.\n * @param {number} expectedTag The expected value for DTAG.\n */\nBinaryXMLDecoder.prototype.readElementStartDTag = function(expectedTag)\n{\n  if (this.offset == this.previouslyPeekedDTagStartOffset) {\n    // peekDTag already decoded this DTag.\n    if (this.previouslyPeekedDTag != expectedTag)\n      throw new ContentDecodingException(new Error("Did not get the expected DTAG " + expectedTag + ", got " + this.previouslyPeekedDTag));\n\n    // Fast forward past the header.\n    this.offset = this.previouslyPeekedDTagEndOffset;\n  }\n  else {\n    var typeAndValue = this.decodeTypeAndVal();\n    if (typeAndValue == null || typeAndValue.type() != XML_DTAG)\n      throw new ContentDecodingException(new Error("Header type is not a DTAG"));\n\n    if (typeAndValue.val() != expectedTag)\n      throw new ContentDecodingException(new Error("Expected start element: " + expectedTag + " got: " + typeAndValue.val()));\n  }\n};\n\n/**\n * @deprecated Use readElementStartDTag. Binary XML string tags and attributes are not used by any NDN encodings and\n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.readStartElement = function(\n    //String\n    startTag,\n    //TreeMap<String, String>\n    attributes)\n{\n  //TypeAndVal\n  var tv = this.decodeTypeAndVal();\n\n  if (null == tv)\n    throw new ContentDecodingException(new Error("Expected start element: " + startTag + " got something not a tag."));\n\n  //String\n  var decodedTag = null;\n\n  if (tv.type() == XML_TAG) {\n    // Tag value represents length-1 as tags can never be empty.\n    var valval;\n\n    if (typeof tv.val() == \'string\')\n      valval = (parseInt(tv.val())) + 1;\n    else\n      valval = (tv.val())+ 1;\n\n    decodedTag = this.decodeUString(valval);\n  }\n  else if (tv.type() == XML_DTAG)\n    decodedTag = tv.val();\n\n  if (null ==  decodedTag || decodedTag != startTag) {\n    console.log(\'expecting \'+ startTag + \' but got \'+ decodedTag);\n    throw new ContentDecodingException(new Error("Expected start element: " + startTag + " got: " + decodedTag + "(" + tv.val() + ")"));\n  }\n\n  // DKS: does not read attributes out of stream if caller doesn\'t\n  // ask for them. Should possibly peek and skip over them regardless.\n  // TODO: fix this\n  if (null != attributes)\n    readAttributes(attributes);\n};\n\n/**\n * @deprecated Binary XML string tags and attributes are not used by any NDN encodings and support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.readAttributes = function(\n  // array of [attributeName, attributeValue]\n  attributes)\n{\n  if (null == attributes)\n    return;\n\n  try {\n    // Now need to get attributes.\n    //TypeAndVal\n    var nextTV = this.peekTypeAndVal();\n\n    while (null != nextTV && (XML_ATTR == nextTV.type() || XML_DATTR == nextTV.type())) {\n      // Decode this attribute. First, really read the type and value.\n      //this.TypeAndVal\n      var thisTV = this.decodeTypeAndVal();\n\n      //String\n      var attributeName = null;\n      if (XML_ATTR == thisTV.type()) {\n        // Tag value represents length-1 as attribute names cannot be empty.\n        var valval ;\n        if (typeof thisTV.val() == \'string\')\n          valval = (parseInt(thisTV.val())) + 1;\n        else\n          valval = (thisTV.val())+ 1;\n\n        attributeName = this.decodeUString(valval);\n      }\n      else if (XML_DATTR == thisTV.type()) {\n        // DKS TODO are attributes same or different dictionary?\n        attributeName = tagToString(thisTV.val());\n        if (null == attributeName)\n          throw new ContentDecodingException(new Error("Unknown DATTR value" + thisTV.val()));\n      }\n\n      // Attribute values are always UDATA\n      //String\n      var attributeValue = this.decodeUString();\n\n      attributes.push([attributeName, attributeValue]);\n      nextTV = this.peekTypeAndVal();\n    }\n  }\n  catch (e) {\n    throw new ContentDecodingException(new Error("readStartElement", e));\n  }\n};\n\n/**\n * @deprecated Use peekDTag.  Binary XML string tags and attributes are not used by any NDN encodings and\n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.peekStartElementAsString = function()\n{\n  //String\n  var decodedTag = null;\n  var previousOffset = this.offset;\n  try {\n    // Have to distinguish genuine errors from wrong tags. Could either use\n    // a special exception subtype, or redo the work here.\n    //this.TypeAndVal\n    var tv = this.decodeTypeAndVal();\n\n    if (null != tv) {\n      if (tv.type() == XML_TAG) {\n        // Tag value represents length-1 as tags can never be empty.\n        var valval ;\n        if (typeof tv.val() == \'string\')\n          valval = (parseInt(tv.val())) + 1;\n        else\n          valval = (tv.val())+ 1;\n\n        decodedTag = this.decodeUString(valval);\n      }\n      else if (tv.type() == XML_DTAG)\n        decodedTag = tagToString(tv.val());\n    } // else, not a type and val, probably an end element. rewind and return false.\n  }\n  catch (e) {\n  }\n  finally {\n    try {\n      this.offset = previousOffset;\n    }\n    catch (e) {\n      Log.logStackTrace(Log.FAC_ENCODING, Level.WARNING, e);\n      throw new ContentDecodingException(new Error("Cannot reset stream! " + e.getMessage(), e));\n    }\n  }\n\n  return decodedTag;\n};\n\n/**\n * Decode the header from the input starting at its position, and if it is a DTAG where the value is the expectedTag,\n * then set return true.  Do not update the input\'s offset.\n * @param {number} expectedTag The expected value for DTAG.\n * @returns {boolean} True if the tag is the expected tag, otherwise false.\n */\nBinaryXMLDecoder.prototype.peekDTag = function(expectedTag)\n{\n  if (this.offset == this.previouslyPeekedDTagStartOffset)\n    // We already decoded this DTag.\n    return this.previouslyPeekedDTag == expectedTag;\n  else {\n    // First check if it is an element close (which cannot be the expected tag).\n    if (this.input[this.offset] == XML_CLOSE)\n      return false;\n\n    var saveOffset = this.offset;\n    var typeAndValue = this.decodeTypeAndVal();\n    // readElementStartDTag will use this to fast forward.\n    this.previouslyPeekedDTagEndOffset = this.offset;\n    // Restore the position.\n    this.offset = saveOffset;\n\n    if (typeAndValue != null && typeAndValue.type() == XML_DTAG) {\n      this.previouslyPeekedDTagStartOffset = saveOffset;\n      this.previouslyPeekedDTag = typeAndValue.val();\n\n      return typeAndValue.val() == expectedTag;\n    }\n    else\n      return false;\n  }\n};\n\n/**\n * @deprecated Use peekDTag.  Binary XML string tags and attributes are not used by any NDN encodings and\n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.peekStartElement = function(\n    //String\n    startTag)\n{\n  //String\n  if (typeof startTag == \'string\') {\n    var decodedTag = this.peekStartElementAsString();\n\n    if (null !=  decodedTag && decodedTag == startTag)\n      return true;\n\n    return false;\n  }\n  else if (typeof startTag == \'number\') {\n    var decodedTag = this.peekStartElementAsLong();\n    if (null !=  decodedTag && decodedTag == startTag)\n      return true;\n\n    return false;\n  }\n  else\n    throw new ContentDecodingException(new Error("SHOULD BE STRING OR NUMBER"));\n};\n\n/**\n * @deprecated Use peekDTag.  Binary XML string tags and attributes are not used by any NDN encodings and\n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.peekStartElementAsLong = function()\n{\n  //Long\n  var decodedTag = null;\n  var previousOffset = this.offset;\n\n  try {\n    // Have to distinguish genuine errors from wrong tags. Could either use\n    // a special exception subtype, or redo the work here.\n    //this.TypeAndVal\n    var tv = this.decodeTypeAndVal();\n\n    if (null != tv) {\n      if (tv.type() == XML_TAG) {\n        if (tv.val() + 1 > DEBUG_MAX_LEN)\n          throw new ContentDecodingException(new Error("Decoding error: length " + tv.val()+1 + " longer than expected maximum length!"));\n\n        var valval;\n        if (typeof tv.val() == \'string\')\n          valval = (parseInt(tv.val())) + 1;\n        else\n          valval = (tv.val())+ 1;\n\n        // Tag value represents length-1 as tags can never be empty.\n        //String\n        var strTag = this.decodeUString(valval);\n\n        decodedTag = stringToTag(strTag);\n      }\n      else if (tv.type() == XML_DTAG)\n        decodedTag = tv.val();\n    } // else, not a type and val, probably an end element. rewind and return false.\n\n  }\n  catch (e) {\n  }\n  finally {\n    try {\n      //this.input.reset();\n      this.offset = previousOffset;\n    } catch (e) {\n      Log.logStackTrace(Log.FAC_ENCODING, Level.WARNING, e);\n      throw new Error("Cannot reset stream! " + e.getMessage(), e);\n    }\n  }\n\n  return decodedTag;\n};\n\n/**\n * Decode the header from the input starting its offset, expecting the type to be DTAG and the value to be expectedTag.\n * Then read one item of any type (presumably BLOB, UDATA, TAG or ATTR) and return a\n * ndnbuf. However, if allowNull is true, then the item may be absent.\n * Finally, read the element close.  Update the input\'s offset.\n * @param {number} expectedTag The expected value for DTAG.\n * @param {boolean} allowNull True if the binary item may be missing.\n * @returns {Buffer} A ndnbuf which is a slice on the data inside the input ndnbuf. However,\n * if allowNull is true and the binary data item is absent, then return null.\n */\nBinaryXMLDecoder.prototype.readBinaryDTagElement = function(expectedTag, allowNull)\n{\n  this.readElementStartDTag(expectedTag);\n  return this.readBlob(allowNull);\n};\n\n/**\n * @deprecated Use readBinaryDTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and\n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.readBinaryElement = function(\n    //long\n    startTag,\n    //TreeMap<String, String>\n    attributes,\n    //boolean\n    allowNull)\n{\n  this.readStartElement(startTag, attributes);\n  return this.readBlob(allowNull);\n};\n\n/**\n * Read one byte from the input starting at its offset, expecting it to be the element close.\n * Update the input\'s offset.\n */\nBinaryXMLDecoder.prototype.readElementClose = function()\n{\n  var next = this.input[this.offset++];\n  if (next != XML_CLOSE)\n    throw new ContentDecodingException(new Error("Expected end element, got: " + next));\n};\n\n/**\n * @deprecated Use readElementClose.\n */\nBinaryXMLDecoder.prototype.readEndElement = function()\n{\n  if (LOG > 4) console.log(\'this.offset is \'+this.offset);\n\n  var next = this.input[this.offset];\n\n  this.offset++;\n\n  if (LOG > 4) console.log(\'XML_CLOSE IS \'+XML_CLOSE);\n  if (LOG > 4) console.log(\'next is \'+next);\n\n  if (next != XML_CLOSE) {\n    console.log("Expected end element, got: " + next);\n    throw new ContentDecodingException(new Error("Expected end element, got: " + next));\n  }\n};\n\n//String\nBinaryXMLDecoder.prototype.readUString = function()\n{\n  //String\n  var ustring = this.decodeUString();\n  this.readElementClose();\n  return ustring;\n};\n\n/**\n * Read a blob as well as the end element. Returns a ndnbuf (or null for missing blob).\n * If the blob is missing and allowNull is false (default), throw an exception.  Otherwise,\n *   just read the end element and return null.\n */\nBinaryXMLDecoder.prototype.readBlob = function(allowNull)\n{\n  if (this.input[this.offset] == XML_CLOSE && allowNull) {\n    this.readElementClose();\n    return null;\n  }\n\n  var blob = this.decodeBlob();\n  this.readElementClose();\n  return blob;\n};\n\n/**\n * Decode the header from the input starting at its offset, expecting the type to be\n * DTAG and the value to be expectedTag.  Then read one item, parse it as an unsigned\n * big endian integer in 4096 ticks per second, and convert it to and NDNTime object.\n * Finally, read the element close.  Update the input\'s offset.\n * @param {number} expectedTag The expected value for DTAG.\n * @returns {NDNTime} The dateTime value.\n */\nBinaryXMLDecoder.prototype.readDateTimeDTagElement = function(expectedTag)\n{\n  var byteTimestamp = this.readBinaryDTagElement(expectedTag);\n  byteTimestamp = DataUtils.toHex(byteTimestamp);\n  byteTimestamp = parseInt(byteTimestamp, 16);\n\n  var lontimestamp = (byteTimestamp/ 4096) * 1000;\n\n  var timestamp = new NDNTime(lontimestamp);\n  if (null == timestamp)\n    throw new ContentDecodingException(new Error("Cannot parse timestamp: " + DataUtils.printHexBytes(byteTimestamp)));\n\n  return timestamp;\n};\n\n/**\n * @deprecated Use readDateTimeDTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and\n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.readDateTime = function(\n  //long\n  startTag)\n{\n  var byteTimestamp = this.readBinaryElement(startTag);\n  byteTimestamp = DataUtils.toHex(byteTimestamp);\n  byteTimestamp = parseInt(byteTimestamp, 16);\n\n  var lontimestamp = (byteTimestamp/ 4096) * 1000;\n\n  if (LOG > 4) console.log(\'DECODED DATE WITH VALUE\');\n  if (LOG > 4) console.log(lontimestamp);\n\n  //NDNTime\n  var timestamp = new NDNTime(lontimestamp);\n  if (null == timestamp)\n    throw new ContentDecodingException(new Error("Cannot parse timestamp: " + DataUtils.printHexBytes(byteTimestamp)));\n\n  return timestamp;\n};\n\nBinaryXMLDecoder.prototype.decodeTypeAndVal = function()\n{\n\n  /*int*/ var type = -1;\n  /*long*/ var val = 0;\n  /*boolean*/ var more = true;\n\n  do {\n    var next = this.input[this.offset ];\n    if (next == null)\n      // Quit the loop.\n      return null;\n\n    if (next < 0)\n      return null;\n\n    if (0 == next && 0 == val)\n      return null;\n\n    more = (0 == (next & XML_TT_NO_MORE));\n\n    if  (more) {\n      val = val << XML_REG_VAL_BITS;\n      val |= (next & XML_REG_VAL_MASK);\n    }\n    else {\n      type = next & XML_TT_MASK;\n      val = val << XML_TT_VAL_BITS;\n      val |= ((next >>> XML_TT_BITS) & XML_TT_VAL_MASK);\n    }\n\n    this.offset++;\n  } while (more);\n\n  if (LOG > 4) console.log(\'TYPE is \'+ type + \' VAL is \'+ val);\n\n  return new TypeAndVal(type, val);\n};\n\n//TypeAndVal\nBinaryXMLDecoder.prototype.peekTypeAndVal = function()\n{\n  //TypeAndVal\n  var tv = null;\n  var previousOffset = this.offset;\n\n  try {\n    tv = this.decodeTypeAndVal();\n  }\n  finally {\n    this.offset = previousOffset;\n  }\n\n  return tv;\n};\n\n//Buffer\nBinaryXMLDecoder.prototype.decodeBlob = function(\n    //int\n    blobLength)\n{\n  if (null == blobLength) {\n    //TypeAndVal\n    var tv = this.decodeTypeAndVal();\n\n    var valval ;\n    if (typeof tv.val() == \'string\')\n      valval = (parseInt(tv.val()));\n    else\n      valval = (tv.val());\n\n    return this.decodeBlob(valval);\n  }\n\n  //Buffer\n  var bytes = new ndnbuf(this.input.slice(this.offset, this.offset+ blobLength));\n  this.offset += blobLength;\n\n  return bytes;\n};\n\n//String\nBinaryXMLDecoder.prototype.decodeUString = function(\n    //int\n    byteLength)\n{\n  if (null == byteLength) {\n    var tempStreamPosition = this.offset;\n\n    //TypeAndVal\n    var tv = this.decodeTypeAndVal();\n\n    if (LOG > 4) console.log(\'TV is \'+tv);\n    if (LOG > 4) console.log(tv);\n\n    if (LOG > 4) console.log(\'Type of TV is \'+typeof tv);\n\n    // if we just have closers left, will get back null\n    if (null == tv || XML_UDATA != tv.type()) {\n      this.offset = tempStreamPosition;\n      return "";\n    }\n\n    return this.decodeUString(tv.val());\n  }\n  else {\n    //Buffer\n    var stringBytes = this.decodeBlob(byteLength);\n\n    // TODO: Should this parse as UTF8?\n    return DataUtils.toString(stringBytes);\n  }\n};\n\n//OBject containg a pair of type and value\nvar TypeAndVal = function TypeAndVal(_type,_val)\n{\n  this.t = _type;\n  this.v = _val;\n};\n\nTypeAndVal.prototype.type = function()\n{\n  return this.t;\n};\n\nTypeAndVal.prototype.val = function()\n{\n  return this.v;\n};\n\n/**\n * Decode the header from the input starting its offset, expecting the type to be DTAG and the value to be expectedTag.\n * Then read one UDATA item, parse it as a decimal integer and return the integer. Finally, read the element close.  Update the input\'s offset.\n * @param {number} expectedTag The expected value for DTAG.\n * @returns {number} The parsed integer.\n */\nBinaryXMLDecoder.prototype.readIntegerDTagElement = function(expectedTag)\n{\n  return parseInt(this.readUTF8DTagElement(expectedTag));\n};\n\n/**\n * @deprecated Use readIntegerDTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and\n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.readIntegerElement = function(\n  //String\n  startTag)\n{\n  //String\n  if (LOG > 4) console.log(\'READING INTEGER \'+ startTag);\n  if (LOG > 4) console.log(\'TYPE OF \'+ typeof startTag);\n\n  var strVal = this.readUTF8Element(startTag);\n\n  return parseInt(strVal);\n};\n\n/**\n * Decode the header from the input starting its offset, expecting the type to be DTAG and the value to be expectedTag.\n * Then read one UDATA item and return a string. Finally, read the element close.  Update the input\'s offset.\n * @param {number} expectedTag The expected value for DTAG.\n * @returns {string} The UDATA string.\n */\nBinaryXMLDecoder.prototype.readUTF8DTagElement = function(expectedTag)\n{\n  this.readElementStartDTag(expectedTag);\n  return this.readUString();;\n};\n\n/**\n * @deprecated Use readUTF8DTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and\n * support is not maintained in the code base.\n */\nBinaryXMLDecoder.prototype.readUTF8Element = function(\n    //String\n    startTag,\n    //TreeMap<String, String>\n    attributes)\n{\n  //throws Error where name == "ContentDecodingException"\n\n  // can\'t use getElementText, can\'t get attributes\n  this.readStartElement(startTag, attributes);\n  //String\n  var strElementText = this.readUString();\n  return strElementText;\n};\n\n/**\n * Set the offset into the input, used for the next read.\n * @param {number} offset The new offset.\n */\nBinaryXMLDecoder.prototype.seek = function(offset)\n{\n  this.offset = offset;\n};\n\n/*\n * Call with: throw new ContentDecodingException(new Error("message")).\n */\nfunction ContentDecodingException(error)\n{\n  this.message = error.message;\n  // Copy lineNumber, etc. from where new Error was called.\n  for (var prop in error)\n      this[prop] = error[prop];\n}\nContentDecodingException.prototype = new Error();\nContentDecodingException.prototype.name = "ContentDecodingException";\n/**\n * This class uses BinaryXMLDecoder to follow the structure of a ndnb binary element to\n * determine its end.\n *\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\n\nvar XML_EXT = 0x00;\nvar XML_TAG = 0x01;\nvar XML_DTAG = 0x02;\nvar XML_ATTR = 0x03;\nvar XML_DATTR = 0x04;\nvar XML_BLOB = 0x05;\nvar XML_UDATA = 0x06;\nvar XML_CLOSE = 0x0;\n\nvar XML_SUBTYPE_PROCESSING_INSTRUCTIONS = 16;\n\nvar XML_TT_BITS = 3;\nvar XML_TT_MASK = ((1 << XML_TT_BITS) - 1);\nvar XML_TT_VAL_BITS = XML_TT_BITS + 1;\nvar XML_TT_VAL_MASK = ((1 << (XML_TT_VAL_BITS)) - 1);\nvar XML_REG_VAL_BITS = 7;\nvar XML_REG_VAL_MASK = ((1 << XML_REG_VAL_BITS) - 1);\nvar XML_TT_NO_MORE = (1 << XML_REG_VAL_BITS); // 0x80\n\n/**\n * @constructor\n */\nvar BinaryXMLStructureDecoder = function BinaryXMLDecoder()\n{\n  this.gotElementEnd = false;\n  this.offset = 0;\n  this.level = 0;\n  this.state = BinaryXMLStructureDecoder.READ_HEADER_OR_CLOSE;\n  this.headerLength = 0;\n  this.useHeaderBuffer = false;\n  this.headerBuffer = new DynamicBuffer(5);\n  this.nBytesToRead = 0;\n};\n\nexports.BinaryXMLStructureDecoder = BinaryXMLStructureDecoder;\n\nBinaryXMLStructureDecoder.READ_HEADER_OR_CLOSE = 0;\nBinaryXMLStructureDecoder.READ_BYTES = 1;\n\n/**\n * Continue scanning input starting from this.offset.  If found the end of the element\n *   which started at offset 0 then return true, else false.\n * If this returns false, you should read more into input and call again.\n * You have to pass in input each time because the array could be reallocated.\n * This throws an exception for badly formed ndnb.\n */\nBinaryXMLStructureDecoder.prototype.findElementEnd = function(\n  // ndnbuf\n  input)\n{\n  if (this.gotElementEnd)\n    // Someone is calling when we already got the end.\n    return true;\n\n  var decoder = new BinaryXMLDecoder(input);\n\n  while (true) {\n    if (this.offset >= input.length)\n      // All the cases assume we have some input.\n      return false;\n\n    switch (this.state) {\n      case BinaryXMLStructureDecoder.READ_HEADER_OR_CLOSE:\n        // First check for XML_CLOSE.\n        if (this.headerLength == 0 && input[this.offset] == XML_CLOSE) {\n          ++this.offset;\n          // Close the level.\n          --this.level;\n          if (this.level == 0) {\n            // Finished.\n            this.gotElementEnd = true;\n            return true;\n          }\n          if (this.level < 0)\n            throw new Error("BinaryXMLStructureDecoder: Unexpected close tag at offset " + (this.offset - 1));\n\n          // Get ready for the next header.\n          this.startHeader();\n          break;\n        }\n\n        var startingHeaderLength = this.headerLength;\n        while (true) {\n          if (this.offset >= input.length) {\n            // We can\'t get all of the header bytes from this input. Save in headerBuffer.\n            this.useHeaderBuffer = true;\n            var nNewBytes = this.headerLength - startingHeaderLength;\n            this.headerBuffer.set(input.slice(this.offset - nNewBytes, nNewBytes), startingHeaderLength);\n\n            return false;\n          }\n          var headerByte = input[this.offset++];\n          ++this.headerLength;\n          if (headerByte & XML_TT_NO_MORE)\n            // Break and read the header.\n            break;\n        }\n\n        var typeAndVal;\n        if (this.useHeaderBuffer) {\n          // Copy the remaining bytes into headerBuffer.\n          nNewBytes = this.headerLength - startingHeaderLength;\n          this.headerBuffer.set(input.slice(this.offset - nNewBytes, nNewBytes), startingHeaderLength);\n\n          typeAndVal = new BinaryXMLDecoder(this.headerBuffer.array).decodeTypeAndVal();\n        }\n        else {\n          // We didn\'t have to use the headerBuffer.\n          decoder.seek(this.offset - this.headerLength);\n          typeAndVal = decoder.decodeTypeAndVal();\n        }\n\n        if (typeAndVal == null)\n          throw new Error("BinaryXMLStructureDecoder: Can\'t read header starting at offset " +\n                          (this.offset - this.headerLength));\n\n        // Set the next state based on the type.\n        var type = typeAndVal.t;\n        if (type == XML_DATTR)\n          // We already consumed the item. READ_HEADER_OR_CLOSE again.\n          // ndnb has rules about what must follow an attribute, but we are just scanning.\n          this.startHeader();\n        else if (type == XML_DTAG || type == XML_EXT) {\n          // Start a new level and READ_HEADER_OR_CLOSE again.\n          ++this.level;\n          this.startHeader();\n        }\n        else if (type == XML_TAG || type == XML_ATTR) {\n          if (type == XML_TAG)\n            // Start a new level and read the tag.\n            ++this.level;\n          // Minimum tag or attribute length is 1.\n          this.nBytesToRead = typeAndVal.v + 1;\n          this.state = BinaryXMLStructureDecoder.READ_BYTES;\n          // ndnb has rules about what must follow an attribute, but we are just scanning.\n        }\n        else if (type == XML_BLOB || type == XML_UDATA) {\n          this.nBytesToRead = typeAndVal.v;\n          this.state = BinaryXMLStructureDecoder.READ_BYTES;\n        }\n        else\n          throw new Error("BinaryXMLStructureDecoder: Unrecognized header type " + type);\n        break;\n\n      case BinaryXMLStructureDecoder.READ_BYTES:\n        var nRemainingBytes = input.length - this.offset;\n        if (nRemainingBytes < this.nBytesToRead) {\n          // Need more.\n          this.offset += nRemainingBytes;\n          this.nBytesToRead -= nRemainingBytes;\n          return false;\n        }\n        // Got the bytes.  Read a new header or close.\n        this.offset += this.nBytesToRead;\n        this.startHeader();\n        break;\n\n      default:\n        // We don\'t expect this to happen.\n        throw new Error("BinaryXMLStructureDecoder: Unrecognized state " + this.state);\n    }\n  }\n};\n\n/**\n * Set the state to READ_HEADER_OR_CLOSE and set up to start reading the header\n */\nBinaryXMLStructureDecoder.prototype.startHeader = function()\n{\n  this.headerLength = 0;\n  this.useHeaderBuffer = false;\n  this.state = BinaryXMLStructureDecoder.READ_HEADER_OR_CLOSE;\n};\n\n/**\n *  Set the offset into the input, used for the next read.\n */\nBinaryXMLStructureDecoder.prototype.seek = function(offset)\n{\n  this.offset = offset;\n};\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * This class represents Interest Objects\n */\n\n/**\n * Create a WireFormat base class where the encode and decode methods throw an error. You should use a derived class like BinaryXmlWireFormat.\n * @constructor\n */\nvar WireFormat = function WireFormat() {\n};\n\nexports.WireFormat = WireFormat;\n\n/**\n * The override method in the derived class should encode the interest and return a ndnbuf.\n * @param {Interest} interest\n * @returns {Buffer}\n * @throws Error This always throws an "unimplemented" error. The derived class should override.\n */\nWireFormat.prototype.encodeInterest = function(interest)\n{\n  throw new Error("encodeInterest is unimplemented in the base WireFormat class.  You should use a derived class.");\n};\n\n/**\n * The override method in the derived class should decode the input and put the result in interest.\n * @param {Interest} interest\n * @param {Buffer} input\n * @throws Error This always throws an "unimplemented" error. The derived class should override.\n */\nWireFormat.prototype.decodeInterest = function(interest, input)\n{\n  throw new Error("decodeInterest is unimplemented in the base WireFormat class.  You should use a derived class.");\n};\n\n/**\n * The override method in the derived class should encode the data and return a ndnbuf.\n * @param {Data} data\n * @returns {Buffer}\n * @throws Error This always throws an "unimplemented" error. The derived class should override.\n */\nWireFormat.prototype.encodeData = function(data)\n{\n  throw new Error("encodeData is unimplemented in the base WireFormat class.  You should use a derived class.");\n};\n\n/**\n * The override method in the derived class should decode the input and put the result in data.\n * @param {Data} data\n * @param {Buffer} input\n * @throws Error This always throws an "unimplemented" error. The derived class should override.\n */\nWireFormat.prototype.decodeData = function(data, input)\n{\n  throw new Error("decodeData is unimplemented in the base WireFormat class.  You should use a derived class.");\n};\n\n\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\n\n/**\n * A BinaryXmlElementReader lets you call onReceivedData multiple times which uses a\n * BinaryXMLStructureDecoder to detect the end of a binary XML element and calls\n * elementListener.onReceivedElement(element) with the element.\n * This handles the case where a single call to onReceivedData may contain multiple elements.\n * @constructor\n * @param {{onReceivedElement:function}} elementListener\n */\nvar BinaryXmlElementReader = function BinaryXmlElementReader(elementListener)\n{\n  this.elementListener = elementListener;\n  this.dataParts = [];\n  this.structureDecoder = new BinaryXMLStructureDecoder();\n};\n\nexports.BinaryXmlElementReader = BinaryXmlElementReader;\n\nBinaryXmlElementReader.prototype.onReceivedData = function(/* ndnbuf */ data)\n{\n  // Process multiple objects in the data.\n  while (true) {\n    // Scan the input to check if a whole ndnb object has been read.\n    this.structureDecoder.seek(0);\n    if (this.structureDecoder.findElementEnd(data)) {\n      // Got the remainder of an object.  Report to the caller.\n      this.dataParts.push(data.slice(0, this.structureDecoder.offset));\n      var element = DataUtils.concatArrays(this.dataParts);\n      this.dataParts = [];\n      try {\n        this.elementListener.onReceivedElement(element);\n      } catch (ex) {\n          console.log("BinaryXmlElementReader: ignoring exception from onReceivedElement: " + ex);\n      }\n\n      // Need to read a new object.\n      data = data.slice(this.structureDecoder.offset, data.length);\n      this.structureDecoder = new BinaryXMLStructureDecoder();\n      if (data.length == 0)\n        // No more data in the packet.\n        return;\n\n      // else loop back to decode.\n    }\n    else {\n      // Save for a later call to concatArrays so that we only copy data once.\n      this.dataParts.push(data);\n      if (LOG > 3) console.log(\'Incomplete packet received. Length \' + data.length + \'. Wait for more input.\');\n        return;\n    }\n  }\n};\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\n/**\n * Create a context for getting the response from the name enumeration command, as neede by getComponents.\n * (To do name enumeration, call the static method NameEnumeration.getComponents.)\n * @param {Face} face The Face object for using expressInterest.\n * @param {function} onComponents The onComponents callback given to getComponents.\n */\nvar NameEnumeration = function NameEnumeration(face, onComponents)\n{\n  this.face = face;\n  this.onComponents = onComponents;\n  this.contentParts = [];\n\n  var self = this;\n  this.onData = function(interest, data) { self.processData(data); };\n  this.onTimeout = function(interest) { self.processTimeout(); };\n};\n\nexports.NameEnumeration = NameEnumeration;\n\n/**\n * Use the name enumeration protocol to get the child components of the name prefix.\n * @param {Face} face The Face object for using expressInterest.\n * @param {Name} name The name prefix for finding the child components.\n * @param {function} onComponents On getting the response, this calls onComponents(components) where\n * components is an array of ndnbuf name components.  If there is no response, this calls onComponents(null).\n */\nNameEnumeration.getComponents = function(face, prefix, onComponents)\n{\n  var command = new Name(prefix);\n  // Add %C1.E.be\n  command.add([0xc1, 0x2e, 0x45, 0x2e, 0x62, 0x65])\n\n  var enumeration = new NameEnumeration(face, onComponents);\n  face.expressInterest(command, enumeration.onData, enumeration.onTimeout);\n};\n\n\n\n\n\n\n\n\n\n/**\n * Create a closure for getting the response from the name enumeration command.\n * @param {Face} face The Face object for using expressInterest.\n * @param {function} onComponents The onComponents callback given to getComponents.\n */\nNameEnumeration.Closure = function NameEnumerationClosure(face, onComponents)\n{\n  // Inherit from Closure.\n  Closure.call(this);\n\n  this.face = face;\n  this.onComponents = onComponents;\n  this.contentParts = [];\n\n  var enumeration = new NameEnumeration(face, onComponents);\n  face.expressInterest(command, enumeration.onData, enumeration.onTimeout);\n};\n\n/**\n * Parse the response from the name enumeration command and call this.onComponents.\n * @param {Data} data\n */\nNameEnumeration.prototype.processData = function(data)\n{\n  try {\n    if (!NameEnumeration.endsWithSegmentNumber(data.name))\n      // We don\'t expect a name without a segment number.  Treat it as a bad packet.\n      this.onComponents(null);\n    else {\n      var segmentNumber = DataUtils.bigEndianToUnsignedInt\n          (data.name.get(data.name.size() - 1).getValue());\n\n      // Each time we get a segment, we put it in contentParts, so its length follows the segment numbers.\n      var expectedSegmentNumber = this.contentParts.length;\n      if (segmentNumber != expectedSegmentNumber)\n        // Try again to get the expected segment.  This also includes the case where the first segment is not segment 0.\n        this.face.expressInterest\n          (data.name.getPrefix(-1).addSegment(expectedSegmentNumber), this.onData, this.onTimeout);\n      else {\n        // Save the content and check if we are finished.\n        this.contentParts.push(data.content);\n\n        if (data.signedInfo != null && data.signedInfo.finalBlockID != null) {\n          var finalSegmentNumber = DataUtils.bigEndianToUnsignedInt(data.signedInfo.finalBlockID);\n          if (segmentNumber == finalSegmentNumber) {\n            // We are finished.  Parse and return the result.\n            this.onComponents(NameEnumeration.parseComponents(Buffer.concat(this.contentParts)));\n            return;\n          }\n        }\n\n        // Fetch the next segment.\n        this.face.expressInterest\n          (data.name.getPrefix(-1).addSegment(expectedSegmentNumber + 1), this.onData, this.onTimeout);\n      }\n    }\n  } catch (ex) {\n    console.log("NameEnumeration: ignoring exception: " + ex);\n  }\n};\n\n/**\n * Just call onComponents(null).\n */\nNameEnumeration.prototype.processTimeout = function()\n{\n  try {\n    this.onComponents(null);\n  } catch (ex) {\n    console.log("NameEnumeration: ignoring exception: " + ex);\n  }\n};\n\n/**\n * Parse the content as a name enumeration response and return an array of components.  This makes a copy of the component.\n * @param {Uint8Array} content The content to parse.\n * @returns {Array<Buffer>} The array of components.\n */\nNameEnumeration.parseComponents = function(content)\n{\n  var components = [];\n  var decoder = new BinaryXMLDecoder(content);\n\n  decoder.readElementStartDTag(NDNProtocolDTags.Collection);\n\n  while (decoder.peekDTag(NDNProtocolDTags.Link)) {\n    decoder.readElementStartDTag(NDNProtocolDTags.Link);\n    decoder.readElementStartDTag(NDNProtocolDTags.Name);\n\n    components.push(new ndnbuf(decoder.readBinaryDTagElement(NDNProtocolDTags.Component)));\n\n    decoder.readElementClose();\n    decoder.readElementClose();\n  }\n\n  decoder.readElementClose();\n  return components;\n};\n\n/**\n * Check if the last component in the name is a segment number.\n * TODO: Move to Name class.\n * @param {Name} name\n * @returns {Boolean} True if the name ends with a segment number, otherwise false.\n */\nNameEnumeration.endsWithSegmentNumber = function(name) {\n  return name.components != null && name.size() >= 1 &&\n         name.get(name.size() - 1).getValue().length >= 1 &&\n         name.get(name.size() - 1).getValue()[0] == 0;\n};\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Wentao Shang\n * See COPYING for copyright and distribution information.\n */\n\n/**\n * @constructor\n */\nvar WebSocketTransport = function WebSocketTransport()\n{\n  if (!WebSocket)\n    throw new Error("WebSocket support is not available on this platform.");\n\n  this.ws = null;\n  this.connectedHost = null; // Read by Face.\n  this.connectedPort = null; // Read by Face.\n  this.elementReader = null;\n  this.defaultGetHostAndPort = Face.makeShuffledGetHostAndPort\n    (["A.ws.ndn.ucla.edu", "B.ws.ndn.ucla.edu", "C.ws.ndn.ucla.edu", "D.ws.ndn.ucla.edu",\n      "E.ws.ndn.ucla.edu"],\n     9696);\n};\n\nexports.WebSocketTransport = WebSocketTransport;\n\n/**\n * Connect to the host and port in face.  This replaces a previous connection and sets connectedHost\n *   and connectedPort.  Once connected, call onopenCallback().\n * Listen on the port to read an entire binary XML encoded element and call\n *    face.onReceivedElement(element).\n */\nWebSocketTransport.prototype.connect = function(face, onopenCallback)\n{\n  if (this.ws != null)\n    delete this.ws;\n\n  this.ws = new WebSocket(\'ws://\' + face.host + \':\' + face.port);\n  if (LOG > 0) console.log(\'ws connection created.\');\n    this.connectedHost = face.host;\n    this.connectedPort = face.port;\n\n  this.ws.binaryType = "arraybuffer";\n\n  this.elementReader = new BinaryXmlElementReader(face);\n  var self = this;\n  this.ws.onmessage = function(ev) {\n    var result = ev.data;\n    //console.log(\'RecvHandle called.\');\n\n    if (result == null || result == undefined || result == "") {\n      console.log(\'INVALID ANSWER\');\n    }\n    else if (result instanceof ArrayBuffer) {\n      var bytearray = new ndnbuf(result);\n\n      if (LOG > 3) console.log(\'BINARY RESPONSE IS \' + bytearray.toString(\'hex\'));\n\n      try {\n        // Find the end of the binary XML element and call face.onReceivedElement.\n        self.elementReader.onReceivedData(bytearray);\n      } catch (ex) {\n        console.log("NDN.ws.onmessage exception: " + ex);\n        return;\n      }\n    }\n  }\n\n  this.ws.onopen = function(ev) {\n    if (LOG > 3) console.log(ev);\n    if (LOG > 3) console.log(\'ws.onopen: WebSocket connection opened.\');\n    if (LOG > 3) console.log(\'ws.onopen: ReadyState: \' + this.readyState);\n    // Face.registerPrefix will fetch the ndndid when needed.\n\n    onopenCallback();\n  }\n\n  this.ws.onerror = function(ev) {\n    console.log(\'ws.onerror: ReadyState: \' + this.readyState);\n    console.log(ev);\n    console.log(\'ws.onerror: WebSocket error: \' + ev.data);\n  }\n\n  this.ws.onclose = function(ev) {\n    console.log(\'ws.onclose: WebSocket connection closed.\');\n    self.ws = null;\n\n    // Close Face when WebSocket is closed\n    face.readyStatus = Face.CLOSED;\n    face.onclose();\n    //console.log("NDN.onclose event fired.");\n  }\n};\n\n/**\n * Send the Uint8Array data.\n */\nWebSocketTransport.prototype.send = function(data)\n{\n  if (this.ws != null) {\n    // If we directly use data.buffer to feed ws.send(),\n    // WebSocket may end up sending a packet with 10000 bytes of data.\n    // That is, WebSocket will flush the entire ndnbuf\n    // regardless of the offset of the Uint8Array. So we have to create\n    // a new Uint8Array ndnbuf with just the right size and copy the\n    // content from binaryInterest to the new ndnbuf.\n    //    ---Wentao\n    var bytearray = new Uint8Array(data.length);\n    bytearray.set(data);\n    this.ws.send(bytearray.buffer);\n    if (LOG > 3) console.log(\'ws.send() returned.\');\n  }\n  else\n    console.log(\'WebSocket connection is not established.\');\n};\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\n// The Face constructor uses TcpTransport by default which is not available in the browser, so override to WebSocketTransport.\nTcpTransport = WebSocketTransport;\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * Provide the callback closure for the async communication methods in the Face class.\n * This is a port of Closure.py from PyNDN, written by:\n * Derek Kulinski <takeda@takeda.tk>\n * Jeff Burke <jburke@ucla.edu>\n */\n\n/**\n * A subclass of Closure is passed to expressInterest and registerPrefix.\n * @deprecated You should use the forms of expressInterest and registerPrefix which use callbacks instead of Closure.\n * @constructor\n */\nvar Closure = function Closure()\n{\n  // I don\'t think storing Face\'s closure is needed\n  // and it creates a reference loop, as of now both\n  // of those variables are never set -- Derek\n  //\n  // Use instance variables to return data to callback\n  this.ndn_data = null;  // this holds the ndn_closure\n  this.ndn_data_dirty = false;\n};\n\nexports.Closure = Closure;\n\n// Upcall result\nClosure.RESULT_ERR               = -1; // upcall detected an error\nClosure.RESULT_OK                =  0; // normal upcall return\nClosure.RESULT_REEXPRESS         =  1; // reexpress the same interest again\nClosure.RESULT_INTEREST_CONSUMED =  2; // upcall claims to consume interest\nClosure.RESULT_VERIFY            =  3; // force an unverified result to be verified\nClosure.RESULT_FETCHKEY          =  4; // get the key in the key locator and re-call the interest\n                                       //   with the key available in the local storage\n\n// Upcall kind\nClosure.UPCALL_FINAL              = 0; // handler is about to be deregistered\nClosure.UPCALL_INTEREST           = 1; // incoming interest\nClosure.UPCALL_CONSUMED_INTEREST  = 2; // incoming interest, someone has answered\nClosure.UPCALL_CONTENT            = 3; // incoming verified content\nClosure.UPCALL_INTEREST_TIMED_OUT = 4; // interest timed out\nClosure.UPCALL_CONTENT_UNVERIFIED = 5; // content that has not been verified\nClosure.UPCALL_CONTENT_BAD        = 6; // verification failed\n\n/**\n * Override this in your subclass.\n * If you\'re getting strange errors in upcall()\n * check your code whether you\'re returning a value.\n */\nClosure.prototype.upcall = function(kind, upcallInfo)\n{\n  //dump(\'upcall \' + this + " " + kind + " " + upcallInfo + "\\n");\n  return Closure.RESULT_OK;\n};\n\n/**\n * An UpcallInfo is passed to Closure.upcall.\n * @constructor\n */\nvar UpcallInfo = function UpcallInfo(face, interest, matchedComps, data)\n{\n  this.face = face;  // Face object (not used)\n  this.ndn = face;   // deprecated\n  this.interest = interest;  // Interest object\n  this.matchedComps = matchedComps;  // int\n  this.data = data;  // Data\n  this.contentObject = data; // deprecated.  Include for backward compatibility.\n};\n\nUpcallInfo.prototype.toString = function()\n{\n  var ret = "face = " + this.face;\n  ret += "\\nInterest = " + this.interest;\n  ret += "\\nmatchedComps = " + this.matchedComps;\n  ret += "\\nData: " + this.data;\n  return ret;\n};\n\nexports.UpcallInfo = UpcallInfo;\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class represents PublisherPublicKeyDigest Objects\n */\n\n\n/**\n * @constructor\n */\nvar PublisherPublicKeyDigest = function PublisherPublicKeyDigest(pkd)\n{\n this.PUBLISHER_ID_LEN = 512/8;\n this.publisherPublicKeyDigest = pkd;\n};\n\nexports.PublisherPublicKeyDigest = PublisherPublicKeyDigest;\n\nPublisherPublicKeyDigest.prototype.from_ndnb = function(decoder)\n{\n  this.publisherPublicKeyDigest = decoder.readBinaryDTagElement(this.getElementLabel());\n\n  if (LOG > 4) console.log(\'Publisher public key digest is \' + this.publisherPublicKeyDigest);\n\n  if (null == this.publisherPublicKeyDigest)\n    throw new Error("Cannot parse publisher key digest.");\n\n  //TODO check if the length of the PublisherPublicKeyDigest is correct (Security reason)\n\n  if (this.publisherPublicKeyDigest.length != this.PUBLISHER_ID_LEN) {\n    if (LOG > 0)\n      console.log(\'LENGTH OF PUBLISHER ID IS WRONG! Expected \' + this.PUBLISHER_ID_LEN + ", got " + this.publisherPublicKeyDigest.length);\n\n    //this.publisherPublicKeyDigest = new PublisherPublicKeyDigest(this.PublisherPublicKeyDigest).PublisherKeyDigest;\n  }\n};\n\nPublisherPublicKeyDigest.prototype.to_ndnb= function(encoder)\n{\n  //TODO Check that the ByteArray for the key is present\n  if (!this.validate())\n    throw new Error("Cannot encode : field values missing.");\n\n  if (LOG > 3) console.log(\'PUBLISHER KEY DIGEST IS\'+this.publisherPublicKeyDigest);\n  encoder.writeDTagElement(this.getElementLabel(), this.publisherPublicKeyDigest);\n};\n\nPublisherPublicKeyDigest.prototype.getElementLabel = function() { return NDNProtocolDTags.PublisherPublicKeyDigest; };\n\nPublisherPublicKeyDigest.prototype.validate = function()\n{\n    return null != this.publisherPublicKeyDigest;\n};\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class represents Publisher and PublisherType Objects\n */\n\n/**\n * @constructor\n */\nvar PublisherType = function PublisherType(tag)\n{\n  this.KEY = NDNProtocolDTags.PublisherPublicKeyDigest;\n  this.CERTIFICATE = NDNProtocolDTags.PublisherCertificateDigest;\n  this.ISSUER_KEY = NDNProtocolDTags.PublisherIssuerKeyDigest;\n  this.ISSUER_CERTIFICATE = NDNProtocolDTags.PublisherIssuerCertificateDigest;\n\n  this.Tag = tag;\n};\n\n/**\n * @constructor\n */\nvar PublisherID = function PublisherID()\n{\n  this.PUBLISHER_ID_DIGEST_ALGORITHM = "SHA-256";\n  this.PUBLISHER_ID_LEN = 256/8;\n\n  //TODO, implement publisherID creation and key creation\n\n  //TODO implement generatePublicKeyDigest\n  this.publisherID =null;//= generatePublicKeyDigest(key);//ByteArray\n\n  //TODO implement generate key\n  //CryptoUtil.generateKeyID(PUBLISHER_ID_DIGEST_ALGORITHM, key);\n  this.publisherType = null;//isIssuer ? PublisherType.ISSUER_KEY : PublisherType.KEY;//publisher Type\n};\n\nexports.PublisherID = PublisherID;\n\nPublisherID.prototype.from_ndnb = function(decoder)\n{\n  // We have a choice here of one of 4 binary element types.\n  var nextTag = PublisherID.peekAndGetNextDTag(decoder);\n\n  this.publisherType = new PublisherType(nextTag);\n\n  if (nextTag < 0)\n    throw new Error("Invalid publisher ID, got unexpected type");\n\n  this.publisherID = decoder.readBinaryDTagElement(nextTag);\n  if (null == this.publisherID)\n    throw new ContentDecodingException(new Error("Cannot parse publisher ID of type : " + nextTag + "."));\n};\n\nPublisherID.prototype.to_ndnb = function(encoder)\n{\n  if (!this.validate())\n    throw new Error("Cannot encode " + this.getClass().getName() + ": field values missing.");\n\n  encoder.writeDTagElement(this.getElementLabel(), this.publisherID);\n};\n\n/**\n * Peek the next DTag in the decoder and return it if it is a PublisherID DTag.\n * @param {BinaryXMLDecoder} decoder The BinaryXMLDecoder with the input to decode.\n * @returns {number} The PublisherID DTag or -1 if it is not one of them.\n */\nPublisherID.peekAndGetNextDTag = function(decoder)\n{\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherPublicKeyDigest))\n    return             NDNProtocolDTags.PublisherPublicKeyDigest;\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherCertificateDigest))\n    return             NDNProtocolDTags.PublisherCertificateDigest;\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherIssuerKeyDigest))\n    return             NDNProtocolDTags.PublisherIssuerKeyDigest;\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherIssuerCertificateDigest))\n    return             NDNProtocolDTags.PublisherIssuerCertificateDigest;\n\n  return -1;\n};\n\nPublisherID.peek = function(/* XMLDecoder */ decoder)\n{\n  return PublisherID.peekAndGetNextDTag(decoder) >= 0;\n};\n\nPublisherID.prototype.getElementLabel = function()\n{\n  return this.publisherType.Tag;\n};\n\nPublisherID.prototype.validate = function()\n{\n  return null != id() && null != type();\n};\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Meki Cheraoui, Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n * This class represents a Name as an array of components where each is a byte array.\n */\n\n/**\n * Create a new Name from components.\n *\n * @constructor\n * @param {string|Name|Array<string|Array<number>|ArrayBuffer|Buffer|Name>} components if a string, parse it as a URI.  If a Name, add a deep copy of its components.\n * Otherwise it is an array of components which are appended according to Name.append, so\n * convert each and store it as an array of ndnbuf.  If a component is a string, encode as utf8.\n */\nvar Name = function Name(components)\n{\n  if (typeof components == \'string\') {\n    if (LOG > 3) console.log(\'Content Name String \' + components);\n    this.components = Name.createNameArray(components);\n  }\n  else if (typeof components === \'object\') {\n    this.components = [];\n    if (components instanceof Name)\n      this.append(components);\n    else {\n      for (var i = 0; i < components.length; ++i)\n        this.append(components[i]);\n    }\n  }\n  else if (components== null)\n    this.components =[];\n  else\n    if (LOG > 1) console.log("NO CONTENT NAME GIVEN");\n};\n\nexports.Name = Name;\n\n/**\n *\n * @constructor\n * Create a new Name.Component with a copy of the given value.\n * @param {Name.Component|String|Array<number>|ArrayBuffer|Buffer} value If the value is a string, encode it as utf8 (but don\'t unescape).\n */\nName.Component = function NameComponent(value)\n{\n  if (typeof value == \'string\')\n    this.value = DataUtils.stringToUtf8Array(value);\n  else if (typeof value == \'object\' && value instanceof Name.Component)\n    this.value = new ndnbuf(value.value);\n  else if (typeof value == \'object\' && value instanceof ndnbuf)\n    this.value = new ndnbuf(value);\n  else if (typeof value == \'object\' && typeof ArrayBuffer != \'undefined\' &&  value instanceof ArrayBuffer) {\n    // Make a copy.  Don\'t use ArrayBuffer.slice since it isn\'t always supported.\n    this.value = new ndnbuf(new ArrayBuffer(value.byteLength));\n    this.value.set(new ndnbuf(value));\n  }\n  else if (typeof value == \'object\')\n    // Assume value is a byte array.  We can\'t check instanceof Array because\n    //   this doesn\'t work in JavaScript if the array comes from a different module.\n    this.value = new ndnbuf(value);\n  else\n    throw new Error("Name.Component constructor: Invalid type");\n}\n\n/**\n * Get the component value.\n * @returns {Buffer} The component value.\n */\nName.Component.prototype.getValue = function()\n{\n  return this.value;\n}\n\n/**\n * Convert this component value to a string by escaping characters according to the NDN URI Scheme.\n * This also adds "..." to a value with zero or more ".".\n * @returns {string} The escaped string.\n */\nName.Component.prototype.toEscapedString = function()\n{\n  return Name.toEscapedString(this.value);\n}\n\n/**\n * @deprecated Use toUri.\n */\nName.prototype.getName = function()\n{\n  return this.toUri();\n};\n\n/** Parse uri as a URI and return an array of ndnbuf components.\n */\nName.createNameArray = function(uri)\n{\n  uri = uri.trim();\n  if (uri.length <= 0)\n    return [];\n\n  var iColon = uri.indexOf(\':\');\n  if (iColon >= 0) {\n    // Make sure the colon came before a \'/\'.\n    var iFirstSlash = uri.indexOf(\'/\');\n    if (iFirstSlash < 0 || iColon < iFirstSlash)\n      // Omit the leading protocol such as ndn:\n      uri = uri.substr(iColon + 1, uri.length - iColon - 1).trim();\n  }\n\n  if (uri[0] == \'/\') {\n    if (uri.length >= 2 && uri[1] == \'/\') {\n      // Strip the authority following "//".\n      var iAfterAuthority = uri.indexOf(\'/\', 2);\n      if (iAfterAuthority < 0)\n        // Unusual case: there was only an authority.\n        return [];\n      else\n        uri = uri.substr(iAfterAuthority + 1, uri.length - iAfterAuthority - 1).trim();\n    }\n    else\n      uri = uri.substr(1, uri.length - 1).trim();\n  }\n\n  var array = uri.split(\'/\');\n\n  // Unescape the components.\n  for (var i = 0; i < array.length; ++i) {\n    var value = Name.fromEscapedString(array[i]);\n\n    if (value == null) {\n      // Ignore the illegal componenent.  This also gets rid of a trailing \'/\'.\n      array.splice(i, 1);\n      --i;\n      continue;\n    }\n    else\n      array[i] = new Name.Component(value);\n  }\n\n  return array;\n};\n\nName.prototype.from_ndnb = function(/*XMLDecoder*/ decoder)\n{\n  decoder.readElementStartDTag(this.getElementLabel());\n\n  this.components = [];\n\n  while (decoder.peekDTag(NDNProtocolDTags.Component))\n    this.append(decoder.readBinaryDTagElement(NDNProtocolDTags.Component));\n\n  decoder.readElementClose();\n};\n\nName.prototype.to_ndnb = function(/*XMLEncoder*/ encoder)\n{\n  if (this.components == null)\n    throw new Error("CANNOT ENCODE EMPTY CONTENT NAME");\n\n  encoder.writeElementStartDTag(this.getElementLabel());\n  var count = this.size();\n  for (var i=0; i < count; i++)\n    encoder.writeDTagElement(NDNProtocolDTags.Component, this.components[i].getValue());\n\n  encoder.writeElementClose();\n};\n\nName.prototype.getElementLabel = function()\n{\n  return NDNProtocolDTags.Name;\n};\n\n/**\n * Convert the component to a ndnbuf and append to this Name.\n * Return this Name object to allow chaining calls to add.\n * @param {Name.Component|String|Array<number>|ArrayBuffer|Buffer|Name} component If a component is a string, encode as utf8 (but don\'t unescape).\n * @returns {Name}\n */\nName.prototype.append = function(component)\n{\n  if (typeof component == \'object\' && component instanceof Name) {\n    var components;\n    if (component == this)\n      // special case, when we need to create a copy\n      components = this.components.slice(0, this.components.length);\n    else\n      components = component.components;\n\n    for (var i = 0; i < components.length; ++i)\n      this.components.push(new Name.Component(components[i]));\n  }\n  else\n    // Just use the Name.Component constructor.\n    this.components.push(new Name.Component(component));\n\n  return this;\n};\n\n/**\n * @deprecated Use append.\n */\nName.prototype.add = function(component)\n{\n  return this.append(component);\n};\n\n/**\n * Return the escaped name string according to "NDNx URI Scheme".\n * @returns {String}\n */\nName.prototype.toUri = function()\n{\n  if (this.size() == 0)\n    return "/";\n\n  var result = "";\n\n  for (var i = 0; i < this.size(); ++i)\n    result += "/"+ Name.toEscapedString(this.components[i].getValue());\n\n  return result;\n};\n\n/**\n * @deprecated Use toUri.\n */\nName.prototype.to_uri = function()\n{\n  return this.toUri();\n};\n\n/**\n * Append a component that represents a segment number\n *\n * This component has a special format handling:\n * - if number is zero, then %00 is added\n * - if number is between 1 and 255, %00%01 .. %00%FF is added\n * - ...\n * @param {number} number the segment number (integer is expected)\n * @returns {Name}\n */\nName.prototype.appendSegment = function(number)\n{\n  var segmentNumberBigEndian = DataUtils.nonNegativeIntToBigEndian(number);\n  // Put a 0 byte in front.\n  var segmentNumberComponent = new ndnbuf(segmentNumberBigEndian.length + 1);\n  segmentNumberComponent[0] = 0;\n  segmentNumberBigEndian.copy(segmentNumberComponent, 1);\n\n  this.components.push(new Name.Component(segmentNumberComponent));\n  return this;\n};\n\n/**\n * @deprecated Use appendSegment.\n */\nName.prototype.addSegment = function(number)\n{\n  return this.appendSegment(number);\n};\n\n/**\n * Get a new name, constructed as a subset of components.\n * @param {number} iStartComponent The index if the first component to get.\n * @param {number} (optional) nComponents The number of components starting at iStartComponent.  If omitted,\n * return components starting at iStartComponent until the end of the name.\n * @returns {Name} A new name.\n */\nName.prototype.getSubName = function(iStartComponent, nComponents)\n{\n  if (nComponents == undefined)\n    nComponents = this.components.length - iStartComponent;\n\n  var result = new Name();\n\n  var iEnd = iStartComponent + nComponents;\n  for (var i = iStartComponent; i < iEnd && i < this.components.length; ++i)\n    result.components.push(this.components[i]);\n\n  return result;\n};\n\n/**\n * Return a new Name with the first nComponents components of this Name.\n * @param {number} nComponents The number of prefix components.  If nComponents is -N then return the prefix up\n * to name.size() - N. For example getPrefix(-1) returns the name without the final component.\n * @returns {Name} A new name.\n */\nName.prototype.getPrefix = function(nComponents)\n{\n  if (nComponents < 0)\n    return this.getSubName(0, this.components.length + nComponents);\n  else\n    return this.getSubName(0, nComponents);\n};\n\n/**\n * @brief Get prefix of the name, containing less minusComponents right components\n * @param minusComponents number of components to cut from the back\n */\nName.prototype.cut = function(minusComponents)\n{\n  return new Name(this.components.slice(0, this.components.length - minusComponents));\n};\n\n/**\n * Return the number of name components.\n * @returns {number}\n */\nName.prototype.size = function()\n{\n  return this.components.length;\n};\n\n/**\n * Return a new Name.Component of the component at the given index.  To get just the component value, use get(i).getValue().\n * @param {Number} i The index of the component, starting from 0.  However, if i is negative, return the component\n * at size() - (-i).\n * @returns {Name.Component}\n */\nName.prototype.get = function(i)\n{\n  if (i >= 0) {\n    if (i >= this.components.length)\n      throw new Error("Name.get: Index is out of bounds");\n\n    return new Name.Component(this.components[i]);\n  }\n  else {\n    // Negative index.\n    if (i < -this.components.length)\n      throw new Error("Name.get: Index is out of bounds");\n\n    return new Name.Component(this.components[this.components.length - (-i)]);\n  }\n};\n\n/**\n * @deprecated Use size().\n */\nName.prototype.getComponentCount = function()\n{\n  return this.components.length;\n};\n\n/**\n * @deprecated To get just the component value, use get(i).getValue().\n */\nName.prototype.getComponent = function(i)\n{\n  return new ndnbuf(this.components[i].getValue());\n};\n\n/**\n * The "file name" in a name is the last component that isn\'t blank and doesn\'t start with one of the\n *   special marker octets (for version, etc.).  Return the index in this.components of\n *   the file name, or -1 if not found.\n */\nName.prototype.indexOfFileName = function()\n{\n  for (var i = this.size() - 1; i >= 0; --i) {\n    var component = this.components[i].getValue();\n    if (component.length <= 0)\n      continue;\n\n    if (component[0] == 0 || component[0] == 0xC0 || component[0] == 0xC1 ||\n        (component[0] >= 0xF5 && component[0] <= 0xFF))\n      continue;\n\n    return i;\n  }\n\n  return -1;\n};\n\n/**\n * Return true if this Name has the same components as name.\n */\nName.prototype.equals = function(name)\n{\n  if (this.components.length != name.components.length)\n    return false;\n\n  // Start from the last component because they are more likely to differ.\n  for (var i = this.components.length - 1; i >= 0; --i) {\n    if (!DataUtils.arraysEqual(this.components[i].getValue(), name.components[i].getValue()))\n      return false;\n  }\n\n  return true;\n};\n\n/**\n * @deprecated Use equals.\n */\nName.prototype.equalsName = function(name)\n{\n  return this.equals(name);\n};\n\n/**\n * Find the last component in name that has a ContentDigest and return the digest value as ndnbuf,\n *   or null if not found.  See Name.getComponentContentDigestValue.\n */\nName.prototype.getContentDigestValue = function()\n{\n  for (var i = this.size() - 1; i >= 0; --i) {\n    var digestValue = Name.getComponentContentDigestValue(this.components[i]);\n    if (digestValue != null)\n      return digestValue;\n  }\n\n  return null;\n};\n\n/**\n * If component is a ContentDigest, return the digest value as a ndnbuf slice (don\'t modify!).\n * If not a ContentDigest, return null.\n * A ContentDigest component is Name.ContentDigestPrefix + 32 bytes + Name.ContentDigestSuffix.\n */\nName.getComponentContentDigestValue = function(component)\n{\n  if (typeof component == \'object\' && component instanceof Name.Component)\n    component = component.getValue();\n\n  var digestComponentLength = Name.ContentDigestPrefix.length + 32 + Name.ContentDigestSuffix.length;\n  // Check for the correct length and equal ContentDigestPrefix and ContentDigestSuffix.\n  if (component.length == digestComponentLength &&\n      DataUtils.arraysEqual(component.slice(0, Name.ContentDigestPrefix.length),\n                            Name.ContentDigestPrefix) &&\n      DataUtils.arraysEqual(component.slice\n         (component.length - Name.ContentDigestSuffix.length, component.length),\n                            Name.ContentDigestSuffix))\n   return component.slice(Name.ContentDigestPrefix.length, Name.ContentDigestPrefix.length + 32);\n else\n   return null;\n};\n\n// Meta GUID "%C1.M.G%C1" + ContentDigest with a 32 byte BLOB.\nName.ContentDigestPrefix = new ndnbuf([0xc1, 0x2e, 0x4d, 0x2e, 0x47, 0xc1, 0x01, 0xaa, 0x02, 0x85]);\nName.ContentDigestSuffix = new ndnbuf([0x00]);\n\n\n/**\n * Return value as an escaped string according to "NDNx URI Scheme".\n * We can\'t use encodeURIComponent because that doesn\'t encode all the characters we want to.\n * @param {Buffer|Name.Component} component The value or Name.Component to escape.\n * @returns {string} The escaped string.\n */\nName.toEscapedString = function(value)\n{\n  if (typeof value == \'object\' && value instanceof Name.Component)\n    value = value.getValue();\n\n  var result = "";\n  var gotNonDot = false;\n  for (var i = 0; i < value.length; ++i) {\n    if (value[i] != 0x2e) {\n      gotNonDot = true;\n      break;\n    }\n  }\n  if (!gotNonDot) {\n    // Special case for component of zero or more periods.  Add 3 periods.\n    result = "...";\n    for (var i = 0; i < value.length; ++i)\n      result += ".";\n  }\n  else {\n    for (var i = 0; i < value.length; ++i) {\n      var x = value[i];\n      // Check for 0-9, A-Z, a-z, (+), (-), (.), (_)\n      if (x >= 0x30 && x <= 0x39 || x >= 0x41 && x <= 0x5a ||\n          x >= 0x61 && x <= 0x7a || x == 0x2b || x == 0x2d ||\n          x == 0x2e || x == 0x5f)\n        result += String.fromCharCode(x);\n      else\n        result += "%" + (x < 16 ? "0" : "") + x.toString(16).toUpperCase();\n    }\n  }\n  return result;\n};\n\n/**\n * Return a ndnbuf byte array by decoding the escapedString according to "NDNx URI Scheme".\n * If escapedString is "", "." or ".." then return null, which means to skip the component in the name.\n * @param {string} escapedString The escaped string to decode.\n * @returns {Buffer} The byte array, or null which means to skip the component in the name.\n */\nName.fromEscapedString = function(escapedString)\n{\n  var value = unescape(escapedString.trim());\n\n  if (value.match(/[^.]/) == null) {\n    // Special case for value of only periods.\n    if (value.length <= 2)\n      // Zero, one or two periods is illegal.  Ignore this componenent to be\n      //   consistent with the C implementation.\n      return null;\n    else\n      // Remove 3 periods.\n      return DataUtils.toNumbersFromString(value.substr(3, value.length - 3));\n  }\n  else\n    return DataUtils.toNumbersFromString(value);\n};\n\n/**\n * Return true if the N components of this name are the same as the first N components of the given name.\n * @param {Name} name The name to check.\n * @returns {Boolean} true if this matches the given name.  This always returns true if this name is empty.\n */\nName.prototype.match = function(name)\n{\n  var i_name = this.components;\n  var o_name = name.components;\n\n  // This name is longer than the name we are checking it against.\n  if (i_name.length > o_name.length)\n    return false;\n\n  // Check if at least one of given components doesn\'t match.\n  for (var i = 0; i < i_name.length; ++i) {\n    if (!DataUtils.arraysEqual(i_name[i].getValue(), o_name[i].getValue()))\n      return false;\n  }\n\n  return true;\n};\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n */\n\n\n/**\n * @constructor\n */\nvar KeyManager = function KeyManager()\n{\n  this.certificate =\n  "MIIBmzCCAQQCCQC32FyQa61S7jANBgkqhkiG9w0BAQUFADASMRAwDgYDVQQDEwd" +\n  "heGVsY2R2MB4XDTEyMDQyODIzNDQzN1oXDTEyMDUyODIzNDQzN1owEjEQMA4GA1" +\n  "UEAxMHYXhlbGNkdjCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA4X0wp9goq" +\n  "xuECxdULcr2IHr9Ih4Iaypg0Wy39URIup8/CLzQmdsh3RYqd55hqonu5VTTpH3i" +\n  "MLx6xZDVJAZ8OJi7pvXcQ2C4Re2kjL2c8SanI0RfDhlS1zJadfr1VhRPmpivcYa" +\n  "wJ4aFuOLAi+qHFxtN7lhcGCgpW1OV60oXd58CAwEAATANBgkqhkiG9w0BAQUFAA" +\n  "OBgQDLOrA1fXzSrpftUB5Ro6DigX1Bjkf7F5Bkd69hSVp+jYeJFBBlsILQAfSxU" +\n  "ZPQtD+2Yc3iCmSYNyxqu9PcufDRJlnvB7PG29+L3y9lR37tetzUV9eTscJ7rdp8" +\n  "Wt6AzpW32IJ/54yKNfP7S6ZIoIG+LP6EIxq6s8K1MXRt8uBJKw==";\n\n  // Public Key\n    this.publicKey =\n  "-----BEGIN PUBLIC KEY-----\\n" +\n  "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDhfTCn2CirG4QLF1QtyvYgev0i\\n" +\n  "HghrKmDRbLf1REi6nz8IvNCZ2yHdFip3nmGqie7lVNOkfeIwvHrFkNUkBnw4mLum\\n" +\n  "9dxDYLhF7aSMvZzxJqcjRF8OGVLXMlp1+vVWFE+amK9xhrAnhoW44sCL6ocXG03u\\n" +\n  "WFwYKClbU5XrShd3nwIDAQAB\\n" +\n  "-----END PUBLIC KEY-----";\n  // Private Key\n    this.privateKey =\n  "-----BEGIN RSA PRIVATE KEY-----\\n" +\n  "MIICXQIBAAKBgQDhfTCn2CirG4QLF1QtyvYgev0iHghrKmDRbLf1REi6nz8IvNCZ\\n" +\n  "2yHdFip3nmGqie7lVNOkfeIwvHrFkNUkBnw4mLum9dxDYLhF7aSMvZzxJqcjRF8O\\n" +\n  "GVLXMlp1+vVWFE+amK9xhrAnhoW44sCL6ocXG03uWFwYKClbU5XrShd3nwIDAQAB\\n" +\n  "AoGAGkv6T6jC3WmhFZYL6CdCWvlc6gysmKrhjarrLTxgavtFY6R5g2ft5BXAsCCV\\n" +\n  "bUkWxkIFSKqxpVNl0gKZCNGEzPDN6mHJOQI/h0rlxNIHAuGfoAbCzALnqmyZivhJ\\n" +\n  "APGijAyKuU9tczsst5+Kpn+bn7ehzHQuj7iwJonS5WbojqECQQD851K8TpW2GrRi\\n" +\n  "zNgG4dx6orZxAaon/Jnl8lS7soXhllQty7qG+oDfzznmdMsiznCqEABzHUUKOVGE\\n" +\n  "9RWPN3aRAkEA5D/w9N55d0ibnChFJlc8cUAoaqH+w+U3oQP2Lb6AZHJpLptN4y4b\\n" +\n  "/uf5d4wYU5/i/gC7SSBH3wFhh9bjRLUDLwJAVOx8vN0Kqt7myfKNbCo19jxjVSlA\\n" +\n  "8TKCn1Oznl/BU1I+rC4oUaEW25DjmX6IpAR8kq7S59ThVSCQPjxqY/A08QJBAIRa\\n" +\n  "F2zGPITQk3r/VumemCvLWiRK/yG0noc9dtibqHOWbCtcXtOm/xDWjq+lis2i3ssO\\n" +\n  "vYrvrv0/HcDY+Dv1An0CQQCLJtMsfSg4kvG/FRY5UMhtMuwo8ovYcMXt4Xv/LWaM\\n" +\n  "hndD67b2UGawQCRqr5ghRTABWdDD/HuuMBjrkPsX0861\\n" +\n  "-----END RSA PRIVATE KEY-----";\n\n  this.key = null;\n};\n\n/**\n * Return a Key object for the keys in this KeyManager.  This creates the Key on the first\n * call and returns a cached copy after that.\n * @returns {Key}\n */\nKeyManager.prototype.getKey = function()\n{\n  if (this.key === null) {\n    this.key = new Key();\n    this.key.fromPemString(this.publicKey, this.privateKey);\n  }\n\n  return this.key;\n}\n\nvar globalKeyManager = globalKeyManager || new KeyManager();\nndn.globalKeyManager = globalKeyManager\nexports.globalKeyManager = globalKeyManager;\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class represents Data Objects\n */\n\n\n/**\n * Create a new Data with the optional values.\n *\n * @constructor\n * @param {Name} name\n * @param {SignedInfo} signedInfo\n * @param {Buffer} content\n */\nvar Data = function Data(name, signedInfo, content)\n{\n  if (typeof name == \'string\')\n    this.name = new Name(name);\n  else\n    //TODO Check the class of name\n    this.name = name;\n\n  this.signedInfo = signedInfo;\n\n  if (typeof content == \'string\')\n    this.content = DataUtils.toNumbersFromString(content);\n  else\n    this.content = content;\n\n  this.signature = new Signature();\n\n  this.startSIG = null;\n  this.endSIG = null;\n\n  this.endContent = null;\n\n  this.rawSignatureData = null;\n};\n\nexports.Data = Data;\n\nData.prototype.sign = function()\n{\n  var n1 = this.encodeObject(this.name);\n  var n2 = this.encodeObject(this.signedInfo);\n  var n3 = this.encodeContent();\n\n  var rsa = ndn.createSign(\'RSA-SHA256\');\n  rsa.update(n1);\n  rsa.update(n2);\n  rsa.update(n3);\n\n  var sig = new ndnbuf(rsa.sign(ndn.globalKeyManager.privateKey));\n\n  this.signature.signature = sig;\n};\n\nData.prototype.verify = function(/*Key*/ key)\n{\n  if (key == null || key.publicKeyPem == null)\n    throw new Error(\'Cannot verify Data without a public key.\');\n\n  var verifier = ndn.createVerify(\'RSA-SHA256\');\n  verifier.update(this.rawSignatureData);\n  return verifier.verify(key.publicKeyPem, this.signature.signature);\n};\n\nData.prototype.encodeObject = function encodeObject(obj)\n{\n  var enc = new BinaryXMLEncoder();\n  obj.to_ndnb(enc);\n  var num = enc.getReducedOstream();\n\n  return num;\n};\n\nData.prototype.encodeContent = function encodeContent()\n{\n  var enc = new BinaryXMLEncoder();\n  enc.writeDTagElement(NDNProtocolDTags.Content, this.content);\n  var num = enc.getReducedOstream();\n\n  return num;\n};\n\nData.prototype.saveRawData = function(bytes)\n{\n  var sigBits = bytes.slice(this.startSIG, this.endSIG);\n  this.rawSignatureData = new ndnbuf(sigBits);\n};\n\nData.prototype.getElementLabel = function() { return NDNProtocolDTags.Data; };\n\n/**\n * Create a new Signature with the optional values.\n * @constructor\n */\nvar Signature = function Signature(witness, signature, digestAlgorithm)\n{\n  this.witness = witness;\n  this.signature = signature;\n  this.digestAlgorithm = digestAlgorithm\n};\n\nexports.Signature = Signature;\n\nSignature.prototype.from_ndnb = function(decoder)\n{\n  decoder.readElementStartDTag(this.getElementLabel());\n\n  if (LOG > 4) console.log(\'STARTED DECODING SIGNATURE\');\n\n  if (decoder.peekDTag(NDNProtocolDTags.DigestAlgorithm)) {\n    if (LOG > 4) console.log(\'DIGIEST ALGORITHM FOUND\');\n    this.digestAlgorithm = decoder.readUTF8DTagElement(NDNProtocolDTags.DigestAlgorithm);\n  }\n  if (decoder.peekDTag(NDNProtocolDTags.Witness)) {\n    if (LOG > 4) console.log(\'WITNESS FOUND\');\n    this.witness = decoder.readBinaryDTagElement(NDNProtocolDTags.Witness);\n  }\n\n  //FORCE TO READ A SIGNATURE\n\n  if (LOG > 4) console.log(\'SIGNATURE FOUND\');\n  this.signature = decoder.readBinaryDTagElement(NDNProtocolDTags.SignatureBits);\n\n  decoder.readElementClose();\n};\n\nSignature.prototype.to_ndnb = function(encoder)\n{\n  if (!this.validate())\n    throw new Error("Cannot encode: field values missing.");\n\n  encoder.writeElementStartDTag(this.getElementLabel());\n\n  if (null != this.digestAlgorithm && !this.digestAlgorithm.equals(NDNDigestHelper.DEFAULT_DIGEST_ALGORITHM))\n    encoder.writeDTagElement(NDNProtocolDTags.DigestAlgorithm, OIDLookup.getDigestOID(this.DigestAlgorithm));\n\n  if (null != this.witness)\n    // needs to handle null witness\n    encoder.writeDTagElement(NDNProtocolDTags.Witness, this.witness);\n\n  encoder.writeDTagElement(NDNProtocolDTags.SignatureBits, this.signature);\n\n  encoder.writeElementClose();\n};\n\nSignature.prototype.getElementLabel = function() { return NDNProtocolDTags.Signature; };\n\nSignature.prototype.validate = function()\n{\n  return null != this.signature;\n};\n\nvar ContentType = {DATA:0, ENCR:1, GONE:2, KEY:3, LINK:4, NACK:5};\nvar ContentTypeValue = {0:0x0C04C0, 1:0x10D091,2:0x18E344,3:0x28463F,4:0x2C834A,5:0x34008A};\nvar ContentTypeValueReverse = {0x0C04C0:0, 0x10D091:1,0x18E344:2,0x28463F:3,0x2C834A:4,0x34008A:5};\n\nexports.ContentType = ContentType;\n\n/**\n * Create a new SignedInfo with the optional values.\n * @constructor\n */\nvar SignedInfo = function SignedInfo(publisher, timestamp, type, locator, freshnessSeconds, finalBlockID)\n{\n  this.publisher = publisher; //publisherPublicKeyDigest\n  this.timestamp=timestamp; // NDN Time\n  this.type=type; // ContentType\n  this.locator =locator;//KeyLocator\n  this.freshnessSeconds =freshnessSeconds; // Integer\n  this.finalBlockID=finalBlockID; //byte array\n\n  this.setFields();\n};\n\nexports.SignedInfo = SignedInfo;\n\nSignedInfo.prototype.setFields = function()\n{\n  var key = ndn.globalKeyManager.getKey();\n  this.publisher = new PublisherPublicKeyDigest(key.getKeyID());\n\n  var d = new Date();\n\n  var time = d.getTime();\n\n  this.timestamp = new NDNTime(time);\n\n  if (LOG > 4) console.log(\'TIME msec is\');\n\n  if (LOG > 4) console.log(this.timestamp.msec);\n\n  //DATA\n  this.type = 0;//0x0C04C0;//ContentTypeValue[ContentType.DATA];\n\n  if (LOG > 4) console.log(\'PUBLIC KEY TO WRITE TO DATA PACKET IS \');\n  if (LOG > 4) console.log(key.publicToDER().toString(\'hex\'));\n\n  this.locator = new KeyLocator(key.publicToDER(), KeyLocatorType.KEY);\n  //this.locator = new KeyLocator(DataUtils.toNumbersFromString(stringCertificate)  ,KeyLocatorType.CERTIFICATE);\n};\n\nSignedInfo.prototype.from_ndnb = function(decoder)\n{\n  decoder.readElementStartDTag(this.getElementLabel());\n\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherPublicKeyDigest)) {\n    if (LOG > 4) console.log(\'DECODING PUBLISHER KEY\');\n    this.publisher = new PublisherPublicKeyDigest();\n    this.publisher.from_ndnb(decoder);\n  }\n\n  if (decoder.peekDTag(NDNProtocolDTags.Timestamp)) {\n    if (LOG > 4) console.log(\'DECODING TIMESTAMP\');\n    this.timestamp = decoder.readDateTimeDTagElement(NDNProtocolDTags.Timestamp);\n  }\n\n  if (decoder.peekDTag(NDNProtocolDTags.Type)) {\n    var binType = decoder.readBinaryDTagElement(NDNProtocolDTags.Type);\n\n    if (LOG > 4) console.log(\'Binary Type of of Signed Info is \'+binType);\n\n    this.type = binType;\n\n    //TODO Implement type of Key Reading\n    if (null == this.type)\n      throw new Error("Cannot parse signedInfo type: bytes.");\n  }\n  else\n    this.type = ContentType.DATA; // default\n\n  if (decoder.peekDTag(NDNProtocolDTags.FreshnessSeconds)) {\n    this.freshnessSeconds = decoder.readIntegerDTagElement(NDNProtocolDTags.FreshnessSeconds);\n    if (LOG > 4) console.log(\'FRESHNESS IN SECONDS IS \'+ this.freshnessSeconds);\n  }\n\n  if (decoder.peekDTag(NDNProtocolDTags.FinalBlockID)) {\n    if (LOG > 4) console.log(\'DECODING FINAL BLOCKID\');\n    this.finalBlockID = decoder.readBinaryDTagElement(NDNProtocolDTags.FinalBlockID);\n  }\n\n  if (decoder.peekDTag(NDNProtocolDTags.KeyLocator)) {\n    if (LOG > 4) console.log(\'DECODING KEY LOCATOR\');\n    this.locator = new KeyLocator();\n    this.locator.from_ndnb(decoder);\n  }\n\n  decoder.readElementClose();\n};\n\nSignedInfo.prototype.to_ndnb = function(encoder)  {\n  if (!this.validate())\n    throw new Error("Cannot encode : field values missing.");\n\n  encoder.writeElementStartDTag(this.getElementLabel());\n\n  if (null != this.publisher) {\n    if (LOG > 3) console.log(\'ENCODING PUBLISHER KEY\' + this.publisher.publisherPublicKeyDigest);\n    this.publisher.to_ndnb(encoder);\n  }\n\n  if (null != this.timestamp)\n    encoder.writeDateTimeDTagElement(NDNProtocolDTags.Timestamp, this.timestamp);\n\n  if (null != this.type && this.type != 0)\n    encoder.writeDTagElement(NDNProtocolDTags.type, this.type);\n\n  if (null != this.freshnessSeconds)\n    encoder.writeDTagElement(NDNProtocolDTags.FreshnessSeconds, this.freshnessSeconds);\n\n  if (null != this.finalBlockID)\n    encoder.writeDTagElement(NDNProtocolDTags.FinalBlockID, this.finalBlockID);\n\n  if (null != this.locator)\n    this.locator.to_ndnb(encoder);\n\n  encoder.writeElementClose();\n};\n\nSignedInfo.prototype.valueToType = function()\n{\n  return null;\n};\n\nSignedInfo.prototype.getElementLabel = function() {\n  return NDNProtocolDTags.SignedInfo;\n};\n\nSignedInfo.prototype.validate = function()\n{\n  // We don\'t do partial matches any more, even though encoder/decoder\n  // is still pretty generous.\n  if (null ==this.publisher || null==this.timestamp ||null== this.locator)\n    return false;\n  return true;\n};\n\n/**\n * @deprecated Use BinaryXmlWireFormat.decodeData.\n */\nData.prototype.from_ndnb = function(/*XMLDecoder*/ decoder)\n{\n  BinaryXmlWireFormat.decodeData(this, decoder);\n};\n\n/**\n * @deprecated Use BinaryXmlWireFormat.encodeData.\n */\nData.prototype.to_ndnb = function(/*XMLEncoder*/ encoder)\n{\n  BinaryXmlWireFormat.encodeData(this, encoder);\n};\n\n/**\n * Encode this Data for a particular wire format.\n * @param {WireFormat} wireFormat if null, use BinaryXmlWireFormat.\n * @returns {Buffer}\n */\nData.prototype.encode = function(wireFormat)\n{\n  wireFormat = (wireFormat || BinaryXmlWireFormat.instance);\n  return wireFormat.encodeData(this);\n};\n\n/**\n * Decode the input using a particular wire format and update this Data.\n * @param {Buffer} input\n * @param {WireFormat} wireFormat if null, use BinaryXmlWireFormat.\n */\nData.prototype.decode = function(input, wireFormat)\n{\n  wireFormat = (wireFormat || BinaryXmlWireFormat.instance);\n  wireFormat.decodeData(this, input);\n};\n\n/**\n * @deprecated Use new Data.\n */\nvar ContentObject = function ContentObject(name, signedInfo, content)\n{\n  // Call the base constructor.\n  Data.call(this, name, signedInfo, content);\n}\n\nContentObject.prototype = new Data();\n\nexports.ContentObject = ContentObject;\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class represents Interest Objects\n */\n\n\n/**\n * Create a new Interest with the optional values.\n *\n * @constructor\n * @param {Name|Interest} nameOrInterest If this is an Interest, copy values from the interest and ignore the\n * other arguments.  Otherwise this is the optional name for the new Interest.\n * @param {number} minSuffixComponents\n * @param {number} maxSuffixComponents\n * @param {Buffer} publisherPublicKeyDigest\n * @param {Exclude} exclude\n * @param {number} childSelector\n * @param {number} answerOriginKind\n * @param {number} scope\n * @param {number} interestLifetimeMilliseconds in milliseconds\n * @param {Buffer} nonce\n */\nvar Interest = function Interest\n   (nameOrInterest, minSuffixComponents, maxSuffixComponents, publisherPublicKeyDigest, exclude,\n    childSelector, answerOriginKind, scope, interestLifetimeMilliseconds, nonce)\n{\n  if (typeof nameOrInterest == \'object\' && nameOrInterest instanceof Interest) {\n    // Special case: this is a copy constructor.  Ignore all but the first argument.\n    var interest = nameOrInterest;\n    if (interest.name)\n      // Copy the name.\n      this.name = new Name(interest.name);\n    this.maxSuffixComponents = interest.maxSuffixComponents;\n    this.minSuffixComponents = interest.minSuffixComponents;\n\n    this.publisherPublicKeyDigest = interest.publisherPublicKeyDigest;\n    this.exclude = interest.exclude;\n    this.childSelector = interest.childSelector;\n    this.answerOriginKind = interest.answerOriginKind;\n    this.scope = interest.scope;\n    this.interestLifetime = interest.interestLifetime;\n    if (interest.nonce)\n      // Copy.\n      this.nonce = new ndnbuf(interest.nonce);\n  }\n  else {\n    this.name = nameOrInterest;\n    this.maxSuffixComponents = maxSuffixComponents;\n    this.minSuffixComponents = minSuffixComponents;\n\n    this.publisherPublicKeyDigest = publisherPublicKeyDigest;\n    this.exclude = exclude;\n    this.childSelector = childSelector;\n    this.answerOriginKind = answerOriginKind;\n    this.scope = scope;\n    this.interestLifetime = interestLifetimeMilliseconds;\n    if (nonce)\n      // Copy and make sure it is a ndnbuf.\n      this.nonce = new ndnbuf(nonce);\n  }\n};\n\nexports.Interest = Interest;\n\nInterest.RECURSIVE_POSTFIX = "*";\n\nInterest.CHILD_SELECTOR_LEFT = 0;\nInterest.CHILD_SELECTOR_RIGHT = 1;\n\nInterest.ANSWER_NO_CONTENT_STORE = 0;\nInterest.ANSWER_CONTENT_STORE = 1;\nInterest.ANSWER_GENERATED = 2;\nInterest.ANSWER_STALE = 4;    // Stale answer OK\nInterest.MARK_STALE = 16;    // Must have scope 0.  Michael calls this a "hack"\n\nInterest.DEFAULT_ANSWER_ORIGIN_KIND = Interest.ANSWER_CONTENT_STORE | Interest.ANSWER_GENERATED;\n\n/**\n * Return true if this.name.match(name) and the name conforms to the interest selectors.\n * @param {Name} name\n * @returns {boolean}\n */\nInterest.prototype.matchesName = function(/*Name*/ name)\n{\n  if (!this.name.match(name))\n    return false;\n\n  if (this.minSuffixComponents != null &&\n      // Add 1 for the implicit digest.\n      !(name.size() + 1 - this.name.size() >= this.minSuffixComponents))\n    return false;\n  if (this.maxSuffixComponents != null &&\n      // Add 1 for the implicit digest.\n      !(name.size() + 1 - this.name.size() <= this.maxSuffixComponents))\n    return false;\n  if (this.exclude != null && name.size() > this.name.size() &&\n      this.exclude.matches(name.components[this.name.size()]))\n    return false;\n\n  return true;\n};\n\n/**\n * @deprecated Use matchesName.\n */\nInterest.prototype.matches_name = function(/*Name*/ name)\n{\n  return this.matchesName(name);\n};\n\n/**\n * Return a new Interest with the same fields as this Interest.\n * Note: This does NOT make a deep clone of the name, exclue or other objects.\n */\nInterest.prototype.clone = function()\n{\n  return new Interest\n     (this.name, this.minSuffixComponents, this.maxSuffixComponents,\n      this.publisherPublicKeyDigest, this.exclude, this.childSelector, this.answerOriginKind,\n      this.scope, this.interestLifetime, this.nonce);\n};\n\nInterest.prototype.setMinSuffixComponents = function(value)\n{\n  this.minSuffixComponents = value;\n}\n\nInterest.prototype.setMaxSuffixComponents = function(value)\n{\n  this.maxSuffixComponents = value;\n}\n\nInterest.prototype.setChildSelector = function(value)\n{\n  this.childSelector = value;\n}\n\nInterest.prototype.setAnswerOriginKind = function(value)\n{\n  this.answerOriginKind = value;\n}\n\nInterest.prototype.setScope = function(value)\n{\n  this.scope = value;\n}\n\nInterest.prototype.setInterestLifetimeMilliseconds = function(value)\n{\n  this.interestLifetime = value;\n}\n\nInterest.prototype.setNonce = function(value)\n{\n  if (value)\n    // Copy and make sure it is a ndnbuf.\n    this.nonce = new ndnbuf(value);\n  else\n    this.nonce = null;\n}\n\n/**\n * Create a new Exclude.\n * @constructor\n * @param {Array<Name.Component|Buffer|Exclude.ANY>} values (optional) An array where each element is either a Name.Component, ndnbuf component or Exclude.ANY.\n */\nvar Exclude = function Exclude(values)\n{\n  this.values = [];\n\n  if (values) {\n    for (var i = 0; i < values.length; ++i) {\n      if (values[i] == Exclude.ANY)\n        this.appendAny();\n      else\n        this.appendComponent(values[i]);\n    }\n  }\n};\n\nexports.Exclude = Exclude;\n\nExclude.ANY = "*";\n\n/**\n * Append an Exclude.ANY element.\n * @returns This Exclude so that you can chain calls to append.\n */\nExclude.prototype.appendAny = function()\n{\n  this.values.push(Exclude.ANY);\n  return this;\n}\n\n/**\n * Append a component entry, copying from component.\n * @param {Name.Component|Buffer} component\n * @returns This Exclude so that you can chain calls to append.\n */\nExclude.prototype.appendComponent = function(component)\n{\n  this.values.push(new Name.Component(component));\n  return this;\n}\n\nExclude.prototype.from_ndnb = function(/*XMLDecoder*/ decoder)\n{\n  decoder.readElementStartDTag(NDNProtocolDTags.Exclude);\n\n  while (true) {\n    if (decoder.peekDTag(NDNProtocolDTags.Component))\n      this.appendComponent(decoder.readBinaryDTagElement(NDNProtocolDTags.Component));\n    else if (decoder.peekDTag(NDNProtocolDTags.Any)) {\n      decoder.readElementStartDTag(NDNProtocolDTags.Any);\n      decoder.readElementClose();\n      this.appendAny();\n    }\n    else if (decoder.peekDTag(NDNProtocolDTags.Bloom)) {\n      // Skip the Bloom and treat it as Any.\n      decoder.readBinaryDTagElement(NDNProtocolDTags.Bloom);\n      this.appendAny();\n    }\n    else\n      break;\n  }\n\n  decoder.readElementClose();\n};\n\nExclude.prototype.to_ndnb = function(/*XMLEncoder*/ encoder)\n{\n  if (this.values == null || this.values.length == 0)\n    return;\n\n  encoder.writeElementStartDTag(NDNProtocolDTags.Exclude);\n\n  // TODO: Do we want to order the components (except for ANY)?\n  for (var i = 0; i < this.values.length; ++i) {\n    if (this.values[i] == Exclude.ANY) {\n      encoder.writeElementStartDTag(NDNProtocolDTags.Any);\n      encoder.writeElementClose();\n    }\n    else\n      encoder.writeDTagElement(NDNProtocolDTags.Component, this.values[i].getValue());\n  }\n\n  encoder.writeElementClose();\n};\n\n/**\n * Return a string with elements separated by "," and Exclude.ANY shown as "*".\n */\nExclude.prototype.toUri = function()\n{\n  if (this.values == null || this.values.length == 0)\n    return "";\n\n  var result = "";\n  for (var i = 0; i < this.values.length; ++i) {\n    if (i > 0)\n      result += ",";\n\n    if (this.values[i] == Exclude.ANY)\n      result += "*";\n    else\n      result += Name.toEscapedString(this.values[i].getValue());\n  }\n  return result;\n};\n\n/**\n * Return true if the component matches any of the exclude criteria.\n */\nExclude.prototype.matches = function(/*Buffer*/ component)\n{\n  if (typeof component == \'object\' && component instanceof Name.Component)\n    component = component.getValue();\n\n  for (var i = 0; i < this.values.length; ++i) {\n    if (this.values[i] == Exclude.ANY) {\n      var lowerBound = null;\n      if (i > 0)\n        lowerBound = this.values[i - 1];\n\n      // Find the upper bound, possibly skipping over multiple ANY in a row.\n      var iUpperBound;\n      var upperBound = null;\n      for (iUpperBound = i + 1; iUpperBound < this.values.length; ++iUpperBound) {\n        if (this.values[iUpperBound] != Exclude.ANY) {\n          upperBound = this.values[iUpperBound];\n          break;\n        }\n      }\n\n      // If lowerBound != null, we already checked component equals lowerBound on the last pass.\n      // If upperBound != null, we will check component equals upperBound on the next pass.\n      if (upperBound != null) {\n        if (lowerBound != null) {\n          if (Exclude.compareComponents(component, lowerBound) > 0 &&\n              Exclude.compareComponents(component, upperBound) < 0)\n            return true;\n        }\n        else {\n          if (Exclude.compareComponents(component, upperBound) < 0)\n            return true;\n        }\n\n        // Make i equal iUpperBound on the next pass.\n        i = iUpperBound - 1;\n      }\n      else {\n        if (lowerBound != null) {\n            if (Exclude.compareComponents(component, lowerBound) > 0)\n              return true;\n        }\n        else\n          // this.values has only ANY.\n          return true;\n      }\n    }\n    else {\n      if (DataUtils.arraysEqual(component, this.values[i].getValue()))\n        return true;\n    }\n  }\n\n  return false;\n};\n\n/**\n * Return -1 if component1 is less than component2, 1 if greater or 0 if equal.\n * A component is less if it is shorter, otherwise if equal length do a byte comparison.\n */\nExclude.compareComponents = function(component1, component2)\n{\n  if (typeof component1 == \'object\' && component1 instanceof Name.Component)\n    component1 = component1.getValue();\n  if (typeof component2 == \'object\' && component2 instanceof Name.Component)\n    component2 = component2.getValue();\n\n  if (component1.length < component2.length)\n    return -1;\n  if (component1.length > component2.length)\n    return 1;\n\n  for (var i = 0; i < component1.length; ++i) {\n    if (component1[i] < component2[i])\n      return -1;\n    if (component1[i] > component2[i])\n      return 1;\n  }\n\n  return 0;\n};\n\n/**\n * @deprecated Use BinaryXmlWireFormat.decodeInterest.\n */\nInterest.prototype.from_ndnb = function(/*XMLDecoder*/ decoder)\n{\n  BinaryXmlWireFormat.decodeInterest(this, decoder);\n};\n\n/**\n * @deprecated Use BinaryXmlWireFormat.encodeInterest.\n */\nInterest.prototype.to_ndnb = function(/*XMLEncoder*/ encoder)\n{\n  BinaryXmlWireFormat.encodeInterest(this, encoder);\n};\n\n/**\n * Encode this Interest for a particular wire format.\n * @param {WireFormat} wireFormat if null, use BinaryXmlWireFormat.\n * @returns {Buffer}\n */\nInterest.prototype.encode = function(wireFormat)\n{\n  wireFormat = (wireFormat || BinaryXmlWireFormat.instance);\n  return wireFormat.encodeInterest(this);\n};\n\n/**\n * Decode the input using a particular wire format and update this Interest.\n * @param {Buffer} input\n * @param {WireFormat} wireFormat if null, use BinaryXmlWireFormat.\n */\nInterest.prototype.decode = function(input, wireFormat)\n{\n  wireFormat = (wireFormat || BinaryXmlWireFormat.instance);\n  wireFormat.decodeInterest(this, input);\n};\n\n/**\n * Encode the name according to the "NDN URI Scheme".  If there are interest selectors, append "?" and\n * added the selectors as a query string.  For example "/test/name?ndn.ChildSelector=1".\n * @returns {string} The URI string.\n */\nInterest.prototype.toUri = function()\n{\n  var selectors = "";\n\n  if (this.minSuffixComponents != null)\n    selectors += "&ndn.MinSuffixComponents=" + this.minSuffixComponents;\n  if (this.maxSuffixComponents != null)\n    selectors += "&ndn.MaxSuffixComponents=" + this.maxSuffixComponents;\n  if (this.childSelector != null)\n    selectors += "&ndn.ChildSelector=" + this.childSelector;\n  if (this.answerOriginKind != null)\n    selectors += "&ndn.AnswerOriginKind=" + this.answerOriginKind;\n  if (this.scope != null)\n    selectors += "&ndn.Scope=" + this.scope;\n  if (this.interestLifetime != null)\n    selectors += "&ndn.InterestLifetime=" + this.interestLifetime;\n  if (this.publisherPublicKeyDigest != null)\n    selectors += "&ndn.PublisherPublicKeyDigest=" + Name.toEscapedString(this.publisherPublicKeyDigest.publisherPublicKeyDigest);\n  if (this.nonce != null)\n    selectors += "&ndn.Nonce=" + Name.toEscapedString(this.nonce);\n  if (this.exclude != null)\n    selectors += "&ndn.Exclude=" + this.exclude.toUri();\n\n  var result = this.name.toUri();\n  if (selectors != "")\n    // Replace the first & with ?.\n    result += "?" + selectors.substr(1);\n\n  return result;\n};\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class represents Key Objects\n */\n\n/**\n * @constructor\n */\n/**\n * Key\n */\nvar Key = function Key()\n{\n  this.publicKeyDer = null;     // ndnbuf\n  this.publicKeyDigest = null;  // ndnbuf\n  this.publicKeyPem = null;     // String\n  this.privateKeyPem = null;    // String\n};\n\nexports.Key = Key;\n\n/**\n * Helper functions to read Key fields\n * TODO: generateRSA()\n */\n\nKey.prototype.publicToDER = function()\n{\n  return this.publicKeyDer;  // ndnbuf\n};\n\nKey.prototype.privateToDER = function()\n{\n  // Remove the \'-----XXX-----\' from the beginning and the end of the key\n  // and also remove any \\n in the key string\n  var lines = this.privateKeyPem.split(\'\\n\');\n  priKey = "";\n  for (var i = 1; i < lines.length - 1; i++)\n    priKey += lines[i];\n\n  return new ndnbuf(priKey, \'base64\');\n};\n\nKey.prototype.publicToPEM = function()\n{\n  return this.publicKeyPem;\n};\n\nKey.prototype.privateToPEM = function()\n{\n  return this.privateKeyPem;\n};\n\nKey.prototype.getKeyID = function()\n{\n  return this.publicKeyDigest;\n};\n\nexports.Key = Key;\n\nKey.prototype.readDerPublicKey = function(/*Buffer*/pub_der)\n{\n  if (LOG > 4) console.log("Encode DER public key:\\n" + pub_der.toString(\'hex\'));\n\n  this.publicKeyDer = pub_der;\n\n  var hash = ndn.createHash(\'sha256\');\n  hash.update(this.publicKeyDer);\n  this.publicKeyDigest = new ndnbuf(hash.digest());\n\n  var keyStr = pub_der.toString(\'base64\');\n  var keyPem = "-----BEGIN PUBLIC KEY-----\\n";\n  for (var i = 0; i < keyStr.length; i += 64)\n  keyPem += (keyStr.substr(i, 64) + "\\n");\n  keyPem += "-----END PUBLIC KEY-----";\n  this.publicKeyPem = keyPem;\n\n  if (LOG > 4) console.log("Convert public key to PEM format:\\n" + this.publicKeyPem);\n};\n\n/**\n * Load RSA key pair from PEM-encoded strings.\n * Will throw an Error if both \'pub\' and \'pri\' are null.\n */\nKey.prototype.fromPemString = function(pub, pri)\n{\n  if (pub == null && pri == null)\n    throw new Error(\'Cannot create Key object if both public and private PEM string is empty.\');\n\n  // Read public key\n  if (pub != null) {\n    this.publicKeyPem = pub;\n    if (LOG > 4) console.log("Key.publicKeyPem: \\n" + this.publicKeyPem);\n\n    // Remove the \'-----XXX-----\' from the beginning and the end of the public key\n    // and also remove any \\n in the public key string\n    var lines = pub.split(\'\\n\');\n    pub = "";\n    for (var i = 1; i < lines.length - 1; i++)\n      pub += lines[i];\n    this.publicKeyDer = new ndnbuf(pub, \'base64\');\n    if (LOG > 4) console.log("Key.publicKeyDer: \\n" + this.publicKeyDer.toString(\'hex\'));\n\n    var hash = ndn.createHash(\'sha256\');\n    hash.update(this.publicKeyDer);\n    this.publicKeyDigest = new ndnbuf(hash.digest());\n    if (LOG > 4) console.log("Key.publicKeyDigest: \\n" + this.publicKeyDigest.toString(\'hex\'));\n  }\n\n  // Read private key\n  if (pri != null) {\n    this.privateKeyPem = pri;\n    if (LOG > 4) console.log("Key.privateKeyPem: \\n" + this.privateKeyPem);\n  }\n};\n\nKey.prototype.fromPem = Key.prototype.fromPemString;\n\n/**\n * Static method that create a Key object.\n * Parameter \'obj\' is a JSON object that has two properties:\n *   pub: the PEM string for the public key\n *   pri: the PEM string for the private key\n * Will throw an Error if both obj.pub and obj.pri are null.\n */\nKey.createFromPEM = function(obj)\n{\n    var key = new Key();\n    key.fromPemString(obj.pub, obj.pri);\n    return key;\n};\n\n/**\n * KeyLocator\n */\nvar KeyLocatorType = {\n  KEY:1,\n  CERTIFICATE:2,\n  KEYNAME:3\n};\n\nexports.KeyLocatorType = KeyLocatorType;\n\n/**\n * @constructor\n */\nvar KeyLocator = function KeyLocator(input,type)\n{\n  this.type = type;\n\n  if (type == KeyLocatorType.KEYNAME) {\n    if (LOG > 3) console.log(\'KeyLocator: SET KEYNAME\');\n    this.keyName = input;\n  }\n  else if (type == KeyLocatorType.KEY) {\n    if (LOG > 3) console.log(\'KeyLocator: SET KEY\');\n    this.publicKey = input;\n  }\n  else if (type == KeyLocatorType.CERTIFICATE) {\n    if (LOG > 3) console.log(\'KeyLocator: SET CERTIFICATE\');\n    this.certificate = input;\n  }\n};\n\nexports.KeyLocator = KeyLocator;\n\nKeyLocator.prototype.from_ndnb = function(decoder) {\n\n  decoder.readElementStartDTag(this.getElementLabel());\n\n  if (decoder.peekDTag(NDNProtocolDTags.Key))\n  {\n    try {\n      var encodedKey = decoder.readBinaryDTagElement(NDNProtocolDTags.Key);\n      // This is a DER-encoded SubjectPublicKeyInfo.\n\n      //TODO FIX THIS, This should create a Key Object instead of keeping bytes\n\n      this.publicKey =   encodedKey;//CryptoUtil.getPublicKey(encodedKey);\n      this.type = KeyLocatorType.KEY;\n\n      if (LOG > 4) console.log(\'PUBLIC KEY FOUND: \'+ this.publicKey);\n    }\n    catch (e) {\n      throw new Error("Cannot parse key: ", e);\n    }\n\n    if (null == this.publicKey)\n      throw new Error("Cannot parse key: ");\n  }\n  else if (decoder.peekDTag(NDNProtocolDTags.Certificate)) {\n    try {\n      var encodedCert = decoder.readBinaryDTagElement(NDNProtocolDTags.Certificate);\n\n      /*\n       * Certificates not yet working\n       */\n\n      this.certificate = encodedCert;\n      this.type = KeyLocatorType.CERTIFICATE;\n\n      if (LOG > 4) console.log(\'CERTIFICATE FOUND: \'+ this.certificate);\n    }\n    catch (e) {\n      throw new Error("Cannot decode certificate: " +  e);\n    }\n    if (null == this.certificate)\n      throw new Error("Cannot parse certificate! ");\n  } else  {\n    this.type = KeyLocatorType.KEYNAME;\n\n    this.keyName = new KeyName();\n    this.keyName.from_ndnb(decoder);\n  }\n  decoder.readElementClose();\n};\n\nKeyLocator.prototype.to_ndnb = function(encoder)\n{\n  if (LOG > 4) console.log(\'type is is \' + this.type);\n  //TODO Check if Name is missing\n  if (!this.validate())\n    throw new Error("Cannot encode " + this.getClass().getName() + ": field values missing.");\n\n  //TODO FIX THIS TOO\n  encoder.writeElementStartDTag(this.getElementLabel());\n\n  if (this.type == KeyLocatorType.KEY) {\n    if (LOG > 5) console.log(\'About to encode a public key\' +this.publicKey);\n    encoder.writeDTagElement(NDNProtocolDTags.Key, this.publicKey);\n  }\n  else if (this.type == KeyLocatorType.CERTIFICATE) {\n    try {\n      encoder.writeDTagElement(NDNProtocolDTags.Certificate, this.certificate);\n    }\n    catch (e) {\n      throw new Error("CertificateEncodingException attempting to write key locator: " + e);\n    }\n  }\n  else if (this.type == KeyLocatorType.KEYNAME)\n    this.keyName.to_ndnb(encoder);\n\n  encoder.writeElementClose();\n};\n\nKeyLocator.prototype.getElementLabel = function()\n{\n  return NDNProtocolDTags.KeyLocator;\n};\n\nKeyLocator.prototype.validate = function()\n{\n  return null != this.keyName || null != this.publicKey || null != this.certificate;\n};\n\n/**\n * KeyName is only used by KeyLocator.\n * @constructor\n */\nvar KeyName = function KeyName()\n{\n  this.contentName = this.contentName;  //contentName\n  this.publisherID = this.publisherID;  //publisherID\n};\n\nexports.KeyName = KeyName;\n\nKeyName.prototype.from_ndnb = function(decoder)\n{\n  decoder.readElementStartDTag(this.getElementLabel());\n\n  this.contentName = new Name();\n  this.contentName.from_ndnb(decoder);\n\n  if (LOG > 4) console.log(\'KEY NAME FOUND: \');\n\n  if (PublisherID.peek(decoder)) {\n    this.publisherID = new PublisherID();\n    this.publisherID.from_ndnb(decoder);\n  }\n\n  decoder.readElementClose();\n};\n\nKeyName.prototype.to_ndnb = function(encoder)\n{\n  if (!this.validate())\n    throw new Error("Cannot encode : field values missing.");\n\n  encoder.writeElementStartDTag(this.getElementLabel());\n\n  this.contentName.to_ndnb(encoder);\n  if (null != this.publisherID)\n    this.publisherID.to_ndnb(encoder);\n\n  encoder.writeElementClose();\n};\n\nKeyName.prototype.getElementLabel = function() { return NDNProtocolDTags.KeyName; };\n\nKeyName.prototype.validate = function()\n{\n    // DKS -- do we do recursive validation?\n    // null signedInfo ok\n    return (null != this.contentName);\n};\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class represents Face Instances\n */\n\n\n/**\n * @constructor\n */\nvar FaceInstance  = function FaceInstance(action, publisherPublicKeyDigest, faceID, ipProto, host, port, multicastInterface,\n    multicastTTL, freshnessSeconds)\n{\n  this.action = action;\n  this.publisherPublicKeyDigest = publisherPublicKeyDigest;\n  this.faceID = faceID;\n  this.ipProto = ipProto;\n  this.host = host;\n  this.Port = port;\n  this.multicastInterface =multicastInterface;\n  this.multicastTTL =multicastTTL;\n  this.freshnessSeconds = freshnessSeconds;\n};\n\nexports.FaceInstance = FaceInstance;\n\nFaceInstance.NetworkProtocol = { TCP:6, UDP:17};\n\n/**\n * Used by NetworkObject to decode the object from a network stream.\n */\nFaceInstance.prototype.from_ndnb = function(\n  //XMLDecoder\n  decoder)\n{\n  decoder.readElementStartDTag(this.getElementLabel());\n\n  if (decoder.peekDTag(NDNProtocolDTags.Action))\n    this.action = decoder.readUTF8DTagElement(NDNProtocolDTags.Action);\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherPublicKeyDigest)) {\n    this.publisherPublicKeyDigest = new PublisherPublicKeyDigest();\n    this.publisherPublicKeyDigest.from_ndnb(decoder);\n  }\n  if (decoder.peekDTag(NDNProtocolDTags.FaceID))\n    this.faceID = decoder.readIntegerDTagElement(NDNProtocolDTags.FaceID);\n  if (decoder.peekDTag(NDNProtocolDTags.IPProto)) {\n    //int\n    var pI = decoder.readIntegerDTagElement(NDNProtocolDTags.IPProto);\n\n    this.ipProto = null;\n\n    if (FaceInstance.NetworkProtocol.TCP == pI)\n      this.ipProto = FaceInstance.NetworkProtocol.TCP;\n    else if (FaceInstance.NetworkProtocol.UDP == pI)\n      this.ipProto = FaceInstance.NetworkProtocol.UDP;\n    else\n      throw new Error("FaceInstance.decoder.  Invalid NDNProtocolDTags.IPProto field: " + pI);\n  }\n\n  if (decoder.peekDTag(NDNProtocolDTags.Host))\n    this.host = decoder.readUTF8DTagElement(NDNProtocolDTags.Host);\n  if (decoder.peekDTag(NDNProtocolDTags.Port))\n    this.Port = decoder.readIntegerDTagElement(NDNProtocolDTags.Port);\n  if (decoder.peekDTag(NDNProtocolDTags.MulticastInterface))\n    this.multicastInterface = decoder.readUTF8DTagElement(NDNProtocolDTags.MulticastInterface);\n  if (decoder.peekDTag(NDNProtocolDTags.MulticastTTL))\n    this.multicastTTL = decoder.readIntegerDTagElement(NDNProtocolDTags.MulticastTTL);\n  if (decoder.peekDTag(NDNProtocolDTags.FreshnessSeconds))\n    this.freshnessSeconds = decoder.readIntegerDTagElement(NDNProtocolDTags.FreshnessSeconds);\n\n  decoder.readElementClose();\n};\n\n/**\n * Used by NetworkObject to encode the object to a network stream.\n */\nFaceInstance.prototype.to_ndnb = function(\n  //XMLEncoder\n  encoder)\n{\n  encoder.writeElementStartDTag(this.getElementLabel());\n\n  if (null != this.action && this.action.length != 0)\n    encoder.writeDTagElement(NDNProtocolDTags.Action, this.action);\n  if (null != this.publisherPublicKeyDigest)\n    this.publisherPublicKeyDigest.to_ndnb(encoder);\n  if (null != this.faceID)\n    encoder.writeDTagElement(NDNProtocolDTags.FaceID, this.faceID);\n  if (null != this.ipProto)\n    encoder.writeDTagElement(NDNProtocolDTags.IPProto, this.ipProto);\n  if (null != this.host && this.host.length != 0)\n    encoder.writeDTagElement(NDNProtocolDTags.Host, this.host);\n  if (null != this.Port)\n    encoder.writeDTagElement(NDNProtocolDTags.Port, this.Port);\n  if (null != this.multicastInterface && this.multicastInterface.length != 0)\n    encoder.writeDTagElement(NDNProtocolDTags.MulticastInterface, this.multicastInterface);\n  if (null !=  this.multicastTTL)\n    encoder.writeDTagElement(NDNProtocolDTags.MulticastTTL, this.multicastTTL);\n  if (null != this.freshnessSeconds)\n    encoder.writeDTagElement(NDNProtocolDTags.FreshnessSeconds, this.freshnessSeconds);\n\n  encoder.writeElementClose();\n};\n\nFaceInstance.prototype.getElementLabel = function()\n{\n  return NDNProtocolDTags.FaceInstance;\n};\n\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n * This class represents Forwarding Entries\n */\n\n\n/**\n * Create a new ForwardingEntry with the optional arguments.\n * @constructor\n * @param {String} action\n * @param {Name} prefixName\n * @param {PublisherPublicKeyDigest} ndndId\n * @param {number} faceID\n * @param {number} flags\n * @param {number} lifetime in seconds\n */\nvar ForwardingEntry = function ForwardingEntry(action, prefixName, ndndId, faceID, flags, lifetime)\n{\n  this.action = action;\n  this.prefixName = prefixName;\n  this.ndndID = ndndId;\n  this.faceID = faceID;\n  this.flags = flags;\n  this.lifetime = lifetime;\n};\n\nexports.ForwardingEntry = ForwardingEntry;\n\nForwardingEntry.ACTIVE         = 1;\nForwardingEntry.CHILD_INHERIT  = 2;\nForwardingEntry.ADVERTISE      = 4;\nForwardingEntry.LAST           = 8;\nForwardingEntry.CAPTURE       = 16;\nForwardingEntry.LOCAL         = 32;\nForwardingEntry.TAP           = 64;\nForwardingEntry.CAPTURE_OK   = 128;\n\nForwardingEntry.prototype.from_ndnb = function(\n  //XMLDecoder\n  decoder)\n  //throws ContentDecodingException\n{\n  decoder.readElementStartDTag(this.getElementLabel());\n  if (decoder.peekDTag(NDNProtocolDTags.Action))\n    this.action = decoder.readUTF8DTagElement(NDNProtocolDTags.Action);\n  if (decoder.peekDTag(NDNProtocolDTags.Name)) {\n    this.prefixName = new Name();\n    this.prefixName.from_ndnb(decoder) ;\n  }\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherPublicKeyDigest)) {\n    this.NdndId = new PublisherPublicKeyDigest();\n    this.NdndId.from_ndnb(decoder);\n  }\n  if (decoder.peekDTag(NDNProtocolDTags.FaceID))\n    this.faceID = decoder.readIntegerDTagElement(NDNProtocolDTags.FaceID);\n  if (decoder.peekDTag(NDNProtocolDTags.ForwardingFlags))\n    this.flags = decoder.readIntegerDTagElement(NDNProtocolDTags.ForwardingFlags);\n  if (decoder.peekDTag(NDNProtocolDTags.FreshnessSeconds))\n    this.lifetime = decoder.readIntegerDTagElement(NDNProtocolDTags.FreshnessSeconds);\n\n  decoder.readElementClose();\n};\n\nForwardingEntry.prototype.to_ndnb = function(\n  //XMLEncoder\n  encoder)\n{\n  encoder.writeElementStartDTag(this.getElementLabel());\n  if (null != this.action && this.action.length != 0)\n    encoder.writeDTagElement(NDNProtocolDTags.Action, this.action);\n  if (null != this.prefixName)\n    this.prefixName.to_ndnb(encoder);\n  if (null != this.NdndId)\n    this.NdndId.to_ndnb(encoder);\n  if (null != this.faceID)\n    encoder.writeDTagElement(NDNProtocolDTags.FaceID, this.faceID);\n  if (null != this.flags)\n    encoder.writeDTagElement(NDNProtocolDTags.ForwardingFlags, this.flags);\n  if (null != this.lifetime)\n    encoder.writeDTagElement(NDNProtocolDTags.FreshnessSeconds, this.lifetime);\n\n  encoder.writeElementClose();\n};\n\nForwardingEntry.prototype.getElementLabel = function() { return NDNProtocolDTags.ForwardingEntry; }\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\n\n/**\n * A ForwardingFlags object holds the flags which specify how the forwarding daemon should forward an interest for\n * a registered prefix.  We use a separate ForwardingFlags object to retain future compatibility if the daemon forwarding\n * bits are changed, amended or deprecated.\n * Create a new ForwardingFlags with "active" and "childInherit" set and all other flags cleared.\n */\nvar ForwardingFlags = function ForwardingFlags()\n{\n  this.active = true;\n  this.childInherit = true;\n  this.advertise = false;\n  this.last = false;\n  this.capture = false;\n  this.local = false;\n  this.tap = false;\n  this.captureOk = false;\n}\n\nexports.ForwardingFlags = ForwardingFlags;\n\n/**\n * Get an integer with the bits set according to the flags as used by the ForwardingEntry message.\n * @returns {number} An integer with the bits set.\n */\nForwardingFlags.prototype.getForwardingEntryFlags = function()\n{\n  var result = 0;\n\n  if (this.active)\n    result |= ForwardingEntry.ACTIVE;\n  if (this.childInherit)\n    result |= ForwardingEntry.CHILD_INHERIT;\n  if (this.advertise)\n    result |= ForwardingEntry.ADVERTISE;\n  if (this.last)\n    result |= ForwardingEntry.LAST;\n  if (this.capture)\n    result |= ForwardingEntry.CAPTURE;\n  if (this.local)\n    result |= ForwardingEntry.LOCAL;\n  if (this.tap)\n    result |= ForwardingEntry.TAP;\n  if (this.captureOk)\n    result |= ForwardingEntry.CAPTURE_OK;\n\n  return result;\n};\n\n/**\n * Set the flags according to the bits in forwardingEntryFlags as used by the ForwardingEntry message.\n * @param {number} forwardingEntryFlags An integer with the bits set.\n */\nForwardingFlags.prototype.setForwardingEntryFlags = function(forwardingEntryFlags)\n{\n  this.active = ((forwardingEntryFlags & ForwardingEntry.ACTIVE) != 0);\n  this.childInherit = ((forwardingEntryFlags & ForwardingEntry.CHILD_INHERIT) != 0);\n  this.advertise = ((forwardingEntryFlags & ForwardingEntry.ADVERTISE) != 0);\n  this.last = ((forwardingEntryFlags & ForwardingEntry.LAST) != 0);\n  this.capture = ((forwardingEntryFlags & ForwardingEntry.CAPTURE) != 0);\n  this.local = ((forwardingEntryFlags & ForwardingEntry.LOCAL) != 0);\n  this.tap = ((forwardingEntryFlags & ForwardingEntry.TAP) != 0);\n  this.captureOk = ((forwardingEntryFlags & ForwardingEntry.CAPTURE_OK) != 0);\n};\n\n/**\n * Get the value of the "active" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getActive = function() { return this.active; };\n\n/**\n * Get the value of the "childInherit" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getChildInherit = function() { return this.childInherit; };\n\n/**\n * Get the value of the "advertise" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getAdvertise = function() { return this.advertise; };\n\n/**\n * Get the value of the "last" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getLast = function() { return this.last; };\n\n/**\n * Get the value of the "capture" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getCapture = function() { return this.capture; };\n\n/**\n * Get the value of the "local" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getLocal = function() { return this.local; };\n\n/**\n * Get the value of the "tap" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getTap = function() { return this.tap; };\n\n/**\n * Get the value of the "captureOk" flag.\n * @returns {Boolean} true if the flag is set, false if it is cleared.\n */\nForwardingFlags.prototype.getCaptureOk = function() { return this.captureOk; };\n\n/**\n * Set the value of the "active" flag\n * @param {number} value true to set the flag, false to clear it.\n */\nForwardingFlags.prototype.setActive = function(value) { this.active = value; };\n\n/**\n * Set the value of the "childInherit" flag\n * @param {number} value true to set the flag, false to clear it.\n */\nForwardingFlags.prototype.setChildInherit = function(value) { this.childInherit = value; };\n\n/**\n * Set the value of the "advertise" flag\n * @param {number} value true to set the flag, false to clear it.\n */\nForwardingFlags.prototype.setAdvertise = function(value) { this.advertise = value; };\n\n/**\n * Set the value of the "last" flag\n * @param {number} value true to set the flag, false to clear it.\n */\nForwardingFlags.prototype.setLast = function(value) { this.last = value; };\n\n/**\n * Set the value of the "capture" flag\n * @param {number} value true to set the flag, false to clear it.\n */\nForwardingFlags.prototype.setCapture = function(value) { this.capture = value; };\n\n/**\n * Set the value of the "local" flag\n * @param {number} value true to set the flag, false to clear it.\n */\nForwardingFlags.prototype.setLocal = function(value) { this.local = value; };\n\n/**\n * Set the value of the "tap" flag\n * @param {number} value true to set the flag, false to clear it.\n */\nForwardingFlags.prototype.setTap = function(value) { this.tap = value; };\n\n/**\n * Set the value of the "captureOk" flag\n * @param {number} value true to set the flag, false to clear it.\n */\nForwardingFlags.prototype.setCaptureOk = function(value) { this.captureOk = value; };\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Jeff Thompson <jefft0@remap.ucla.edu>\n * See COPYING for copyright and distribution information.\n */\n\n/**\n * A BinaryXmlWireFormat implements the WireFormat interface for encoding and decoding in binary XML.\n * @constructor\n */\nvar BinaryXmlWireFormat = function BinaryXmlWireFormat()\n{\n  // Inherit from WireFormat.\n  WireFormat.call(this);\n};\n\nexports.BinaryXmlWireFormat = BinaryXmlWireFormat;\n\n// Default object.\nBinaryXmlWireFormat.instance = new BinaryXmlWireFormat();\n\n/**\n * Encode the interest and return a ndnbuf.\n * @param {Interest} interest\n * @returns {Buffer}\n */\nBinaryXmlWireFormat.prototype.encodeInterest = function(interest)\n{\n  var encoder = new BinaryXMLEncoder();\n  BinaryXmlWireFormat.encodeInterest(interest, encoder);\n  return encoder.getReducedOstream();\n};\n\n/**\n * Decode the input and put the result in interest.\n * @param {Interest} interest\n * @param {Buffer} input\n */\nBinaryXmlWireFormat.prototype.decodeInterest = function(interest, input)\n{\n  var decoder = new BinaryXMLDecoder(input);\n  BinaryXmlWireFormat.decodeInterest(interest, decoder);\n};\n\n/**\n * Encode the data and return a ndnbuf.\n * @param {Data} data\n * @returns {Buffer}\n */\nBinaryXmlWireFormat.prototype.encodeData = function(data)\n{\n  var encoder = new BinaryXMLEncoder(1500);\n  BinaryXmlWireFormat.encodeData(data, encoder);\n  return encoder.getReducedOstream();\n};\n\n/**\n * @deprecated Use encodeData(data).\n */\nBinaryXmlWireFormat.prototype.encodeContentObject = function(data)\n{\n  return this.encodeData(data);\n}\n\n/**\n * Decode the input and put the result in data.\n * @param {Data} data\n * @param {Buffer} input\n */\nBinaryXmlWireFormat.prototype.decodeData = function(data, input)\n{\n  var decoder = new BinaryXMLDecoder(input);\n  BinaryXmlWireFormat.decodeData(data, decoder);\n};\n\n/**\n * @deprecated Use decodeData(data, input).\n */\nBinaryXmlWireFormat.prototype.decodeContentObject = function(data, input)\n{\n  this.decodeData(data, input);\n}\n\n/**\n * Encode the interest by calling the operations on the encoder.\n * @param {Interest} interest\n * @param {BinaryXMLEncoder} encoder\n */\nBinaryXmlWireFormat.encodeInterest = function(interest, encoder)\n{\n  encoder.writeElementStartDTag(NDNProtocolDTags.Interest);\n\n  interest.name.to_ndnb(encoder);\n\n  if (null != interest.minSuffixComponents)\n    encoder.writeDTagElement(NDNProtocolDTags.MinSuffixComponents, interest.minSuffixComponents);\n\n  if (null != interest.maxSuffixComponents)\n    encoder.writeDTagElement(NDNProtocolDTags.MaxSuffixComponents, interest.maxSuffixComponents);\n\n  if (null != interest.publisherPublicKeyDigest)\n    interest.publisherPublicKeyDigest.to_ndnb(encoder);\n\n  if (null != interest.exclude)\n    interest.exclude.to_ndnb(encoder);\n\n  if (null != interest.childSelector)\n    encoder.writeDTagElement(NDNProtocolDTags.ChildSelector, interest.childSelector);\n\n  if (interest.DEFAULT_ANSWER_ORIGIN_KIND != interest.answerOriginKind && interest.answerOriginKind!=null)\n    encoder.writeDTagElement(NDNProtocolDTags.AnswerOriginKind, interest.answerOriginKind);\n\n  if (null != interest.scope)\n    encoder.writeDTagElement(NDNProtocolDTags.Scope, interest.scope);\n\n  if (null != interest.interestLifetime)\n    encoder.writeDTagElement(NDNProtocolDTags.InterestLifetime,\n                DataUtils.nonNegativeIntToBigEndian((interest.interestLifetime / 1000.0) * 4096));\n\n  if (null != interest.nonce)\n    encoder.writeDTagElement(NDNProtocolDTags.Nonce, interest.nonce);\n\n  encoder.writeElementClose();\n};\n\n\n/**\n * Use the decoder to place the result in interest.\n * @param {Interest} interest\n * @param {BinaryXMLDecoder} decoder\n */\nBinaryXmlWireFormat.decodeInterest = function(interest, decoder)\n{\n  decoder.readElementStartDTag(NDNProtocolDTags.Interest);\n\n  interest.name = new Name();\n  interest.name.from_ndnb(decoder);\n\n  if (decoder.peekDTag(NDNProtocolDTags.MinSuffixComponents))\n    interest.minSuffixComponents = decoder.readIntegerDTagElement(NDNProtocolDTags.MinSuffixComponents);\n  else\n    interest.minSuffixComponents = null;\n\n  if (decoder.peekDTag(NDNProtocolDTags.MaxSuffixComponents))\n    interest.maxSuffixComponents = decoder.readIntegerDTagElement(NDNProtocolDTags.MaxSuffixComponents);\n  else\n    interest.maxSuffixComponents = null;\n\n  if (decoder.peekDTag(NDNProtocolDTags.PublisherPublicKeyDigest)) {\n    interest.publisherPublicKeyDigest = new PublisherPublicKeyDigest();\n    interest.publisherPublicKeyDigest.from_ndnb(decoder);\n  }\n  else\n    interest.publisherPublicKeyDigest = null;\n\n  if (decoder.peekDTag(NDNProtocolDTags.Exclude)) {\n    interest.exclude = new Exclude();\n    interest.exclude.from_ndnb(decoder);\n  }\n  else\n    interest.exclude = null;\n\n  if (decoder.peekDTag(NDNProtocolDTags.ChildSelector))\n    interest.childSelector = decoder.readIntegerDTagElement(NDNProtocolDTags.ChildSelector);\n  else\n    interest.childSelector = null;\n\n  if (decoder.peekDTag(NDNProtocolDTags.AnswerOriginKind))\n    interest.answerOriginKind = decoder.readIntegerDTagElement(NDNProtocolDTags.AnswerOriginKind);\n  else\n    interest.answerOriginKind = null;\n\n  if (decoder.peekDTag(NDNProtocolDTags.Scope))\n    interest.scope = decoder.readIntegerDTagElement(NDNProtocolDTags.Scope);\n  else\n    interest.scope = null;\n\n  if (decoder.peekDTag(NDNProtocolDTags.InterestLifetime))\n    interest.interestLifetime = 1000.0 * DataUtils.bigEndianToUnsignedInt\n               (decoder.readBinaryDTagElement(NDNProtocolDTags.InterestLifetime)) / 4096;\n  else\n    interest.interestLifetime = null;\n\n  if (decoder.peekDTag(NDNProtocolDTags.Nonce))\n    interest.nonce = decoder.readBinaryDTagElement(NDNProtocolDTags.Nonce);\n  else\n    interest.nonce = null;\n\n  decoder.readElementClose();\n};\n\n/**\n * Encode the data by calling the operations on the encoder.\n * @param {Data} data\n * @param {BinaryXMLEncoder} encoder\n */\nBinaryXmlWireFormat.encodeData = function(data, encoder)\n{\n  //TODO verify name, SignedInfo and Signature is present\n  encoder.writeElementStartDTag(data.getElementLabel());\n\n  if (null != data.signature)\n    data.signature.to_ndnb(encoder);\n\n  data.startSIG = encoder.offset;\n\n  if (null != data.name)\n    data.name.to_ndnb(encoder);\n\n  if (null != data.signedInfo)\n    data.signedInfo.to_ndnb(encoder);\n\n  encoder.writeDTagElement(NDNProtocolDTags.Content, data.content);\n\n  data.endSIG = encoder.offset;\n\n  encoder.writeElementClose();\n\n  data.saveRawData(encoder.ostream);\n};\n\n/**\n * Use the decoder to place the result in data.\n * @param {Data} data\n * @param {BinaryXMLDecoder} decoder\n */\nBinaryXmlWireFormat.decodeData = function(data, decoder)\n{\n  // TODO VALIDATE THAT ALL FIELDS EXCEPT SIGNATURE ARE PRESENT\n  decoder.readElementStartDTag(data.getElementLabel());\n\n  if (decoder.peekDTag(NDNProtocolDTags.Signature)) {\n    data.signature = new Signature();\n    data.signature.from_ndnb(decoder);\n  }\n  else\n    data.signature = null;\n\n  data.startSIG = decoder.offset;\n\n  data.name = new Name();\n  data.name.from_ndnb(decoder);\n\n  if (decoder.peekDTag(NDNProtocolDTags.SignedInfo)) {\n    data.signedInfo = new SignedInfo();\n    data.signedInfo.from_ndnb(decoder);\n  }\n  else\n    data.signedInfo = null;\n\n  data.content = decoder.readBinaryDTagElement(NDNProtocolDTags.Content, true);\n\n  data.endSIG = decoder.offset;\n\n  decoder.readElementClose();\n\n  data.saveRawData(decoder.input);\n};\n/**\n * This file contains utilities to help encode and decode NDN objects.\n * Copyright (C) 2013 Regents of the University of California.\n * author: Meki Cheraoui\n * See COPYING for copyright and distribution information.\n */\n\n/**\n * An EncodingUtils has static methods for encoding data.\n * @constructor\n */\nvar EncodingUtils = function EncodingUtils()\n{\n};\n\nexports.EncodingUtils = EncodingUtils;\n\nEncodingUtils.encodeToHexInterest = function(interest)\n{\n  return DataUtils.toHex(interest.encode());\n};\n\nEncodingUtils.encodeToHexData = function(data)\n{\n  return DataUtils.toHex(data.encode());\n};\n\n/**\n * @deprecated Use EncodingUtils.encodeToHexData(data).\n */\nEncodingUtils.encodeToHexContentObject = function(data)\n{\n  return EncodingUtils.encodeToHexData(data);\n}\n\nEncodingUtils.encodeForwardingEntry = function(data)\n{\n  var enc = new BinaryXMLEncoder();\n  data.to_ndnb(enc);\n  var bytes = enc.getReducedOstream();\n\n  return bytes;\n};\n\nEncodingUtils.decodeHexFaceInstance = function(result)\n{\n  var numbers = DataUtils.toNumbers(result);\n  var decoder = new BinaryXMLDecoder(numbers);\n\n  if (LOG > 3) console.log(\'DECODING HEX FACE INSTANCE  \\n\'+numbers);\n\n  var faceInstance = new FaceInstance();\n  faceInstance.from_ndnb(decoder);\n\n  return faceInstance;\n};\n\nEncodingUtils.decodeHexInterest = function(input)\n{\n  var interest = new Interest();\n  interest.decode(DataUtils.toNumbers(input));\n  return interest;\n};\n\nEncodingUtils.decodeHexData = function(input)\n{\n  var data = new Data();\n  data.decode(DataUtils.toNumbers(input));\n  return data;\n};\n\n/**\n * @deprecated Use EncodingUtils.decodeHexData(input).\n */\nEncodingUtils.decodeHexContentObject = function(input)\n{\n  return EncodingUtils.decodeHexData(input);\n}\n\nEncodingUtils.decodeHexForwardingEntry = function(result)\n{\n  var numbers = DataUtils.toNumbers(result);\n  var decoder = new BinaryXMLDecoder(numbers);\n\n  if (LOG > 3) console.log(\'DECODED HEX FORWARDING ENTRY \\n\'+numbers);\n\n  var forwardingEntry = new ForwardingEntry();\n  forwardingEntry.from_ndnb(decoder);\n  return forwardingEntry;\n};\n\n/**\n * Decode the ndnbuf array which holds SubjectPublicKeyInfo and return an RSAKey.\n */\nEncodingUtils.decodeSubjectPublicKeyInfo = function(array)\n{\n  var hex = DataUtils.toHex(array).toLowerCase();\n  var a = _x509_getPublicKeyHexArrayFromCertHex(hex, _x509_getSubjectPublicKeyPosFromCertHex(hex, 0));\n  var rsaKey = new RSAKey();\n  rsaKey.setPublic(a[0], a[1]);\n  return rsaKey;\n}\n\n/**\n * Return a user friendly HTML string with the contents of data.\n * This also outputs to console.log.\n */\nEncodingUtils.dataToHtml = function(/* Data */ data)\n{\n  var output ="";\n\n  if (data == -1)\n    output+= "NO CONTENT FOUND"\n  else if (data == -2)\n    output+= "CONTENT NAME IS EMPTY"\n  else {\n    if (data.name != null && data.name.components != null) {\n      output+= "NAME: " + data.name.toUri();\n\n      output+= "<br />";\n      output+= "<br />";\n    }\n    if (data.content != null) {\n      output += "CONTENT(ASCII): "+ DataUtils.toString(data.content);\n\n      output+= "<br />";\n      output+= "<br />";\n    }\n    if (data.content != null) {\n      output += "CONTENT(hex): "+ DataUtils.toHex(data.content);\n\n      output+= "<br />";\n      output+= "<br />";\n    }\n    if (data.signature != null && data.signature.digestAlgorithm != null) {\n      output += "DigestAlgorithm (hex): "+ DataUtils.toHex(data.signature.digestAlgorithm);\n\n      output+= "<br />";\n      output+= "<br />";\n    }\n    if (data.signature != null && data.signature.witness != null) {\n      output += "Witness (hex): "+ DataUtils.toHex(data.signature.witness);\n\n      output+= "<br />";\n      output+= "<br />";\n    }\n    if (data.signature != null && data.signature.signature != null) {\n      output += "Signature(hex): "+ DataUtils.toHex(data.signature.signature);\n\n      output+= "<br />";\n      output+= "<br />";\n    }\n    if (data.signedInfo != null && data.signedInfo.publisher != null && data.signedInfo.publisher.publisherPublicKeyDigest != null) {\n      output += "Publisher Public Key Digest(hex): "+ DataUtils.toHex(data.signedInfo.publisher.publisherPublicKeyDigest);\n\n      output+= "<br />";\n      output+= "<br />";\n    }\n    if (data.signedInfo != null && data.signedInfo.timestamp != null) {\n      var d = new Date();\n      d.setTime(data.signedInfo.timestamp.msec);\n\n      var bytes = [217, 185, 12, 225, 217, 185, 12, 225];\n\n      output += "TimeStamp: "+d;\n      output+= "<br />";\n      output += "TimeStamp(number): "+ data.signedInfo.timestamp.msec;\n\n      output+= "<br />";\n    }\n    if (data.signedInfo != null && data.signedInfo.finalBlockID != null) {\n      output += "FinalBlockID: "+ DataUtils.toHex(data.signedInfo.finalBlockID);\n      output+= "<br />";\n    }\n    if (data.signedInfo != null && data.signedInfo.locator != null && data.signedInfo.locator.type) {\n      output += "keyLocator: ";\n      if (data.signedInfo.locator.type == KeyLocatorType.KEY)\n        output += "Key: " + DataUtils.toHex(data.signedInfo.locator.publicKey).toLowerCase() + "<br />";\n      else if (data.signedInfo.locator.type == KeyLocatorType.CERTIFICATE)\n        output += "Certificate: " + DataUtils.toHex(data.signedInfo.locator.certificate).toLowerCase() + "<br />";\n      else if (data.signedInfo.locator.type == KeyLocatorType.KEYNAME)\n        output += "KeyName: " + data.signedInfo.locator.keyName.contentName.to_uri() + "<br />";\n      else\n        output += "[unrecognized ndn_KeyLocatorType " + data.signedInfo.locator.type + "]<br />";\n    }\n    if (data.signedInfo!= null && data.signedInfo.locator!= null && data.signedInfo.locator.publicKey!= null) {\n      var publickeyHex = DataUtils.toHex(data.signedInfo.locator.publicKey).toLowerCase();\n      var publickeyString = DataUtils.toString(data.signedInfo.locator.publicKey);\n      var signature = DataUtils.toHex(data.signature.signature).toLowerCase();\n      var input = DataUtils.toString(data.rawSignatureData);\n\n      var witHex = "";\n      if (data.signature.witness != null)\n        witHex = DataUtils.toHex(data.signature.witness);\n\n      // Already showed data.signedInfo.locator.publicKey above.\n      output+= "<br />";\n\n      if (LOG > 2) console.log(" ContentName + SignedInfo + Content = "+input);\n      if (LOG > 2) console.log(" PublicKeyHex = "+publickeyHex);\n      if (LOG > 2) console.log(" PublicKeyString = "+publickeyString);\n\n      if (LOG > 2) console.log(" Signature "+signature);\n      if (LOG > 2) console.log(" Witness "+witHex);\n\n      if (LOG > 2) console.log(" Signature NOW IS");\n\n      if (LOG > 2) console.log(data.signature.signature);\n\n      var rsakey = new Key();\n      rsakey.readDerPublicKey(data.signedInfo.locator.publicKey);\n\n      var result = data.verify(rsakey);\n      if (result)\n      output += \'SIGNATURE VALID\';\n      else\n      output += \'SIGNATURE INVALID\';\n\n      output+= "<br />";\n      output+= "<br />";\n    }\n  }\n\n  return output;\n};\n\n/**\n * @deprecated Use return EncodingUtils.dataToHtml(data).\n */\nEncodingUtils.contentObjectToHtml = function(data)\n{\n  return EncodingUtils.dataToHtml(data);\n}\n\n//\n// Deprecated: For the browser, define these in the global scope.  Applications should access as member of EncodingUtils.\n//\n\nvar encodeToHexInterest = function(interest) { return EncodingUtils.encodeToHexInterest(interest); }\nvar encodeToHexContentObject = function(data) { return EncodingUtils.encodeToHexData(data); }\nvar encodeForwardingEntry = function(data) { return EncodingUtils.encodeForwardingEntry(data); }\nvar decodeHexFaceInstance = function(input) { return EncodingUtils.decodeHexFaceInstance(input); }\nvar decodeHexInterest = function(input) { return EncodingUtils.decodeHexInterest(input); }\nvar decodeHexContentObject = function(input) { return EncodingUtils.decodeHexData(input); }\nvar decodeHexForwardingEntry = function(input) { return EncodingUtils.decodeHexForwardingEntry(input); }\nvar decodeSubjectPublicKeyInfo = function(input) { return EncodingUtils.decodeSubjectPublicKeyInfo(input); }\nvar contentObjectToHtml = function(data) { return EncodingUtils.dataToHtml(data); }\n\n/**\n * @deprecated Use interest.encode().\n */\nfunction encodeToBinaryInterest(interest) { return interest.encode(); }\n/**\n * @deprecated Use data.encode().\n */\nfunction encodeToBinaryContentObject(data) { return data.encode(); }\n/**\n * Copyright (C) 2013 Regents of the University of California.\n * @author: Meki Cherkaoui, Jeff Thompson <jefft0@remap.ucla.edu>, Wentao Shang\n * See COPYING for copyright and distribution information.\n * This class represents the top-level object for communicating with an NDN host.\n */\n\n/**\n * Create a new Face with the given settings.\n * This throws an exception if Face.supported is false.\n * @constructor\n * @param {Object} settings if not null, an associative array with the following defaults:\n * {\n *   getTransport: function() { return new WebSocketTransport(); }, // If in the browser.\n *              OR function() { return new TcpTransport(); },       // If in Node.js.\n *   getHostAndPort: transport.defaultGetHostAndPort, // a function, on each call it returns a new { host: host, port: port } or null if there are no more hosts.\n *   host: null, // If null, use getHostAndPort when connecting.\n *   port: 9696, // If in the browser.\n *      OR 6363, // If in Node.js.\n *   onopen: function() { if (LOG > 3) console.log("NDN connection established."); },\n *   onclose: function() { if (LOG > 3) console.log("NDN connection closed."); },\n *   verify: false // If false, don\'t verify and call upcall with Closure.UPCALL_CONTENT_UNVERIFIED.\n * }\n */\nvar Face = function Face(settings)\n{\n  if (!Face.supported)\n    throw new Error("The necessary JavaScript support is not available on this platform.");\n\n  settings = (settings || {});\n  // For the browser, browserify-tcp-transport.js replaces TcpTransport with WebSocketTransport.\n  var getTransport = (settings.getTransport || function() { return new TcpTransport(); });\n  this.transport = getTransport();\n  this.getHostAndPort = (settings.getHostAndPort || this.transport.defaultGetHostAndPort);\n  this.host = (settings.host !== undefined ? settings.host : null);\n  this.port = (settings.port || (typeof WebSocketTransport != \'undefined\' ? 9696 : 6363));\n  this.readyStatus = Face.UNOPEN;\n  this.verify = (settings.verify !== undefined ? settings.verify : false);\n  // Event handler\n  this.onopen = (settings.onopen || function() { if (LOG > 3) console.log("Face connection established."); });\n  this.onclose = (settings.onclose || function() { if (LOG > 3) console.log("Face connection closed."); });\n  this.ndndid = null;\n};\n\nexports.Face = Face;\n\nFace.UNOPEN = 0;  // created but not opened yet\nFace.OPENED = 1;  // connection to ndnd opened\nFace.CLOSED = 2;  // connection to ndnd closed\n\n/**\n * Return true if necessary JavaScript support is available, else log an error and return false.\n */\nFace.getSupported = function()\n{\n  try {\n    var dummy = new ndnbuf(1).slice(0, 1);\n  }\n  catch (ex) {\n    console.log("NDN not available: ndnbuf not supported. " + ex);\n    return false;\n  }\n\n  return true;\n};\n\nFace.supported = Face.getSupported();\n\nFace.ndndIdFetcher = new Name(\'/%C1.M.S.localhost/%C1.M.SRV/ndnd/KEY\');\n\nFace.prototype.createRoute = function(host, port)\n{\n  this.host=host;\n  this.port=port;\n};\n\nFace.KeyStore = new Array();\n\nvar KeyStoreEntry = function KeyStoreEntry(name, rsa, time)\n{\n  this.keyName = name;  // KeyName\n  this.rsaKey = rsa;    // RSA key\n  this.timeStamp = time;  // Time Stamp\n};\n\nFace.addKeyEntry = function(/* KeyStoreEntry */ keyEntry)\n{\n  var result = Face.getKeyByName(keyEntry.keyName);\n  if (result == null)\n    Face.KeyStore.push(keyEntry);\n  else\n    result = keyEntry;\n};\n\nFace.getKeyByName = function(/* KeyName */ name)\n{\n  var result = null;\n\n  for (var i = 0; i < Face.KeyStore.length; i++) {\n    if (Face.KeyStore[i].keyName.contentName.match(name.contentName)) {\n      if (result == null || Face.KeyStore[i].keyName.contentName.components.length > result.keyName.contentName.components.length)\n        result = Face.KeyStore[i];\n    }\n  }\n\n  return result;\n};\n\nFace.prototype.close = function()\n{\n  if (this.readyStatus != Face.OPENED)\n    throw new Error(\'Cannot close because Face connection is not opened.\');\n\n  this.readyStatus = Face.CLOSED;\n  this.transport.close();\n};\n\n// For fetching data\nFace.PITTable = new Array();\n\n/**\n * @constructor\n */\nvar PITEntry = function PITEntry(interest, closure)\n{\n  this.interest = interest;  // Interest\n  this.closure = closure;    // Closure\n  this.timerID = -1;  // Timer ID\n};\n\n/**\n * Return the entry from Face.PITTable where the name conforms to the interest selectors, and\n * the interest name is the longest that matches name.\n */\nFace.getEntryForExpressedInterest = function(/*Name*/ name)\n{\n  var result = null;\n\n  for (var i = 0; i < Face.PITTable.length; i++) {\n    if (Face.PITTable[i].interest.matchesName(name)) {\n      if (result == null || Face.PITTable[i].interest.name.components.length > result.interest.name.components.length)\n        result = Face.PITTable[i];\n    }\n  }\n\n  return result;\n};\n\n// For publishing data\nFace.registeredPrefixTable = new Array();\n\n/**\n * @constructor\n */\nvar RegisteredPrefix = function RegisteredPrefix(prefix, closure)\n{\n  this.prefix = prefix;        // String\n  this.closure = closure;  // Closure\n};\n\n/**\n * Find the first entry from Face.registeredPrefixTable where the entry prefix is the longest that matches name.\n * @param {Name} name The name to find the PrefixEntry for (from the incoming interest packet).\n * @returns {object} The entry from Face.registeredPrefixTable, or 0 if not found.\n */\nfunction getEntryForRegisteredPrefix(name)\n{\n  var iResult = -1;\n\n  for (var i = 0; i < Face.registeredPrefixTable.length; i++) {\n    if (LOG > 3) console.log("Registered prefix " + i + ": checking if " + Face.registeredPrefixTable[i].prefix + " matches " + name);\n    if (Face.registeredPrefixTable[i].prefix.match(name)) {\n      if (iResult < 0 ||\n          Face.registeredPrefixTable[i].prefix.size() > Face.registeredPrefixTable[iResult].prefix.size())\n        // Update to the longer match.\n        iResult = i;\n    }\n  }\n\n  if (iResult >= 0)\n    return Face.registeredPrefixTable[iResult];\n  else\n    return null;\n}\n\n/**\n * Return a function that selects a host at random from hostList and returns { host: host, port: port }.\n * If no more hosts remain, return null.\n */\nFace.makeShuffledGetHostAndPort = function(hostList, port)\n{\n  // Make a copy.\n  hostList = hostList.slice(0, hostList.length);\n  DataUtils.shuffle(hostList);\n\n  return function() {\n    if (hostList.length == 0)\n      return null;\n\n    return { host: hostList.splice(0, 1)[0], port: port };\n  };\n};\n\n/**\n * Send the interest through the transport, read the entire response and call onData.\n * If the interest times out according to interest lifetime, call onTimeout (if not omitted).\n * There are two forms of expressInterest.  The first form takes the exact interest (including lifetime):\n * expressInterest(interest, onData [, onTimeout]).  The second form creates the interest from\n * a name and optional interest template:\n * expressInterest(name [, template], onData [, onTimeout]).\n * This also supports the deprecated form expressInterest(name, closure [, template]), but you should use the other forms.\n * @param {Interest} interest The Interest to send which includes the interest lifetime for the timeout.\n * @param {function} onData When a matching data packet is received, this calls onData(interest, data) where:\n *   interest is the interest given to expressInterest,\n *   data is the received Data object.\n * @param {function} onTimeout (optional) If the interest times out according to the interest lifetime,\n *   this calls onTimeout(interest) where:\n *   interest is the interest given to expressInterest.\n * @param {Name} name The Name for the interest. (only used for the second form of expressInterest).\n * @param {Interest} template (optional) If not omitted, copy the interest selectors from this Interest.\n * If omitted, use a default interest lifetime. (only used for the second form of expressInterest).\n */\nFace.prototype.expressInterest = function(interestOrName, arg2, arg3, arg4)\n{\n  // There are several overloaded versions of expressInterest, each shown inline below.\n\n  // expressInterest(Name name, Closure closure);                      // deprecated\n  // expressInterest(Name name, Closure closure,   Interest template); // deprecated\n  if (arg2 && arg2.upcall && typeof arg2.upcall == \'function\') {\n    // Assume arg2 is the deprecated use with Closure.\n    if (arg3)\n      this.expressInterestWithClosure(interestOrName, arg2, arg3);\n    else\n      this.expressInterestWithClosure(interestOrName, arg2);\n    return;\n  }\n\n  var interest;\n  var onData;\n  var onTimeout;\n  // expressInterest(Interest interest, function onData);\n  // expressInterest(Interest interest, function onData, function onTimeout);\n  if (typeof interestOrName == \'object\' && interestOrName instanceof Interest) {\n    // Just use a copy of the interest.\n    interest = new Interest(interestOrName);\n    onData = arg2;\n    onTimeout = (arg3 ? arg3 : function() {});\n  }\n  else {\n    // The first argument is a name. Make the interest from the name and possible template.\n    interest = new Interest(interestOrName);\n    // expressInterest(Name name, Interest template, function onData);\n    // expressInterest(Name name, Interest template, function onData, function onTimeout);\n    if (arg2 && typeof arg2 == \'object\' && arg2 instanceof Interest) {\n      var template = arg2;\n      interest.minSuffixComponents = template.minSuffixComponents;\n      interest.maxSuffixComponents = template.maxSuffixComponents;\n      interest.publisherPublicKeyDigest = template.publisherPublicKeyDigest;\n      interest.exclude = template.exclude;\n      interest.childSelector = template.childSelector;\n      interest.answerOriginKind = template.answerOriginKind;\n      interest.scope = template.scope;\n      interest.interestLifetime = template.interestLifetime;\n\n      onData = arg3;\n      onTimeout = (arg4 ? arg4 : function() {});\n    }\n    // expressInterest(Name name, function onData);\n    // expressInterest(Name name, function onData,   function onTimeout);\n    else {\n      interest.interestLifetime = 4000;   // default interest timeout value in milliseconds.\n      onData = arg2;\n      onTimeout = (arg3 ? arg3 : function() {});\n    }\n  }\n\n  // Make a Closure from the callbacks so we can use expressInterestWithClosure.\n  // TODO: Convert the PIT to use callbacks, not a closure.\n  this.expressInterestWithClosure(interest, new Face.CallbackClosure(onData, onTimeout), interest);\n}\n\nFace.CallbackClosure = function FaceCallbackClosure(onData, onTimeout, onInterest, prefix, transport) {\n  // Inherit from Closure.\n  Closure.call(this);\n\n  this.onData = onData;\n  this.onTimeout = onTimeout;\n  this.onInterest = onInterest;\n  this.prefix = prefix;\n  this.transport = transport;\n};\n\nFace.CallbackClosure.prototype.upcall = function(kind, upcallInfo) {\n  if (kind == Closure.UPCALL_CONTENT || kind == Closure.UPCALL_CONTENT_UNVERIFIED)\n    this.onData(upcallInfo.interest, upcallInfo.data);\n  else if (kind == Closure.UPCALL_INTEREST_TIMED_OUT)\n    this.onTimeout(upcallInfo.interest);\n  else if (kind == Closure.UPCALL_INTEREST)\n    // Note: We never return INTEREST_CONSUMED because onInterest will send the result to the transport.\n    this.onInterest(this.prefix, upcallInfo.interest, this.transport)\n\n  return Closure.RESULT_OK;\n};\n\n/**\n * A private method to encode name as an Interest and send the it to host:port, read the entire response and call\n * closure.upcall(Closure.UPCALL_CONTENT (or Closure.UPCALL_CONTENT_UNVERIFIED),\n *                 new UpcallInfo(this, interest, 0, data)).\n * @deprecated Use expressInterest with callback functions, not Closure.\n * @param {Name} name Encode name as an Interest using the template (if supplied).\n * @param {Closure} closure\n * @param {Interest} template If not null, use its attributes.\n */\nFace.prototype.expressInterestWithClosure = function(name, closure, template)\n{\n  var interest = new Interest(name);\n  if (template != null) {\n    interest.minSuffixComponents = template.minSuffixComponents;\n    interest.maxSuffixComponents = template.maxSuffixComponents;\n    interest.publisherPublicKeyDigest = template.publisherPublicKeyDigest;\n    interest.exclude = template.exclude;\n    interest.childSelector = template.childSelector;\n    interest.answerOriginKind = template.answerOriginKind;\n    interest.scope = template.scope;\n    interest.interestLifetime = template.interestLifetime;\n  }\n  else\n    interest.interestLifetime = 4000;   // default interest timeout value in milliseconds.\n\n  if (this.host == null || this.port == null) {\n    if (this.getHostAndPort == null)\n      console.log(\'ERROR: host OR port NOT SET\');\n    else {\n      var thisNDN = this;\n      this.connectAndExecute(function() { thisNDN.reconnectAndExpressInterest(interest, closure); });\n    }\n  }\n  else\n    this.reconnectAndExpressInterest(interest, closure);\n};\n\n/**\n * If the host and port are different than the ones in this.transport, then call\n *   this.transport.connect to change the connection (or connect for the first time).\n * Then call expressInterestHelper.\n */\nFace.prototype.reconnectAndExpressInterest = function(interest, closure)\n{\n  if (this.transport.connectedHost != this.host || this.transport.connectedPort != this.port) {\n    var thisNDN = this;\n    this.transport.connect(thisNDN, function() { thisNDN.expressInterestHelper(interest, closure); });\n    this.readyStatus = Face.OPENED;\n  }\n  else\n    this.expressInterestHelper(interest, closure);\n};\n\n/**\n * Do the work of reconnectAndExpressInterest once we know we are connected.  Set the PITTable and call\n *   this.transport.send to send the interest.\n */\nFace.prototype.expressInterestHelper = function(interest, closure)\n{\n  var binaryInterest = interest.encode();\n  var thisNDN = this;\n  //TODO: check local content store first\n  if (closure != null) {\n    var pitEntry = new PITEntry(interest, closure);\n    // TODO: This needs to be a single thread-safe transaction on a global object.\n    Face.PITTable.push(pitEntry);\n    closure.pitEntry = pitEntry;\n\n    // Set interest timer.\n    var timeoutMilliseconds = (interest.interestLifetime || 4000);\n    var timeoutCallback = function() {\n      if (LOG > 1) console.log("Interest time out: " + interest.name.toUri());\n\n      // Remove PIT entry from Face.PITTable, even if we add it again later to re-express\n      //   the interest because we don\'t want to match it in the mean time.\n      // TODO: Make this a thread-safe operation on the global PITTable.\n      var index = Face.PITTable.indexOf(pitEntry);\n      if (index >= 0)\n        Face.PITTable.splice(index, 1);\n\n      // Raise closure callback\n      if (closure.upcall(Closure.UPCALL_INTEREST_TIMED_OUT, new UpcallInfo(thisNDN, interest, 0, null)) == Closure.RESULT_REEXPRESS) {\n        if (LOG > 1) console.log("Re-express interest: " + interest.name.toUri());\n        pitEntry.timerID = setTimeout(timeoutCallback, timeoutMilliseconds);\n        Face.PITTable.push(pitEntry);\n        thisNDN.transport.send(binaryInterest);\n      }\n    };\n\n    pitEntry.timerID = setTimeout(timeoutCallback, timeoutMilliseconds);\n  }\n\n  this.transport.send(binaryInterest);\n};\n\n/**\n * Register prefix with the connected NDN hub and call onInterest when a matching interest is received.\n * This uses the form:\n * registerPrefix(name, onInterest, onRegisterFailed [, flags]).\n * This also supports the deprecated form registerPrefix(name, closure [, intFlags]), but you should use the main form.\n * @param {Name} prefix The Name prefix.\n * @param {function} onInterest When an interest is received which matches the name prefix, this calls\n * onInterest(prefix, interest, transport) where:\n *   prefix is the prefix given to registerPrefix.\n *   interest is the received interest.\n *   transport The Transport with the connection which received the interest. You must encode a signed Data packet and send it using transport.send().\n * @param {function} onRegisterFailed If failed to retrieve the connected hub\'s ID or failed to register the prefix,\n * this calls onRegisterFailed(prefix) where:\n *   prefix is the prefix given to registerPrefix.\n * @param {ForwardingFlags} flags (optional) The flags for finer control of which interests are forward to the application.\n * If omitted, use the default flags defined by the default ForwardingFlags constructor.\n */\nFace.prototype.registerPrefix = function(prefix, arg2, arg3, arg4)\n{\n  // There are several overloaded versions of registerPrefix, each shown inline below.\n\n  // registerPrefix(Name prefix, Closure closure);            // deprecated\n  // registerPrefix(Name prefix, Closure closure, int flags); // deprecated\n  if (arg2 && arg2.upcall && typeof arg2.upcall == \'function\') {\n    // Assume arg2 is the deprecated use with Closure.\n    if (arg3)\n      this.registerPrefixWithClosure(prefix, arg2, arg3);\n    else\n      this.registerPrefixWithClosure(prefix, arg2);\n    return;\n  }\n\n  // registerPrefix(Name prefix, function onInterest, function onRegisterFailed);\n  // registerPrefix(Name prefix, function onInterest, function onRegisterFailed, ForwardingFlags flags);\n  var onInterest = arg2;\n  var onRegisterFailed = (arg3 ? arg3 : function() {});\n  var intFlags = (arg4 ? arg4.getForwardingEntryFlags() : new ForwardingFlags().getForwardingEntryFlags());\n  this.registerPrefixWithClosure(prefix, new Face.CallbackClosure(null, null, onInterest, prefix, this.transport),\n                                 intFlags, onRegisterFailed);\n}\n\n/**\n * A private method to register the prefix with the host, receive the data and call\n * closure.upcall(Closure.UPCALL_INTEREST, new UpcallInfo(this, interest, 0, null)).\n * @deprecated Use registerPrefix with callback functions, not Closure.\n * @param {Name} prefix\n * @param {Closure} closure\n * @param {number} intFlags\n * @param {function} (optional) If called from the non-deprecated registerPrefix, call onRegisterFailed(prefix)\n * if registration fails.\n */\nFace.prototype.registerPrefixWithClosure = function(prefix, closure, intFlags, onRegisterFailed)\n{\n  intFlags = intFlags | 3;\n  var thisNDN = this;\n  var onConnected = function() {\n    if (thisNDN.ndndid == null) {\n      // Fetch ndndid first, then register.\n      var interest = new Interest(Face.ndndIdFetcher);\n      interest.interestLifetime = 4000; // milliseconds\n      if (LOG > 3) console.log(\'Expressing interest for ndndid from ndnd.\');\n      thisNDN.reconnectAndExpressInterest\n        (interest, new Face.FetchNdndidClosure(thisNDN, prefix, closure, intFlags, onRegisterFailed));\n    }\n    else\n      thisNDN.registerPrefixHelper(prefix, closure, intFlags);\n  };\n\n  if (this.host == null || this.port == null) {\n    if (this.getHostAndPort == null)\n      console.log(\'ERROR: host OR port NOT SET\');\n    else\n      this.connectAndExecute(onConnected);\n  }\n  else\n    onConnected();\n};\n\n/**\n * This is a closure to receive the Data for Face.ndndIdFetcher and call\n *   registerPrefixHelper(prefix, callerClosure, flags).\n */\nFace.FetchNdndidClosure = function FetchNdndidClosure(face, prefix, callerClosure, flags, onRegisterFailed)\n{\n  // Inherit from Closure.\n  Closure.call(this);\n\n  this.face = face;\n  this.prefix = prefix;\n  this.callerClosure = callerClosure;\n  this.flags = flags;\n  this.onRegisterFailed = onRegisterFailed;\n};\n\nFace.FetchNdndidClosure.prototype.upcall = function(kind, upcallInfo)\n{\n  if (kind == Closure.UPCALL_INTEREST_TIMED_OUT) {\n    console.log("Timeout while requesting the ndndid.  Cannot registerPrefix for " + this.prefix.toUri() + " .");\n    if (this.onRegisterFailed)\n      this.onRegisterFailed(this.prefix);\n    return Closure.RESULT_OK;\n  }\n  if (!(kind == Closure.UPCALL_CONTENT ||\n        kind == Closure.UPCALL_CONTENT_UNVERIFIED))\n    // The upcall is not for us.  Don\'t expect this to happen.\n    return Closure.RESULT_ERR;\n\n  var data = upcallInfo.data;\n  if (!data.signedInfo || !data.signedInfo.publisher || !data.signedInfo.publisher.publisherPublicKeyDigest) {\n    console.log\n      ("Data doesn\'t have a publisherPublicKeyDigest. Cannot set ndndid and registerPrefix for "\n       + this.prefix.toUri() + " .");\n    if (this.onRegisterFailed)\n      this.onRegisterFailed(this.prefix);\n  }\n  else {\n    if (LOG > 3) console.log(\'Got ndndid from ndnd.\');\n    this.face.ndndid = data.signedInfo.publisher.publisherPublicKeyDigest;\n    if (LOG > 3) console.log(this.face.ndndid);\n    this.face.registerPrefixHelper(this.prefix, this.callerClosure, this.flags);\n  }\n\n  return Closure.RESULT_OK;\n};\n\n/**\n * Do the work of registerPrefix once we know we are connected with a ndndid.\n */\nFace.prototype.registerPrefixHelper = function(prefix, closure, flags)\n{\n  var fe = new ForwardingEntry(\'selfreg\', prefix, null, null, flags, 2147483647);\n\n  var encoder = new BinaryXMLEncoder();\n  fe.to_ndnb(encoder);\n  var bytes = encoder.getReducedOstream();\n\n  var si = new SignedInfo();\n  si.setFields();\n\n  var data = new Data(new Name(), si, bytes);\n  data.sign();\n  var coBinary = data.encode();;\n\n  var nodename = this.ndndid;\n  var interestName = new Name([\'ndnx\', nodename, \'selfreg\', coBinary]);\n\n  var interest = new Interest(interestName);\n  interest.scope = 1;\n  if (LOG > 3) console.log(\'Send Interest registration packet.\');\n\n  Face.registeredPrefixTable.push(new RegisteredPrefix(prefix, closure));\n\n  this.transport.send(interest.encode());\n};\n\n/**\n * This is called when an entire binary XML element is received, such as a Data or Interest.\n * Look up in the PITTable and call the closure callback.\n */\nFace.prototype.onReceivedElement = function(element)\n{\n  if (LOG > 3) console.log(\'Complete element received. Length \' + element.length + \'. Start decoding.\');\n  var decoder = new BinaryXMLDecoder(element);\n  // Dispatch according to packet type\n  if (decoder.peekDTag(NDNProtocolDTags.Interest)) {  // Interest packet\n    if (LOG > 3) console.log(\'Interest packet received.\');\n\n    var interest = new Interest();\n    interest.from_ndnb(decoder);\n    if (LOG > 3) console.log(interest);\n    if (LOG > 3) console.log(interest.name.toUri());\n\n    var entry = getEntryForRegisteredPrefix(interest.name);\n    if (entry != null) {\n      if (LOG > 3) console.log("Found registered prefix for " + interest.name.toUri());\n      var info = new UpcallInfo(this, interest, 0, null);\n      var ret = entry.closure.upcall(Closure.UPCALL_INTEREST, info);\n      if (ret == Closure.RESULT_INTEREST_CONSUMED && info.data != null)\n        this.transport.send(info.data.encode());\n    }\n  }\n  else if (decoder.peekDTag(NDNProtocolDTags.Data)) {  // Content packet\n    if (LOG > 3) console.log(\'Data packet received.\');\n\n    var data = new Data();\n    data.from_ndnb(decoder);\n\n    var pitEntry = Face.getEntryForExpressedInterest(data.name);\n    if (pitEntry != null) {\n      // Cancel interest timer\n      clearTimeout(pitEntry.timerID);\n\n      // Remove PIT entry from Face.PITTable\n      var index = Face.PITTable.indexOf(pitEntry);\n      if (index >= 0)\n        Face.PITTable.splice(index, 1);\n\n      var currentClosure = pitEntry.closure;\n\n      if (this.verify == false) {\n        // Pass content up without verifying the signature\n        currentClosure.upcall(Closure.UPCALL_CONTENT_UNVERIFIED, new UpcallInfo(this, pitEntry.interest, 0, data));\n        return;\n      }\n\n      // Key verification\n\n      // Recursive key fetching & verification closure\n      var KeyFetchClosure = function KeyFetchClosure(content, closure, key, sig, wit) {\n        this.data = content;  // unverified data packet object\n        this.closure = closure;  // closure corresponding to the data\n        this.keyName = key;  // name of current key to be fetched\n\n        Closure.call(this);\n      };\n\n      var thisNDN = this;\n      KeyFetchClosure.prototype.upcall = function(kind, upcallInfo) {\n        if (kind == Closure.UPCALL_INTEREST_TIMED_OUT) {\n          console.log("In KeyFetchClosure.upcall: interest time out.");\n          console.log(this.keyName.contentName.toUri());\n        }\n        else if (kind == Closure.UPCALL_CONTENT) {\n          var rsakey = new Key();\n          rsakey.readDerPublicKey(upcallInfo.data.content);\n          var verified = data.verify(rsakey);\n\n          var flag = (verified == true) ? Closure.UPCALL_CONTENT : Closure.UPCALL_CONTENT_BAD;\n          this.closure.upcall(flag, new UpcallInfo(thisNDN, null, 0, this.data));\n\n          // Store key in cache\n          var keyEntry = new KeyStoreEntry(keylocator.keyName, rsakey, new Date().getTime());\n          Face.addKeyEntry(keyEntry);\n        }\n        else if (kind == Closure.UPCALL_CONTENT_BAD)\n          console.log("In KeyFetchClosure.upcall: signature verification failed");\n      };\n\n      if (data.signedInfo && data.signedInfo.locator && data.signature) {\n        if (LOG > 3) console.log("Key verification...");\n        var sigHex = DataUtils.toHex(data.signature.signature).toLowerCase();\n\n        var wit = null;\n        if (data.signature.witness != null)\n            //SWT: deprecate support for Witness decoding and Merkle hash tree verification\n            currentClosure.upcall(Closure.UPCALL_CONTENT_BAD, new UpcallInfo(this, pitEntry.interest, 0, data));\n\n        var keylocator = data.signedInfo.locator;\n        if (keylocator.type == KeyLocatorType.KEYNAME) {\n          if (LOG > 3) console.log("KeyLocator contains KEYNAME");\n\n          if (keylocator.keyName.contentName.match(data.name)) {\n            if (LOG > 3) console.log("Content is key itself");\n\n            var rsakey = new Key();\n            rsakey.readDerPublicKey(data.content);\n            var verified = data.verify(rsakey);\n            var flag = (verified == true) ? Closure.UPCALL_CONTENT : Closure.UPCALL_CONTENT_BAD;\n\n            currentClosure.upcall(flag, new UpcallInfo(this, pitEntry.interest, 0, data));\n\n            // SWT: We don\'t need to store key here since the same key will be stored again in the closure.\n          }\n          else {\n            // Check local key store\n            var keyEntry = Face.getKeyByName(keylocator.keyName);\n            if (keyEntry) {\n              // Key found, verify now\n              if (LOG > 3) console.log("Local key cache hit");\n              var rsakey = keyEntry.rsaKey;\n              var verified = data.verify(rsakey);\n              var flag = (verified == true) ? Closure.UPCALL_CONTENT : Closure.UPCALL_CONTENT_BAD;\n\n              // Raise callback\n              currentClosure.upcall(flag, new UpcallInfo(this, pitEntry.interest, 0, data));\n            }\n            else {\n              // Not found, fetch now\n              if (LOG > 3) console.log("Fetch key according to keylocator");\n              var nextClosure = new KeyFetchClosure(data, currentClosure, keylocator.keyName, sigHex, wit);\n              // TODO: Use expressInterest with callbacks, not Closure.\n              this.expressInterest(keylocator.keyName.contentName.getPrefix(4), nextClosure);\n            }\n          }\n        }\n        else if (keylocator.type == KeyLocatorType.KEY) {\n          if (LOG > 3) console.log("Keylocator contains KEY");\n\n          var rsakey = new Key();\n          rsakey.readDerPublicKey(keylocator.publicKey);\n          var verified = data.verify(rsakey);\n\n          var flag = (verified == true) ? Closure.UPCALL_CONTENT : Closure.UPCALL_CONTENT_BAD;\n          // Raise callback\n          currentClosure.upcall(Closure.UPCALL_CONTENT, new UpcallInfo(this, pitEntry.interest, 0, data));\n\n          // Since KeyLocator does not contain key name for this key,\n          // we have no way to store it as a key entry in KeyStore.\n        }\n        else {\n          var cert = keylocator.certificate;\n          console.log("KeyLocator contains CERT");\n          console.log(cert);\n          // TODO: verify certificate\n        }\n      }\n    }\n  }\n  else\n    console.log(\'Incoming packet is not Interest or Data. Discard now.\');\n};\n\n/**\n * Assume this.getHostAndPort is not null.  This is called when this.host is null or its host\n *   is not alive.  Get a host and port, connect, then execute onConnected().\n */\nFace.prototype.connectAndExecute = function(onConnected)\n{\n  var hostAndPort = this.getHostAndPort();\n  if (hostAndPort == null) {\n    console.log(\'ERROR: No more hosts from getHostAndPort\');\n    this.host = null;\n    return;\n  }\n\n  if (hostAndPort.host == this.host && hostAndPort.port == this.port) {\n    console.log(\'ERROR: The host returned by getHostAndPort is not alive: \' + this.host + ":" + this.port);\n    return;\n  }\n\n  this.host = hostAndPort.host;\n  this.port = hostAndPort.port;\n  if (LOG>0) console.log("connectAndExecute: trying host from getHostAndPort: " + this.host);\n\n  // Fetch any content.\n  var interest = new Interest(new Name("/"));\n  interest.interestLifetime = 4000; // milliseconds\n\n  var thisNDN = this;\n  var timerID = setTimeout(function() {\n    if (LOG>0) console.log("connectAndExecute: timeout waiting for host " + thisNDN.host);\n      // Try again.\n      thisNDN.connectAndExecute(onConnected);\n  }, 3000);\n\n  this.reconnectAndExpressInterest(interest, new Face.ConnectClosure(this, onConnected, timerID));\n};\n\n/**\n * This is called by the Transport when the connection is closed by the remote host.\n */\nFace.prototype.closeByTransport = function()\n{\n  this.readyStatus = Face.CLOSED;\n  this.onclose();\n};\n\nFace.ConnectClosure = function ConnectClosure(face, onConnected, timerID)\n{\n  // Inherit from Closure.\n  Closure.call(this);\n\n  this.face = face;\n  this.onConnected = onConnected;\n  this.timerID = timerID;\n};\n\nFace.ConnectClosure.prototype.upcall = function(kind, upcallInfo)\n{\n  if (!(kind == Closure.UPCALL_CONTENT ||\n        kind == Closure.UPCALL_CONTENT_UNVERIFIED))\n    // The upcall is not for us.\n    return Closure.RESULT_ERR;\n\n  // The host is alive, so cancel the timeout and continue with onConnected().\n  clearTimeout(this.timerID);\n\n    // Call Face.onopen after success\n  this.face.readyStatus = Face.OPENED;\n  this.face.onopen();\n\n  if (LOG>0) console.log("connectAndExecute: connected to host " + this.face.host);\n  this.onConnected();\n\n  return Closure.RESULT_OK;\n};\n\n/**\n * @deprecated Use new Face.\n */\nvar NDN = function NDN(settings)\n{\n  // Call the base constructor.\n  Face.call(this, settings);\n}\n\n// Use dummy functions so that the Face constructor will not try to set its own defaults.\nNDN.prototype = new Face({ getTransport: function(){}, getHostAndPort: function(){} });\n\nexports.NDN = NDN;\n\nNDN.supported = Face.supported;\nNDN.UNOPEN = Face.UNOPEN;\nNDN.OPENED = Face.OPENED;\nNDN.CLOSED = Face.CLOSED;\n\n\nmodule.exports = exports/*\nCryptoJS v3.1.2\ncode.google.com/p/crypto-js\n(c) 2009-2013 by Jeff Mott. All rights reserved.\ncode.google.com/p/crypto-js/wiki/License\n*/\n/**\n * CryptoJS core components.\n */\nvar CryptoJS = CryptoJS || (function (Math, undefined) {\n    /**\n     * CryptoJS namespace.\n     */\n    var C = {};\n\n    /**\n     * Library namespace.\n     */\n    var C_lib = C.lib = {};\n\n    /**\n     * Base object for prototypal inheritance.\n     */\n    var Base = C_lib.Base = (function () {\n        function F() {}\n\n        return {\n            /**\n             * Creates a new object that inherits from this object.\n             *\n             * @param {Object} overrides Properties to copy into the new object.\n             *\n             * @return {Object} The new object.\n             *\n             * @static\n             *\n             * @example\n             *\n             *     var MyType = CryptoJS.lib.Base.extend({\n             *         field: \'value\',\n             *\n             *         method: function () {\n             *         }\n             *     });\n             */\n            extend: function (overrides) {\n                // Spawn\n                F.prototype = this;\n                var subtype = new F();\n\n                // Augment\n                if (overrides) {\n                    subtype.mixIn(overrides);\n                }\n\n                // Create default initializer\n                if (!subtype.hasOwnProperty(\'init\')) {\n                    subtype.init = function () {\n                        subtype.$super.init.apply(this, arguments);\n                    };\n                }\n\n                // Initializer\'s prototype is the subtype object\n                subtype.init.prototype = subtype;\n\n                // Reference supertype\n                subtype.$super = this;\n\n                return subtype;\n            },\n\n            /**\n             * Extends this object and runs the init method.\n             * Arguments to create() will be passed to init().\n             *\n             * @return {Object} The new object.\n             *\n             * @static\n             *\n             * @example\n             *\n             *     var instance = MyType.create();\n             */\n            create: function () {\n                var instance = this.extend();\n                instance.init.apply(instance, arguments);\n\n                return instance;\n            },\n\n            /**\n             * Initializes a newly created object.\n             * Override this method to add some logic when your objects are created.\n             *\n             * @example\n             *\n             *     var MyType = CryptoJS.lib.Base.extend({\n             *         init: function () {\n             *             // ...\n             *         }\n             *     });\n             */\n            init: function () {\n            },\n\n            /**\n             * Copies properties into this object.\n             *\n             * @param {Object} properties The properties to mix in.\n             *\n             * @example\n             *\n             *     MyType.mixIn({\n             *         field: \'value\'\n             *     });\n             */\n            mixIn: function (properties) {\n                for (var propertyName in properties) {\n                    if (properties.hasOwnProperty(propertyName)) {\n                        this[propertyName] = properties[propertyName];\n                    }\n                }\n\n                // IE won\'t copy toString using the loop above\n                if (properties.hasOwnProperty(\'toString\')) {\n                    this.toString = properties.toString;\n                }\n            },\n\n            /**\n             * Creates a copy of this object.\n             *\n             * @return {Object} The clone.\n             *\n             * @example\n             *\n             *     var clone = instance.clone();\n             */\n            clone: function () {\n                return this.init.prototype.extend(this);\n            }\n        };\n    }());\n\n    /**\n     * An array of 32-bit words.\n     *\n     * @property {Array} words The array of 32-bit words.\n     * @property {number} sigBytes The number of significant bytes in this word array.\n     */\n    var WordArray = C_lib.WordArray = Base.extend({\n        /**\n         * Initializes a newly created word array.\n         *\n         * @param {Array} words (Optional) An array of 32-bit words.\n         * @param {number} sigBytes (Optional) The number of significant bytes in the words.\n         *\n         * @example\n         *\n         *     var wordArray = CryptoJS.lib.WordArray.create();\n         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);\n         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);\n         */\n        init: function (words, sigBytes) {\n            words = this.words = words || [];\n\n            if (sigBytes != undefined) {\n                this.sigBytes = sigBytes;\n            } else {\n                this.sigBytes = words.length * 4;\n            }\n        },\n\n        /**\n         * Converts this word array to a string.\n         *\n         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex\n         *\n         * @return {string} The stringified word array.\n         *\n         * @example\n         *\n         *     var string = wordArray + \'\';\n         *     var string = wordArray.toString();\n         *     var string = wordArray.toString(CryptoJS.enc.Utf8);\n         */\n        toString: function (encoder) {\n            return (encoder || Hex).stringify(this);\n        },\n\n        /**\n         * Concatenates a word array to this word array.\n         *\n         * @param {WordArray} wordArray The word array to append.\n         *\n         * @return {WordArray} This word array.\n         *\n         * @example\n         *\n         *     wordArray1.concat(wordArray2);\n         */\n        concat: function (wordArray) {\n            // Shortcuts\n            var thisWords = this.words;\n            var thatWords = wordArray.words;\n            var thisSigBytes = this.sigBytes;\n            var thatSigBytes = wordArray.sigBytes;\n\n            // Clamp excess bits\n            this.clamp();\n\n            // Concat\n            if (thisSigBytes % 4) {\n                // Copy one byte at a time\n                for (var i = 0; i < thatSigBytes; i++) {\n                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);\n                }\n            } else if (thatWords.length > 0xffff) {\n                // Copy one word at a time\n                for (var i = 0; i < thatSigBytes; i += 4) {\n                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];\n                }\n            } else {\n                // Copy all words at once\n                thisWords.push.apply(thisWords, thatWords);\n            }\n            this.sigBytes += thatSigBytes;\n\n            // Chainable\n            return this;\n        },\n\n        /**\n         * Removes insignificant bits.\n         *\n         * @example\n         *\n         *     wordArray.clamp();\n         */\n        clamp: function () {\n            // Shortcuts\n            var words = this.words;\n            var sigBytes = this.sigBytes;\n\n            // Clamp\n            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);\n            words.length = Math.ceil(sigBytes / 4);\n        },\n\n        /**\n         * Creates a copy of this word array.\n         *\n         * @return {WordArray} The clone.\n         *\n         * @example\n         *\n         *     var clone = wordArray.clone();\n         */\n        clone: function () {\n            var clone = Base.clone.call(this);\n            clone.words = this.words.slice(0);\n\n            return clone;\n        },\n\n        /**\n         * Creates a word array filled with random bytes.\n         *\n         * @param {number} nBytes The number of random bytes to generate.\n         *\n         * @return {WordArray} The random word array.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var wordArray = CryptoJS.lib.WordArray.random(16);\n         */\n        random: function (nBytes) {\n            var words = [];\n            for (var i = 0; i < nBytes; i += 4) {\n                words.push((Math.random() * 0x100000000) | 0);\n            }\n\n            return new WordArray.init(words, nBytes);\n        }\n    });\n\n    /**\n     * Encoder namespace.\n     */\n    var C_enc = C.enc = {};\n\n    /**\n     * Hex encoding strategy.\n     */\n    var Hex = C_enc.Hex = {\n        /**\n         * Converts a word array to a hex string.\n         *\n         * @param {WordArray} wordArray The word array.\n         *\n         * @return {string} The hex string.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);\n         */\n        stringify: function (wordArray) {\n            // Shortcuts\n            var words = wordArray.words;\n            var sigBytes = wordArray.sigBytes;\n\n            // Convert\n            var hexChars = [];\n            for (var i = 0; i < sigBytes; i++) {\n                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n                hexChars.push((bite >>> 4).toString(16));\n                hexChars.push((bite & 0x0f).toString(16));\n            }\n\n            return hexChars.join(\'\');\n        },\n\n        /**\n         * Converts a hex string to a word array.\n         *\n         * @param {string} hexStr The hex string.\n         *\n         * @return {WordArray} The word array.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);\n         */\n        parse: function (hexStr) {\n            // Shortcut\n            var hexStrLength = hexStr.length;\n\n            // Convert\n            var words = [];\n            for (var i = 0; i < hexStrLength; i += 2) {\n                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);\n            }\n\n            return new WordArray.init(words, hexStrLength / 2);\n        }\n    };\n\n    /**\n     * Latin1 encoding strategy.\n     */\n    var Latin1 = C_enc.Latin1 = {\n        /**\n         * Converts a word array to a Latin1 string.\n         *\n         * @param {WordArray} wordArray The word array.\n         *\n         * @return {string} The Latin1 string.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);\n         */\n        stringify: function (wordArray) {\n            // Shortcuts\n            var words = wordArray.words;\n            var sigBytes = wordArray.sigBytes;\n\n            // Convert\n            var latin1Chars = [];\n            for (var i = 0; i < sigBytes; i++) {\n                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n                latin1Chars.push(String.fromCharCode(bite));\n            }\n\n            return latin1Chars.join(\'\');\n        },\n\n        /**\n         * Converts a Latin1 string to a word array.\n         *\n         * @param {string} latin1Str The Latin1 string.\n         *\n         * @return {WordArray} The word array.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);\n         */\n        parse: function (latin1Str) {\n            // Shortcut\n            var latin1StrLength = latin1Str.length;\n\n            // Convert\n            var words = [];\n            for (var i = 0; i < latin1StrLength; i++) {\n                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);\n            }\n\n            return new WordArray.init(words, latin1StrLength);\n        }\n    };\n\n    /**\n     * UTF-8 encoding strategy.\n     */\n    var Utf8 = C_enc.Utf8 = {\n        /**\n         * Converts a word array to a UTF-8 string.\n         *\n         * @param {WordArray} wordArray The word array.\n         *\n         * @return {string} The UTF-8 string.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);\n         */\n        stringify: function (wordArray) {\n            try {\n                return decodeURIComponent(escape(Latin1.stringify(wordArray)));\n            } catch (e) {\n                throw new Error(\'Malformed UTF-8 data\');\n            }\n        },\n\n        /**\n         * Converts a UTF-8 string to a word array.\n         *\n         * @param {string} utf8Str The UTF-8 string.\n         *\n         * @return {WordArray} The word array.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);\n         */\n        parse: function (utf8Str) {\n            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\n        }\n    };\n\n    /**\n     * Abstract buffered block algorithm template.\n     *\n     * The property blockSize must be implemented in a concrete subtype.\n     *\n     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0\n     */\n    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({\n        /**\n         * Resets this block algorithm\'s data buffer to its initial state.\n         *\n         * @example\n         *\n         *     bufferedBlockAlgorithm.reset();\n         */\n        reset: function () {\n            // Initial values\n            this._data = new WordArray.init();\n            this._nDataBytes = 0;\n        },\n\n        /**\n         * Adds new data to this block algorithm\'s buffer.\n         *\n         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.\n         *\n         * @example\n         *\n         *     bufferedBlockAlgorithm._append(\'data\');\n         *     bufferedBlockAlgorithm._append(wordArray);\n         */\n        _append: function (data) {\n            // Convert string to WordArray, else assume WordArray already\n            if (typeof data == \'string\') {\n                data = Utf8.parse(data);\n            }\n\n            // Append\n            this._data.concat(data);\n            this._nDataBytes += data.sigBytes;\n        },\n\n        /**\n         * Processes available data blocks.\n         *\n         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.\n         *\n         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.\n         *\n         * @return {WordArray} The processed data.\n         *\n         * @example\n         *\n         *     var processedData = bufferedBlockAlgorithm._process();\n         *     var processedData = bufferedBlockAlgorithm._process(!!\'flush\');\n         */\n        _process: function (doFlush) {\n            // Shortcuts\n            var data = this._data;\n            var dataWords = data.words;\n            var dataSigBytes = data.sigBytes;\n            var blockSize = this.blockSize;\n            var blockSizeBytes = blockSize * 4;\n\n            // Count blocks ready\n            var nBlocksReady = dataSigBytes / blockSizeBytes;\n            if (doFlush) {\n                // Round up to include partial blocks\n                nBlocksReady = Math.ceil(nBlocksReady);\n            } else {\n                // Round down to include only full blocks,\n                // less the number of blocks that must remain in the buffer\n                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n            }\n\n            // Count words ready\n            var nWordsReady = nBlocksReady * blockSize;\n\n            // Count bytes ready\n            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);\n\n            // Process blocks\n            if (nWordsReady) {\n                for (var offset = 0; offset < nWordsReady; offset += blockSize) {\n                    // Perform concrete-algorithm logic\n                    this._doProcessBlock(dataWords, offset);\n                }\n\n                // Remove processed words\n                var processedWords = dataWords.splice(0, nWordsReady);\n                data.sigBytes -= nBytesReady;\n            }\n\n            // Return processed words\n            return new WordArray.init(processedWords, nBytesReady);\n        },\n\n        /**\n         * Creates a copy of this object.\n         *\n         * @return {Object} The clone.\n         *\n         * @example\n         *\n         *     var clone = bufferedBlockAlgorithm.clone();\n         */\n        clone: function () {\n            var clone = Base.clone.call(this);\n            clone._data = this._data.clone();\n\n            return clone;\n        },\n\n        _minBufferSize: 0\n    });\n\n    /**\n     * Abstract hasher template.\n     *\n     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)\n     */\n    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({\n        /**\n         * Configuration options.\n         */\n        cfg: Base.extend(),\n\n        /**\n         * Initializes a newly created hasher.\n         *\n         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.\n         *\n         * @example\n         *\n         *     var hasher = CryptoJS.algo.SHA256.create();\n         */\n        init: function (cfg) {\n            // Apply config defaults\n            this.cfg = this.cfg.extend(cfg);\n\n            // Set initial values\n            this.reset();\n        },\n\n        /**\n         * Resets this hasher to its initial state.\n         *\n         * @example\n         *\n         *     hasher.reset();\n         */\n        reset: function () {\n            // Reset data buffer\n            BufferedBlockAlgorithm.reset.call(this);\n\n            // Perform concrete-hasher logic\n            this._doReset();\n        },\n\n        /**\n         * Updates this hasher with a message.\n         *\n         * @param {WordArray|string} messageUpdate The message to append.\n         *\n         * @return {Hasher} This hasher.\n         *\n         * @example\n         *\n         *     hasher.update(\'message\');\n         *     hasher.update(wordArray);\n         */\n        update: function (messageUpdate) {\n            // Append\n            this._append(messageUpdate);\n\n            // Update the hash\n            this._process();\n\n            // Chainable\n            return this;\n        },\n\n        /**\n         * Finalizes the hash computation.\n         * Note that the finalize operation is effectively a destructive, read-once operation.\n         *\n         * @param {WordArray|string} messageUpdate (Optional) A final message update.\n         *\n         * @return {WordArray} The hash.\n         *\n         * @example\n         *\n         *     var hash = hasher.finalize();\n         *     var hash = hasher.finalize(\'message\');\n         *     var hash = hasher.finalize(wordArray);\n         */\n        finalize: function (messageUpdate) {\n            // Final message update\n            if (messageUpdate) {\n                this._append(messageUpdate);\n            }\n\n            // Perform concrete-hasher logic\n            var hash = this._doFinalize();\n\n            return hash;\n        },\n\n        blockSize: 512/32,\n\n        /**\n         * Creates a shortcut function to a hasher\'s object interface.\n         *\n         * @param {Hasher} hasher The hasher to create a helper for.\n         *\n         * @return {Function} The shortcut function.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);\n         */\n        _createHelper: function (hasher) {\n            return function (message, cfg) {\n                return new hasher.init(cfg).finalize(message);\n            };\n        },\n\n        /**\n         * Creates a shortcut function to the HMAC\'s object interface.\n         *\n         * @param {Hasher} hasher The hasher to use in this HMAC helper.\n         *\n         * @return {Function} The shortcut function.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);\n         */\n        _createHmacHelper: function (hasher) {\n            return function (message, key) {\n                return new C_algo.HMAC.init(hasher, key).finalize(message);\n            };\n        }\n    });\n\n    /**\n     * Algorithm namespace.\n     */\n    var C_algo = C.algo = {};\n\n    return C;\n}(Math));\n/*\nCryptoJS v3.1.2\ncode.google.com/p/crypto-js\n(c) 2009-2013 by Jeff Mott. All rights reserved.\ncode.google.com/p/crypto-js/wiki/License\n*/\n(function (Math) {\n    // Shortcuts\n    var C = CryptoJS;\n    var C_lib = C.lib;\n    var WordArray = C_lib.WordArray;\n    var Hasher = C_lib.Hasher;\n    var C_algo = C.algo;\n\n    // Initialization and round constants tables\n    var H = [];\n    var K = [];\n\n    // Compute constants\n    (function () {\n        function isPrime(n) {\n            var sqrtN = Math.sqrt(n);\n            for (var factor = 2; factor <= sqrtN; factor++) {\n                if (!(n % factor)) {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        function getFractionalBits(n) {\n            return ((n - (n | 0)) * 0x100000000) | 0;\n        }\n\n        var n = 2;\n        var nPrime = 0;\n        while (nPrime < 64) {\n            if (isPrime(n)) {\n                if (nPrime < 8) {\n                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));\n                }\n                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));\n\n                nPrime++;\n            }\n\n            n++;\n        }\n    }());\n\n    // Reusable object\n    var W = [];\n\n    /**\n     * SHA-256 hash algorithm.\n     */\n    var SHA256 = C_algo.SHA256 = Hasher.extend({\n        _doReset: function () {\n            this._hash = new WordArray.init(H.slice(0));\n        },\n\n        _doProcessBlock: function (M, offset) {\n            // Shortcut\n            var H = this._hash.words;\n\n            // Working variables\n            var a = H[0];\n            var b = H[1];\n            var c = H[2];\n            var d = H[3];\n            var e = H[4];\n            var f = H[5];\n            var g = H[6];\n            var h = H[7];\n\n            // Computation\n            for (var i = 0; i < 64; i++) {\n                if (i < 16) {\n                    W[i] = M[offset + i] | 0;\n                } else {\n                    var gamma0x = W[i - 15];\n                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^\n                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^\n                                   (gamma0x >>> 3);\n\n                    var gamma1x = W[i - 2];\n                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^\n                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^\n                                   (gamma1x >>> 10);\n\n                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];\n                }\n\n                var ch  = (e & f) ^ (~e & g);\n                var maj = (a & b) ^ (a & c) ^ (b & c);\n\n                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));\n                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));\n\n                var t1 = h + sigma1 + ch + K[i] + W[i];\n                var t2 = sigma0 + maj;\n\n                h = g;\n                g = f;\n                f = e;\n                e = (d + t1) | 0;\n                d = c;\n                c = b;\n                b = a;\n                a = (t1 + t2) | 0;\n            }\n\n            // Intermediate hash value\n            H[0] = (H[0] + a) | 0;\n            H[1] = (H[1] + b) | 0;\n            H[2] = (H[2] + c) | 0;\n            H[3] = (H[3] + d) | 0;\n            H[4] = (H[4] + e) | 0;\n            H[5] = (H[5] + f) | 0;\n            H[6] = (H[6] + g) | 0;\n            H[7] = (H[7] + h) | 0;\n        },\n\n        _doFinalize: function () {\n            // Shortcuts\n            var data = this._data;\n            var dataWords = data.words;\n\n            var nBitsTotal = this._nDataBytes * 8;\n            var nBitsLeft = data.sigBytes * 8;\n\n            // Add padding\n            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);\n            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;\n            data.sigBytes = dataWords.length * 4;\n\n            // Hash final blocks\n            this._process();\n\n            // Return final computed hash\n            return this._hash;\n        },\n\n        clone: function () {\n            var clone = Hasher.clone.call(this);\n            clone._hash = this._hash.clone();\n\n            return clone;\n        }\n    });\n\n    /**\n     * Shortcut function to the hasher\'s object interface.\n     *\n     * @param {WordArray|string} message The message to hash.\n     *\n     * @return {WordArray} The hash.\n     *\n     * @static\n     *\n     * @example\n     *\n     *     var hash = CryptoJS.SHA256(\'message\');\n     *     var hash = CryptoJS.SHA256(wordArray);\n     */\n    C.SHA256 = Hasher._createHelper(SHA256);\n\n    /**\n     * Shortcut function to the HMAC\'s object interface.\n     *\n     * @param {WordArray|string} message The message to hash.\n     * @param {WordArray|string} key The secret key.\n     *\n     * @return {WordArray} The HMAC.\n     *\n     * @static\n     *\n     * @example\n     *\n     *     var hmac = CryptoJS.HmacSHA256(message, key);\n     */\n    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);\n}(Math));\nvar b64map="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";\nvar b64pad="=";\n\nfunction hex2b64(h) {\n  var i;\n  var c;\n  var ret = "";\n  for(i = 0; i+3 <= h.length; i+=3) {\n    c = parseInt(h.substring(i,i+3),16);\n    ret += b64map.charAt(c >> 6) + b64map.charAt(c & 63);\n  }\n  if(i+1 == h.length) {\n    c = parseInt(h.substring(i,i+1),16);\n    ret += b64map.charAt(c << 2);\n  }\n  else if(i+2 == h.length) {\n    c = parseInt(h.substring(i,i+2),16);\n    ret += b64map.charAt(c >> 2) + b64map.charAt((c & 3) << 4);\n  }\n  if (b64pad) while((ret.length & 3) > 0) ret += b64pad;\n  return ret;\n}\n\n// convert a base64 string to hex\nfunction b64tohex(s) {\n  var ret = ""\n  var i;\n  var k = 0; // b64 state, 0-3\n  var slop;\n  for(i = 0; i < s.length; ++i) {\n    if(s.charAt(i) == b64pad) break;\n    v = b64map.indexOf(s.charAt(i));\n    if(v < 0) continue;\n    if(k == 0) {\n      ret += int2char(v >> 2);\n      slop = v & 3;\n      k = 1;\n    }\n    else if(k == 1) {\n      ret += int2char((slop << 2) | (v >> 4));\n      slop = v & 0xf;\n      k = 2;\n    }\n    else if(k == 2) {\n      ret += int2char(slop);\n      ret += int2char(v >> 2);\n      slop = v & 3;\n      k = 3;\n    }\n    else {\n      ret += int2char((slop << 2) | (v >> 4));\n      ret += int2char(v & 0xf);\n      k = 0;\n    }\n  }\n  if(k == 1)\n    ret += int2char(slop << 2);\n  return ret;\n}\n\n// convert a base64 string to a byte/number array\nfunction b64toBA(s) {\n  //piggyback on b64tohex for now, optimize later\n  var h = b64tohex(s);\n  var i;\n  var a = new Array();\n  for(i = 0; 2*i < h.length; ++i) {\n    a[i] = parseInt(h.substring(2*i,2*i+2),16);\n  }\n  return a;\n}\n// Depends on jsbn.js and rng.js\n\n// Version 1.1: support utf-8 encoding in pkcs1pad2\n\n// convert a (hex) string to a bignum object\nfunction parseBigInt(str,r) {\n  return new BigInteger(str,r);\n}\n\nfunction linebrk(s,n) {\n  var ret = "";\n  var i = 0;\n  while(i + n < s.length) {\n    ret += s.substring(i,i+n) + "\\n";\n    i += n;\n  }\n  return ret + s.substring(i,s.length);\n}\n\nfunction byte2Hex(b) {\n  if(b < 0x10)\n    return "0" + b.toString(16);\n  else\n    return b.toString(16);\n}\n\n// PKCS#1 (type 2, random) pad input string s to n bytes, and return a bigint\nfunction pkcs1pad2(s,n) {\n  if(n < s.length + 11) { // TODO: fix for utf-8\n    alert("Message too long for RSA");\n    return null;\n  }\n  var ba = new Array();\n  var i = s.length - 1;\n  while(i >= 0 && n > 0) {\n    var c = s.charCodeAt(i--);\n    if(c < 128) { // encode using utf-8\n      ba[--n] = c;\n    }\n    else if((c > 127) && (c < 2048)) {\n      ba[--n] = (c & 63) | 128;\n      ba[--n] = (c >> 6) | 192;\n    }\n    else {\n      ba[--n] = (c & 63) | 128;\n      ba[--n] = ((c >> 6) & 63) | 128;\n      ba[--n] = (c >> 12) | 224;\n    }\n  }\n  ba[--n] = 0;\n  var rng = new SecureRandom();\n  var x = new Array();\n  while(n > 2) { // random non-zero pad\n    x[0] = 0;\n    while(x[0] == 0) rng.nextBytes(x);\n    ba[--n] = x[0];\n  }\n  ba[--n] = 2;\n  ba[--n] = 0;\n  return new BigInteger(ba);\n}\n\n// PKCS#1 (OAEP) mask generation function\nfunction oaep_mgf1_arr(seed, len, hash)\n{\n    var mask = \'\', i = 0;\n\n    while (mask.length < len)\n    {\n        mask += hash(String.fromCharCode.apply(String, seed.concat([\n                (i & 0xff000000) >> 24,\n                (i & 0x00ff0000) >> 16,\n                (i & 0x0000ff00) >> 8,\n                i & 0x000000ff])));\n        i += 1;\n    }\n\n    return mask;\n}\n\nvar SHA1_SIZE = 20;\n\n// PKCS#1 (OAEP) pad input string s to n bytes, and return a bigint\nfunction oaep_pad(s, n, hash)\n{\n    if (s.length + 2 * SHA1_SIZE + 2 > n)\n    {\n        throw "Message too long for RSA";\n    }\n\n    var PS = \'\', i;\n\n    for (i = 0; i < n - s.length - 2 * SHA1_SIZE - 2; i += 1)\n    {\n        PS += \'\\x00\';\n    }\n\n    var DB = rstr_sha1(\'\') + PS + \'\\x01\' + s;\n    var seed = new Array(SHA1_SIZE);\n    new SecureRandom().nextBytes(seed);\n\n    var dbMask = oaep_mgf1_arr(seed, DB.length, hash || rstr_sha1);\n    var maskedDB = [];\n\n    for (i = 0; i < DB.length; i += 1)\n    {\n        maskedDB[i] = DB.charCodeAt(i) ^ dbMask.charCodeAt(i);\n    }\n\n    var seedMask = oaep_mgf1_arr(maskedDB, seed.length, rstr_sha1);\n    var maskedSeed = [0];\n\n    for (i = 0; i < seed.length; i += 1)\n    {\n        maskedSeed[i + 1] = seed[i] ^ seedMask.charCodeAt(i);\n    }\n\n    return new BigInteger(maskedSeed.concat(maskedDB));\n}\n\n// "empty" RSA key constructor\nfunction RSAKey() {\n  this.n = null;\n  this.e = 0;\n  this.d = null;\n  this.p = null;\n  this.q = null;\n  this.dmp1 = null;\n  this.dmq1 = null;\n  this.coeff = null;\n}\n\n// Set the public key fields N and e from hex strings\nfunction RSASetPublic(N,E) {\n  if (typeof N !== "string")\n  {\n    this.n = N;\n    this.e = E;\n  }\n  else if(N != null && E != null && N.length > 0 && E.length > 0) {\n    this.n = parseBigInt(N,16);\n    this.e = parseInt(E,16);\n  }\n  else\n    alert("Invalid RSA public key");\n}\n\n// Perform raw public operation on "x": return x^e (mod n)\nfunction RSADoPublic(x) {\n  return x.modPowInt(this.e, this.n);\n}\n\n// Return the PKCS#1 RSA encryption of "text" as an even-length hex string\nfunction RSAEncrypt(text) {\n  var m = pkcs1pad2(text,(this.n.bitLength()+7)>>3);\n  if(m == null) return null;\n  var c = this.doPublic(m);\n  if(c == null) return null;\n  var h = c.toString(16);\n  if((h.length & 1) == 0) return h; else return "0" + h;\n}\n\n// Return the PKCS#1 OAEP RSA encryption of "text" as an even-length hex string\nfunction RSAEncryptOAEP(text, hash) {\n  var m = oaep_pad(text, (this.n.bitLength()+7)>>3, hash);\n  if(m == null) return null;\n  var c = this.doPublic(m);\n  if(c == null) return null;\n  var h = c.toString(16);\n  if((h.length & 1) == 0) return h; else return "0" + h;\n}\n\n// Return the PKCS#1 RSA encryption of "text" as a Base64-encoded string\n//function RSAEncryptB64(text) {\n//  var h = this.encrypt(text);\n//  if(h) return hex2b64(h); else return null;\n//}\n\n// protected\nRSAKey.prototype.doPublic = RSADoPublic;\n\n// public\nRSAKey.prototype.setPublic = RSASetPublic;\nRSAKey.prototype.encrypt = RSAEncrypt;\nRSAKey.prototype.encryptOAEP = RSAEncryptOAEP;\n//RSAKey.prototype.encrypt_b64 = RSAEncryptB64;\n// Depends on rsa.js and jsbn2.js\n\n// Version 1.1: support utf-8 decoding in pkcs1unpad2\n\n// Undo PKCS#1 (type 2, random) padding and, if valid, return the plaintext\nfunction pkcs1unpad2(d,n) {\n  var b = d.toByteArray();\n  var i = 0;\n  while(i < b.length && b[i] == 0) ++i;\n  if(b.length-i != n-1 || b[i] != 2)\n    return null;\n  ++i;\n  while(b[i] != 0)\n    if(++i >= b.length) return null;\n  var ret = "";\n  while(++i < b.length) {\n    var c = b[i] & 255;\n    if(c < 128) { // utf-8 decode\n      ret += String.fromCharCode(c);\n    }\n    else if((c > 191) && (c < 224)) {\n      ret += String.fromCharCode(((c & 31) << 6) | (b[i+1] & 63));\n      ++i;\n    }\n    else {\n      ret += String.fromCharCode(((c & 15) << 12) | ((b[i+1] & 63) << 6) | (b[i+2] & 63));\n      i += 2;\n    }\n  }\n  return ret;\n}\n\n// PKCS#1 (OAEP) mask generation function\nfunction oaep_mgf1_str(seed, len, hash)\n{\n    var mask = \'\', i = 0;\n\n    while (mask.length < len)\n    {\n        mask += hash(seed + String.fromCharCode.apply(String, [\n                (i & 0xff000000) >> 24,\n                (i & 0x00ff0000) >> 16,\n                (i & 0x0000ff00) >> 8,\n                i & 0x000000ff]));\n        i += 1;\n    }\n\n    return mask;\n}\n\nvar SHA1_SIZE = 20;\n\n// Undo PKCS#1 (OAEP) padding and, if valid, return the plaintext\nfunction oaep_unpad(d, n, hash)\n{\n    d = d.toByteArray();\n\n    var i;\n\n    for (i = 0; i < d.length; i += 1)\n    {\n        d[i] &= 0xff;\n    }\n\n    while (d.length < n)\n    {\n        d.unshift(0);\n    }\n\n    d = String.fromCharCode.apply(String, d);\n\n    if (d.length < 2 * SHA1_SIZE + 2)\n    {\n        throw "Cipher too short";\n    }\n\n    var maskedSeed = d.substr(1, SHA1_SIZE)\n    var maskedDB = d.substr(SHA1_SIZE + 1);\n\n    var seedMask = oaep_mgf1_str(maskedDB, SHA1_SIZE, hash || rstr_sha1);\n    var seed = [], i;\n\n    for (i = 0; i < maskedSeed.length; i += 1)\n    {\n        seed[i] = maskedSeed.charCodeAt(i) ^ seedMask.charCodeAt(i);\n    }\n\n    var dbMask = oaep_mgf1_str(String.fromCharCode.apply(String, seed),\n                           d.length - SHA1_SIZE, rstr_sha1);\n\n    var DB = [];\n\n    for (i = 0; i < maskedDB.length; i += 1)\n    {\n        DB[i] = maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i);\n    }\n\n    DB = String.fromCharCode.apply(String, DB);\n\n    if (DB.substr(0, SHA1_SIZE) !== rstr_sha1(\'\'))\n    {\n        throw "Hash mismatch";\n    }\n\n    DB = DB.substr(SHA1_SIZE);\n\n    var first_one = DB.indexOf(\'\\x01\');\n    var last_zero = (first_one != -1) ? DB.substr(0, first_one).lastIndexOf(\'\\x00\') : -1;\n\n    if (last_zero + 1 != first_one)\n    {\n        throw "Malformed data";\n    }\n\n    return DB.substr(first_one + 1);\n}\n\n// Set the private key fields N, e, and d from hex strings\nfunction RSASetPrivate(N,E,D) {\n  if (typeof N !== "string")\n  {\n    this.n = N;\n    this.e = E;\n    this.d = D;\n  }\n  else if(N != null && E != null && N.length > 0 && E.length > 0) {\n    this.n = parseBigInt(N,16);\n    this.e = parseInt(E,16);\n    this.d = parseBigInt(D,16);\n  }\n  else\n    alert("Invalid RSA private key");\n}\n\n// Set the private key fields N, e, d and CRT params from hex strings\nfunction RSASetPrivateEx(N,E,D,P,Q,DP,DQ,C) {\n  //alert("RSASetPrivateEx called");\n  if (N == null) throw "RSASetPrivateEx N == null";\n  if (E == null) throw "RSASetPrivateEx E == null";\n  if (N.length == 0) throw "RSASetPrivateEx N.length == 0";\n  if (E.length == 0) throw "RSASetPrivateEx E.length == 0";\n\n  if (N != null && E != null && N.length > 0 && E.length > 0) {\n    this.n = parseBigInt(N,16);\n    this.e = parseInt(E,16);\n    this.d = parseBigInt(D,16);\n    this.p = parseBigInt(P,16);\n    this.q = parseBigInt(Q,16);\n    this.dmp1 = parseBigInt(DP,16);\n    this.dmq1 = parseBigInt(DQ,16);\n    this.coeff = parseBigInt(C,16);\n  } else {\n    alert("Invalid RSA private key in RSASetPrivateEx");\n  }\n}\n\n// Generate a new random private key B bits long, using public expt E\nfunction RSAGenerate(B,E) {\n  var rng = new SecureRandom();\n  var qs = B>>1;\n  this.e = parseInt(E,16);\n  var ee = new BigInteger(E,16);\n  for(;;) {\n    for(;;) {\n      this.p = new BigInteger(B-qs,1,rng);\n      if(this.p.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) == 0 && this.p.isProbablePrime(10)) break;\n    }\n    for(;;) {\n      this.q = new BigInteger(qs,1,rng);\n      if(this.q.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) == 0 && this.q.isProbablePrime(10)) break;\n    }\n    if(this.p.compareTo(this.q) <= 0) {\n      var t = this.p;\n      this.p = this.q;\n      this.q = t;\n    }\n    var p1 = this.p.subtract(BigInteger.ONE);\t// p1 = p - 1\n    var q1 = this.q.subtract(BigInteger.ONE);\t// q1 = q - 1\n    var phi = p1.multiply(q1);\n    if(phi.gcd(ee).compareTo(BigInteger.ONE) == 0) {\n      this.n = this.p.multiply(this.q);\t// this.n = p * q\n      this.d = ee.modInverse(phi);\t// this.d =\n      this.dmp1 = this.d.mod(p1);\t// this.dmp1 = d mod (p - 1)\n      this.dmq1 = this.d.mod(q1);\t// this.dmq1 = d mod (q - 1)\n      this.coeff = this.q.modInverse(this.p);\t// this.coeff = (q ^ -1) mod p\n      break;\n    }\n  }\n}\n\n// Perform raw private operation on "x": return x^d (mod n)\nfunction RSADoPrivate(x) {\n  if(this.p == null || this.q == null)\n    return x.modPow(this.d, this.n);\n\n  // TODO: re-calculate any missing CRT params\n  var xp = x.mod(this.p).modPow(this.dmp1, this.p); // xp=cp?\n  var xq = x.mod(this.q).modPow(this.dmq1, this.q); // xq=cq?\n\n  while(xp.compareTo(xq) < 0)\n    xp = xp.add(this.p);\n  // NOTE:\n  // xp.subtract(xq) => cp -cq\n  // xp.subtract(xq).multiply(this.coeff).mod(this.p) => (cp - cq) * u mod p = h\n  // xp.subtract(xq).multiply(this.coeff).mod(this.p).multiply(this.q).add(xq) => cq + (h * q) = M\n  return xp.subtract(xq).multiply(this.coeff).mod(this.p).multiply(this.q).add(xq);\n}\n\n// Return the PKCS#1 RSA decryption of "ctext".\n// "ctext" is an even-length hex string and the output is a plain string.\nfunction RSADecrypt(ctext) {\n  var c = parseBigInt(ctext, 16);\n  var m = this.doPrivate(c);\n  if(m == null) return null;\n  return pkcs1unpad2(m, (this.n.bitLength()+7)>>3);\n}\n\n// Return the PKCS#1 OAEP RSA decryption of "ctext".\n// "ctext" is an even-length hex string and the output is a plain string.\nfunction RSADecryptOAEP(ctext, hash) {\n  var c = parseBigInt(ctext, 16);\n  var m = this.doPrivate(c);\n  if(m == null) return null;\n  return oaep_unpad(m, (this.n.bitLength()+7)>>3, hash);\n}\n\n// Return the PKCS#1 RSA decryption of "ctext".\n// "ctext" is a Base64-encoded string and the output is a plain string.\n//function RSAB64Decrypt(ctext) {\n//  var h = b64tohex(ctext);\n//  if(h) return this.decrypt(h); else return null;\n//}\n\n// protected\nRSAKey.prototype.doPrivate = RSADoPrivate;\n\n// public\nRSAKey.prototype.setPrivate = RSASetPrivate;\nRSAKey.prototype.setPrivateEx = RSASetPrivateEx;\nRSAKey.prototype.generate = RSAGenerate;\nRSAKey.prototype.decrypt = RSADecrypt;\nRSAKey.prototype.decryptOAEP = RSADecryptOAEP;\n//RSAKey.prototype.b64_decrypt = RSAB64Decrypt;\n/*! crypto-1.0.4.js (c) 2013 Kenji Urushima | kjur.github.com/jsrsasign/license\n */\n/*\n * crypto.js - Cryptographic Algorithm Provider class\n *\n * Copyright (c) 2013 Kenji Urushima (kenji.urushima@gmail.com)\n *\n * This software is licensed under the terms of the MIT License.\n * http://kjur.github.com/jsrsasign/license\n *\n * The above copyright and license notice shall be\n * included in all copies or substantial portions of the Software.\n */\n\n/**\n * @fileOverview\n * @name crypto-1.0.js\n * @author Kenji Urushima kenji.urushima@gmail.com\n * @version 1.0.4 (2013-Mar-28)\n * @since 2.2\n * @license <a href="http://kjur.github.io/jsrsasign/license/">MIT License</a>\n */\n\n/**\n * kjur\'s class library name space\n * @name KJUR\n * @namespace kjur\'s class library name space\n */\nif (typeof KJUR == "undefined" || !KJUR) KJUR = {};\n/**\n * kjur\'s cryptographic algorithm provider library name space\n * <p>\n * This namespace privides following crytpgrahic classes.\n * <ul>\n * <li>{@link KJUR.crypto.MessageDigest} - Java JCE(cryptograhic extension) style MessageDigest class</li>\n * <li>{@link KJUR.crypto.Signature} - Java JCE(cryptograhic extension) style Signature class</li>\n * <li>{@link KJUR.crypto.Util} - cryptographic utility functions and properties</li>\n * </ul>\n * NOTE: Please ignore method summary and document of this namespace. This caused by a bug of jsdoc2.\n * </p>\n * @name KJUR.crypto\n * @namespace\n */\nif (typeof KJUR.crypto == "undefined" || !KJUR.crypto) KJUR.crypto = {};\n\n/**\n * static object for cryptographic function utilities\n * @name KJUR.crypto.Util\n * @class static object for cryptographic function utilities\n * @property {Array} DIGESTINFOHEAD PKCS#1 DigestInfo heading hexadecimal bytes for each hash algorithms\n * @description\n */\nKJUR.crypto.Util = new function() {\n    this.DIGESTINFOHEAD = {\n\t\'sha1\':      "3021300906052b0e03021a05000414",\n        \'sha224\':    "302d300d06096086480165030402040500041c",\n\t\'sha256\':    "3031300d060960864801650304020105000420",\n\t\'sha384\':    "3041300d060960864801650304020205000430",\n\t\'sha512\':    "3051300d060960864801650304020305000440",\n\t\'md2\':       "3020300c06082a864886f70d020205000410",\n\t\'md5\':       "3020300c06082a864886f70d020505000410",\n\t\'ripemd160\': "3021300906052b2403020105000414"\n    };\n\n    /**\n     * get hexadecimal DigestInfo\n     * @name getDigestInfoHex\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} hHash hexadecimal hash value\n     * @param {String} alg hash algorithm name (ex. \'sha1\')\n     * @return {String} hexadecimal string DigestInfo ASN.1 structure\n     */\n    this.getDigestInfoHex = function(hHash, alg) {\n\tif (typeof this.DIGESTINFOHEAD[alg] == "undefined")\n\t    throw "alg not supported in Util.DIGESTINFOHEAD: " + alg;\n\treturn this.DIGESTINFOHEAD[alg] + hHash;\n    };\n\n    /**\n     * get PKCS#1 padded hexadecimal DigestInfo\n     * @name getPaddedDigestInfoHex\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} hHash hexadecimal hash value\n     * @param {String} alg hash algorithm name (ex. \'sha1\')\n     * @param {Integer} keySize key bit length (ex. 1024)\n     * @return {String} hexadecimal string of PKCS#1 padded DigestInfo\n     */\n    this.getPaddedDigestInfoHex = function(hHash, alg, keySize) {\n\tvar hDigestInfo = this.getDigestInfoHex(hHash, alg);\n\tvar pmStrLen = keySize / 4; // minimum PM length\n\n\tif (hDigestInfo.length + 22 > pmStrLen) // len(0001+ff(*8)+00+hDigestInfo)=22\n\t    throw "key is too short for SigAlg: keylen=" + keySize + "," + alg;\n\n\tvar hHead = "0001";\n\tvar hTail = "00" + hDigestInfo;\n\tvar hMid = "";\n\tvar fLen = pmStrLen - hHead.length - hTail.length;\n\tfor (var i = 0; i < fLen; i += 2) {\n\t    hMid += "ff";\n\t}\n\tvar hPaddedMessage = hHead + hMid + hTail;\n\treturn hPaddedMessage;\n    };\n\n    /**\n     * get hexadecimal SHA1 hash of string\n     * @name sha1\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} s input string to be hashed\n     * @return {String} hexadecimal string of hash value\n     * @since 1.0.3\n     */\n    this.sha1 = function(s) {\n        var md = new KJUR.crypto.MessageDigest({\'alg\':\'sha1\', \'prov\':\'cryptojs\'});\n        return md.digestString(s);\n    };\n\n    /**\n     * get hexadecimal SHA256 hash of string\n     * @name sha256\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} s input string to be hashed\n     * @return {String} hexadecimal string of hash value\n     * @since 1.0.3\n     */\n    this.sha256 = function(s) {\n        var md = new KJUR.crypto.MessageDigest({\'alg\':\'sha256\', \'prov\':\'cryptojs\'});\n        return md.digestString(s);\n    };\n\n    /**\n     * get hexadecimal SHA512 hash of string\n     * @name sha512\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} s input string to be hashed\n     * @return {String} hexadecimal string of hash value\n     * @since 1.0.3\n     */\n    this.sha512 = function(s) {\n        var md = new KJUR.crypto.MessageDigest({\'alg\':\'sha512\', \'prov\':\'cryptojs\'});\n        return md.digestString(s);\n    };\n\n    /**\n     * get hexadecimal MD5 hash of string\n     * @name md5\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} s input string to be hashed\n     * @return {String} hexadecimal string of hash value\n     * @since 1.0.3\n     */\n    this.md5 = function(s) {\n        var md = new KJUR.crypto.MessageDigest({\'alg\':\'md5\', \'prov\':\'cryptojs\'});\n        return md.digestString(s);\n    };\n\n    /**\n     * get hexadecimal RIPEMD160 hash of string\n     * @name ripemd160\n     * @memberOf KJUR.crypto.Util\n     * @function\n     * @param {String} s input string to be hashed\n     * @return {String} hexadecimal string of hash value\n     * @since 1.0.3\n     */\n    this.ripemd160 = function(s) {\n        var md = new KJUR.crypto.MessageDigest({\'alg\':\'ripemd160\', \'prov\':\'cryptojs\'});\n        return md.digestString(s);\n    };\n};\n\n/**\n * MessageDigest class which is very similar to java.security.MessageDigest class\n * @name KJUR.crypto.MessageDigest\n * @class MessageDigest class which is very similar to java.security.MessageDigest class\n * @param {Array} params parameters for constructor\n * @description\n * <br/>\n * Currently this supports following algorithm and providers combination:\n * <ul>\n * <li>md5 - cryptojs</li>\n * <li>sha1 - cryptojs</li>\n * <li>sha224 - cryptojs</li>\n * <li>sha256 - cryptojs</li>\n * <li>sha384 - cryptojs</li>\n * <li>sha512 - cryptojs</li>\n * <li>ripemd160 - cryptojs</li>\n * <li>sha256 - sjcl (NEW from crypto.js 1.0.4)</li>\n * </ul>\n * @example\n * // CryptoJS provider sample\n * &lt;script src="http://crypto-js.googlecode.com/svn/tags/3.1.2/build/components/core.js"&gt;&lt;/script&gt;\n * &lt;script src="http://crypto-js.googlecode.com/svn/tags/3.1.2/build/components/sha1.js"&gt;&lt;/script&gt;\n * &lt;script src="crypto-1.0.js"&gt;&lt;/script&gt;\n * var md = new KJUR.crypto.MessageDigest({alg: "sha1", prov: "cryptojs"});\n * md.updateString(\'aaa\')\n * var mdHex = md.digest()\n *\n * // SJCL(Stanford JavaScript Crypto Library) provider sample\n * &lt;script src="http://bitwiseshiftleft.github.io/sjcl/sjcl.js"&gt;&lt;/script&gt;\n * &lt;script src="crypto-1.0.js"&gt;&lt;/script&gt;\n * var md = new KJUR.crypto.MessageDigest({alg: "sha256", prov: "sjcl"}); // sjcl supports sha256 only\n * md.updateString(\'aaa\')\n * var mdHex = md.digest()\n */\nKJUR.crypto.MessageDigest = function(params) {\n    var md = null;\n    var algName = null;\n    var provName = null;\n    var _CryptoJSMdName = {\n\t\'md5\': \'CryptoJS.algo.MD5\',\n\t\'sha1\': \'CryptoJS.algo.SHA1\',\n\t\'sha224\': \'CryptoJS.algo.SHA224\',\n\t\'sha256\': \'CryptoJS.algo.SHA256\',\n\t\'sha384\': \'CryptoJS.algo.SHA384\',\n\t\'sha512\': \'CryptoJS.algo.SHA512\',\n\t\'ripemd160\': \'CryptoJS.algo.RIPEMD160\'\n    };\n\n    /**\n     * set hash algorithm and provider\n     * @name setAlgAndProvider\n     * @memberOf KJUR.crypto.MessageDigest\n     * @function\n     * @param {String} alg hash algorithm name\n     * @param {String} prov provider name\n     * @description\n     * @example\n     * // for SHA1\n     * md.setAlgAndProvider(\'sha1\', \'cryptojs\');\n     * // for RIPEMD160\n     * md.setAlgAndProvider(\'ripemd160\', \'cryptojs\');\n     */\n    this.setAlgAndProvider = function(alg, prov) {\n\tif (\':md5:sha1:sha224:sha256:sha384:sha512:ripemd160:\'.indexOf(alg) != -1 &&\n\t    prov == \'cryptojs\') {\n\t    try {\n\t\tthis.md = eval(_CryptoJSMdName[alg]).create();\n\t    } catch (ex) {\n\t\tthrow "setAlgAndProvider hash alg set fail alg=" + alg + "/" + ex;\n\t    }\n\t    this.updateString = function(str) {\n\t\tthis.md.update(str);\n\t    };\n\t    this.updateHex = function(hex) {\n\t\tvar wHex = CryptoJS.enc.Hex.parse(hex);\n\t\tthis.md.update(wHex);\n\t    };\n\t    this.digest = function() {\n\t\tvar hash = this.md.finalize();\n\t\treturn hash.toString(CryptoJS.enc.Hex);\n\t    };\n\t    this.digestString = function(str) {\n\t\tthis.updateString(str);\n\t\treturn this.digest();\n\t    };\n\t    this.digestHex = function(hex) {\n\t\tthis.updateHex(hex);\n\t\treturn this.digest();\n\t    };\n\t}\n\tif (\':sha256:\'.indexOf(alg) != -1 &&\n\t    prov == \'sjcl\') {\n\t    try {\n\t\tthis.md = new sjcl.hash.sha256();\n\t    } catch (ex) {\n\t\tthrow "setAlgAndProvider hash alg set fail alg=" + alg + "/" + ex;\n\t    }\n\t    this.updateString = function(str) {\n\t\tthis.md.update(str);\n\t    };\n\t    this.updateHex = function(hex) {\n\t\tvar baHex = sjcl.codec.hex.toBits(hex);\n\t\tthis.md.update(baHex);\n\t    };\n\t    this.digest = function() {\n\t\tvar hash = this.md.finalize();\n\t\treturn sjcl.codec.hex.fromBits(hash);\n\t    };\n\t    this.digestString = function(str) {\n\t\tthis.updateString(str);\n\t\treturn this.digest();\n\t    };\n\t    this.digestHex = function(hex) {\n\t\tthis.updateHex(hex);\n\t\treturn this.digest();\n\t    };\n\t}\n    };\n\n    /**\n     * update digest by specified string\n     * @name updateString\n     * @memberOf KJUR.crypto.MessageDigest\n     * @function\n     * @param {String} str string to update\n     * @description\n     * @example\n     * md.updateString(\'New York\');\n     */\n    this.updateString = function(str) {\n\tthrow "updateString(str) not supported for this alg/prov: " + this.algName + "/" + this.provName;\n    };\n\n    /**\n     * update digest by specified hexadecimal string\n     * @name updateHex\n     * @memberOf KJUR.crypto.MessageDigest\n     * @function\n     * @param {String} hex hexadecimal string to update\n     * @description\n     * @example\n     * md.updateHex(\'0afe36\');\n     */\n    this.updateHex = function(hex) {\n\tthrow "updateHex(hex) not supported for this alg/prov: " + this.algName + "/" + this.provName;\n    };\n\n    /**\n     * completes hash calculation and returns hash result\n     * @name digest\n     * @memberOf KJUR.crypto.MessageDigest\n     * @function\n     * @description\n     * @example\n     * md.digest()\n     */\n    this.digest = function() {\n\tthrow "digest() not supported for this alg/prov: " + this.algName + "/" + this.provName;\n    };\n\n    /**\n     * performs final update on the digest using string, then completes the digest computation\n     * @name digestString\n     * @memberOf KJUR.crypto.MessageDigest\n     * @function\n     * @param {String} str string to final update\n     * @description\n     * @example\n     * md.digestString(\'aaa\')\n     */\n    this.digestString = function(str) {\n\tthrow "digestString(str) not supported for this alg/prov: " + this.algName + "/" + this.provName;\n    };\n\n    /**\n     * performs final update on the digest using hexadecimal string, then completes the digest computation\n     * @name digestHex\n     * @memberOf KJUR.crypto.MessageDigest\n     * @function\n     * @param {String} hex hexadecimal string to final update\n     * @description\n     * @example\n     * md.digestHex(\'0f2abd\')\n     */\n    this.digestHex = function(hex) {\n\tthrow "digestHex(hex) not supported for this alg/prov: " + this.algName + "/" + this.provName;\n    };\n\n    if (typeof params != "undefined") {\n\tif (typeof params[\'alg\'] != "undefined") {\n\t    this.algName = params[\'alg\'];\n\t    this.provName = params[\'prov\'];\n\t    this.setAlgAndProvider(params[\'alg\'], params[\'prov\']);\n\t}\n    }\n};\n\n\n/**\n * Signature class which is very similar to java.security.Signature class\n * @name KJUR.crypto.Signature\n * @class Signature class which is very similar to java.security.Signature class\n * @param {Array} params parameters for constructor\n * @property {String} state Current state of this signature object whether \'SIGN\', \'VERIFY\' or null\n * @description\n * <br/>\n * As for params of constructor\'s argument, it can be specify following attributes:\n * <ul>\n * <li>alg - signature algorithm name (ex. {MD5,SHA1,SHA224,SHA256,SHA384,SHA512,RIPEMD160}withRSA)</li>\n * <li>provider - currently \'cryptojs/jsrsa\' only</li>\n * <li>prvkeypem - PEM string of signer\'s private key. If this specified, no need to call initSign(prvKey).</li>\n * </ul>\n * <h4>SUPPORTED ALGORITHMS AND PROVIDERS</h4>\n * Signature class supports {MD5,SHA1,SHA224,SHA256,SHA384,SHA512,RIPEMD160}\n * withRSA algorithm in \'cryptojs/jsrsa\' provider.\n * <h4>EXAMPLES</h4>\n * @example\n * // signature generation\n * var sig = new KJUR.crypto.Signature({"alg": "SHA1withRSA", "prov": "cryptojs/jsrsa"});\n * sig.initSign(prvKey);\n * sig.updateString(\'aaa\');\n * var hSigVal = sig.sign();\n *\n * // signature validation\n * var sig2 = new KJUR.crypto.Signature({"alg": "SHA1withRSA", "prov": "cryptojs/jsrsa"});\n * sig2.initVerifyByCertificatePEM(cert)\n * sig.updateString(\'aaa\');\n * var isValid = sig2.verify(hSigVal);\n */\nKJUR.crypto.Signature = function(params) {\n    var prvKey = null; // RSAKey for signing\n    var pubKey = null; // RSAKey for verifying\n\n    var md = null; // KJUR.crypto.MessageDigest object\n    var sig = null;\n    var algName = null;\n    var provName = null;\n    var algProvName = null;\n    var mdAlgName = null;\n    var pubkeyAlgName = null;\n    var state = null;\n\n    var sHashHex = null; // hex hash value for hex\n    var hDigestInfo = null;\n    var hPaddedDigestInfo = null;\n    var hSign = null;\n\n    this._setAlgNames = function() {\n\tif (this.algName.match(/^(.+)with(.+)$/)) {\n\t    this.mdAlgName = RegExp.$1.toLowerCase();\n\t    this.pubkeyAlgName = RegExp.$2.toLowerCase();\n\t}\n    };\n\n    this._zeroPaddingOfSignature = function(hex, bitLength) {\n\tvar s = "";\n\tvar nZero = bitLength / 4 - hex.length;\n\tfor (var i = 0; i < nZero; i++) {\n\t    s = s + "0";\n\t}\n\treturn s + hex;\n    };\n\n    /**\n     * set signature algorithm and provider\n     * @name setAlgAndProvider\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {String} alg signature algorithm name\n     * @param {String} prov provider name\n     * @description\n     * @example\n     * md.setAlgAndProvider(\'SHA1withRSA\', \'cryptojs/jsrsa\');\n     */\n    this.setAlgAndProvider = function(alg, prov) {\n\tthis._setAlgNames();\n\tif (prov != \'cryptojs/jsrsa\')\n\t    throw "provider not supported: " + prov;\n\n\tif (\':md5:sha1:sha224:sha256:sha384:sha512:ripemd160:\'.indexOf(this.mdAlgName) != -1) {\n\t    try {\n\t\tthis.md = new KJUR.crypto.MessageDigest({\'alg\':this.mdAlgName,\'prov\':\'cryptojs\'});\n\t    } catch (ex) {\n\t\tthrow "setAlgAndProvider hash alg set fail alg=" + this.mdAlgName + "/" + ex;\n\t    }\n\n\t    this.initSign = function(prvKey) {\n\t\tthis.prvKey = prvKey;\n\t\tthis.state = "SIGN";\n\t    };\n\n\t    this.initVerifyByPublicKey = function(rsaPubKey) {\n\t\tthis.pubKey = rsaPubKey;\n\t\tthis.state = "VERIFY";\n\t    };\n\n\t    this.initVerifyByCertificatePEM = function(certPEM) {\n\t\tvar x509 = new X509();\n\t\tx509.readCertPEM(certPEM);\n\t\tthis.pubKey = x509.subjectPublicKeyRSA;\n\t\tthis.state = "VERIFY";\n\t    };\n\n\t    this.updateString = function(str) {\n\t\tthis.md.updateString(str);\n\t    };\n\t    this.updateHex = function(hex) {\n\t\tthis.md.updateHex(hex);\n\t    };\n\t    this.sign = function() {\n                var util = KJUR.crypto.Util;\n\t\tvar keyLen = this.prvKey.n.bitLength();\n\t\tthis.sHashHex = this.md.digest();\n\t\tthis.hDigestInfo = util.getDigestInfoHex(this.sHashHex, this.mdAlgName);\n\t\tthis.hPaddedDigestInfo =\n                    util.getPaddedDigestInfoHex(this.sHashHex, this.mdAlgName, keyLen);\n\n\t\tvar biPaddedDigestInfo = parseBigInt(this.hPaddedDigestInfo, 16);\n\t\tthis.hoge = biPaddedDigestInfo.toString(16);\n\n\t\tvar biSign = this.prvKey.doPrivate(biPaddedDigestInfo);\n\t\tthis.hSign = this._zeroPaddingOfSignature(biSign.toString(16), keyLen);\n\t\treturn this.hSign;\n\t    };\n\t    this.signString = function(str) {\n\t\tthis.updateString(str);\n\t\tthis.sign();\n\t    };\n\t    this.signHex = function(hex) {\n\t\tthis.updateHex(hex);\n\t\tthis.sign();\n\t    };\n\t    this.verify = function(hSigVal) {\n                var util = KJUR.crypto.Util;\n\t\tvar keyLen = this.pubKey.n.bitLength();\n\t\tthis.sHashHex = this.md.digest();\n\n\t\tvar biSigVal = parseBigInt(hSigVal, 16);\n\t\tvar biPaddedDigestInfo = this.pubKey.doPublic(biSigVal);\n\t\tthis.hPaddedDigestInfo = biPaddedDigestInfo.toString(16);\n                var s = this.hPaddedDigestInfo;\n                s = s.replace(/^1ff+00/, \'\');\n\n\t\tvar hDIHEAD = KJUR.crypto.Util.DIGESTINFOHEAD[this.mdAlgName];\n                if (s.indexOf(hDIHEAD) != 0) {\n\t\t    return false;\n\t\t}\n\t\tvar hHashFromDI = s.substr(hDIHEAD.length);\n\t\t//alert(hHashFromDI + "\\n" + this.sHashHex);\n\t\treturn (hHashFromDI == this.sHashHex);\n\t    };\n\t}\n    };\n\n    /**\n     * Initialize this object for verifying with a public key\n     * @name initVerifyByPublicKey\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {RSAKey} rsaPubKey RSAKey object of public key\n     * @since 1.0.2\n     * @description\n     * @example\n     * sig.initVerifyByPublicKey(prvKey)\n     */\n    this.initVerifyByPublicKey = function(rsaPubKey) {\n\tthrow "initVerifyByPublicKey(rsaPubKeyy) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * Initialize this object for verifying with a certficate\n     * @name initVerifyByCertificatePEM\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {String} certPEM PEM formatted string of certificate\n     * @since 1.0.2\n     * @description\n     * @example\n     * sig.initVerifyByCertificatePEM(certPEM)\n     */\n    this.initVerifyByCertificatePEM = function(certPEM) {\n\tthrow "initVerifyByCertificatePEM(certPEM) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * Initialize this object for signing\n     * @name initSign\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {RSAKey} prvKey RSAKey object of private key\n     * @description\n     * @example\n     * sig.initSign(prvKey)\n     */\n    this.initSign = function(prvKey) {\n\tthrow "initSign(prvKey) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * Updates the data to be signed or verified by a string\n     * @name updateString\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {String} str string to use for the update\n     * @description\n     * @example\n     * sig.updateString(\'aaa\')\n     */\n    this.updateString = function(str) {\n\tthrow "updateString(str) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * Updates the data to be signed or verified by a hexadecimal string\n     * @name updateHex\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {String} hex hexadecimal string to use for the update\n     * @description\n     * @example\n     * sig.updateHex(\'1f2f3f\')\n     */\n    this.updateHex = function(hex) {\n\tthrow "updateHex(hex) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * Returns the signature bytes of all data updates as a hexadecimal string\n     * @name sign\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @return the signature bytes as a hexadecimal string\n     * @description\n     * @example\n     * var hSigValue = sig.sign()\n     */\n    this.sign = function() {\n\tthrow "sign() not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * performs final update on the sign using string, then returns the signature bytes of all data updates as a hexadecimal string\n     * @name signString\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {String} str string to final update\n     * @return the signature bytes of a hexadecimal string\n     * @description\n     * @example\n     * var hSigValue = sig.signString(\'aaa\')\n     */\n    this.signString = function(str) {\n\tthrow "digestString(str) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * performs final update on the sign using hexadecimal string, then returns the signature bytes of all data updates as a hexadecimal string\n     * @name signHex\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {String} hex hexadecimal string to final update\n     * @return the signature bytes of a hexadecimal string\n     * @description\n     * @example\n     * var hSigValue = sig.signHex(\'1fdc33\')\n     */\n    this.signHex = function(hex) {\n\tthrow "digestHex(hex) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    /**\n     * verifies the passed-in signature.\n     * @name verify\n     * @memberOf KJUR.crypto.Signature\n     * @function\n     * @param {String} str string to final update\n     * @return {Boolean} true if the signature was verified, otherwise false\n     * @description\n     * @example\n     * var isValid = sig.verify(\'1fbcefdca4823a7(snip)\')\n     */\n    this.verify = function(hSigVal) {\n\tthrow "verify(hSigVal) not supported for this alg:prov=" + this.algProvName;\n    };\n\n    if (typeof params != "undefined") {\n\tif (typeof params[\'alg\'] != "undefined") {\n\t    this.algName = params[\'alg\'];\n\t    this.provName = params[\'prov\'];\n\t    this.algProvName = params[\'alg\'] + ":" + params[\'prov\'];\n\t    this.setAlgAndProvider(params[\'alg\'], params[\'prov\']);\n\t    this._setAlgNames();\n\t}\n\tif (typeof params[\'prvkeypem\'] != "undefined") {\n\t    if (typeof params[\'prvkeypas\'] != "undefined") {\n\t\tthrow "both prvkeypem and prvkeypas parameters not supported";\n\t    } else {\n\t\ttry {\n\t\t    var prvKey = new RSAKey();\n\t\t    prvKey.readPrivateKeyFromPEMString(params[\'prvkeypem\']);\n\t\t    this.initSign(prvKey);\n\t\t} catch (ex) {\n\t\t    throw "fatal error to load pem private key: " + ex;\n\t\t}\n\t    }\n\t}\n    }\n};\n\n/*! rsapem-1.1.js (c) 2012 Kenji Urushima | kjur.github.com/jsrsasign/license\n */\n//\n// rsa-pem.js - adding function for reading/writing PKCS#1 PEM private key\n//              to RSAKey class.\n//\n// version: 1.1.1 (2013-Apr-12)\n//\n// Copyright (c) 2010-2013 Kenji Urushima (kenji.urushima@gmail.com)\n//\n// This software is licensed under the terms of the MIT License.\n// http://kjur.github.com/jsrsasign/license/\n//\n// The above copyright and license notice shall be\n// included in all copies or substantial portions of the Software.\n//\n//\n// Depends on:\n//\n//\n//\n// _RSApem_pemToBase64(sPEM)\n//\n//   removing PEM header, PEM footer and space characters including\n//   new lines from PEM formatted RSA private key string.\n//\n\n/**\n * @fileOverview\n * @name rsapem-1.1.js\n * @author Kenji Urushima kenji.urushima@gmail.com\n * @version 1.1\n * @license <a href="http://kjur.github.io/jsrsasign/license/">MIT License</a>\n */\nfunction _rsapem_pemToBase64(sPEMPrivateKey) {\n  var s = sPEMPrivateKey;\n  s = s.replace("-----BEGIN RSA PRIVATE KEY-----", "");\n  s = s.replace("-----END RSA PRIVATE KEY-----", "");\n  s = s.replace(/[ \\n]+/g, "");\n  return s;\n}\n\nfunction _rsapem_getPosArrayOfChildrenFromHex(hPrivateKey) {\n  var a = new Array();\n  var v1 = ASN1HEX.getStartPosOfV_AtObj(hPrivateKey, 0);\n  var n1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, v1);\n  var e1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, n1);\n  var d1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, e1);\n  var p1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, d1);\n  var q1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, p1);\n  var dp1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, q1);\n  var dq1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, dp1);\n  var co1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, dq1);\n  a.push(v1, n1, e1, d1, p1, q1, dp1, dq1, co1);\n  return a;\n}\n\nfunction _rsapem_getHexValueArrayOfChildrenFromHex(hPrivateKey) {\n  var posArray = _rsapem_getPosArrayOfChildrenFromHex(hPrivateKey);\n  var v =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[0]);\n  var n =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[1]);\n  var e =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[2]);\n  var d =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[3]);\n  var p =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[4]);\n  var q =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[5]);\n  var dp = ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[6]);\n  var dq = ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[7]);\n  var co = ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[8]);\n  var a = new Array();\n  a.push(v, n, e, d, p, q, dp, dq, co);\n  return a;\n}\n\n/**\n * read RSA private key from a ASN.1 hexadecimal string\n * @name readPrivateKeyFromASN1HexString\n * @memberOf RSAKey#\n * @function\n * @param {String} keyHex ASN.1 hexadecimal string of PKCS#1 private key.\n * @since 1.1.1\n */\nfunction _rsapem_readPrivateKeyFromASN1HexString(keyHex) {\n  var a = _rsapem_getHexValueArrayOfChildrenFromHex(keyHex);\n  this.setPrivateEx(a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);\n}\n\n/**\n * read PKCS#1 private key from a string\n * @name readPrivateKeyFromPEMString\n * @memberOf RSAKey#\n * @function\n * @param {String} keyPEM string of PKCS#1 private key.\n */\nfunction _rsapem_readPrivateKeyFromPEMString(keyPEM) {\n  var keyB64 = _rsapem_pemToBase64(keyPEM);\n  var keyHex = b64tohex(keyB64) // depends base64.js\n  var a = _rsapem_getHexValueArrayOfChildrenFromHex(keyHex);\n  this.setPrivateEx(a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);\n}\n\nRSAKey.prototype.readPrivateKeyFromPEMString = _rsapem_readPrivateKeyFromPEMString;\nRSAKey.prototype.readPrivateKeyFromASN1HexString = _rsapem_readPrivateKeyFromASN1HexString;\n/*! rsasign-1.2.2.js (c) 2012 Kenji Urushima | kjur.github.com/jsrsasign/license\n */\n//\n// rsa-sign.js - adding signing functions to RSAKey class.\n//\n//\n// version: 1.2.2 (13 May 2013)\n//\n// Copyright (c) 2010-2013 Kenji Urushima (kenji.urushima@gmail.com)\n//\n// This software is licensed under the terms of the MIT License.\n// http://kjur.github.com/jsrsasign/license/\n//\n// The above copyright and license notice shall be\n// included in all copies or substantial portions of the Software.\n\n//\n// Depends on:\n//   function sha1.hex(s) of sha1.js\n//   jsbn.js\n//   jsbn2.js\n//   rsa.js\n//   rsa2.js\n//\n\n// keysize / pmstrlen\n//  512 /  128\n// 1024 /  256\n// 2048 /  512\n// 4096 / 1024\n\n/**\n * @fileOverview\n * @name rsasign-1.2.js\n * @author Kenji Urushima kenji.urushima@gmail.com\n * @version 1.2.2\n * @license <a href="http://kjur.github.io/jsrsasign/license/">MIT License</a>\n */\n\n/**\n * @property {Dictionary} _RSASIGN_DIHEAD\n * @description Array of head part of hexadecimal DigestInfo value for hash algorithms.\n * You can add any DigestInfo hash algorith for signing.\n * See PKCS#1 v2.1 spec (p38).\n */\nvar _RSASIGN_DIHEAD = [];\n_RSASIGN_DIHEAD[\'sha1\'] =      "3021300906052b0e03021a05000414";\n_RSASIGN_DIHEAD[\'sha256\'] =    "3031300d060960864801650304020105000420";\n_RSASIGN_DIHEAD[\'sha384\'] =    "3041300d060960864801650304020205000430";\n_RSASIGN_DIHEAD[\'sha512\'] =    "3051300d060960864801650304020305000440";\n_RSASIGN_DIHEAD[\'md2\'] =       "3020300c06082a864886f70d020205000410";\n_RSASIGN_DIHEAD[\'md5\'] =       "3020300c06082a864886f70d020505000410";\n_RSASIGN_DIHEAD[\'ripemd160\'] = "3021300906052b2403020105000414";\n\n/**\n * @property {Dictionary} _RSASIGN_HASHHEXFUNC\n * @description Array of functions which calculate hash and returns it as hexadecimal.\n * You can add any hash algorithm implementations.\n */\nvar _RSASIGN_HASHHEXFUNC = [];\n_RSASIGN_HASHHEXFUNC[\'sha1\'] =      function(s){return KJUR.crypto.Util.sha1(s);};\n_RSASIGN_HASHHEXFUNC[\'sha256\'] =    function(s){return KJUR.crypto.Util.sha256(s);}\n_RSASIGN_HASHHEXFUNC[\'sha512\'] =    function(s){return KJUR.crypto.Util.sha512(s);}\n_RSASIGN_HASHHEXFUNC[\'md5\'] =       function(s){return KJUR.crypto.Util.md5(s);};\n_RSASIGN_HASHHEXFUNC[\'ripemd160\'] = function(s){return KJUR.crypto.Util.ripemd160(s);};\n\n//_RSASIGN_HASHHEXFUNC[\'sha1\'] =   function(s){return sha1.hex(s);}   // http://user1.matsumoto.ne.jp/~goma/js/hash.html\n//_RSASIGN_HASHHEXFUNC[\'sha256\'] = function(s){return sha256.hex;}    // http://user1.matsumoto.ne.jp/~goma/js/hash.html\n\nvar _RE_HEXDECONLY = new RegExp("");\n_RE_HEXDECONLY.compile("[^0-9a-f]", "gi");\n\n// ========================================================================\n// Signature Generation\n// ========================================================================\n\nfunction _rsasign_getHexPaddedDigestInfoForString(s, keySize, hashAlg) {\n    var pmStrLen = keySize / 4;\n    var hashFunc = _RSASIGN_HASHHEXFUNC[hashAlg];\n    var sHashHex = hashFunc(s);\n\n    var sHead = "0001";\n    var sTail = "00" + _RSASIGN_DIHEAD[hashAlg] + sHashHex;\n    var sMid = "";\n    var fLen = pmStrLen - sHead.length - sTail.length;\n    for (var i = 0; i < fLen; i += 2) {\n\tsMid += "ff";\n    }\n    sPaddedMessageHex = sHead + sMid + sTail;\n    return sPaddedMessageHex;\n}\n\nfunction _zeroPaddingOfSignature(hex, bitLength) {\n    var s = "";\n    var nZero = bitLength / 4 - hex.length;\n    for (var i = 0; i < nZero; i++) {\n\ts = s + "0";\n    }\n    return s + hex;\n}\n\n/**\n * sign for a message string with RSA private key.<br/>\n * @name signString\n * @memberOf RSAKey#\n * @function\n * @param {String} s message string to be signed.\n * @param {String} hashAlg hash algorithm name for signing.<br/>\n * @return returns hexadecimal string of signature value.\n */\nfunction _rsasign_signString(s, hashAlg) {\n    //alert("this.n.bitLength() = " + this.n.bitLength());\n    var hPM = _rsasign_getHexPaddedDigestInfoForString(s, this.n.bitLength(), hashAlg);\n    var biPaddedMessage = parseBigInt(hPM, 16);\n    var biSign = this.doPrivate(biPaddedMessage);\n    var hexSign = biSign.toString(16);\n    return _zeroPaddingOfSignature(hexSign, this.n.bitLength());\n}\n\nfunction _rsasign_signStringWithSHA1(s) {\n    return _rsasign_signString.call(this, s, \'sha1\');\n}\n\nfunction _rsasign_signStringWithSHA256(s) {\n    return _rsasign_signString.call(this, s, \'sha256\');\n}\n\n// PKCS#1 (PSS) mask generation function\nfunction pss_mgf1_str(seed, len, hash) {\n    var mask = \'\', i = 0;\n\n    while (mask.length < len) {\n        mask += hash(seed + String.fromCharCode.apply(String, [\n                (i & 0xff000000) >> 24,\n                (i & 0x00ff0000) >> 16,\n                (i & 0x0000ff00) >> 8,\n                i & 0x000000ff]));\n        i += 1;\n    }\n\n    return mask;\n}\n\n/**\n * sign for a message string with RSA private key by PKCS#1 PSS signing.<br/>\n * @name signStringPSS\n * @memberOf RSAKey#\n * @function\n * @param {String} s message string to be signed.\n * @param {String} hashAlg hash algorithm name for signing.<br/>\n * @return returns hexadecimal string of signature value.\n */\nfunction _rsasign_signStringPSS(s, hashAlg, sLen) {\n    var hashFunc = _RSASIGN_HASHRAWFUNC[hashAlg];\n    var mHash = hashFunc(s);\n    var hLen = mHash.length;\n    var emBits = this.n.bitLength() - 1;\n    var emLen = Math.ceil(emBits / 8);\n    var i;\n\n    if (sLen === -1) {\n        sLen = hLen; // same has hash length\n    } else if ((sLen === -2) || (sLen === undefined)) {\n        sLen = emLen - hLen - 2; // maximum\n    } else if (sLen < -2) {\n        throw "invalid salt length";\n    }\n\n    if (emLen < (hLen + sLen + 2)) {\n        throw "data too long";\n    }\n\n    var salt = \'\';\n\n    if (sLen > 0) {\n        salt = new Array(sLen);\n        new SecureRandom().nextBytes(salt);\n        salt = String.fromCharCode.apply(String, salt);\n    }\n\n    var H = hashFunc(\'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\' + mHash + salt);\n    var PS = [];\n\n    for (i = 0; i < emLen - sLen - hLen - 2; i += 1) {\n        PS[i] = 0x00;\n    }\n\n    var DB = String.fromCharCode.apply(String, PS) + \'\\x01\' + salt;\n    var dbMask = pss_mgf1_str(H, DB.length, hashFunc);\n    var maskedDB = [];\n\n    for (i = 0; i < DB.length; i += 1) {\n        maskedDB[i] = DB.charCodeAt(i) ^ dbMask.charCodeAt(i);\n    }\n\n    var mask = (0xff00 >> (8 * emLen - emBits)) & 0xff;\n    maskedDB[0] &= ~mask;\n\n    for (i = 0; i < hLen; i++) {\n        maskedDB.push(H.charCodeAt(i));\n    }\n\n    maskedDB.push(0xbc);\n\n    return _zeroPaddingOfSignature(\n            this.doPrivate(new BigInteger(maskedDB)).toString(16),\n            this.n.bitLength());\n}\n\n// ========================================================================\n// Signature Verification\n// ========================================================================\n\nfunction _rsasign_getDecryptSignatureBI(biSig, hN, hE) {\n    var rsa = new RSAKey();\n    rsa.setPublic(hN, hE);\n    var biDecryptedSig = rsa.doPublic(biSig);\n    return biDecryptedSig;\n}\n\nfunction _rsasign_getHexDigestInfoFromSig(biSig, hN, hE) {\n    var biDecryptedSig = _rsasign_getDecryptSignatureBI(biSig, hN, hE);\n    var hDigestInfo = biDecryptedSig.toString(16).replace(/^1f+00/, \'\');\n    return hDigestInfo;\n}\n\nfunction _rsasign_getAlgNameAndHashFromHexDisgestInfo(hDigestInfo) {\n    for (var algName in _RSASIGN_DIHEAD) {\n\tvar head = _RSASIGN_DIHEAD[algName];\n\tvar len = head.length;\n\tif (hDigestInfo.substring(0, len) == head) {\n\t    var a = [algName, hDigestInfo.substring(len)];\n\t    return a;\n\t}\n    }\n    return [];\n}\n\nfunction _rsasign_verifySignatureWithArgs(sMsg, biSig, hN, hE) {\n    var hDigestInfo = _rsasign_getHexDigestInfoFromSig(biSig, hN, hE);\n    var digestInfoAry = _rsasign_getAlgNameAndHashFromHexDisgestInfo(hDigestInfo);\n    if (digestInfoAry.length == 0) return false;\n    var algName = digestInfoAry[0];\n    var diHashValue = digestInfoAry[1];\n    var ff = _RSASIGN_HASHHEXFUNC[algName];\n    var msgHashValue = ff(sMsg);\n    return (diHashValue == msgHashValue);\n}\n\nfunction _rsasign_verifyHexSignatureForMessage(hSig, sMsg) {\n    var biSig = parseBigInt(hSig, 16);\n    var result = _rsasign_verifySignatureWithArgs(sMsg, biSig,\n\t\t\t\t\t\t  this.n.toString(16),\n\t\t\t\t\t\t  this.e.toString(16));\n    return result;\n}\n\n/**\n * verifies a sigature for a message string with RSA public key.<br/>\n * @name verifyString\n * @memberOf RSAKey#\n * @function\n * @param {String} sMsg message string to be verified.\n * @param {String} hSig hexadecimal string of siganture.<br/>\n *                 non-hexadecimal charactors including new lines will be ignored.\n * @return returns 1 if valid, otherwise 0\n */\nfunction _rsasign_verifyString(sMsg, hSig) {\n    hSig = hSig.replace(_RE_HEXDECONLY, \'\');\n    if (hSig.length != this.n.bitLength() / 4) return 0;\n    hSig = hSig.replace(/[ \\n]+/g, "");\n    var biSig = parseBigInt(hSig, 16);\n    var biDecryptedSig = this.doPublic(biSig);\n    var hDigestInfo = biDecryptedSig.toString(16).replace(/^1f+00/, \'\');\n    var digestInfoAry = _rsasign_getAlgNameAndHashFromHexDisgestInfo(hDigestInfo);\n\n    if (digestInfoAry.length == 0) return false;\n    var algName = digestInfoAry[0];\n    var diHashValue = digestInfoAry[1];\n    var ff = _RSASIGN_HASHHEXFUNC[algName];\n    var msgHashValue = ff(sMsg);\n    return (diHashValue == msgHashValue);\n}\n\n/**\n * verifies a sigature for a message string with RSA public key by PKCS#1 PSS sign.<br/>\n * @name verifyStringPSS\n * @memberOf RSAKey#\n * @function\n * @param {String} sMsg message string to be verified.\n * @param {String} hSig hexadecimal string of siganture.<br/>\n *                 non-hexadecimal charactors including new lines will be ignored.\n * @return returns 1 if valid, otherwise 0\n */\nfunction _rsasign_verifyStringPSS(sMsg, hSig, hashAlg, sLen) {\n    if (hSig.length !== this.n.bitLength() / 4) {\n        return false;\n    }\n\n    var hashFunc = _RSASIGN_HASHRAWFUNC[hashAlg];\n    var mHash = hashFunc(sMsg);\n    var hLen = mHash.length;\n    var emBits = this.n.bitLength() - 1;\n    var emLen = Math.ceil(emBits / 8);\n    var i;\n\n    if (sLen === -1) {\n        sLen = hLen; // same has hash length\n    } else if ((sLen === -2) || (sLen === undefined)) {\n        sLen = emLen - hLen - 2; // maximum\n    } else if (sLen < -2) {\n        throw "invalid salt length";\n    }\n\n    if (emLen < (hLen + sLen + 2)) {\n        throw "data too long";\n    }\n\n    var em = this.doPublic(parseBigInt(hSig, 16)).toByteArray();\n\n    for (i = 0; i < em.length; i += 1) {\n        em[i] &= 0xff;\n    }\n\n    while (em.length < emLen) {\n        em.unshift(0);\n    }\n\n    if (em[emLen -1] !== 0xbc) {\n        throw "encoded message does not end in 0xbc";\n    }\n\n    em = String.fromCharCode.apply(String, em);\n\n    var maskedDB = em.substr(0, emLen - hLen - 1);\n    var H = em.substr(maskedDB.length, hLen);\n\n    var mask = (0xff00 >> (8 * emLen - emBits)) & 0xff;\n\n    if ((maskedDB.charCodeAt(0) & mask) !== 0) {\n        throw "bits beyond keysize not zero";\n    }\n\n    var dbMask = pss_mgf1_str(H, maskedDB.length, hashFunc);\n    var DB = [];\n\n    for (i = 0; i < maskedDB.length; i += 1) {\n        DB[i] = maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i);\n    }\n\n    DB[0] &= ~mask;\n\n    var checkLen = emLen - hLen - sLen - 2;\n\n    for (i = 0; i < checkLen; i += 1) {\n        if (DB[i] !== 0x00) {\n            throw "leftmost octets not zero";\n        }\n    }\n\n    if (DB[checkLen] !== 0x01) {\n        throw "0x01 marker not found";\n    }\n\n    return H === hashFunc(\'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\' + mHash +\n                          String.fromCharCode.apply(String, DB.slice(-sLen)));\n}\n\nRSAKey.prototype.signString = _rsasign_signString;\nRSAKey.prototype.signStringWithSHA1 = _rsasign_signStringWithSHA1;\nRSAKey.prototype.signStringWithSHA256 = _rsasign_signStringWithSHA256;\nRSAKey.prototype.sign = _rsasign_signString;\nRSAKey.prototype.signWithSHA1 = _rsasign_signStringWithSHA1;\nRSAKey.prototype.signWithSHA256 = _rsasign_signStringWithSHA256;\nRSAKey.prototype.signStringPSS = _rsasign_signStringPSS;\nRSAKey.prototype.signPSS = _rsasign_signStringPSS;\nRSAKey.SALT_LEN_HLEN = -1;\nRSAKey.SALT_LEN_MAX = -2;\n\nRSAKey.prototype.verifyString = _rsasign_verifyString;\nRSAKey.prototype.verifyHexSignatureForMessage = _rsasign_verifyHexSignatureForMessage;\nRSAKey.prototype.verify = _rsasign_verifyString;\nRSAKey.prototype.verifyHexSignatureForByteArrayMessage = _rsasign_verifyHexSignatureForMessage;\nRSAKey.prototype.verifyStringPSS = _rsasign_verifyStringPSS;\nRSAKey.prototype.verifyPSS = _rsasign_verifyStringPSS;\nRSAKey.SALT_LEN_RECOVER = -2;\n\n/**\n * @name RSAKey\n * @class key of RSA public key algorithm\n * @description Tom Wu\'s RSA Key class and extension\n */\n/*! asn1hex-1.1.js (c) 2012 Kenji Urushima | kjur.github.com/jsrsasign/license\n */\n//\n// asn1hex.js - Hexadecimal represented ASN.1 string library\n//\n// version: 1.1 (09-May-2012)\n//\n// Copyright (c) 2010-2012 Kenji Urushima (kenji.urushima@gmail.com)\n//\n// This software is licensed under the terms of the MIT License.\n// http://kjur.github.com/jsrsasign/license/\n//\n// The above copyright and license notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// Depends on:\n//\n\n// MEMO:\n//   f(\'3082025b02...\', 2) ... 82025b ... 3bytes\n//   f(\'020100\', 2) ... 01 ... 1byte\n//   f(\'0203001...\', 2) ... 03 ... 1byte\n//   f(\'02818003...\', 2) ... 8180 ... 2bytes\n//   f(\'3080....0000\', 2) ... 80 ... -1\n//\n//   Requirements:\n//   - ASN.1 type octet length MUST be 1.\n//     (i.e. ASN.1 primitives like SET, SEQUENCE, INTEGER, OCTETSTRING ...)\n//   -\n\n/**\n * @fileOverview\n * @name asn1hex-1.1.js\n * @author Kenji Urushima kenji.urushima@gmail.com\n * @version 1.1\n * @license <a href="http://kjur.github.io/jsrsasign/license/">MIT License</a>\n */\n\n/**\n * get byte length for ASN.1 L(length) bytes\n * @name getByteLengthOfL_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} pos string index\n * @return byte length for ASN.1 L(length) bytes\n */\nfunction _asnhex_getByteLengthOfL_AtObj(s, pos) {\n  if (s.substring(pos + 2, pos + 3) != \'8\') return 1;\n  var i = parseInt(s.substring(pos + 3, pos + 4));\n  if (i == 0) return -1; \t\t// length octet \'80\' indefinite length\n  if (0 < i && i < 10) return i + 1;\t// including \'8?\' octet;\n  return -2;\t\t\t\t// malformed format\n}\n\n\n/**\n * get hexadecimal string for ASN.1 L(length) bytes\n * @name getHexOfL_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} pos string index\n * @return {String} hexadecimal string for ASN.1 L(length) bytes\n */\nfunction _asnhex_getHexOfL_AtObj(s, pos) {\n  var len = _asnhex_getByteLengthOfL_AtObj(s, pos);\n  if (len < 1) return \'\';\n  return s.substring(pos + 2, pos + 2 + len * 2);\n}\n\n//\n//   getting ASN.1 length value at the position \'idx\' of\n//   hexa decimal string \'s\'.\n//\n//   f(\'3082025b02...\', 0) ... 82025b ... ???\n//   f(\'020100\', 0) ... 01 ... 1\n//   f(\'0203001...\', 0) ... 03 ... 3\n//   f(\'02818003...\', 0) ... 8180 ... 128\n/**\n * get integer value of ASN.1 length for ASN.1 data\n * @name getIntOfL_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} pos string index\n * @return ASN.1 L(length) integer value\n */\nfunction _asnhex_getIntOfL_AtObj(s, pos) {\n  var hLength = _asnhex_getHexOfL_AtObj(s, pos);\n  if (hLength == \'\') return -1;\n  var bi;\n  if (parseInt(hLength.substring(0, 1)) < 8) {\n     bi = parseBigInt(hLength, 16);\n  } else {\n     bi = parseBigInt(hLength.substring(2), 16);\n  }\n  return bi.intValue();\n}\n\n/**\n * get ASN.1 value starting string position for ASN.1 object refered by index \'idx\'.\n * @name getStartPosOfV_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} pos string index\n */\nfunction _asnhex_getStartPosOfV_AtObj(s, pos) {\n  var l_len = _asnhex_getByteLengthOfL_AtObj(s, pos);\n  if (l_len < 0) return l_len;\n  return pos + (l_len + 1) * 2;\n}\n\n/**\n * get hexadecimal string of ASN.1 V(value)\n * @name getHexOfV_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} pos string index\n * @return {String} hexadecimal string of ASN.1 value.\n */\nfunction _asnhex_getHexOfV_AtObj(s, pos) {\n  var pos1 = _asnhex_getStartPosOfV_AtObj(s, pos);\n  var len = _asnhex_getIntOfL_AtObj(s, pos);\n  return s.substring(pos1, pos1 + len * 2);\n}\n\n/**\n * get hexadecimal string of ASN.1 TLV at\n * @name getHexOfTLV_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} pos string index\n * @return {String} hexadecimal string of ASN.1 TLV.\n * @since 1.1\n */\nfunction _asnhex_getHexOfTLV_AtObj(s, pos) {\n  var hT = s.substr(pos, 2);\n  var hL = _asnhex_getHexOfL_AtObj(s, pos);\n  var hV = _asnhex_getHexOfV_AtObj(s, pos);\n  return hT + hL + hV;\n}\n\n/**\n * get next sibling starting index for ASN.1 object string\n * @name getPosOfNextSibling_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} pos string index\n * @return next sibling starting index for ASN.1 object string\n */\nfunction _asnhex_getPosOfNextSibling_AtObj(s, pos) {\n  var pos1 = _asnhex_getStartPosOfV_AtObj(s, pos);\n  var len = _asnhex_getIntOfL_AtObj(s, pos);\n  return pos1 + len * 2;\n}\n\n/**\n * get array of indexes of child ASN.1 objects\n * @name getPosArrayOfChildren_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} s hexadecimal string of ASN.1 DER encoded data\n * @param {Number} start string index of ASN.1 object\n * @return {Array of Number} array of indexes for childen of ASN.1 objects\n */\nfunction _asnhex_getPosArrayOfChildren_AtObj(h, pos) {\n  var a = new Array();\n  var p0 = _asnhex_getStartPosOfV_AtObj(h, pos);\n  a.push(p0);\n\n  var len = _asnhex_getIntOfL_AtObj(h, pos);\n  var p = p0;\n  var k = 0;\n  while (1) {\n    var pNext = _asnhex_getPosOfNextSibling_AtObj(h, p);\n    if (pNext == null || (pNext - p0  >= (len * 2))) break;\n    if (k >= 200) break;\n\n    a.push(pNext);\n    p = pNext;\n\n    k++;\n  }\n\n  return a;\n}\n\n/**\n * get string index of nth child object of ASN.1 object refered by h, idx\n * @name getNthChildIndex_AtObj\n * @memberOf ASN1HEX\n * @function\n * @param {String} h hexadecimal string of ASN.1 DER encoded data\n * @param {Number} idx start string index of ASN.1 object\n * @param {Number} nth for child\n * @return {Number} string index of nth child.\n * @since 1.1\n */\nfunction _asnhex_getNthChildIndex_AtObj(h, idx, nth) {\n  var a = _asnhex_getPosArrayOfChildren_AtObj(h, idx);\n  return a[nth];\n}\n\n// ========== decendant methods ==============================\n\n/**\n * get string index of nth child object of ASN.1 object refered by h, idx\n * @name getDecendantIndexByNthList\n * @memberOf ASN1HEX\n * @function\n * @param {String} h hexadecimal string of ASN.1 DER encoded data\n * @param {Number} currentIndex start string index of ASN.1 object\n * @param {Array of Number} nthList array list of nth\n * @return {Number} string index refered by nthList\n * @since 1.1\n */\nfunction _asnhex_getDecendantIndexByNthList(h, currentIndex, nthList) {\n  if (nthList.length == 0) {\n    return currentIndex;\n  }\n  var firstNth = nthList.shift();\n  var a = _asnhex_getPosArrayOfChildren_AtObj(h, currentIndex);\n  return _asnhex_getDecendantIndexByNthList(h, a[firstNth], nthList);\n}\n\n/**\n * get hexadecimal string of ASN.1 TLV refered by current index and nth index list.\n * @name getDecendantHexTLVByNthList\n * @memberOf ASN1HEX\n * @function\n * @param {String} h hexadecimal string of ASN.1 DER encoded data\n * @param {Number} currentIndex start string index of ASN.1 object\n * @param {Array of Number} nthList array list of nth\n * @return {Number} hexadecimal string of ASN.1 TLV refered by nthList\n * @since 1.1\n */\nfunction _asnhex_getDecendantHexTLVByNthList(h, currentIndex, nthList) {\n  var idx = _asnhex_getDecendantIndexByNthList(h, currentIndex, nthList);\n  return _asnhex_getHexOfTLV_AtObj(h, idx);\n}\n\n/**\n * get hexadecimal string of ASN.1 V refered by current index and nth index list.\n * @name getDecendantHexVByNthList\n * @memberOf ASN1HEX\n * @function\n * @param {String} h hexadecimal string of ASN.1 DER encoded data\n * @param {Number} currentIndex start string index of ASN.1 object\n * @param {Array of Number} nthList array list of nth\n * @return {Number} hexadecimal string of ASN.1 V refered by nthList\n * @since 1.1\n */\nfunction _asnhex_getDecendantHexVByNthList(h, currentIndex, nthList) {\n  var idx = _asnhex_getDecendantIndexByNthList(h, currentIndex, nthList);\n  return _asnhex_getHexOfV_AtObj(h, idx);\n}\n\n// ========== class definition ==============================\n\n/**\n * ASN.1 DER encoded hexadecimal string utility class\n * @class ASN.1 DER encoded hexadecimal string utility class\n * @author Kenji Urushima\n * @version 1.1 (09 May 2012)\n * @see <a href="http://kjur.github.com/jsrsasigns/">\'jwrsasign\'(RSA Sign JavaScript Library) home page http://kjur.github.com/jsrsasign/</a>\n * @since 1.1\n */\nfunction ASN1HEX() {\n  return ASN1HEX;\n}\n\nASN1HEX.getByteLengthOfL_AtObj = _asnhex_getByteLengthOfL_AtObj;\nASN1HEX.getHexOfL_AtObj = _asnhex_getHexOfL_AtObj;\nASN1HEX.getIntOfL_AtObj = _asnhex_getIntOfL_AtObj;\nASN1HEX.getStartPosOfV_AtObj = _asnhex_getStartPosOfV_AtObj;\nASN1HEX.getHexOfV_AtObj = _asnhex_getHexOfV_AtObj;\nASN1HEX.getHexOfTLV_AtObj = _asnhex_getHexOfTLV_AtObj;\nASN1HEX.getPosOfNextSibling_AtObj = _asnhex_getPosOfNextSibling_AtObj;\nASN1HEX.getPosArrayOfChildren_AtObj = _asnhex_getPosArrayOfChildren_AtObj;\nASN1HEX.getNthChildIndex_AtObj = _asnhex_getNthChildIndex_AtObj;\nASN1HEX.getDecendantIndexByNthList = _asnhex_getDecendantIndexByNthList;\nASN1HEX.getDecendantHexVByNthList = _asnhex_getDecendantHexVByNthList;\nASN1HEX.getDecendantHexTLVByNthList = _asnhex_getDecendantHexTLVByNthList;\n/*! x509-1.1.js (c) 2012 Kenji Urushima | kjur.github.com/jsrsasign/license\n */\n//\n// x509.js - X509 class to read subject public key from certificate.\n//\n// version: 1.1 (10-May-2012)\n//\n// Copyright (c) 2010-2012 Kenji Urushima (kenji.urushima@gmail.com)\n//\n// This software is licensed under the terms of the MIT License.\n// http://kjur.github.com/jsrsasign/license\n//\n// The above copyright and license notice shall be\n// included in all copies or substantial portions of the Software.\n//\n\n// Depends:\n//   base64.js\n//   rsa.js\n//   asn1hex.js\n\n/**\n * @fileOverview\n * @name x509-1.1.js\n * @author Kenji Urushima kenji.urushima@gmail.com\n * @version 1.1\n * @license <a href="http://kjur.github.io/jsrsasign/license/">MIT License</a>\n */\n\nfunction _x509_pemToBase64(sCertPEM) {\n  var s = sCertPEM;\n  s = s.replace("-----BEGIN CERTIFICATE-----", "");\n  s = s.replace("-----END CERTIFICATE-----", "");\n  s = s.replace(/[ \\n]+/g, "");\n  return s;\n}\n\nfunction _x509_pemToHex(sCertPEM) {\n  var b64Cert = _x509_pemToBase64(sCertPEM);\n  var hCert = b64tohex(b64Cert);\n  return hCert;\n}\n\nfunction _x509_getHexTbsCertificateFromCert(hCert) {\n  var pTbsCert = ASN1HEX.getStartPosOfV_AtObj(hCert, 0);\n  return pTbsCert;\n}\n\n// NOTE: privateKeyUsagePeriod field of X509v2 not supported.\n// NOTE: v1 and v3 supported\nfunction _x509_getSubjectPublicKeyInfoPosFromCertHex(hCert) {\n  var pTbsCert = ASN1HEX.getStartPosOfV_AtObj(hCert, 0);\n  var a = ASN1HEX.getPosArrayOfChildren_AtObj(hCert, pTbsCert);\n  if (a.length < 1) return -1;\n  if (hCert.substring(a[0], a[0] + 10) == "a003020102") { // v3\n    if (a.length < 6) return -1;\n    return a[6];\n  } else {\n    if (a.length < 5) return -1;\n    return a[5];\n  }\n}\n\n// NOTE: Without BITSTRING encapsulation.\nfunction _x509_getSubjectPublicKeyPosFromCertHex(hCert) {\n  var pInfo = _x509_getSubjectPublicKeyInfoPosFromCertHex(hCert);\n  if (pInfo == -1) return -1;\n  var a = ASN1HEX.getPosArrayOfChildren_AtObj(hCert, pInfo);\n  if (a.length != 2) return -1;\n  var pBitString = a[1];\n  if (hCert.substring(pBitString, pBitString + 2) != \'03\') return -1;\n  var pBitStringV = ASN1HEX.getStartPosOfV_AtObj(hCert, pBitString);\n\n  if (hCert.substring(pBitStringV, pBitStringV + 2) != \'00\') return -1;\n  return pBitStringV + 2;\n}\n\nfunction _x509_getPublicKeyHexArrayFromCertHex(hCert) {\n  var p = _x509_getSubjectPublicKeyPosFromCertHex(hCert);\n  var a = ASN1HEX.getPosArrayOfChildren_AtObj(hCert, p);\n  if (a.length != 2) return [];\n  var hN = ASN1HEX.getHexOfV_AtObj(hCert, a[0]);\n  var hE = ASN1HEX.getHexOfV_AtObj(hCert, a[1]);\n  if (hN != null && hE != null) {\n    return [hN, hE];\n  } else {\n    return [];\n  }\n}\n\nfunction _x509_getPublicKeyHexArrayFromCertPEM(sCertPEM) {\n  var hCert = _x509_pemToHex(sCertPEM);\n  var a = _x509_getPublicKeyHexArrayFromCertHex(hCert);\n  return a;\n}\n\n// ===== get basic fields from hex =====================================\n/**\n * get hexadecimal string of serialNumber field of certificate.<br/>\n * @name getSerialNumberHex\n * @memberOf X509#\n * @function\n */\nfunction _x509_getSerialNumberHex() {\n  return ASN1HEX.getDecendantHexVByNthList(this.hex, 0, [0, 1]);\n}\n\n/**\n * get hexadecimal string of issuer field of certificate.<br/>\n * @name getIssuerHex\n * @memberOf X509#\n * @function\n */\nfunction _x509_getIssuerHex() {\n  return ASN1HEX.getDecendantHexTLVByNthList(this.hex, 0, [0, 3]);\n}\n\n/**\n * get string of issuer field of certificate.<br/>\n * @name getIssuerString\n * @memberOf X509#\n * @function\n */\nfunction _x509_getIssuerString() {\n  return _x509_hex2dn(ASN1HEX.getDecendantHexTLVByNthList(this.hex, 0, [0, 3]));\n}\n\n/**\n * get hexadecimal string of subject field of certificate.<br/>\n * @name getSubjectHex\n * @memberOf X509#\n * @function\n */\nfunction _x509_getSubjectHex() {\n  return ASN1HEX.getDecendantHexTLVByNthList(this.hex, 0, [0, 5]);\n}\n\n/**\n * get string of subject field of certificate.<br/>\n * @name getSubjectString\n * @memberOf X509#\n * @function\n */\nfunction _x509_getSubjectString() {\n  return _x509_hex2dn(ASN1HEX.getDecendantHexTLVByNthList(this.hex, 0, [0, 5]));\n}\n\n/**\n * get notBefore field string of certificate.<br/>\n * @name getNotBefore\n * @memberOf X509#\n * @function\n */\nfunction _x509_getNotBefore() {\n  var s = ASN1HEX.getDecendantHexVByNthList(this.hex, 0, [0, 4, 0]);\n  s = s.replace(/(..)/g, "%$1");\n  s = decodeURIComponent(s);\n  return s;\n}\n\n/**\n * get notAfter field string of certificate.<br/>\n * @name getNotAfter\n * @memberOf X509#\n * @function\n */\nfunction _x509_getNotAfter() {\n  var s = ASN1HEX.getDecendantHexVByNthList(this.hex, 0, [0, 4, 1]);\n  s = s.replace(/(..)/g, "%$1");\n  s = decodeURIComponent(s);\n  return s;\n}\n\n// ===== read certificate =====================================\n\n_x509_DN_ATTRHEX = {\n    "0603550406": "C",\n    "060355040a": "O",\n    "060355040b": "OU",\n    "0603550403": "CN",\n    "0603550405": "SN",\n    "0603550408": "ST",\n    "0603550407": "L" };\n\nfunction _x509_hex2dn(hDN) {\n  var s = "";\n  var a = ASN1HEX.getPosArrayOfChildren_AtObj(hDN, 0);\n  for (var i = 0; i < a.length; i++) {\n    var hRDN = ASN1HEX.getHexOfTLV_AtObj(hDN, a[i]);\n    s = s + "/" + _x509_hex2rdn(hRDN);\n  }\n  return s;\n}\n\nfunction _x509_hex2rdn(hRDN) {\n    var hType = ASN1HEX.getDecendantHexTLVByNthList(hRDN, 0, [0, 0]);\n    var hValue = ASN1HEX.getDecendantHexVByNthList(hRDN, 0, [0, 1]);\n    var type = "";\n    try { type = _x509_DN_ATTRHEX[hType]; } catch (ex) { type = hType; }\n    hValue = hValue.replace(/(..)/g, "%$1");\n    var value = decodeURIComponent(hValue);\n    return type + "=" + value;\n}\n\n// ===== read certificate =====================================\n\n\n/**\n * read PEM formatted X.509 certificate from string.<br/>\n * @name readCertPEM\n * @memberOf X509#\n * @function\n * @param {String} sCertPEM string for PEM formatted X.509 certificate\n */\nfunction _x509_readCertPEM(sCertPEM) {\n  var hCert = _x509_pemToHex(sCertPEM);\n  var a = _x509_getPublicKeyHexArrayFromCertHex(hCert);\n  var rsa = new RSAKey();\n  rsa.setPublic(a[0], a[1]);\n  this.subjectPublicKeyRSA = rsa;\n  this.subjectPublicKeyRSA_hN = a[0];\n  this.subjectPublicKeyRSA_hE = a[1];\n  this.hex = hCert;\n}\n\nfunction _x509_readCertPEMWithoutRSAInit(sCertPEM) {\n  var hCert = _x509_pemToHex(sCertPEM);\n  var a = _x509_getPublicKeyHexArrayFromCertHex(hCert);\n  this.subjectPublicKeyRSA.setPublic(a[0], a[1]);\n  this.subjectPublicKeyRSA_hN = a[0];\n  this.subjectPublicKeyRSA_hE = a[1];\n  this.hex = hCert;\n}\n\n/**\n * X.509 certificate class.<br/>\n * @class X.509 certificate class\n * @property {RSAKey} subjectPublicKeyRSA Tom Wu\'s RSAKey object\n * @property {String} subjectPublicKeyRSA_hN hexadecimal string for modulus of RSA public key\n * @property {String} subjectPublicKeyRSA_hE hexadecimal string for public exponent of RSA public key\n * @property {String} hex hexacedimal string for X.509 certificate.\n * @author Kenji Urushima\n * @version 1.0.1 (08 May 2012)\n * @see <a href="http://kjur.github.com/jsrsasigns/">\'jwrsasign\'(RSA Sign JavaScript Library) home page http://kjur.github.com/jsrsasign/</a>\n */\nfunction X509() {\n  this.subjectPublicKeyRSA = null;\n  this.subjectPublicKeyRSA_hN = null;\n  this.subjectPublicKeyRSA_hE = null;\n  this.hex = null;\n}\n\nX509.prototype.readCertPEM = _x509_readCertPEM;\nX509.prototype.readCertPEMWithoutRSAInit = _x509_readCertPEMWithoutRSAInit;\nX509.prototype.getSerialNumberHex = _x509_getSerialNumberHex;\nX509.prototype.getIssuerHex = _x509_getIssuerHex;\nX509.prototype.getSubjectHex = _x509_getSubjectHex;\nX509.prototype.getIssuerString = _x509_getIssuerString;\nX509.prototype.getSubjectString = _x509_getSubjectString;\nX509.prototype.getNotBefore = _x509_getNotBefore;\nX509.prototype.getNotAfter = _x509_getNotAfter;\n\n// Copyright (c) 2005  Tom Wu\n// All Rights Reserved.\n// See "LICENSE" for details.\n\n// Basic JavaScript BN library - subset useful for RSA encryption.\n\n// Bits per digit\nvar dbits;\n\n// JavaScript engine analysis\nvar canary = 0xdeadbeefcafe;\nvar j_lm = ((canary&0xffffff)==0xefcafe);\n\n// (public) Constructor\nfunction BigInteger(a,b,c) {\n  if(a != null)\n    if("number" == typeof a) this.fromNumber(a,b,c);\n    else if(b == null && "string" != typeof a) this.fromString(a,256);\n    else this.fromString(a,b);\n}\n\n// return new, unset BigInteger\nfunction nbi() { return new BigInteger(null); }\n\n// am: Compute w_j += (x*this_i), propagate carries,\n// c is initial carry, returns final carry.\n// c < 3*dvalue, x < 2*dvalue, this_i < dvalue\n// We need to select the fastest one that works in this environment.\n\n// am1: use a single mult and divide to get the high bits,\n// max digit bits should be 26 because\n// max internal value = 2*dvalue^2-2*dvalue (< 2^53)\nfunction am1(i,x,w,j,c,n) {\n  while(--n >= 0) {\n    var v = x*this[i++]+w[j]+c;\n    c = Math.floor(v/0x4000000);\n    w[j++] = v&0x3ffffff;\n  }\n  return c;\n}\n// am2 avoids a big mult-and-extract completely.\n// Max digit bits should be <= 30 because we do bitwise ops\n// on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)\nfunction am2(i,x,w,j,c,n) {\n  var xl = x&0x7fff, xh = x>>15;\n  while(--n >= 0) {\n    var l = this[i]&0x7fff;\n    var h = this[i++]>>15;\n    var m = xh*l+h*xl;\n    l = xl*l+((m&0x7fff)<<15)+w[j]+(c&0x3fffffff);\n    c = (l>>>30)+(m>>>15)+xh*h+(c>>>30);\n    w[j++] = l&0x3fffffff;\n  }\n  return c;\n}\n// Alternately, set max digit bits to 28 since some\n// browsers slow down when dealing with 32-bit numbers.\nfunction am3(i,x,w,j,c,n) {\n  var xl = x&0x3fff, xh = x>>14;\n  while(--n >= 0) {\n    var l = this[i]&0x3fff;\n    var h = this[i++]>>14;\n    var m = xh*l+h*xl;\n    l = xl*l+((m&0x3fff)<<14)+w[j]+c;\n    c = (l>>28)+(m>>14)+xh*h;\n    w[j++] = l&0xfffffff;\n  }\n  return c;\n}\nif(j_lm && (navigator.appName == "Microsoft Internet Explorer")) {\n  BigInteger.prototype.am = am2;\n  dbits = 30;\n}\nelse if(j_lm && (navigator.appName != "Netscape")) {\n  BigInteger.prototype.am = am1;\n  dbits = 26;\n}\nelse { // Mozilla/Netscape seems to prefer am3\n  BigInteger.prototype.am = am3;\n  dbits = 28;\n}\n\nBigInteger.prototype.DB = dbits;\nBigInteger.prototype.DM = ((1<<dbits)-1);\nBigInteger.prototype.DV = (1<<dbits);\n\nvar BI_FP = 52;\nBigInteger.prototype.FV = Math.pow(2,BI_FP);\nBigInteger.prototype.F1 = BI_FP-dbits;\nBigInteger.prototype.F2 = 2*dbits-BI_FP;\n\n// Digit conversions\nvar BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";\nvar BI_RC = new Array();\nvar rr,vv;\nrr = "0".charCodeAt(0);\nfor(vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;\nrr = "a".charCodeAt(0);\nfor(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\nrr = "A".charCodeAt(0);\nfor(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n\nfunction int2char(n) { return BI_RM.charAt(n); }\nfunction intAt(s,i) {\n  var c = BI_RC[s.charCodeAt(i)];\n  return (c==null)?-1:c;\n}\n\n// (protected) copy this to r\nfunction bnpCopyTo(r) {\n  for(var i = this.t-1; i >= 0; --i) r[i] = this[i];\n  r.t = this.t;\n  r.s = this.s;\n}\n\n// (protected) set from integer value x, -DV <= x < DV\nfunction bnpFromInt(x) {\n  this.t = 1;\n  this.s = (x<0)?-1:0;\n  if(x > 0) this[0] = x;\n  else if(x < -1) this[0] = x+DV;\n  else this.t = 0;\n}\n\n// return bigint initialized to value\nfunction nbv(i) { var r = nbi(); r.fromInt(i); return r; }\n\n// (protected) set from string and radix\nfunction bnpFromString(s,b) {\n  var k;\n  if(b == 16) k = 4;\n  else if(b == 8) k = 3;\n  else if(b == 256) k = 8; // byte array\n  else if(b == 2) k = 1;\n  else if(b == 32) k = 5;\n  else if(b == 4) k = 2;\n  else { this.fromRadix(s,b); return; }\n  this.t = 0;\n  this.s = 0;\n  var i = s.length, mi = false, sh = 0;\n  while(--i >= 0) {\n    var x = (k==8)?s[i]&0xff:intAt(s,i);\n    if(x < 0) {\n      if(s.charAt(i) == "-") mi = true;\n      continue;\n    }\n    mi = false;\n    if(sh == 0)\n      this[this.t++] = x;\n    else if(sh+k > this.DB) {\n      this[this.t-1] |= (x&((1<<(this.DB-sh))-1))<<sh;\n      this[this.t++] = (x>>(this.DB-sh));\n    }\n    else\n      this[this.t-1] |= x<<sh;\n    sh += k;\n    if(sh >= this.DB) sh -= this.DB;\n  }\n  if(k == 8 && (s[0]&0x80) != 0) {\n    this.s = -1;\n    if(sh > 0) this[this.t-1] |= ((1<<(this.DB-sh))-1)<<sh;\n  }\n  this.clamp();\n  if(mi) BigInteger.ZERO.subTo(this,this);\n}\n\n// (protected) clamp off excess high words\nfunction bnpClamp() {\n  var c = this.s&this.DM;\n  while(this.t > 0 && this[this.t-1] == c) --this.t;\n}\n\n// (public) return string representation in given radix\nfunction bnToString(b) {\n  if(this.s < 0) return "-"+this.negate().toString(b);\n  var k;\n  if(b == 16) k = 4;\n  else if(b == 8) k = 3;\n  else if(b == 2) k = 1;\n  else if(b == 32) k = 5;\n  else if(b == 4) k = 2;\n  else return this.toRadix(b);\n  var km = (1<<k)-1, d, m = false, r = "", i = this.t;\n  var p = this.DB-(i*this.DB)%k;\n  if(i-- > 0) {\n    if(p < this.DB && (d = this[i]>>p) > 0) { m = true; r = int2char(d); }\n    while(i >= 0) {\n      if(p < k) {\n        d = (this[i]&((1<<p)-1))<<(k-p);\n        d |= this[--i]>>(p+=this.DB-k);\n      }\n      else {\n        d = (this[i]>>(p-=k))&km;\n        if(p <= 0) { p += this.DB; --i; }\n      }\n      if(d > 0) m = true;\n      if(m) r += int2char(d);\n    }\n  }\n  return m?r:"0";\n}\n\n// (public) -this\nfunction bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; }\n\n// (public) |this|\nfunction bnAbs() { return (this.s<0)?this.negate():this; }\n\n// (public) return + if this > a, - if this < a, 0 if equal\nfunction bnCompareTo(a) {\n  var r = this.s-a.s;\n  if(r != 0) return r;\n  var i = this.t;\n  r = i-a.t;\n  if(r != 0) return (this.s<0)?-r:r;\n  while(--i >= 0) if((r=this[i]-a[i]) != 0) return r;\n  return 0;\n}\n\n// returns bit length of the integer x\nfunction nbits(x) {\n  var r = 1, t;\n  if((t=x>>>16) != 0) { x = t; r += 16; }\n  if((t=x>>8) != 0) { x = t; r += 8; }\n  if((t=x>>4) != 0) { x = t; r += 4; }\n  if((t=x>>2) != 0) { x = t; r += 2; }\n  if((t=x>>1) != 0) { x = t; r += 1; }\n  return r;\n}\n\n// (public) return the number of bits in "this"\nfunction bnBitLength() {\n  if(this.t <= 0) return 0;\n  return this.DB*(this.t-1)+nbits(this[this.t-1]^(this.s&this.DM));\n}\n\n// (protected) r = this << n*DB\nfunction bnpDLShiftTo(n,r) {\n  var i;\n  for(i = this.t-1; i >= 0; --i) r[i+n] = this[i];\n  for(i = n-1; i >= 0; --i) r[i] = 0;\n  r.t = this.t+n;\n  r.s = this.s;\n}\n\n// (protected) r = this >> n*DB\nfunction bnpDRShiftTo(n,r) {\n  for(var i = n; i < this.t; ++i) r[i-n] = this[i];\n  r.t = Math.max(this.t-n,0);\n  r.s = this.s;\n}\n\n// (protected) r = this << n\nfunction bnpLShiftTo(n,r) {\n  var bs = n%this.DB;\n  var cbs = this.DB-bs;\n  var bm = (1<<cbs)-1;\n  var ds = Math.floor(n/this.DB), c = (this.s<<bs)&this.DM, i;\n  for(i = this.t-1; i >= 0; --i) {\n    r[i+ds+1] = (this[i]>>cbs)|c;\n    c = (this[i]&bm)<<bs;\n  }\n  for(i = ds-1; i >= 0; --i) r[i] = 0;\n  r[ds] = c;\n  r.t = this.t+ds+1;\n  r.s = this.s;\n  r.clamp();\n}\n\n// (protected) r = this >> n\nfunction bnpRShiftTo(n,r) {\n  r.s = this.s;\n  var ds = Math.floor(n/this.DB);\n  if(ds >= this.t) { r.t = 0; return; }\n  var bs = n%this.DB;\n  var cbs = this.DB-bs;\n  var bm = (1<<bs)-1;\n  r[0] = this[ds]>>bs;\n  for(var i = ds+1; i < this.t; ++i) {\n    r[i-ds-1] |= (this[i]&bm)<<cbs;\n    r[i-ds] = this[i]>>bs;\n  }\n  if(bs > 0) r[this.t-ds-1] |= (this.s&bm)<<cbs;\n  r.t = this.t-ds;\n  r.clamp();\n}\n\n// (protected) r = this - a\nfunction bnpSubTo(a,r) {\n  var i = 0, c = 0, m = Math.min(a.t,this.t);\n  while(i < m) {\n    c += this[i]-a[i];\n    r[i++] = c&this.DM;\n    c >>= this.DB;\n  }\n  if(a.t < this.t) {\n    c -= a.s;\n    while(i < this.t) {\n      c += this[i];\n      r[i++] = c&this.DM;\n      c >>= this.DB;\n    }\n    c += this.s;\n  }\n  else {\n    c += this.s;\n    while(i < a.t) {\n      c -= a[i];\n      r[i++] = c&this.DM;\n      c >>= this.DB;\n    }\n    c -= a.s;\n  }\n  r.s = (c<0)?-1:0;\n  if(c < -1) r[i++] = this.DV+c;\n  else if(c > 0) r[i++] = c;\n  r.t = i;\n  r.clamp();\n}\n\n// (protected) r = this * a, r != this,a (HAC 14.12)\n// "this" should be the larger one if appropriate.\nfunction bnpMultiplyTo(a,r) {\n  var x = this.abs(), y = a.abs();\n  var i = x.t;\n  r.t = i+y.t;\n  while(--i >= 0) r[i] = 0;\n  for(i = 0; i < y.t; ++i) r[i+x.t] = x.am(0,y[i],r,i,0,x.t);\n  r.s = 0;\n  r.clamp();\n  if(this.s != a.s) BigInteger.ZERO.subTo(r,r);\n}\n\n// (protected) r = this^2, r != this (HAC 14.16)\nfunction bnpSquareTo(r) {\n  var x = this.abs();\n  var i = r.t = 2*x.t;\n  while(--i >= 0) r[i] = 0;\n  for(i = 0; i < x.t-1; ++i) {\n    var c = x.am(i,x[i],r,2*i,0,1);\n    if((r[i+x.t]+=x.am(i+1,2*x[i],r,2*i+1,c,x.t-i-1)) >= x.DV) {\n      r[i+x.t] -= x.DV;\n      r[i+x.t+1] = 1;\n    }\n  }\n  if(r.t > 0) r[r.t-1] += x.am(i,x[i],r,2*i,0,1);\n  r.s = 0;\n  r.clamp();\n}\n\n// (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)\n// r != q, this != m.  q or r may be null.\nfunction bnpDivRemTo(m,q,r) {\n  var pm = m.abs();\n  if(pm.t <= 0) return;\n  var pt = this.abs();\n  if(pt.t < pm.t) {\n    if(q != null) q.fromInt(0);\n    if(r != null) this.copyTo(r);\n    return;\n  }\n  if(r == null) r = nbi();\n  var y = nbi(), ts = this.s, ms = m.s;\n  var nsh = this.DB-nbits(pm[pm.t-1]);\t// normalize modulus\n  if(nsh > 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); }\n  else { pm.copyTo(y); pt.copyTo(r); }\n  var ys = y.t;\n  var y0 = y[ys-1];\n  if(y0 == 0) return;\n  var yt = y0*(1<<this.F1)+((ys>1)?y[ys-2]>>this.F2:0);\n  var d1 = this.FV/yt, d2 = (1<<this.F1)/yt, e = 1<<this.F2;\n  var i = r.t, j = i-ys, t = (q==null)?nbi():q;\n  y.dlShiftTo(j,t);\n  if(r.compareTo(t) >= 0) {\n    r[r.t++] = 1;\n    r.subTo(t,r);\n  }\n  BigInteger.ONE.dlShiftTo(ys,t);\n  t.subTo(y,y);\t// "negative" y so we can replace sub with am later\n  while(y.t < ys) y[y.t++] = 0;\n  while(--j >= 0) {\n    // Estimate quotient digit\n    var qd = (r[--i]==y0)?this.DM:Math.floor(r[i]*d1+(r[i-1]+e)*d2);\n    if((r[i]+=y.am(0,qd,r,j,0,ys)) < qd) {\t// Try it out\n      y.dlShiftTo(j,t);\n      r.subTo(t,r);\n      while(r[i] < --qd) r.subTo(t,r);\n    }\n  }\n  if(q != null) {\n    r.drShiftTo(ys,q);\n    if(ts != ms) BigInteger.ZERO.subTo(q,q);\n  }\n  r.t = ys;\n  r.clamp();\n  if(nsh > 0) r.rShiftTo(nsh,r);\t// Denormalize remainder\n  if(ts < 0) BigInteger.ZERO.subTo(r,r);\n}\n\n// (public) this mod a\nfunction bnMod(a) {\n  var r = nbi();\n  this.abs().divRemTo(a,null,r);\n  if(this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r,r);\n  return r;\n}\n\n// Modular reduction using "classic" algorithm\nfunction Classic(m) { this.m = m; }\nfunction cConvert(x) {\n  if(x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);\n  else return x;\n}\nfunction cRevert(x) { return x; }\nfunction cReduce(x) { x.divRemTo(this.m,null,x); }\nfunction cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\nfunction cSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\nClassic.prototype.convert = cConvert;\nClassic.prototype.revert = cRevert;\nClassic.prototype.reduce = cReduce;\nClassic.prototype.mulTo = cMulTo;\nClassic.prototype.sqrTo = cSqrTo;\n\n// (protected) return "-1/this % 2^DB"; useful for Mont. reduction\n// justification:\n//         xy == 1 (mod m)\n//         xy =  1+km\n//   xy(2-xy) = (1+km)(1-km)\n// x[y(2-xy)] = 1-k^2m^2\n// x[y(2-xy)] == 1 (mod m^2)\n// if y is 1/x mod m, then y(2-xy) is 1/x mod m^2\n// should reduce x and y(2-xy) by m^2 at each step to keep size bounded.\n// JS multiply "overflows" differently from C/C++, so care is needed here.\nfunction bnpInvDigit() {\n  if(this.t < 1) return 0;\n  var x = this[0];\n  if((x&1) == 0) return 0;\n  var y = x&3;\t\t// y == 1/x mod 2^2\n  y = (y*(2-(x&0xf)*y))&0xf;\t// y == 1/x mod 2^4\n  y = (y*(2-(x&0xff)*y))&0xff;\t// y == 1/x mod 2^8\n  y = (y*(2-(((x&0xffff)*y)&0xffff)))&0xffff;\t// y == 1/x mod 2^16\n  // last step - calculate inverse mod DV directly;\n  // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints\n  y = (y*(2-x*y%this.DV))%this.DV;\t\t// y == 1/x mod 2^dbits\n  // we really want the negative inverse, and -DV < y < DV\n  return (y>0)?this.DV-y:-y;\n}\n\n// Montgomery reduction\nfunction Montgomery(m) {\n  this.m = m;\n  this.mp = m.invDigit();\n  this.mpl = this.mp&0x7fff;\n  this.mph = this.mp>>15;\n  this.um = (1<<(m.DB-15))-1;\n  this.mt2 = 2*m.t;\n}\n\n// xR mod m\nfunction montConvert(x) {\n  var r = nbi();\n  x.abs().dlShiftTo(this.m.t,r);\n  r.divRemTo(this.m,null,r);\n  if(x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r,r);\n  return r;\n}\n\n// x/R mod m\nfunction montRevert(x) {\n  var r = nbi();\n  x.copyTo(r);\n  this.reduce(r);\n  return r;\n}\n\n// x = x/R mod m (HAC 14.32)\nfunction montReduce(x) {\n  while(x.t <= this.mt2)\t// pad x so am has enough room later\n    x[x.t++] = 0;\n  for(var i = 0; i < this.m.t; ++i) {\n    // faster way of calculating u0 = x[i]*mp mod DV\n    var j = x[i]&0x7fff;\n    var u0 = (j*this.mpl+(((j*this.mph+(x[i]>>15)*this.mpl)&this.um)<<15))&x.DM;\n    // use am to combine the multiply-shift-add into one call\n    j = i+this.m.t;\n    x[j] += this.m.am(0,u0,x,i,0,this.m.t);\n    // propagate carry\n    while(x[j] >= x.DV) { x[j] -= x.DV; x[++j]++; }\n  }\n  x.clamp();\n  x.drShiftTo(this.m.t,x);\n  if(x.compareTo(this.m) >= 0) x.subTo(this.m,x);\n}\n\n// r = "x^2/R mod m"; x != r\nfunction montSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\n// r = "xy/R mod m"; x,y != r\nfunction montMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\n\nMontgomery.prototype.convert = montConvert;\nMontgomery.prototype.revert = montRevert;\nMontgomery.prototype.reduce = montReduce;\nMontgomery.prototype.mulTo = montMulTo;\nMontgomery.prototype.sqrTo = montSqrTo;\n\n// (protected) true iff this is even\nfunction bnpIsEven() { return ((this.t>0)?(this[0]&1):this.s) == 0; }\n\n// (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)\nfunction bnpExp(e,z) {\n  if(e > 0xffffffff || e < 1) return BigInteger.ONE;\n  var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e)-1;\n  g.copyTo(r);\n  while(--i >= 0) {\n    z.sqrTo(r,r2);\n    if((e&(1<<i)) > 0) z.mulTo(r2,g,r);\n    else { var t = r; r = r2; r2 = t; }\n  }\n  return z.revert(r);\n}\n\n// (public) this^e % m, 0 <= e < 2^32\nfunction bnModPowInt(e,m) {\n  var z;\n  if(e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);\n  return this.exp(e,z);\n}\n\n// protected\nBigInteger.prototype.copyTo = bnpCopyTo;\nBigInteger.prototype.fromInt = bnpFromInt;\nBigInteger.prototype.fromString = bnpFromString;\nBigInteger.prototype.clamp = bnpClamp;\nBigInteger.prototype.dlShiftTo = bnpDLShiftTo;\nBigInteger.prototype.drShiftTo = bnpDRShiftTo;\nBigInteger.prototype.lShiftTo = bnpLShiftTo;\nBigInteger.prototype.rShiftTo = bnpRShiftTo;\nBigInteger.prototype.subTo = bnpSubTo;\nBigInteger.prototype.multiplyTo = bnpMultiplyTo;\nBigInteger.prototype.squareTo = bnpSquareTo;\nBigInteger.prototype.divRemTo = bnpDivRemTo;\nBigInteger.prototype.invDigit = bnpInvDigit;\nBigInteger.prototype.isEven = bnpIsEven;\nBigInteger.prototype.exp = bnpExp;\n\n// public\nBigInteger.prototype.toString = bnToString;\nBigInteger.prototype.negate = bnNegate;\nBigInteger.prototype.abs = bnAbs;\nBigInteger.prototype.compareTo = bnCompareTo;\nBigInteger.prototype.bitLength = bnBitLength;\nBigInteger.prototype.mod = bnMod;\nBigInteger.prototype.modPowInt = bnModPowInt;\n\n// "constants"\nBigInteger.ZERO = nbv(0);\nBigInteger.ONE = nbv(1);\n// Copyright (c) 2005-2009  Tom Wu\n// All Rights Reserved.\n// See "LICENSE" for details.\n\n// Extended JavaScript BN functions, required for RSA private ops.\n\n// Version 1.1: new BigInteger("0", 10) returns "proper" zero\n// Version 1.2: square() API, isProbablePrime fix\n\n// (public)\nfunction bnClone() { var r = nbi(); this.copyTo(r); return r; }\n\n// (public) return value as integer\nfunction bnIntValue() {\n  if(this.s < 0) {\n    if(this.t == 1) return this[0]-this.DV;\n    else if(this.t == 0) return -1;\n  }\n  else if(this.t == 1) return this[0];\n  else if(this.t == 0) return 0;\n  // assumes 16 < DB < 32\n  return ((this[1]&((1<<(32-this.DB))-1))<<this.DB)|this[0];\n}\n\n// (public) return value as byte\nfunction bnByteValue() { return (this.t==0)?this.s:(this[0]<<24)>>24; }\n\n// (public) return value as short (assumes DB>=16)\nfunction bnShortValue() { return (this.t==0)?this.s:(this[0]<<16)>>16; }\n\n// (protected) return x s.t. r^x < DV\nfunction bnpChunkSize(r) { return Math.floor(Math.LN2*this.DB/Math.log(r)); }\n\n// (public) 0 if this == 0, 1 if this > 0\nfunction bnSigNum() {\n  if(this.s < 0) return -1;\n  else if(this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;\n  else return 1;\n}\n\n// (protected) convert to radix string\nfunction bnpToRadix(b) {\n  if(b == null) b = 10;\n  if(this.signum() == 0 || b < 2 || b > 36) return "0";\n  var cs = this.chunkSize(b);\n  var a = Math.pow(b,cs);\n  var d = nbv(a), y = nbi(), z = nbi(), r = "";\n  this.divRemTo(d,y,z);\n  while(y.signum() > 0) {\n    r = (a+z.intValue()).toString(b).substr(1) + r;\n    y.divRemTo(d,y,z);\n  }\n  return z.intValue().toString(b) + r;\n}\n\n// (protected) convert from radix string\nfunction bnpFromRadix(s,b) {\n  this.fromInt(0);\n  if(b == null) b = 10;\n  var cs = this.chunkSize(b);\n  var d = Math.pow(b,cs), mi = false, j = 0, w = 0;\n  for(var i = 0; i < s.length; ++i) {\n    var x = intAt(s,i);\n    if(x < 0) {\n      if(s.charAt(i) == "-" && this.signum() == 0) mi = true;\n      continue;\n    }\n    w = b*w+x;\n    if(++j >= cs) {\n      this.dMultiply(d);\n      this.dAddOffset(w,0);\n      j = 0;\n      w = 0;\n    }\n  }\n  if(j > 0) {\n    this.dMultiply(Math.pow(b,j));\n    this.dAddOffset(w,0);\n  }\n  if(mi) BigInteger.ZERO.subTo(this,this);\n}\n\n// (protected) alternate constructor\nfunction bnpFromNumber(a,b,c) {\n  if("number" == typeof b) {\n    // new BigInteger(int,int,RNG)\n    if(a < 2) this.fromInt(1);\n    else {\n      this.fromNumber(a,c);\n      if(!this.testBit(a-1))\t// force MSB set\n        this.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,this);\n      if(this.isEven()) this.dAddOffset(1,0); // force odd\n      while(!this.isProbablePrime(b)) {\n        this.dAddOffset(2,0);\n        if(this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a-1),this);\n      }\n    }\n  }\n  else {\n    // new BigInteger(int,RNG)\n    var x = new Array(), t = a&7;\n    x.length = (a>>3)+1;\n    b.nextBytes(x);\n    if(t > 0) x[0] &= ((1<<t)-1); else x[0] = 0;\n    this.fromString(x,256);\n  }\n}\n\n// (public) convert to bigendian byte array\nfunction bnToByteArray() {\n  var i = this.t, r = new Array();\n  r[0] = this.s;\n  var p = this.DB-(i*this.DB)%8, d, k = 0;\n  if(i-- > 0) {\n    if(p < this.DB && (d = this[i]>>p) != (this.s&this.DM)>>p)\n      r[k++] = d|(this.s<<(this.DB-p));\n    while(i >= 0) {\n      if(p < 8) {\n        d = (this[i]&((1<<p)-1))<<(8-p);\n        d |= this[--i]>>(p+=this.DB-8);\n      }\n      else {\n        d = (this[i]>>(p-=8))&0xff;\n        if(p <= 0) { p += this.DB; --i; }\n      }\n      if((d&0x80) != 0) d |= -256;\n      if(k == 0 && (this.s&0x80) != (d&0x80)) ++k;\n      if(k > 0 || d != this.s) r[k++] = d;\n    }\n  }\n  return r;\n}\n\nfunction bnEquals(a) { return(this.compareTo(a)==0); }\nfunction bnMin(a) { return(this.compareTo(a)<0)?this:a; }\nfunction bnMax(a) { return(this.compareTo(a)>0)?this:a; }\n\n// (protected) r = this op a (bitwise)\nfunction bnpBitwiseTo(a,op,r) {\n  var i, f, m = Math.min(a.t,this.t);\n  for(i = 0; i < m; ++i) r[i] = op(this[i],a[i]);\n  if(a.t < this.t) {\n    f = a.s&this.DM;\n    for(i = m; i < this.t; ++i) r[i] = op(this[i],f);\n    r.t = this.t;\n  }\n  else {\n    f = this.s&this.DM;\n    for(i = m; i < a.t; ++i) r[i] = op(f,a[i]);\n    r.t = a.t;\n  }\n  r.s = op(this.s,a.s);\n  r.clamp();\n}\n\n// (public) this & a\nfunction op_and(x,y) { return x&y; }\nfunction bnAnd(a) { var r = nbi(); this.bitwiseTo(a,op_and,r); return r; }\n\n// (public) this | a\nfunction op_or(x,y) { return x|y; }\nfunction bnOr(a) { var r = nbi(); this.bitwiseTo(a,op_or,r); return r; }\n\n// (public) this ^ a\nfunction op_xor(x,y) { return x^y; }\nfunction bnXor(a) { var r = nbi(); this.bitwiseTo(a,op_xor,r); return r; }\n\n// (public) this & ~a\nfunction op_andnot(x,y) { return x&~y; }\nfunction bnAndNot(a) { var r = nbi(); this.bitwiseTo(a,op_andnot,r); return r; }\n\n// (public) ~this\nfunction bnNot() {\n  var r = nbi();\n  for(var i = 0; i < this.t; ++i) r[i] = this.DM&~this[i];\n  r.t = this.t;\n  r.s = ~this.s;\n  return r;\n}\n\n// (public) this << n\nfunction bnShiftLeft(n) {\n  var r = nbi();\n  if(n < 0) this.rShiftTo(-n,r); else this.lShiftTo(n,r);\n  return r;\n}\n\n// (public) this >> n\nfunction bnShiftRight(n) {\n  var r = nbi();\n  if(n < 0) this.lShiftTo(-n,r); else this.rShiftTo(n,r);\n  return r;\n}\n\n// return index of lowest 1-bit in x, x < 2^31\nfunction lbit(x) {\n  if(x == 0) return -1;\n  var r = 0;\n  if((x&0xffff) == 0) { x >>= 16; r += 16; }\n  if((x&0xff) == 0) { x >>= 8; r += 8; }\n  if((x&0xf) == 0) { x >>= 4; r += 4; }\n  if((x&3) == 0) { x >>= 2; r += 2; }\n  if((x&1) == 0) ++r;\n  return r;\n}\n\n// (public) returns index of lowest 1-bit (or -1 if none)\nfunction bnGetLowestSetBit() {\n  for(var i = 0; i < this.t; ++i)\n    if(this[i] != 0) return i*this.DB+lbit(this[i]);\n  if(this.s < 0) return this.t*this.DB;\n  return -1;\n}\n\n// return number of 1 bits in x\nfunction cbit(x) {\n  var r = 0;\n  while(x != 0) { x &= x-1; ++r; }\n  return r;\n}\n\n// (public) return number of set bits\nfunction bnBitCount() {\n  var r = 0, x = this.s&this.DM;\n  for(var i = 0; i < this.t; ++i) r += cbit(this[i]^x);\n  return r;\n}\n\n// (public) true iff nth bit is set\nfunction bnTestBit(n) {\n  var j = Math.floor(n/this.DB);\n  if(j >= this.t) return(this.s!=0);\n  return((this[j]&(1<<(n%this.DB)))!=0);\n}\n\n// (protected) this op (1<<n)\nfunction bnpChangeBit(n,op) {\n  var r = BigInteger.ONE.shiftLeft(n);\n  this.bitwiseTo(r,op,r);\n  return r;\n}\n\n// (public) this | (1<<n)\nfunction bnSetBit(n) { return this.changeBit(n,op_or); }\n\n// (public) this & ~(1<<n)\nfunction bnClearBit(n) { return this.changeBit(n,op_andnot); }\n\n// (public) this ^ (1<<n)\nfunction bnFlipBit(n) { return this.changeBit(n,op_xor); }\n\n// (protected) r = this + a\nfunction bnpAddTo(a,r) {\n  var i = 0, c = 0, m = Math.min(a.t,this.t);\n  while(i < m) {\n    c += this[i]+a[i];\n    r[i++] = c&this.DM;\n    c >>= this.DB;\n  }\n  if(a.t < this.t) {\n    c += a.s;\n    while(i < this.t) {\n      c += this[i];\n      r[i++] = c&this.DM;\n      c >>= this.DB;\n    }\n    c += this.s;\n  }\n  else {\n    c += this.s;\n    while(i < a.t) {\n      c += a[i];\n      r[i++] = c&this.DM;\n      c >>= this.DB;\n    }\n    c += a.s;\n  }\n  r.s = (c<0)?-1:0;\n  if(c > 0) r[i++] = c;\n  else if(c < -1) r[i++] = this.DV+c;\n  r.t = i;\n  r.clamp();\n}\n\n// (public) this + a\nfunction bnAdd(a) { var r = nbi(); this.addTo(a,r); return r; }\n\n// (public) this - a\nfunction bnSubtract(a) { var r = nbi(); this.subTo(a,r); return r; }\n\n// (public) this * a\nfunction bnMultiply(a) { var r = nbi(); this.multiplyTo(a,r); return r; }\n\n// (public) this^2\nfunction bnSquare() { var r = nbi(); this.squareTo(r); return r; }\n\n// (public) this / a\nfunction bnDivide(a) { var r = nbi(); this.divRemTo(a,r,null); return r; }\n\n// (public) this % a\nfunction bnRemainder(a) { var r = nbi(); this.divRemTo(a,null,r); return r; }\n\n// (public) [this/a,this%a]\nfunction bnDivideAndRemainder(a) {\n  var q = nbi(), r = nbi();\n  this.divRemTo(a,q,r);\n  return new Array(q,r);\n}\n\n// (protected) this *= n, this >= 0, 1 < n < DV\nfunction bnpDMultiply(n) {\n  this[this.t] = this.am(0,n-1,this,0,0,this.t);\n  ++this.t;\n  this.clamp();\n}\n\n// (protected) this += n << w words, this >= 0\nfunction bnpDAddOffset(n,w) {\n  if(n == 0) return;\n  while(this.t <= w) this[this.t++] = 0;\n  this[w] += n;\n  while(this[w] >= this.DV) {\n    this[w] -= this.DV;\n    if(++w >= this.t) this[this.t++] = 0;\n    ++this[w];\n  }\n}\n\n// A "null" reducer\nfunction NullExp() {}\nfunction nNop(x) { return x; }\nfunction nMulTo(x,y,r) { x.multiplyTo(y,r); }\nfunction nSqrTo(x,r) { x.squareTo(r); }\n\nNullExp.prototype.convert = nNop;\nNullExp.prototype.revert = nNop;\nNullExp.prototype.mulTo = nMulTo;\nNullExp.prototype.sqrTo = nSqrTo;\n\n// (public) this^e\nfunction bnPow(e) { return this.exp(e,new NullExp()); }\n\n// (protected) r = lower n words of "this * a", a.t <= n\n// "this" should be the larger one if appropriate.\nfunction bnpMultiplyLowerTo(a,n,r) {\n  var i = Math.min(this.t+a.t,n);\n  r.s = 0; // assumes a,this >= 0\n  r.t = i;\n  while(i > 0) r[--i] = 0;\n  var j;\n  for(j = r.t-this.t; i < j; ++i) r[i+this.t] = this.am(0,a[i],r,i,0,this.t);\n  for(j = Math.min(a.t,n); i < j; ++i) this.am(0,a[i],r,i,0,n-i);\n  r.clamp();\n}\n\n// (protected) r = "this * a" without lower n words, n > 0\n// "this" should be the larger one if appropriate.\nfunction bnpMultiplyUpperTo(a,n,r) {\n  --n;\n  var i = r.t = this.t+a.t-n;\n  r.s = 0; // assumes a,this >= 0\n  while(--i >= 0) r[i] = 0;\n  for(i = Math.max(n-this.t,0); i < a.t; ++i)\n    r[this.t+i-n] = this.am(n-i,a[i],r,0,0,this.t+i-n);\n  r.clamp();\n  r.drShiftTo(1,r);\n}\n\n// Barrett modular reduction\nfunction Barrett(m) {\n  // setup Barrett\n  this.r2 = nbi();\n  this.q3 = nbi();\n  BigInteger.ONE.dlShiftTo(2*m.t,this.r2);\n  this.mu = this.r2.divide(m);\n  this.m = m;\n}\n\nfunction barrettConvert(x) {\n  if(x.s < 0 || x.t > 2*this.m.t) return x.mod(this.m);\n  else if(x.compareTo(this.m) < 0) return x;\n  else { var r = nbi(); x.copyTo(r); this.reduce(r); return r; }\n}\n\nfunction barrettRevert(x) { return x; }\n\n// x = x mod m (HAC 14.42)\nfunction barrettReduce(x) {\n  x.drShiftTo(this.m.t-1,this.r2);\n  if(x.t > this.m.t+1) { x.t = this.m.t+1; x.clamp(); }\n  this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);\n  this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);\n  while(x.compareTo(this.r2) < 0) x.dAddOffset(1,this.m.t+1);\n  x.subTo(this.r2,x);\n  while(x.compareTo(this.m) >= 0) x.subTo(this.m,x);\n}\n\n// r = x^2 mod m; x != r\nfunction barrettSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\n// r = x*y mod m; x,y != r\nfunction barrettMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\n\nBarrett.prototype.convert = barrettConvert;\nBarrett.prototype.revert = barrettRevert;\nBarrett.prototype.reduce = barrettReduce;\nBarrett.prototype.mulTo = barrettMulTo;\nBarrett.prototype.sqrTo = barrettSqrTo;\n\n// (public) this^e % m (HAC 14.85)\nfunction bnModPow(e,m) {\n  var i = e.bitLength(), k, r = nbv(1), z;\n  if(i <= 0) return r;\n  else if(i < 18) k = 1;\n  else if(i < 48) k = 3;\n  else if(i < 144) k = 4;\n  else if(i < 768) k = 5;\n  else k = 6;\n  if(i < 8)\n    z = new Classic(m);\n  else if(m.isEven())\n    z = new Barrett(m);\n  else\n    z = new Montgomery(m);\n\n  // precomputation\n  var g = new Array(), n = 3, k1 = k-1, km = (1<<k)-1;\n  g[1] = z.convert(this);\n  if(k > 1) {\n    var g2 = nbi();\n    z.sqrTo(g[1],g2);\n    while(n <= km) {\n      g[n] = nbi();\n      z.mulTo(g2,g[n-2],g[n]);\n      n += 2;\n    }\n  }\n\n  var j = e.t-1, w, is1 = true, r2 = nbi(), t;\n  i = nbits(e[j])-1;\n  while(j >= 0) {\n    if(i >= k1) w = (e[j]>>(i-k1))&km;\n    else {\n      w = (e[j]&((1<<(i+1))-1))<<(k1-i);\n      if(j > 0) w |= e[j-1]>>(this.DB+i-k1);\n    }\n\n    n = k;\n    while((w&1) == 0) { w >>= 1; --n; }\n    if((i -= n) < 0) { i += this.DB; --j; }\n    if(is1) {\t// ret == 1, don\'t bother squaring or multiplying it\n      g[w].copyTo(r);\n      is1 = false;\n    }\n    else {\n      while(n > 1) { z.sqrTo(r,r2); z.sqrTo(r2,r); n -= 2; }\n      if(n > 0) z.sqrTo(r,r2); else { t = r; r = r2; r2 = t; }\n      z.mulTo(r2,g[w],r);\n    }\n\n    while(j >= 0 && (e[j]&(1<<i)) == 0) {\n      z.sqrTo(r,r2); t = r; r = r2; r2 = t;\n      if(--i < 0) { i = this.DB-1; --j; }\n    }\n  }\n  return z.revert(r);\n}\n\n// (public) gcd(this,a) (HAC 14.54)\nfunction bnGCD(a) {\n  var x = (this.s<0)?this.negate():this.clone();\n  var y = (a.s<0)?a.negate():a.clone();\n  if(x.compareTo(y) < 0) { var t = x; x = y; y = t; }\n  var i = x.getLowestSetBit(), g = y.getLowestSetBit();\n  if(g < 0) return x;\n  if(i < g) g = i;\n  if(g > 0) {\n    x.rShiftTo(g,x);\n    y.rShiftTo(g,y);\n  }\n  while(x.signum() > 0) {\n    if((i = x.getLowestSetBit()) > 0) x.rShiftTo(i,x);\n    if((i = y.getLowestSetBit()) > 0) y.rShiftTo(i,y);\n    if(x.compareTo(y) >= 0) {\n      x.subTo(y,x);\n      x.rShiftTo(1,x);\n    }\n    else {\n      y.subTo(x,y);\n      y.rShiftTo(1,y);\n    }\n  }\n  if(g > 0) y.lShiftTo(g,y);\n  return y;\n}\n\n// (protected) this % n, n < 2^26\nfunction bnpModInt(n) {\n  if(n <= 0) return 0;\n  var d = this.DV%n, r = (this.s<0)?n-1:0;\n  if(this.t > 0)\n    if(d == 0) r = this[0]%n;\n    else for(var i = this.t-1; i >= 0; --i) r = (d*r+this[i])%n;\n  return r;\n}\n\n// (public) 1/this % m (HAC 14.61)\nfunction bnModInverse(m) {\n  var ac = m.isEven();\n  if((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;\n  var u = m.clone(), v = this.clone();\n  var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);\n  while(u.signum() != 0) {\n    while(u.isEven()) {\n      u.rShiftTo(1,u);\n      if(ac) {\n        if(!a.isEven() || !b.isEven()) { a.addTo(this,a); b.subTo(m,b); }\n        a.rShiftTo(1,a);\n      }\n      else if(!b.isEven()) b.subTo(m,b);\n      b.rShiftTo(1,b);\n    }\n    while(v.isEven()) {\n      v.rShiftTo(1,v);\n      if(ac) {\n        if(!c.isEven() || !d.isEven()) { c.addTo(this,c); d.subTo(m,d); }\n        c.rShiftTo(1,c);\n      }\n      else if(!d.isEven()) d.subTo(m,d);\n      d.rShiftTo(1,d);\n    }\n    if(u.compareTo(v) >= 0) {\n      u.subTo(v,u);\n      if(ac) a.subTo(c,a);\n      b.subTo(d,b);\n    }\n    else {\n      v.subTo(u,v);\n      if(ac) c.subTo(a,c);\n      d.subTo(b,d);\n    }\n  }\n  if(v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;\n  if(d.compareTo(m) >= 0) return d.subtract(m);\n  if(d.signum() < 0) d.addTo(m,d); else return d;\n  if(d.signum() < 0) return d.add(m); else return d;\n}\n\nvar lowprimes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997];\nvar lplim = (1<<26)/lowprimes[lowprimes.length-1];\n\n// (public) test primality with certainty >= 1-.5^t\nfunction bnIsProbablePrime(t) {\n  var i, x = this.abs();\n  if(x.t == 1 && x[0] <= lowprimes[lowprimes.length-1]) {\n    for(i = 0; i < lowprimes.length; ++i)\n      if(x[0] == lowprimes[i]) return true;\n    return false;\n  }\n  if(x.isEven()) return false;\n  i = 1;\n  while(i < lowprimes.length) {\n    var m = lowprimes[i], j = i+1;\n    while(j < lowprimes.length && m < lplim) m *= lowprimes[j++];\n    m = x.modInt(m);\n    while(i < j) if(m%lowprimes[i++] == 0) return false;\n  }\n  return x.millerRabin(t);\n}\n\n// (protected) true if probably prime (HAC 4.24, Miller-Rabin)\nfunction bnpMillerRabin(t) {\n  var n1 = this.subtract(BigInteger.ONE);\n  var k = n1.getLowestSetBit();\n  if(k <= 0) return false;\n  var r = n1.shiftRight(k);\n  t = (t+1)>>1;\n  if(t > lowprimes.length) t = lowprimes.length;\n  var a = nbi();\n  for(var i = 0; i < t; ++i) {\n    //Pick bases at random, instead of starting at 2\n    a.fromInt(lowprimes[Math.floor(Math.random()*lowprimes.length)]);\n    var y = a.modPow(r,this);\n    if(y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {\n      var j = 1;\n      while(j++ < k && y.compareTo(n1) != 0) {\n        y = y.modPowInt(2,this);\n        if(y.compareTo(BigInteger.ONE) == 0) return false;\n      }\n      if(y.compareTo(n1) != 0) return false;\n    }\n  }\n  return true;\n}\n\n// protected\nBigInteger.prototype.chunkSize = bnpChunkSize;\nBigInteger.prototype.toRadix = bnpToRadix;\nBigInteger.prototype.fromRadix = bnpFromRadix;\nBigInteger.prototype.fromNumber = bnpFromNumber;\nBigInteger.prototype.bitwiseTo = bnpBitwiseTo;\nBigInteger.prototype.changeBit = bnpChangeBit;\nBigInteger.prototype.addTo = bnpAddTo;\nBigInteger.prototype.dMultiply = bnpDMultiply;\nBigInteger.prototype.dAddOffset = bnpDAddOffset;\nBigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;\nBigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;\nBigInteger.prototype.modInt = bnpModInt;\nBigInteger.prototype.millerRabin = bnpMillerRabin;\n\n// public\nBigInteger.prototype.clone = bnClone;\nBigInteger.prototype.intValue = bnIntValue;\nBigInteger.prototype.byteValue = bnByteValue;\nBigInteger.prototype.shortValue = bnShortValue;\nBigInteger.prototype.signum = bnSigNum;\nBigInteger.prototype.toByteArray = bnToByteArray;\nBigInteger.prototype.equals = bnEquals;\nBigInteger.prototype.min = bnMin;\nBigInteger.prototype.max = bnMax;\nBigInteger.prototype.and = bnAnd;\nBigInteger.prototype.or = bnOr;\nBigInteger.prototype.xor = bnXor;\nBigInteger.prototype.andNot = bnAndNot;\nBigInteger.prototype.not = bnNot;\nBigInteger.prototype.shiftLeft = bnShiftLeft;\nBigInteger.prototype.shiftRight = bnShiftRight;\nBigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;\nBigInteger.prototype.bitCount = bnBitCount;\nBigInteger.prototype.testBit = bnTestBit;\nBigInteger.prototype.setBit = bnSetBit;\nBigInteger.prototype.clearBit = bnClearBit;\nBigInteger.prototype.flipBit = bnFlipBit;\nBigInteger.prototype.add = bnAdd;\nBigInteger.prototype.subtract = bnSubtract;\nBigInteger.prototype.multiply = bnMultiply;\nBigInteger.prototype.divide = bnDivide;\nBigInteger.prototype.remainder = bnRemainder;\nBigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;\nBigInteger.prototype.modPow = bnModPow;\nBigInteger.prototype.modInverse = bnModInverse;\nBigInteger.prototype.pow = bnPow;\nBigInteger.prototype.gcd = bnGCD;\nBigInteger.prototype.isProbablePrime = bnIsProbablePrime;\n\n// JSBN-specific extension\nBigInteger.prototype.square = bnSquare;\n\n// BigInteger interfaces not implemented in jsbn:\n\n// BigInteger(int signum, byte[] magnitude)\n// double doubleValue()\n// float floatValue()\n// int hashCode()\n// long longValue()\n// static BigInteger valueOf(long val)\n\n})(require("__browserify_buffer").Buffer)\n},{"__browserify_buffer":7}],2:[function(require,module,exports){\n\nself.ndn = require(\'ndn-browser-shim\');\n\nvar yManager = function() {\n\n  this.certificate = null\n  this.publicKey = null\n  this.privateKey = null\n\n  this.key = null;\n};\nyManager.prototype.getKey = function()\n{\n  if (this.key === null) {\n    this.key = new ndn.Key();\n    this.key.fromPemString(this.publicKey, this.privateKey);\n  }\n\n  return this.key;\n}\n\nmodule.exports = new yManager()\n\n},{"ndn-browser-shim":5}],3:[function(require,module,exports){\nvar utils = {}\nvar Data = require(\'ndn-browser-shim\').Data\nvar Name = require(\'ndn-browser-shim\').Name\nvar SignedInfo = require(\'ndn-browser-shim\').SignedInfo\nvar ndnbuf = require(\'ndn-browser-shim\').ndnbuf\nvar DataUtils = require(\'ndn-browser-shim\').DataUtils\n\nutils.chunkArbitraryData = function(opts) {\n  var ndnArray = [];\n  //console.log(name)\n  if (opts.type == \'object\') {\n    var string = JSON.stringify(opts.thing);\n  } else if (typeof opts.data == \'string\') {\n    var string = data;\n  } else if (typeof opts.data == \'file\') {\n    //console.log(\'no handlers yet for datatype: \', typeof data);\n    return;\n  };\n  var name = new ndn.Name(opts.uri)\n  if (opts.version != false) {\n    utils.appendVersion(name, opts.version)\n  }\n  var stringArray = string.match(/.{1,4000}/g);\n  var segmentNames = [];\n  for (i = 0; i < stringArray.length; i++) {\n    segmentNames[i] = new Name(name).appendSegment(i)\n    var co = new Data(segmentNames[i], new SignedInfo(), new ndnbuf(stringArray[i]));\n    co.signedInfo.setFields()\n    co.signedInfo.finalBlockID = utils.initSegment(stringArray.length - 1)\n    console.log(co.signedInfo.finalBlockID)\n    if (opts.freshness != undefined) {\n      co.signedInfo.freshnessSeconds = fresh\n    }\n    co.sign()\n    ndnArray[i] = co.encode()\n  };\n\n  return {array:ndnArray, name: name};\n\n};\n\nutils.initSegment = function(seg) {\n    if (seg == null || seg == 0)\n\t  return (new ndnbuf(\'00\', \'hex\'));\n\n    var segStr = seg.toString(16);\n\n    if (segStr.length % 2 == 1)\n\tsegStr = \'0\' + segStr;\n\n    segStr = \'00\' + segStr;\n    return (new ndnbuf(segStr, \'hex\'));\n};\n\nutils.getAllPrefixes = function(name) {\n  var uriArray = [];\n  for (i = 0 ; i < name.components.length + 1 ; i++) {\n    var uri = name.getPrefix(i).toUri()\n    uriArray.push(uri);\n  };\n  return uriArray;\n};\n\nutils.isFirstSegment = function(name) {\n    return name.components != null && name.components.length >= 1 &&\n        name.components[name.components.length - 1].value.length == 1 &&\n        name.components[name.components.length - 1].value[0] == 0;\n};\n\nutils.isLastSegment = function(name, co) {\n\n    return DataUtils.arraysEqual(name.components[name.components.length - 1].value, co.signedInfo.finalBlockID);\n}\n\nutils.normalizeUri = function(name) {\n  //console.log(name)\n  if (!endsWithSegmentNumber(name)) {\n    normalizedName = name;\n    requestedSegment = 0\n  } else if (!isFirstSegment(name)) {\n    normalizedName = name.getPrefix(name.components.length - 1);\n    requestedSegment = DataUtils.bigEndianToUnsignedInt(name.components[name.components.length - 1].value);\n  } else {\n    normalizedName = name.getPrefix(name.components.length - 1) ;\n    requestedSegment = 0;\n  };\n  var returns = [normalizedName, requestedSegment];\n  return returns;\n};\n\nutils.getSegmentInteger = function(name) {\n  if (name.components != null && name.components.length >= 1 &&\n  name.components[name.components.length - 1].value.length >= 1 &&\n  name.components[name.components.length - 1].value[0] == 0) {\n    return DataUtils.bigEndianToUnsignedInt(name.components[name.components.length - 1].value)\n  } else {\n    return 0;\n  }\n};\n\nutils.normalizeNameToObjectStore = function(name) {\n  var throwaway = utils.getNameWithoutCommandMarker(name);\n\n  if (!utils.endsWithSegmentNumber(throwaway)) {\n    return throwaway.appendSegment(0).toUri();\n  } else if (!utils.isFirstSegment(throwaway)) {\n    return throwaway.getPrefix(name.components.length - 1).appendSegment(0).toUri();\n  } else {\n    return throwaway.toUri();\n  };\n};\n\nutils.endsWithSegmentNumber = function(name) {\n    return name.components != null && name.components.length >= 1 &&\n        name.components[name.components.length - 1].value.length >= 1 &&\n        name.components[name.components.length - 1].value[0] == 0;\n}\n\nutils.nameHasCommandMarker = function(name) {\n  for (var i = name.size() - 1; i >= 0; --i) {\n    var component = name.components[i].getValue();\n    if (component.length <= 0)\n      continue;\n\n    if (component[0] == 0xC1) {\n      return true\n    };\n  }\n\n  return false;\n};\n\nutils.getCommandMarker = function(name) {\n  //console.log(name)\n  for (var i = name.size() - 1; i >= 0; --i) {\n    var component = name.components[i].getValue();\n    if (component.length <= 0)\n      continue;\n\n    if (component[0] == 0xC1 && component[2] != 0x4E) {\n      return name.components[i].toEscapedString()\n    };\n  }\n};\n\nutils.getNameWithoutCommandMarker = function(name) {\n  var strippedName = new Name(\'\');\n\n  for (var i = 0 ; i < name.size(); i++) {\n    var component = name.components[i].getValue();\n    if (component.length <= 0)\n      continue;\n\n    if (component[0] != 0xC1) {\n      strippedName.append(name.components[i]);\n    };\n  };\n  return strippedName;\n};\n\n\nutils.getSuffix = function(name, p) {\n    return new Name(name.components.slice(p));\n};\n\nutils.appendVersion = function(name, date) {\n    console.log(date)\n    if (date) {\n      if (date instanceof Date) {\n        var d = date.getTime()\n\n      } else if (typeof date == "number")\n        var d = new Date().setTime(date)\n    } else {\n      var d = new Date().getTime();\n    };\n\n    var time = d.toString(16);\n    if (time.length % 2 == 1) {\n\t    time = \'0\' + time;\n    };\n    time = \'fd\' + time;\n    var binTime = new ndnbuf(time, \'hex\');\n    //console.log(binTime)\n    return name.append(binTime);\n};\n\nutils.timeToVersion = function(date) {\n  if (date instanceof Date) {\n    var d = date.getTime\n  } else {\n    var d = date;\n  };\n  var time = d.toString(16);\n  if (time.length % 2 == 1) {\n    time = \'0\' + time;\n  };\n  time = \'fd\' + time;\n  var binTime = new ndnbuf(time, \'hex\');\n  return (new Name.Component(binTime).toEscapedString())\n\n};\n\nutils.versionToTime = function(version) {\n  time = 0\n  array = DataUtils.toNumbers(DataUtils.toHex(version))\n  //console.log(array)\n  for (i = 1; i < array.length ; i++) {\n    time = time + (array[i] * Math.pow(2, (7 - i)));\n    //console.log(time)\n  };\n  return time\n};\n\n\n\nutils.setNonce = function(interest) {\n  var bytes = [0xc1, 0x2e, 0x4e, 0x00];\n  for (var n = 8; n > 0; n--) {\n\t  bytes.push(Math.floor(Math.random() * 256));\n\t  //console.log(bytes)\n  }\n  var buf = new ndnbuf(bytes);\n  interest.nonce = buf;\n}\n\nmodule.exports = utils;\n\n},{"ndn-browser-shim":5}],4:[function(require,module,exports){\nvar ndn = require(\'ndn-browser-shim\');\nvar BinaryXmlElementReader = ndn.BinaryXmlElementReader;\nvar ndnbuf = ndn.ndnbuf;\nvar Name = ndn.Name\nvar Data = ndn.Data\nvar LOG = require(\'./LOG.js\')\nvar local = {}\n\nlocal.transport = function (port) {\n  this.port = port\n};\n\n\n/**\n * Connect to the host and port in face.  This replaces a previous connection and sets connectedHost\n *   and connectedPort.  Once connected, call onopenCallback().\n * Listen on the port to read an entire binary XML encoded element and call\n *    face.onReceivedElement(element).\n */\nlocal.transport.prototype.connect = function(face, onopenCallback)\n{\n  this.elementReader = new BinaryXmlElementReader(face);\n  var self = this;\n  this.port.onmessage = function(ev) {\n    //console.log(\'RecvHandle called on local face\', result);\n\n    if (ev.data == null || ev.data == undefined || ev.data == "") {\n      console.log(\'INVALID ANSWER\');\n    }\n    else if (ev.data instanceof ArrayBuffer) {\n      var bytearray = new ndnbuf(ev.data);\n\n      if (LOG > 3) console.log(\'BINARY RESPONSE IS \' + bytearray.toString(\'hex\'));\n\n      try {\n        // Find the end of the binary XML element and call face.onReceivedElement.\n        self.elementReader.onReceivedData(bytearray);\n      } catch (ex) {\n        console.log("NDN.ws.onmessage exception: " + ex);\n        return;\n      }\n      // garbage collect arraybuffer\n      //var ms = new MessageChannel()\n      //ms.port1.postMessage(ev.data, [ev.data])\n    }\n  };\n\n  onopenCallback();\n\n};\n\n/**\n * Send the Uint8Array data.\n */\nlocal.transport.prototype.send = function(data)\n{\n  if (true) {\n        // If we directly use data.buffer to feed ws.send(),\n        // WebSocket may end up sending a packet with 10000 bytes of data.\n        // That is, WebSocket will flush the entire buffer\n        // regardless of the offset of the Uint8Array. So we have to create\n        // a new Uint8Array buffer with just the right size and copy the\n        // content from binaryInterest to the new buffer.\n        //    ---Wentao\n        var bytearray = new Uint8Array(data.length);\n        bytearray.set(data);\n        this.port.postMessage(bytearray.buffer);\n\n        //garbage collect\n        //var ms = new MessageChannel();\n        //ms.port1.postMessage(bytearray.buffer, [bytearray.buffer])\n        //ms.port1.postMessage(data.buffer, [data.buffer])\n    console.log(\'local.send() returned.\');\n  }\n  else\n    console.log(\'local connection is not established.\');\n};\n\nmodule.exports = local;\n\n},{"./LOG.js":6,"ndn-browser-shim":5}]},{},[1])\n;'],{type:"text/javascript"})));

io.outstandingFetches = [];
io.outstandingMakes = []
var ms = new MessageChannel();

io.accessDaemon = function(daemon, cert, priPem, pubPem){
  daemon.postMessage({port: "ioPort"}, [ms.port1]);
  io.worker.postMessage({port: "daemonPort"}, [ms.port2]);
  io.worker.postMessage({cert: cert, priPem: priPem, pubPem: pubPem})
}

io.fetch = function(req, whenGotten, whenNotGotten) {
  uri = (new ndn.Name(req.uri)).toUri()
  io.worker.postMessage({
    "command": "fetch",
    "uri": uri,
    "type": req.type,
    "version": req.version,
    "selectors": req.selectors
  });
  io.outstandingFetches.push({uri: uri, whenGotten: whenGotten, whenNotGotten: whenNotGotten});
}

io.publish = function(opts){
  console.log('sending publish command')
  io.worker.postMessage({
    "command": "publish",
    "uri": opts.uri,
    "type": opts.type,
    "thing": opts.thing,
    "version": opts.version
  })
}

io.makeEncodedData = function(uri, bytes, callback){
  io.outstandingMakes.push({id: bytes.toString(), callback: callback})
  io.worker.postMessage({command: "makeEncoded", uri: uri, bytes: bytes, id: bytes.toString()})
}

io.worker.onmessage = function (e) {
  if (e.data.responseTo == "fetch") {
    executeFetchCallback(e.data);
  } else if (e.data.responseTo == "publish") {
    executePublishCallback(e.data);
  } else if (e.data.responseTo == "makeEncoded") {
    executeEncodedDataCallback(e.data)
  }
}

function executeEncodedDataCallback(data) {
  for (var i = 0; i < io.outstandingMakes.length; i++) {
    if (io.outstandingMakes[i].id == data.id){
      io.outstandingMakes[i].callback(data.encoded)
    }
  }

}

var executeFetchCallback = function(response) {
  var mtch;
  console.log(response, io.outstandingFetches)
  for (var i = 0; i < io.outstandingFetches.length; i++){
    if (io.outstandingFetches[i].uri == response.uri) {
      console.log('matched outstanding fetch')
      mtch = io.outstandingFetches.splice(i,1)[0]
    }
  }
  console.log(mtch)
  if (response.success == true){
    mtch.whenGotten(new ndn.Name(mtch.uri), response.thing, response.firstCo);
  } else {
    mtch.whenNotGotten(new ndn.Name(mtch.uri));
  }

}

module.exports = io;

},{"ndn-browser-shim":128}],21:[function(require,module,exports){

self.ndn = require('ndn-browser-shim');

var yManager = function() {

  this.certificate = null
  this.publicKey = null
  this.privateKey = null

  this.key = null;
};
yManager.prototype.getKey = function()
{
  if (this.key === null) {
    this.key = new ndn.Key();
    this.key.fromPemString(this.publicKey, this.privateKey);
  }

  return this.key;
}

module.exports = new yManager()

},{"ndn-browser-shim":128}],22:[function(require,module,exports){
require('../forge.min.js');
var keygen = {};
var pki = forge.pki;

keygen.init = function(keyManagerPort, callback){
  console.log('checking keypair')
  if (localStorage['certificate'] == undefined) {

    var self = this;
    console.log('generating keypair', forge)
    pki.rsa.generateKeyPair({bits: 2048, workers: 2}, function(er, keys){
      console.log(er, keys)
      var cert = pki.createCertificate();
      cert.publicKey = keys.publicKey;
      cert.serialNumber = '01';
      cert.validity.notBefore = new Date();
      cert.validity.notAfter = new Date();
      cert.validity.notAfter.setFullYear(cert.validity.notBefore.getFullYear() + 1);
      cert.sign(keys.privateKey);
      var pem = pki.certificateToPem(cert);
      var pubPem = pki.publicKeyToPem(keys.publicKey);
      var priOpenPem = pki.privateKeyToPem(keys.privateKey);
      localStorage['certificate'] = pem;
      localStorage['publicKey'] = pubPem;
      var password = prompt('Please input a password to protect your new encryption key');
      var priPem = pki.encryptRsaPrivateKey(keys.privateKey, password);
      localStorage['privateKey'] = priPem;
      keyManagerPort.postMessage([pem, pubPem, priOpenPem])
    });
  } else {
    var password = prompt('please enter your password to unlock your private key')
    var EncryptedPriPem = localStorage['privateKey']
    var priKey = pki.decryptRsaPrivateKey(EncryptedPriPem, password)
    var priPem = pki.privateKeyToPem(priKey)
    var cert = localStorage['certificate']
    var pubPem = localStorage['publicKey']
    keyManagerPort.onmessage = function(e) {
      window.ndndid = e.data
      callback(e.data, cert,  priPem, pubPem)
    }
    keyManagerPort.postMessage([cert, pubPem, priPem])


  }
}

module.exports = keygen;


},{"../forge.min.js":9}],23:[function(require,module,exports){
var ndn = require('ndn-browser-shim');
ndn.io = require('./ndn-io.js')
var utils = require('./utils.js');
var RTCWorkerChannel = require('./ndn-RTCWorkerChannel.js');
var BinaryXmlElementReader = ndn.BinaryXmlElementReader;
var BinaryXmlWireFormat = ndn.BinaryXmlWireFormat;
var ndnbuf = ndn.ndnbuf;
var Name = ndn.Name
var Data = ndn.Data
var LOG = require('./LOG.js')


var PeerConnection = window.mozRTCPeerConnection || window.webkitRTCPeerConnection;
var IceCandidate = window.mozRTCIceCandidate || window.RTCIceCandidate;
var SessionDescription = window.mozRTCSessionDescription || window.RTCSessionDescription;

var rtc = {};
var servers = server = {
    iceServers: [
        {url: "stun:stun.l.google.com:19302"}
    ]
};


function sendOfferAndIceCandidate(ndndid, face, peer, offer, candidate) {
  var iceOffer = new Name(['ndnx', ndndid, 'newRTCface']);

  var obj = {action: 'newRTCface', sdp: offer.sdp, ice: candidate};
  console.log(ndn)
  var string = JSON.stringify(obj)
  var bytes = new ndn.ndnbuf(string)

  function onRemote(){
    peer.addIceCandidate(new RTCIceCandidate({
        sdpMLineIndex: answerIce.ice.sdpMLineIndex,
        candidate: answerIce.ice.candidate
    }));
  };

  var onAnswer = function (interest, data) {

    answerIce = JSON.parse(ndn.DataUtils.toString(data.content));
    console.log('got answer', answerIce)
    peer.setRemoteDescription(new RTCSessionDescription(answerIce.sdp), onRemote)
  };

  function encodingCallback (encoded){
    iceOffer.append(encoded)
    var offerInterest = new ndn.Interest(iceOffer)
    //console.log(offerInterest, face);
    offerInterest.interestLifetime = 5000;
    utils.setNonce(offerInterest);

    face.expressInterest(offerInterest, onAnswer);
  }
  ndn.io.makeEncodedData('', bytes, encodingCallback)
};


rtc.createDataChannel = function (ndndid, face) {
  if (ndndid == undefined) {
    ndndid = 'filler'
  }
  var peer = new PeerConnection(servers)
  var dataChannel = peer.createDataChannel('ndn', null);
  window.test = [peer, dataChannel]

  peer.onicecandidate = function (evt) {
    if (evt.candidate) {
      console.log('got ICE candidate, ', evt.candidate);
      sendOfferAndIceCandidate(ndndid, face, peer, peer.offer, evt.candidate);
      peer.onicecandidate = null;
    };
  };

  function onOfferCreated(offer){
    peer.offer = offer;
    peer.setLocalDescription(offer, onLocalDescriptionSet);
  }

  function onLocalDescriptionSet() {
    // after this function returns, pc1 will start firing icecandidate events
    //console.log('local description set, ', peer);
  };
  var cb = function(){return true}
  peer.createOffer(onOfferCreated);
  return dataChannel;
};

rtc.onInterest = function (prefix, interest, transport) {
  var nfblob = interest.name.components[3].value
  var d = new Data();
  d.decode(nfblob)
  var string = ndn.DataUtils.toString(d.content);
  //console.log(string)
  var iceOffer = JSON.parse(string)
  //console.log(iceOffer)
  var candidate = iceOffer.ice;

  //console.log(iceOffer);

  var offer = {
    type: "offer",
    sdp: iceOffer.sdp
  };

  var peer = new PeerConnection(servers);
  //window.test = peer

  peer.onicecandidate = function (evt) {
    peer.answer.ice = evt.candidate
    var string = JSON.stringify(peer.answer);
    var sending = new ndn.ndnbuf(string)
    var data = new ndn.Data(interest.name, new ndn.SignedInfo(), sending)
    data.signedInfo.setFields()
    data.signedInfo.freshnessSeconds = 0
    data.sign();
    var encoded = data.encode()

    transport.send(encoded);
    //console.log('sent answer', peer.answer);
    peer.onicecandidate = null;
  };

  peer.ondatachannel = function (evt) {
    var dataChannel = evt.channel
    var wrapper = new RTCWorkerChannel(dataChannel);

    rtc.daemon.postMessage({port: "RTCPort", ndndid: d.signedInfo.publisher.publisherPublicKeyDigest}, [wrapper.port])

  };

  peer.setRemoteDescription(new RTCSessionDescription(offer), onRemoteSet)


  var onCreated = function(sdp) {
    peer.setLocalDescription(sdp)
    peer.answer = {};
    peer.answer.sdp = sdp

  };

  function onRemoteSet() {
    peer.addIceCandidate(new RTCIceCandidate({
      sdpMLineIndex: candidate.sdpMLineIndex,
      candidate: candidate.candidate
    }));
    peer.createAnswer(onCreated)
  };

};

rtc.init = function(daemon) {
  rtc.daemon = daemon
}

module.exports = rtc;

},{"./LOG.js":11,"./ndn-RTCWorkerChannel.js":17,"./ndn-io.js":20,"./utils.js":26,"ndn-browser-shim":128}],24:[function(require,module,exports){
var ndn = require('ndn-browser-shim'),
    utils = require('./utils.js'),
    FIB = require('./ndn-FIB.js'),
    strategy = {};

ndn.PIT = require('./ndn-PIT.js');


strategy.forwardInterest = function(thisFace, element, interest) {

  console.log('interest got cache miss in forwarding face')
  // Send the interest to the matching faces in the FIB.
  var isLocalInterest = false;
  if (utils.nameHasCommandMarker(interest.name)) {
    if (utils.getCommandMarker(interest.name) == '%C1.M.S.localhost') {
      //console.log("interest has localhost commandMarker")
      isLocalInterest = true;
    }
  }
  //console.log(ndn.FIB)

  function forward(FIBEntrys) {
    console.log("found FIBEntrys ", FIBEntrys)
    var sent = []
    for (var i = 0; i < FIBEntrys.length; i++){
      var entry = FIBEntrys[i]
      var faceID = entry.faceID
      if (sent[faceID] == undefined) {
        ndn.Faces.list[faceID].transport.send(element)
        sent[faceID] = true
      }
    }
  }

  ndn.FIB.lookupByName(interest.name, forward)
}

strategy.forwardData = function(element) {}

strategy.onNewFace = function(face) {
  function express (results){
    for(var i = 0; i < results.length; i++) {
      var element = results[i].encodedInterest
      face.transport.send(element)
    }
  }
  if (face.registeredPrefixes!= null){
    for (var j = 0; j < face.registeredPrefixes.length; j++) {
      console.log(ndn.PIT)
      ndn.PIT.lookupName(face.registeredPrefixes[j], express )
    }
  }

  var faceID = ndn.Faces.add(face)
}

strategy.onPrefixRegistered = function(forwardingEntry) {

}

strategy.caughtDataSends = function(caught) {
  console.log(caught)
}

module.exports = strategy

},{"./ndn-FIB.js":13,"./ndn-PIT.js":16,"./utils.js":26,"ndn-browser-shim":128}],25:[function(require,module,exports){
var ndn = require("ndn-browser-shim");
var utils = require("./utils.js");
var rtc = require("./ndn-rtc.js");
ndn.MessageChannelTransport = require("./ndn-MessageChannelTransport.js")
var Face = ndn.Face;
var Data = ndn.Data;
var Interest = ndn.Interest;
var LOG = require('./LOG.js')


var RegisteredPrefix = function RegisteredPrefix(prefix, closure)
{
  this.prefix = prefix;        // String
  this.closure = closure;  // Closure
};



var onInterest = function(prefix, interest, transport) {
  if (LOG > 3) console.log("got intersest in ndnx system namespace", prefix, interest, transport);
  if (interest.name.components.length > 2) {
    if (interest.name.components[2].toEscapedString() == "newRTCface") {
      console.log("interest ")
      rtc.onInterest(prefix, interest, transport)
    } else if (interest.name.components[2].toEscapedString() == "selfreg") {
      console.log('y u try non working feature?')
      ndn.fd.postMessage({ndnx: 'selfreg', interest: interest})

    };
  }


};

var ndnx = {}

ndnx.init = function(daemon, id){
  var ms = new MessageChannel()
  console.log(id)
  var prefix = new ndn.Name(['ndnx', id]);
  var uri = prefix.toUri()
  ndnx.face = new ndn.Face({host:20, port:20, getTransport: function(){return new ndn.MessageChannelTransport.transport(ms.port1)}})
  ndnx.face.transport.connect(ndnx.face, function(){console.log('ndnx face connected')})
  var closure = new Face.CallbackClosure(null, null, onInterest, prefix, ndnx.face.transport);
  Face.registeredPrefixTable.push(new RegisteredPrefix(prefix, closure));
  daemon.postMessage({port: "ndnxPort"}, [ms.port2])
  rtc.init(daemon)
}



module.exports = ndnx

},{"./LOG.js":11,"./ndn-MessageChannelTransport.js":15,"./ndn-rtc.js":23,"./utils.js":26,"ndn-browser-shim":128}],26:[function(require,module,exports){
var utils = {}
var Data = require('ndn-browser-shim').Data
var Name = require('ndn-browser-shim').Name
var SignedInfo = require('ndn-browser-shim').SignedInfo
var ndnbuf = require('ndn-browser-shim').ndnbuf
var DataUtils = require('ndn-browser-shim').DataUtils

utils.chunkArbitraryData = function(opts) {
  var ndnArray = [];
  //console.log(name)
  if (opts.type == 'object') {
    var string = JSON.stringify(opts.thing);
  } else if (typeof opts.data == 'string') {
    var string = data;
  } else if (typeof opts.data == 'file') {
    //console.log('no handlers yet for datatype: ', typeof data);
    return;
  };
  var name = new ndn.Name(opts.uri)
  if (opts.version != false) {
    utils.appendVersion(name, opts.version)
  }
  var stringArray = string.match(/.{1,4000}/g);
  var segmentNames = [];
  for (i = 0; i < stringArray.length; i++) {
    segmentNames[i] = new Name(name).appendSegment(i)
    var co = new Data(segmentNames[i], new SignedInfo(), new ndnbuf(stringArray[i]));
    co.signedInfo.setFields()
    co.signedInfo.finalBlockID = utils.initSegment(stringArray.length - 1)
    console.log(co.signedInfo.finalBlockID)
    if (opts.freshness != undefined) {
      co.signedInfo.freshnessSeconds = fresh
    }
    co.sign()
    ndnArray[i] = co.encode()
  };

  return {array:ndnArray, name: name};

};

utils.initSegment = function(seg) {
    if (seg == null || seg == 0)
	  return (new ndnbuf('00', 'hex'));

    var segStr = seg.toString(16);

    if (segStr.length % 2 == 1)
	segStr = '0' + segStr;

    segStr = '00' + segStr;
    return (new ndnbuf(segStr, 'hex'));
};

utils.getAllPrefixes = function(name) {
  var uriArray = [];
  for (i = 0 ; i < name.components.length + 1 ; i++) {
    var uri = name.getPrefix(i).toUri()
    uriArray.push(uri);
  };
  return uriArray;
};

utils.isFirstSegment = function(name) {
    return name.components != null && name.components.length >= 1 &&
        name.components[name.components.length - 1].value.length == 1 &&
        name.components[name.components.length - 1].value[0] == 0;
};

utils.isLastSegment = function(name, co) {

    return DataUtils.arraysEqual(name.components[name.components.length - 1].value, co.signedInfo.finalBlockID);
}

utils.normalizeUri = function(name) {
  //console.log(name)
  if (!endsWithSegmentNumber(name)) {
    normalizedName = name;
    requestedSegment = 0
  } else if (!isFirstSegment(name)) {
    normalizedName = name.getPrefix(name.components.length - 1);
    requestedSegment = DataUtils.bigEndianToUnsignedInt(name.components[name.components.length - 1].value);
  } else {
    normalizedName = name.getPrefix(name.components.length - 1) ;
    requestedSegment = 0;
  };
  var returns = [normalizedName, requestedSegment];
  return returns;
};

utils.getSegmentInteger = function(name) {
  if (name.components != null && name.components.length >= 1 &&
  name.components[name.components.length - 1].value.length >= 1 &&
  name.components[name.components.length - 1].value[0] == 0) {
    return DataUtils.bigEndianToUnsignedInt(name.components[name.components.length - 1].value)
  } else {
    return 0;
  }
};

utils.normalizeNameToObjectStore = function(name) {
  var throwaway = utils.getNameWithoutCommandMarker(name);

  if (!utils.endsWithSegmentNumber(throwaway)) {
    return throwaway.appendSegment(0).toUri();
  } else if (!utils.isFirstSegment(throwaway)) {
    return throwaway.getPrefix(name.components.length - 1).appendSegment(0).toUri();
  } else {
    return throwaway.toUri();
  };
};

utils.endsWithSegmentNumber = function(name) {
    return name.components != null && name.components.length >= 1 &&
        name.components[name.components.length - 1].value.length >= 1 &&
        name.components[name.components.length - 1].value[0] == 0;
}

utils.nameHasCommandMarker = function(name) {
  for (var i = name.size() - 1; i >= 0; --i) {
    var component = name.components[i].getValue();
    if (component.length <= 0)
      continue;

    if (component[0] == 0xC1) {
      return true
    };
  }

  return false;
};

utils.getCommandMarker = function(name) {
  //console.log(name)
  for (var i = name.size() - 1; i >= 0; --i) {
    var component = name.components[i].getValue();
    if (component.length <= 0)
      continue;

    if (component[0] == 0xC1 && component[2] != 0x4E) {
      return name.components[i].toEscapedString()
    };
  }
};

utils.getNameWithoutCommandMarker = function(name) {
  var strippedName = new Name('');

  for (var i = 0 ; i < name.size(); i++) {
    var component = name.components[i].getValue();
    if (component.length <= 0)
      continue;

    if (component[0] != 0xC1) {
      strippedName.append(name.components[i]);
    };
  };
  return strippedName;
};


utils.getSuffix = function(name, p) {
    return new Name(name.components.slice(p));
};

utils.appendVersion = function(name, date) {
    console.log(date)
    if (date) {
      if (date instanceof Date) {
        var d = date.getTime()

      } else if (typeof date == "number")
        var d = new Date().setTime(date)
    } else {
      var d = new Date().getTime();
    };

    var time = d.toString(16);
    if (time.length % 2 == 1) {
	    time = '0' + time;
    };
    time = 'fd' + time;
    var binTime = new ndnbuf(time, 'hex');
    //console.log(binTime)
    return name.append(binTime);
};

utils.timeToVersion = function(date) {
  if (date instanceof Date) {
    var d = date.getTime
  } else {
    var d = date;
  };
  var time = d.toString(16);
  if (time.length % 2 == 1) {
    time = '0' + time;
  };
  time = 'fd' + time;
  var binTime = new ndnbuf(time, 'hex');
  return (new Name.Component(binTime).toEscapedString())

};

utils.versionToTime = function(version) {
  time = 0
  array = DataUtils.toNumbers(DataUtils.toHex(version))
  //console.log(array)
  for (i = 1; i < array.length ; i++) {
    time = time + (array[i] * Math.pow(2, (7 - i)));
    //console.log(time)
  };
  return time
};



utils.setNonce = function(interest) {
  var bytes = [0xc1, 0x2e, 0x4e, 0x00];
  for (var n = 8; n > 0; n--) {
	  bytes.push(Math.floor(Math.random() * 256));
	  //console.log(bytes)
  }
  var buf = new ndnbuf(bytes);
  interest.nonce = buf;
}

module.exports = utils;

},{"ndn-browser-shim":128}],27:[function(require,module,exports){
/*global window:false, self:false, define:false, module:false */

/**
 * @license IDBWrapper - A cross-browser wrapper for IndexedDB
 * Copyright (c) 2011 - 2013 Jens Arps
 * http://jensarps.de/
 *
 * Licensed under the MIT (X11) license
 */

(function (name, definition, global) {
  if (typeof define === 'function') {
    define(definition);
  } else if (typeof module !== 'undefined' && module.exports) {
    module.exports = definition();
  } else {
    global[name] = definition();
  }
})('IDBStore', function () {

  'use strict';

  var defaultErrorHandler = function (error) {
    throw error;
  };

  var defaults = {
    storeName: 'Store',
    storePrefix: 'IDBWrapper-',
    dbVersion: 1,
    keyPath: 'id',
    autoIncrement: true,
    onStoreReady: function () {
    },
    onError: defaultErrorHandler,
    indexes: []
  };

  /**
   *
   * The IDBStore constructor
   *
   * @constructor
   * @name IDBStore
   * @version 1.4.1
   *
   * @param {Object} [kwArgs] An options object used to configure the store and
   *  set callbacks
   * @param {String} [kwArgs.storeName='Store'] The name of the store
   * @param {String} [kwArgs.storePrefix='IDBWrapper-'] A prefix that is
   *  internally used to construct the name of the database, which will be
   *  kwArgs.storePrefix + kwArgs.storeName
   * @param {Number} [kwArgs.dbVersion=1] The version of the store
   * @param {String} [kwArgs.keyPath='id'] The key path to use. If you want to
   *  setup IDBWrapper to work with out-of-line keys, you need to set this to
   *  `null`
   * @param {Boolean} [kwArgs.autoIncrement=true] If set to true, IDBStore will
   *  automatically make sure a unique keyPath value is present on each object
   *  that is stored.
   * @param {Function} [kwArgs.onStoreReady] A callback to be called when the
   *  store is ready to be used.
   * @param {Function} [kwArgs.onError=throw] A callback to be called when an
   *  error occurred during instantiation of the store.
   * @param {Array} [kwArgs.indexes=[]] An array of indexData objects
   *  defining the indexes to use with the store. For every index to be used
   *  one indexData object needs to be passed in the array.
   *  An indexData object is defined as follows:
   * @param {Object} [kwArgs.indexes.indexData] An object defining the index to
   *  use
   * @param {String} kwArgs.indexes.indexData.name The name of the index
   * @param {String} [kwArgs.indexes.indexData.keyPath] The key path of the index
   * @param {Boolean} [kwArgs.indexes.indexData.unique] Whether the index is unique
   * @param {Boolean} [kwArgs.indexes.indexData.multiEntry] Whether the index is multi entry
   * @param {Function} [onStoreReady] A callback to be called when the store
   * is ready to be used.
   * @example
      // create a store for customers with an additional index over the
      // `lastname` property.
      var myCustomerStore = new IDBStore({
        dbVersion: 1,
        storeName: 'customer-index',
        keyPath: 'customerid',
        autoIncrement: true,
        onStoreReady: populateTable,
        indexes: [
          { name: 'lastname', keyPath: 'lastname', unique: false, multiEntry: false }
        ]
      });
   * @example
      // create a generic store
      var myCustomerStore = new IDBStore({
        storeName: 'my-data-store',
        onStoreReady: function(){
          // start working with the store.
        }
      });
   */
  var IDBStore = function (kwArgs, onStoreReady) {

    if (typeof onStoreReady == 'undefined' && typeof kwArgs == 'function') {
      onStoreReady = kwArgs;
    }
    if (Object.prototype.toString.call(kwArgs) != '[object Object]') {
      kwArgs = {};
    }

    for (var key in defaults) {
      this[key] = typeof kwArgs[key] != 'undefined' ? kwArgs[key] : defaults[key];
    }

    this.dbName = this.storePrefix + this.storeName;
    this.dbVersion = parseInt(this.dbVersion, 10) || 1;

    onStoreReady && (this.onStoreReady = onStoreReady);

    var env = typeof window == 'object' ? window : self;
    this.idb = env.indexedDB || env.webkitIndexedDB || env.mozIndexedDB;
    this.keyRange = env.IDBKeyRange || env.webkitIDBKeyRange || env.mozIDBKeyRange;

    this.features = {
      hasAutoIncrement: !env.mozIndexedDB
    };

    this.consts = {
      'READ_ONLY':         'readonly',
      'READ_WRITE':        'readwrite',
      'VERSION_CHANGE':    'versionchange',
      'NEXT':              'next',
      'NEXT_NO_DUPLICATE': 'nextunique',
      'PREV':              'prev',
      'PREV_NO_DUPLICATE': 'prevunique'
    };

    this.openDB();
  };

  IDBStore.prototype = /** @lends IDBStore */ {

    /**
     * A pointer to the IDBStore ctor
     *
     * @type IDBStore
     */
    constructor: IDBStore,

    /**
     * The version of IDBStore
     *
     * @type String
     */
    version: '1.4.1',

    /**
     * A reference to the IndexedDB object
     *
     * @type Object
     */
    db: null,

    /**
     * The full name of the IndexedDB used by IDBStore, composed of
     * this.storePrefix + this.storeName
     *
     * @type String
     */
    dbName: null,

    /**
     * The version of the IndexedDB used by IDBStore
     *
     * @type Number
     */
    dbVersion: null,

    /**
     * A reference to the objectStore used by IDBStore
     *
     * @type Object
     */
    store: null,

    /**
     * The store name
     *
     * @type String
     */
    storeName: null,

    /**
     * The key path
     *
     * @type String
     */
    keyPath: null,

    /**
     * Whether IDBStore uses autoIncrement
     *
     * @type Boolean
     */
    autoIncrement: null,

    /**
     * The indexes used by IDBStore
     *
     * @type Array
     */
    indexes: null,

    /**
     * A hashmap of features of the used IDB implementation
     *
     * @type Object
     * @proprty {Boolean} autoIncrement If the implementation supports
     *  native auto increment
     */
    features: null,

    /**
     * The callback to be called when the store is ready to be used
     *
     * @type Function
     */
    onStoreReady: null,

    /**
     * The callback to be called if an error occurred during instantiation
     * of the store
     *
     * @type Function
     */
    onError: null,

    /**
     * The internal insertID counter
     *
     * @type Number
     * @private
     */
    _insertIdCount: 0,

    /**
     * Opens an IndexedDB; called by the constructor.
     *
     * Will check if versions match and compare provided index configuration
     * with existing ones, and update indexes if necessary.
     *
     * Will call this.onStoreReady() if everything went well and the store
     * is ready to use, and this.onError() is something went wrong.
     *
     * @private
     *
     */
    openDB: function () {

      var openRequest = this.idb.open(this.dbName, this.dbVersion);
      var preventSuccessCallback = false;

      openRequest.onerror = function (error) {

        var gotVersionErr = false;
        if ('error' in error.target) {
          gotVersionErr = error.target.error.name == 'VersionError';
        } else if ('errorCode' in error.target) {
          gotVersionErr = error.target.errorCode == 12;
        }

        if (gotVersionErr) {
          this.onError(new Error('The version number provided is lower than the existing one.'));
        } else {
          this.onError(error);
        }
      }.bind(this);

      openRequest.onsuccess = function (event) {

        if (preventSuccessCallback) {
          return;
        }

        if(this.db){
          this.onStoreReady();
          return;
        }

        this.db = event.target.result;

        if(typeof this.db.version == 'string'){
          this.onError(new Error('The IndexedDB implementation in this browser is outdated. Please upgrade your browser.'));
          return;
        }

        if(!this.db.objectStoreNames.contains(this.storeName)){
          // We should never ever get here.
          // Lets notify the user anyway.
          this.onError(new Error('Something is wrong with the IndexedDB implementation in this browser. Please upgrade your browser.'));
          return;
        }

        var emptyTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);
        this.store = emptyTransaction.objectStore(this.storeName);

        // check indexes
        var existingIndexes = Array.prototype.slice.call(this.getIndexList());
        this.indexes.forEach(function(indexData){
          var indexName = indexData.name;

          if(!indexName){
            preventSuccessCallback = true;
            this.onError(new Error('Cannot create index: No index name given.'));
            return;
          }

          this.normalizeIndexData(indexData);

          if(this.hasIndex(indexName)){
            // check if it complies
            var actualIndex = this.store.index(indexName);
            var complies = this.indexComplies(actualIndex, indexData);
            if(!complies){
              preventSuccessCallback = true;
              this.onError(new Error('Cannot modify index "' + indexName + '" for current version. Please bump version number to ' + ( this.dbVersion + 1 ) + '.'));
            }

            existingIndexes.splice(existingIndexes.indexOf(indexName), 1);
          } else {
            preventSuccessCallback = true;
            this.onError(new Error('Cannot create new index "' + indexName + '" for current version. Please bump version number to ' + ( this.dbVersion + 1 ) + '.'));
          }

        }, this);

        if (existingIndexes.length) {
          preventSuccessCallback = true;
          this.onError(new Error('Cannot delete index(es) "' + existingIndexes.toString() + '" for current version. Please bump version number to ' + ( this.dbVersion + 1 ) + '.'));
        }

        preventSuccessCallback || this.onStoreReady();
      }.bind(this);

      openRequest.onupgradeneeded = function(/* IDBVersionChangeEvent */ event){

        this.db = event.target.result;

        if(this.db.objectStoreNames.contains(this.storeName)){
          this.store = event.target.transaction.objectStore(this.storeName);
        } else {
          var optionalParameters = { autoIncrement: this.autoIncrement };
          if (this.keyPath !== null) {
            optionalParameters.keyPath = this.keyPath;
          }
          this.store = this.db.createObjectStore(this.storeName, optionalParameters);
        }

        var existingIndexes = Array.prototype.slice.call(this.getIndexList());
        this.indexes.forEach(function(indexData){
          var indexName = indexData.name;

          if(!indexName){
            preventSuccessCallback = true;
            this.onError(new Error('Cannot create index: No index name given.'));
          }

          this.normalizeIndexData(indexData);

          if(this.hasIndex(indexName)){
            // check if it complies
            var actualIndex = this.store.index(indexName);
            var complies = this.indexComplies(actualIndex, indexData);
            if(!complies){
              // index differs, need to delete and re-create
              this.store.deleteIndex(indexName);
              this.store.createIndex(indexName, indexData.keyPath, { unique: indexData.unique, multiEntry: indexData.multiEntry });
            }

            existingIndexes.splice(existingIndexes.indexOf(indexName), 1);
          } else {
            this.store.createIndex(indexName, indexData.keyPath, { unique: indexData.unique, multiEntry: indexData.multiEntry });
          }

        }, this);

        if (existingIndexes.length) {
          existingIndexes.forEach(function(_indexName){
            this.store.deleteIndex(_indexName);
          }, this);
        }

      }.bind(this);
    },

    /**
     * Deletes the database used for this store if the IDB implementations
     * provides that functionality.
     */
    deleteDatabase: function () {
      if (this.idb.deleteDatabase) {
        this.idb.deleteDatabase(this.dbName);
      }
    },

    /*********************
     * data manipulation *
     *********************/

    /**
     * Puts an object into the store. If an entry with the given id exists,
     * it will be overwritten. This method has a different signature for inline
     * keys and out-of-line keys; please see the examples below.
     *
     * @param {*} [key] The key to store. This is only needed if IDBWrapper
     *  is set to use out-of-line keys. For inline keys - the default scenario -
     *  this can be omitted.
     * @param {Object} value The data object to store.
     * @param {Function} [onSuccess] A callback that is called if insertion
     *  was successful.
     * @param {Function} [onError] A callback that is called if insertion
     *  failed.
     * @returns {IDBTransaction} The transaction used for this operation.
     * @example
        // Storing an object, using inline keys (the default scenario):
        var myCustomer = {
          customerid: 2346223,
          lastname: 'Doe',
          firstname: 'John'
        };
        myCustomerStore.put(myCustomer, mySuccessHandler, myErrorHandler);
        // Note that passing success- and error-handlers is optional.
     * @example
        // Storing an object, using out-of-line keys:
       var myCustomer = {
         lastname: 'Doe',
         firstname: 'John'
       };
       myCustomerStore.put(2346223, myCustomer, mySuccessHandler, myErrorHandler);
      // Note that passing success- and error-handlers is optional.
     */
    put: function (key, value, onSuccess, onError) {
      if (this.keyPath !== null) {
        onError = onSuccess;
        onSuccess = value;
        value = key;
      }
      onError || (onError = defaultErrorHandler);
      onSuccess || (onSuccess = noop);

      var hasSuccess = false,
          result = null,
          putRequest;

      var putTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);
      putTransaction.oncomplete = function () {
        var callback = hasSuccess ? onSuccess : onError;
        callback(result);
      };
      putTransaction.onabort = onError;
      putTransaction.onerror = onError;

      if (this.keyPath !== null) { // in-line keys
        this._addIdPropertyIfNeeded(value);
        putRequest = putTransaction.objectStore(this.storeName).put(value);
      } else { // out-of-line keys
        putRequest = putTransaction.objectStore(this.storeName).put(value, key);
      }
      putRequest.onsuccess = function (event) {
        hasSuccess = true;
        result = event.target.result;
      };
      putRequest.onerror = onError;

      return putTransaction;
    },

    /**
     * Retrieves an object from the store. If no entry exists with the given id,
     * the success handler will be called with null as first and only argument.
     *
     * @param {*} key The id of the object to fetch.
     * @param {Function} [onSuccess] A callback that is called if fetching
     *  was successful. Will receive the object as only argument.
     * @param {Function} [onError] A callback that will be called if an error
     *  occurred during the operation.
     * @returns {IDBTransaction} The transaction used for this operation.
     */
    get: function (key, onSuccess, onError) {
      onError || (onError = defaultErrorHandler);
      onSuccess || (onSuccess = noop);

      var hasSuccess = false,
          result = null;
      
      var getTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);
      getTransaction.oncomplete = function () {
        var callback = hasSuccess ? onSuccess : onError;
        callback(result);
      };
      getTransaction.onabort = onError;
      getTransaction.onerror = onError;
      var getRequest = getTransaction.objectStore(this.storeName).get(key);
      getRequest.onsuccess = function (event) {
        hasSuccess = true;
        result = event.target.result;
      };
      getRequest.onerror = onError;

      return getTransaction;
    },

    /**
     * Removes an object from the store.
     *
     * @param {*} key The id of the object to remove.
     * @param {Function} [onSuccess] A callback that is called if the removal
     *  was successful.
     * @param {Function} [onError] A callback that will be called if an error
     *  occurred during the operation.
     * @returns {IDBTransaction} The transaction used for this operation.
     */
    remove: function (key, onSuccess, onError) {
      onError || (onError = defaultErrorHandler);
      onSuccess || (onSuccess = noop);

      var hasSuccess = false,
          result = null;

      var removeTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);
      removeTransaction.oncomplete = function () {
        var callback = hasSuccess ? onSuccess : onError;
        callback(result);
      };
      removeTransaction.onabort = onError;
      removeTransaction.onerror = onError;

      var deleteRequest = removeTransaction.objectStore(this.storeName)['delete'](key);
      deleteRequest.onsuccess = function (event) {
        hasSuccess = true;
        result = event.target.result;
      };
      deleteRequest.onerror = onError;

      return removeTransaction;
    },

    /**
     * Runs a batch of put and/or remove operations on the store.
     *
     * @param {Array} dataArray An array of objects containing the operation to run
     *  and the data object (for put operations).
     * @param {Function} [onSuccess] A callback that is called if all operations
     *  were successful.
     * @param {Function} [onError] A callback that is called if an error
     *  occurred during one of the operations.
     * @returns {IDBTransaction} The transaction used for this operation.
     */
    batch: function (dataArray, onSuccess, onError) {
      onError || (onError = defaultErrorHandler);
      onSuccess || (onSuccess = noop);

      if(Object.prototype.toString.call(dataArray) != '[object Array]'){
        onError(new Error('dataArray argument must be of type Array.'));
      }
      var batchTransaction = this.db.transaction([this.storeName] , this.consts.READ_WRITE);
      batchTransaction.oncomplete = function () {
        var callback = hasSuccess ? onSuccess : onError;
        callback(hasSuccess);
      };
      batchTransaction.onabort = onError;
      batchTransaction.onerror = onError;
      
      var count = dataArray.length;
      var called = false;
      var hasSuccess = false;

      var onItemSuccess = function () {
        count--;
        if (count === 0 && !called) {
          called = true;
          hasSuccess = true;
        }
      };

      dataArray.forEach(function (operation) {
        var type = operation.type;
        var key = operation.key;
        var value = operation.value;

        var onItemError = function (err) {
          batchTransaction.abort();
          if (!called) {
            called = true;
            onError(err, type, key);
          }
        };

        if (type == 'remove') {
          var deleteRequest = batchTransaction.objectStore(this.storeName)['delete'](key);
          deleteRequest.onsuccess = onItemSuccess;
          deleteRequest.onerror = onItemError;
        } else if (type == 'put') {
          var putRequest;
          if (this.keyPath !== null) { // in-line keys
            this._addIdPropertyIfNeeded(value);
            putRequest = batchTransaction.objectStore(this.storeName).put(value);
          } else { // out-of-line keys
            putRequest = batchTransaction.objectStore(this.storeName).put(value, key);
          }
          putRequest.onsuccess = onItemSuccess;
          putRequest.onerror = onItemError;
        }
      }, this);

      return batchTransaction;
    },

    /**
     * Takes an array of objects and stores them in a single transaction.
     *
     * @param {Array} dataArray An array of objects to store
     * @param {Function} [onSuccess] A callback that is called if all operations
     *  were successful.
     * @param {Function} [onError] A callback that is called if an error
     *  occurred during one of the operations.
     * @returns {IDBTransaction} The transaction used for this operation.
     */
    putBatch: function (dataArray, onSuccess, onError) {
      var batchData = dataArray.map(function(item){
        return { type: 'put', value: item };
      });

      return this.batch(batchData, onSuccess, onError);
    },

    /**
     * Takes an array of keys and removes matching objects in a single
     * transaction.
     *
     * @param {Array} keyArray An array of keys to remove
     * @param {Function} [onSuccess] A callback that is called if all operations
     *  were successful.
     * @param {Function} [onError] A callback that is called if an error
     *  occurred during one of the operations.
     * @returns {IDBTransaction} The transaction used for this operation.
     */
    removeBatch: function (keyArray, onSuccess, onError) {
      var batchData = keyArray.map(function(key){
        return { type: 'remove', key: key };
      });

      return this.batch(batchData, onSuccess, onError);
    },

    /**
     * Takes an array of keys and fetches matching objects
     *
     * @param {Array} keyArray An array of keys identifying the objects to fetch
     * @param {Function} [onSuccess] A callback that is called if all operations
     *  were successful.
     * @param {Function} [onError] A callback that is called if an error
     *  occurred during one of the operations.
     * @param {String} [arrayType='sparse'] The type of array to pass to the
     *  success handler. May be one of 'sparse', 'dense' or 'skip'. Defaults to
     *  'sparse'. This parameter specifies how to handle the situation if a get
     *  operation did not throw an error, but there was no matching object in
     *  the database. In most cases, 'sparse' provides the most desired
     *  behavior. See the examples for details.
     * @returns {IDBTransaction} The transaction used for this operation.
     * @example
     // given that there are two objects in the database with the keypath
     // values 1 and 2, and the call looks like this:
     myStore.getBatch([1, 5, 2], onError, function (data) { … }, arrayType);

     // this is what the `data` array will be like:

     // arrayType == 'sparse':
     // data is a sparse array containing two entries and having a length of 3:
       [Object, 2: Object]
         0: Object
         2: Object
         length: 3
         __proto__: Array[0]
     // calling forEach on data will result in the callback being called two
     // times, with the index parameter matching the index of the key in the
     // keyArray.

     // arrayType == 'dense':
     // data is a dense array containing three entries and having a length of 3,
     // where data[1] is of type undefined:
       [Object, undefined, Object]
         0: Object
         1: undefined
         2: Object
         length: 3
         __proto__: Array[0]
     // calling forEach on data will result in the callback being called three
     // times, with the index parameter matching the index of the key in the
     // keyArray, but the second call will have undefined as first argument.

     // arrayType == 'skip':
     // data is a dense array containing two entries and having a length of 2:
       [Object, Object]
         0: Object
         1: Object
         length: 2
         __proto__: Array[0]
     // calling forEach on data will result in the callback being called two
     // times, with the index parameter not matching the index of the key in the
     // keyArray.
     */
    getBatch: function (keyArray, onSuccess, onError, arrayType) {
      onError || (onError = defaultErrorHandler);
      onSuccess || (onSuccess = noop);
      arrayType || (arrayType = 'sparse');

      if(Object.prototype.toString.call(keyArray) != '[object Array]'){
        onError(new Error('keyArray argument must be of type Array.'));
      }
      var batchTransaction = this.db.transaction([this.storeName] , this.consts.READ_ONLY);
      batchTransaction.oncomplete = function () {
        var callback = hasSuccess ? onSuccess : onError;
        callback(result);
      };
      batchTransaction.onabort = onError;
      batchTransaction.onerror = onError;

      var data = [];
      var count = keyArray.length;
      var called = false;
      var hasSuccess = false;
      var result = null;

      var onItemSuccess = function (event) {
        if (event.target.result || arrayType == 'dense') {
          data.push(event.target.result);
        } else if (arrayType == 'sparse') {
          data.length++;
        }
        count--;
        if (count === 0) {
          called = true;
          hasSuccess = true;
          result = data;
        }
      };

      keyArray.forEach(function (key) {

        var onItemError = function (err) {
          called = true;
          result = err;
          onError(err);
          batchTransaction.abort();
        };

        var getRequest = batchTransaction.objectStore(this.storeName).get(key);
        getRequest.onsuccess = onItemSuccess;
        getRequest.onerror = onItemError;

      }, this);

      return batchTransaction;
    },

    /**
     * Fetches all entries in the store.
     *
     * @param {Function} [onSuccess] A callback that is called if the operation
     *  was successful. Will receive an array of objects.
     * @param {Function} [onError] A callback that will be called if an error
     *  occurred during the operation.
     * @returns {IDBTransaction} The transaction used for this operation.
     */
    getAll: function (onSuccess, onError) {
      onError || (onError = defaultErrorHandler);
      onSuccess || (onSuccess = noop);
      var getAllTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);
      var store = getAllTransaction.objectStore(this.storeName);
      if (store.getAll) {
        this._getAllNative(getAllTransaction, store, onSuccess, onError);
      } else {
        this._getAllCursor(getAllTransaction, store, onSuccess, onError);
      }

      return getAllTransaction;
    },

    /**
     * Implements getAll for IDB implementations that have a non-standard
     * getAll() method.
     *
     * @param {Object} getAllTransaction An open READ transaction.
     * @param {Object} store A reference to the store.
     * @param {Function} onSuccess A callback that will be called if the
     *  operation was successful.
     * @param {Function} onError A callback that will be called if an
     *  error occurred during the operation.
     * @private
     */
    _getAllNative: function (getAllTransaction, store, onSuccess, onError) {
      var hasSuccess = false,
          result = null;

      getAllTransaction.oncomplete = function () {
        var callback = hasSuccess ? onSuccess : onError;
        callback(result);
      };
      getAllTransaction.onabort = onError;
      getAllTransaction.onerror = onError;

      var getAllRequest = store.getAll();
      getAllRequest.onsuccess = function (event) {
        hasSuccess = true;
        result = event.target.result;
      };
      getAllRequest.onerror = onError;
    },

    /**
     * Implements getAll for IDB implementations that do not have a getAll()
     * method.
     *
     * @param {Object} getAllTransaction An open READ transaction.
     * @param {Object} store A reference to the store.
     * @param {Function} onSuccess A callback that will be called if the
     *  operation was successful.
     * @param {Function} onError A callback that will be called if an
     *  error occurred during the operation.
     * @private
     */
    _getAllCursor: function (getAllTransaction, store, onSuccess, onError) {
      var all = [],
          hasSuccess = false,
          result = null;

      getAllTransaction.oncomplete = function () {
        var callback = hasSuccess ? onSuccess : onError;
        callback(result);
      };
      getAllTransaction.onabort = onError;
      getAllTransaction.onerror = onError;

      var cursorRequest = store.openCursor();
      cursorRequest.onsuccess = function (event) {
        var cursor = event.target.result;
        if (cursor) {
          all.push(cursor.value);
          cursor['continue']();
        }
        else {
          hasSuccess = true;
          result = all;
        }
      };
      cursorRequest.onError = onError;
    },

    /**
     * Clears the store, i.e. deletes all entries in the store.
     *
     * @param {Function} [onSuccess] A callback that will be called if the
     *  operation was successful.
     * @param {Function} [onError] A callback that will be called if an
     *  error occurred during the operation.
     * @returns {IDBTransaction} The transaction used for this operation.
     */
    clear: function (onSuccess, onError) {
      onError || (onError = defaultErrorHandler);
      onSuccess || (onSuccess = noop);

      var hasSuccess = false,
          result = null;

      var clearTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);
      clearTransaction.oncomplete = function () {
        var callback = hasSuccess ? onSuccess : onError;
        callback(result);
      };
      clearTransaction.onabort = onError;
      clearTransaction.onerror = onError;

      var clearRequest = clearTransaction.objectStore(this.storeName).clear();
      clearRequest.onsuccess = function (event) {
        hasSuccess = true;
        result = event.target.result;
      };
      clearRequest.onerror = onError;

      return clearTransaction;
    },

    /**
     * Checks if an id property needs to present on a object and adds one if
     * necessary.
     *
     * @param {Object} dataObj The data object that is about to be stored
     * @private
     */
    _addIdPropertyIfNeeded: function (dataObj) {
      if (!this.features.hasAutoIncrement && typeof dataObj[this.keyPath] == 'undefined') {
        dataObj[this.keyPath] = this._insertIdCount++ + Date.now();
      }
    },

    /************
     * indexing *
     ************/

    /**
     * Returns a DOMStringList of index names of the store.
     *
     * @return {DOMStringList} The list of index names
     */
    getIndexList: function () {
      return this.store.indexNames;
    },

    /**
     * Checks if an index with the given name exists in the store.
     *
     * @param {String} indexName The name of the index to look for
     * @return {Boolean} Whether the store contains an index with the given name
     */
    hasIndex: function (indexName) {
      return this.store.indexNames.contains(indexName);
    },

    /**
     * Normalizes an object containing index data and assures that all
     * properties are set.
     *
     * @param {Object} indexData The index data object to normalize
     * @param {String} indexData.name The name of the index
     * @param {String} [indexData.keyPath] The key path of the index
     * @param {Boolean} [indexData.unique] Whether the index is unique
     * @param {Boolean} [indexData.multiEntry] Whether the index is multi entry
     */
    normalizeIndexData: function (indexData) {
      indexData.keyPath = indexData.keyPath || indexData.name;
      indexData.unique = !!indexData.unique;
      indexData.multiEntry = !!indexData.multiEntry;
    },

    /**
     * Checks if an actual index complies with an expected index.
     *
     * @param {Object} actual The actual index found in the store
     * @param {Object} expected An Object describing an expected index
     * @return {Boolean} Whether both index definitions are identical
     */
    indexComplies: function (actual, expected) {
      var complies = ['keyPath', 'unique', 'multiEntry'].every(function (key) {
        // IE10 returns undefined for no multiEntry
        if (key == 'multiEntry' && actual[key] === undefined && expected[key] === false) {
          return true;
        }
        // Compound keys
        if (key == 'keyPath' && Object.prototype.toString.call(expected[key]) == '[object Array]') {
          var exp = expected.keyPath;
          var act = actual.keyPath;

          // IE10 can't handle keyPath sequences and stores them as a string.
          // The index will be unusable there, but let's still return true if
          // the keyPath sequence matches.
          if (typeof act == 'string') {
            return exp.toString() == act;
          }

          // Chrome/Opera stores keyPath squences as DOMStringList, Firefox
          // as Array
          if ( ! (typeof act.contains == 'function' || typeof act.indexOf == 'function') ) {
            return false;
          }

          if (act.length !== exp.length) {
            return false;
          }

          for (var i = 0, m = exp.length; i<m; i++) {
            if ( ! ( (act.contains && act.contains(exp[i])) || act.indexOf(exp[i] !== -1) )) {
              return false;
            }
          }
          return true;
        }
        return expected[key] == actual[key];
      });
      return complies;
    },

    /**********
     * cursor *
     **********/

    /**
     * Iterates over the store using the given options and calling onItem
     * for each entry matching the options.
     *
     * @param {Function} onItem A callback to be called for each match
     * @param {Object} [options] An object defining specific options
     * @param {Object} [options.index=null] An IDBIndex to operate on
     * @param {String} [options.order=ASC] The order in which to provide the
     *  results, can be 'DESC' or 'ASC'
     * @param {Boolean} [options.autoContinue=true] Whether to automatically
     *  iterate the cursor to the next result
     * @param {Boolean} [options.filterDuplicates=false] Whether to exclude
     *  duplicate matches
     * @param {Object} [options.keyRange=null] An IDBKeyRange to use
     * @param {Boolean} [options.writeAccess=false] Whether grant write access
     *  to the store in the onItem callback
     * @param {Function} [options.onEnd=null] A callback to be called after
     *  iteration has ended
     * @param {Function} [options.onError=throw] A callback to be called
     *  if an error occurred during the operation.
     * @returns {IDBTransaction} The transaction used for this operation.
     */
    iterate: function (onItem, options) {
      options = mixin({
        index: null,
        order: 'ASC',
        autoContinue: true,
        filterDuplicates: false,
        keyRange: null,
        writeAccess: false,
        onEnd: null,
        onError: defaultErrorHandler
      }, options || {});

      var directionType = options.order.toLowerCase() == 'desc' ? 'PREV' : 'NEXT';
      if (options.filterDuplicates) {
        directionType += '_NO_DUPLICATE';
      }

      var hasSuccess = false;
      var cursorTransaction = this.db.transaction([this.storeName], this.consts[options.writeAccess ? 'READ_WRITE' : 'READ_ONLY']);
      var cursorTarget = cursorTransaction.objectStore(this.storeName);
      if (options.index) {
        cursorTarget = cursorTarget.index(options.index);
      }

      cursorTransaction.oncomplete = function () {
        if (!hasSuccess) {
          options.onError(null);
          return;
        }
        if (options.onEnd) {
          options.onEnd();
        } else {
          onItem(null);
        }
      };
      cursorTransaction.onabort = options.onError;
      cursorTransaction.onerror = options.onError;

      var cursorRequest = cursorTarget.openCursor(options.keyRange, this.consts[directionType]);
      cursorRequest.onerror = options.onError;
      cursorRequest.onsuccess = function (event) {
        var cursor = event.target.result;
        if (cursor) {
          onItem(cursor.value, cursor, cursorTransaction);
          if (options.autoContinue) {
            cursor['continue']();
          }
        } else {
          hasSuccess = true;
        }
      };

      return cursorTransaction;
    },

    /**
     * Runs a query against the store and passes an array containing matched
     * objects to the success handler.
     *
     * @param {Function} onSuccess A callback to be called when the operation
     *  was successful.
     * @param {Object} [options] An object defining specific query options
     * @param {Object} [options.index=null] An IDBIndex to operate on
     * @param {String} [options.order=ASC] The order in which to provide the
     *  results, can be 'DESC' or 'ASC'
     * @param {Boolean} [options.filterDuplicates=false] Whether to exclude
     *  duplicate matches
     * @param {Object} [options.keyRange=null] An IDBKeyRange to use
     * @param {Function} [options.onError=throw] A callback to be called if an error
     *  occurred during the operation.
     * @returns {IDBTransaction} The transaction used for this operation.
     */
    query: function (onSuccess, options) {
      var result = [];
      options = options || {};
      options.onEnd = function () {
        onSuccess(result);
      };
      return this.iterate(function (item) {
        result.push(item);
      }, options);
    },

    /**
     *
     * Runs a query against the store, but only returns the number of matches
     * instead of the matches itself.
     *
     * @param {Function} onSuccess A callback to be called if the opration
     *  was successful.
     * @param {Object} [options] An object defining specific options
     * @param {Object} [options.index=null] An IDBIndex to operate on
     * @param {Object} [options.keyRange=null] An IDBKeyRange to use
     * @param {Function} [options.onError=throw] A callback to be called if an error
     *  occurred during the operation.
     * @returns {IDBTransaction} The transaction used for this operation.
     */
    count: function (onSuccess, options) {

      options = mixin({
        index: null,
        keyRange: null
      }, options || {});

      var onError = options.onError || defaultErrorHandler;

      var hasSuccess = false,
          result = null;

      var cursorTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);
      cursorTransaction.oncomplete = function () {
        var callback = hasSuccess ? onSuccess : onError;
        callback(result);
      };
      cursorTransaction.onabort = onError;
      cursorTransaction.onerror = onError;

      var cursorTarget = cursorTransaction.objectStore(this.storeName);
      if (options.index) {
        cursorTarget = cursorTarget.index(options.index);
      }
      var countRequest = cursorTarget.count(options.keyRange);
      countRequest.onsuccess = function (evt) {
        hasSuccess = true;
        result = evt.target.result;
      };
      countRequest.onError = onError;

      return cursorTransaction;
    },

    /**************/
    /* key ranges */
    /**************/

    /**
     * Creates a key range using specified options. This key range can be
     * handed over to the count() and iterate() methods.
     *
     * Note: You must provide at least one or both of "lower" or "upper" value.
     *
     * @param {Object} options The options for the key range to create
     * @param {*} [options.lower] The lower bound
     * @param {Boolean} [options.excludeLower] Whether to exclude the lower
     *  bound passed in options.lower from the key range
     * @param {*} [options.upper] The upper bound
     * @param {Boolean} [options.excludeUpper] Whether to exclude the upper
     *  bound passed in options.upper from the key range
     * @param {*} [options.only] A single key value. Use this if you need a key
     *  range that only includes one value for a key. Providing this
     *  property invalidates all other properties.
     * @return {Object} The IDBKeyRange representing the specified options
     */
    makeKeyRange: function(options){
      /*jshint onecase:true */
      var keyRange,
          hasLower = typeof options.lower != 'undefined',
          hasUpper = typeof options.upper != 'undefined',
          isOnly = typeof options.only != 'undefined';

      switch(true){
        case isOnly:
          keyRange = this.keyRange.only(options.only);
          break;
        case hasLower && hasUpper:
          keyRange = this.keyRange.bound(options.lower, options.upper, options.excludeLower, options.excludeUpper);
          break;
        case hasLower:
          keyRange = this.keyRange.lowerBound(options.lower, options.excludeLower);
          break;
        case hasUpper:
          keyRange = this.keyRange.upperBound(options.upper, options.excludeUpper);
          break;
        default:
          throw new Error('Cannot create KeyRange. Provide one or both of "lower" or "upper" value, or an "only" value.');
      }

      return keyRange;

    }

  };

  /** helpers **/

  var noop = function () {
  };
  var empty = {};
  var mixin = function (target, source) {
    var name, s;
    for (name in source) {
      s = source[name];
      if (s !== empty[name] && s !== target[name]) {
        target[name] = s;
      }
    }
    return target;
  };

  IDBStore.version = IDBStore.prototype.version;

  return IDBStore;

}, this);

},{}],28:[function(require,module,exports){
function addOperation (type, key, value, options) {
  var operation = {
    type: type,
    key: key,
    value: value,
    options: options
  }

  if (options && options.prefix) {
    operation.prefix = options.prefix
    delete options.prefix
  }

  this._operations.push(operation)

  return this
}

function Batch(sdb) {
  this._operations = []
  this._sdb = sdb

  this.put = addOperation.bind(this, 'put')
  this.del = addOperation.bind(this, 'del')
}

var B = Batch.prototype


B.clear = function () {
  this._operations = []
}

B.write = function (cb) {
  this._sdb.batch(this._operations, cb)
}

module.exports = Batch

},{}],29:[function(require,module,exports){
var process=require("__browserify_process");var EventEmitter = require('events').EventEmitter
var next         = process.nextTick
var SubDb        = require('./sub')
var Batch        = require('./batch')
var fixRange     = require('level-fix-range')

var Hooks   = require('level-hooks')

module.exports   = function (_db, options) {
  function DB () {}
  DB.prototype = _db
  var db = new DB()

  if (db.sublevel) return db

  options = options || {}

  //use \xff (255) as the seperator,
  //so that sections of the database will sort after the regular keys
  var sep = options.sep = options.sep || '\xff'
  db._options = options

  Hooks(db)

  db.sublevels = {}

  db.sublevel = function (prefix, options) {
    if(db.sublevels[prefix])
      return db.sublevels[prefix]
    return new SubDb(db, prefix, options || this._options)
  }

  db.methods = {}

  db.prefix = function (key) {
    return '' + (key || '')
  }

  db.pre = function (range, hook) {
    if(!hook)
      hook = range, range = {
        max  : sep
      }
    return db.hooks.pre(range, hook)
  }

  db.post = function (range, hook) {
    if(!hook)
      hook = range, range = {
        max : sep
      }
    return db.hooks.post(range, hook)
  }

  function safeRange(fun) {
    return function (opts) {
      opts = opts || {}
      opts = fixRange(opts)

      if(opts.reverse) opts.start = opts.start || sep
      else             opts.end   = opts.end || sep

      return fun.call(db, opts)
    }
  }

  db.readStream =
  db.createReadStream  = safeRange(db.createReadStream)
  db.keyStream =
  db.createKeyStream   = safeRange(db.createKeyStream)
  db.valuesStream =
  db.createValueStream = safeRange(db.createValueStream)

  var batch = db.batch
  db.batch = function (changes, opts, cb) {
    if(!Array.isArray(changes))
      return new Batch(db)
    changes.forEach(function (e) {
      if(e.prefix) {
        if('function' === typeof e.prefix.prefix)
          e.key = e.prefix.prefix(e.key)
        else if('string'  === typeof e.prefix)
          e.key = e.prefix + e.key
      }
    })
    batch.call(db, changes, opts, cb)
  }
  return db
}


},{"./batch":28,"./sub":40,"__browserify_process":160,"events":157,"level-fix-range":30,"level-hooks":32}],30:[function(require,module,exports){
var clone = require('clone')

module.exports = 
function fixRange(opts) {
  opts = clone(opts)

  var reverse = opts.reverse
  var end     = opts.max || opts.end
  var start   = opts.min || opts.start

  var range = [start, end]
  if(start != null && end != null)
    range.sort()
  if(reverse)
    range = range.reverse()

  opts.start   = range[0]
  opts.end     = range[1]

  delete opts.min
  delete opts.max

  return opts
}

},{"clone":31}],31:[function(require,module,exports){
var Buffer=require("__browserify_Buffer");"use strict";

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

var util = {
  isArray: function (ar) {
    return Array.isArray(ar) || (typeof ar === 'object' && objectToString(ar) === '[object Array]');
  },
  isDate: function (d) {
    return typeof d === 'object' && objectToString(d) === '[object Date]';
  },
  isRegExp: function (re) {
    return typeof re === 'object' && objectToString(re) === '[object RegExp]';
  },
  getRegExpFlags: function (re) {
    var flags = '';
    re.global && (flags += 'g');
    re.ignoreCase && (flags += 'i');
    re.multiline && (flags += 'm');
    return flags;
  }
};

if (typeof module === 'object')
  module.exports = clone;

/**
 * Clones (copies) an Object using deep copying.
 *
 * This function supports circular references by default, but if you are certain
 * there are no circular references in your object, you can save some CPU time
 * by calling clone(obj, false).
 *
 * Caution: if `circular` is false and `parent` contains circular references,
 * your program may enter an infinite loop and crash.
 *
 * @param `parent` - the object to be cloned
 * @param `circular` - set to true if the object to be cloned may contain
 *    circular references. (optional - true by default)
*/
function clone(parent, circular) {
  if (typeof circular == 'undefined')
    circular = true;

  var useBuffer = typeof Buffer != 'undefined';

  var circularParent = {};
  var circularResolved = {};
  var circularReplace = [];

  function _clone(parent, context, child, cIndex) {
    var i; // Use local context within this function
    // Deep clone all properties of parent into child
    if (typeof parent == 'object') {
      if (parent == null)
        return parent;
      // Check for circular references
      for(i in circularParent)
        if (circularParent[i] === parent) {
          // We found a circular reference
          circularReplace.push({'resolveTo': i, 'child': child, 'i': cIndex});
          return null; //Just return null for now...
          // we will resolve circular references later
        }

      // Add to list of all parent objects
      circularParent[context] = parent;
      // Now continue cloning...
      if (util.isArray(parent)) {
        child = [];
        for(i in parent)
          child[i] = _clone(parent[i], context + '[' + i + ']', child, i);
      }
      else if (util.isDate(parent))
        child = new Date(parent.getTime());
      else if (util.isRegExp(parent)) {
        child = new RegExp(parent.source, util.getRegExpFlags(parent));
        if (parent.lastIndex) child.lastIndex = parent.lastIndex;
      } else if (useBuffer && Buffer.isBuffer(parent))
      {
        child = new Buffer(parent.length);
        parent.copy(child);
      }
      else {
        child = {};

        // Also copy prototype over to new cloned object
        child.__proto__ = parent.__proto__;
        for(i in parent)
          child[i] = _clone(parent[i], context + '[' + i + ']', child, i);
      }

      // Add to list of all cloned objects
      circularResolved[context] = child;
    }
    else
      child = parent; //Just a simple shallow copy will do
    return child;
  }

  var i;
  if (circular) {
    var cloned = _clone(parent, '*');

    // Now this object has been cloned. Let's check to see if there are any
    // circular references for it
    for(i in circularReplace) {
      var c = circularReplace[i];
      if (c && c.child && c.i in c.child) {
        c.child[c.i] = circularResolved[c.resolveTo];
      }
    }
    return cloned;
  } else {
    // Deep clone all properties of parent into child
    var child;
    if (typeof parent == 'object') {
      if (parent == null)
        return parent;
      if (parent.constructor.name === 'Array') {
        child = [];
        for(i in parent)
          child[i] = clone(parent[i], circular);
      }
      else if (util.isDate(parent))
        child = new Date(parent.getTime() );
      else if (util.isRegExp(parent)) {
        child = new RegExp(parent.source, util.getRegExpFlags(parent));
        if (parent.lastIndex) child.lastIndex = parent.lastIndex;
      } else {
        child = {};
        child.__proto__ = parent.__proto__;
        for(i in parent)
          child[i] = clone(parent[i], circular);
      }
    }
    else
      child = parent; // Just a simple shallow clone will do
    return child;
  }
}

/**
 * Simple flat clone using prototype, accepts only objects, usefull for property
 * override on FLAT configuration object (no nested props).
 *
 * USE WITH CAUTION! This may not behave as you wish if you do not know how this
 * works.
 */
clone.clonePrototype = function(parent) {
  if (parent === null)
    return null;

  var c = function () {};
  c.prototype = parent;
  return new c();
};

},{"__browserify_Buffer":159}],32:[function(require,module,exports){
var ranges = require('string-range')

module.exports = function (db) {

  if(db.hooks) {
    return     
  }

  var posthooks = []
  var prehooks  = []

  function getPrefix (p) {
    return p && (
        'string' ===   typeof p        ? p
      : 'string' ===   typeof p.prefix ? p.prefix
      : 'function' === typeof p.prefix ? p.prefix()
      :                                  ''
      )
  }

  function getKeyEncoding (db) {
    if(db && db._getKeyEncoding)
      return db._getKeyEncoding(db)
  }

  function getValueEncoding (db) {
    if(db && db._getValueEncoding)
      return db._getValueEncoding(db)
  }

  function remover (array, item) {
    return function () {
      var i = array.indexOf(item)
      if(!~i) return false        
      array.splice(i, 1)
      return true
    }
  }

  db.hooks = {
    post: function (prefix, hook) {
      if(!hook) hook = prefix, prefix = ''
      var h = {test: ranges.checker(prefix), hook: hook}
      posthooks.push(h)
      return remover(posthooks, h)
    },
    pre: function (prefix, hook) {
      if(!hook) hook = prefix, prefix = ''
      var h = {test: ranges.checker(prefix), hook: hook}
      prehooks.push(h)
      return remover(prehooks, h)
    },
    posthooks: posthooks,
    prehooks: prehooks
  }

  //POST HOOKS

  function each (e) {
    if(e && e.type) {
      posthooks.forEach(function (h) {
        if(h.test(e.key)) h.hook(e)
      })
    }
  }

  db.on('put', function (key, val) {
    each({type: 'put', key: key, value: val})
  })
  db.on('del', function (key, val) {
    each({type: 'del', key: key, value: val})
  })
  db.on('batch', function onBatch (ary) {
    ary.forEach(each)
  })

  //PRE HOOKS

  var put = db.put
  var del = db.del
  var batch = db.batch

  function callHooks (isBatch, b, opts, cb) {
    try {
    b.forEach(function hook(e, i) {
      prehooks.forEach(function (h) {
        if(h.test(String(e.key))) {
          //optimize this?
          //maybe faster to not create a new object each time?
          //have one object and expose scope to it?
          var context = {
            add: function (ch, db) {
              if(typeof ch === 'undefined') {
                return this
              }
              if(ch === false)
                return delete b[i]
              var prefix = (
                getPrefix(ch.prefix) || 
                getPrefix(db) || 
                h.prefix || ''
              )  
              //don't leave a circular json object there incase using multilevel.
              if(prefix) ch.prefix = prefix
              ch.key = prefix + ch.key
              if(h.test(String(ch.key))) {
                //this usually means a stack overflow.
                throw new Error('prehook cannot insert into own range')
              }
              var ke = ch.keyEncoding   || getKeyEncoding(ch.prefix)
              var ve = ch.valueEncoding || getValueEncoding(ch.prefix)
              if(ke) ch.keyEncoding = ke
              if(ve) ch.valueEncoding = ve

              b.push(ch)
              hook(ch, b.length - 1)
              return this
            },
            put: function (ch, db) {
              if('object' === typeof ch) ch.type = 'put'
              return this.add(ch, db)
            },
            del: function (ch, db) {
              if('object' === typeof ch) ch.type = 'del'
              return this.add(ch, db)
            },
            veto: function () {
              return this.add(false)
            }
          }
          h.hook.call(context, e, context.add, b)
        }
      })
    })
    } catch (err) {
      return (cb || opts)(err)
    }
    b = b.filter(function (e) {
      return e && e.type //filter out empty items
    })

    if(b.length == 1 && !isBatch) {
      var change = b[0]
      return change.type == 'put' 
        ? put.call(db, change.key, change.value, opts, cb) 
        : del.call(db, change.key, opts, cb)  
    }
    return batch.call(db, b, opts, cb)
  }

  db.put = function (key, value, opts, cb ) {
    var batch = [{key: key, value: value, type: 'put'}]
    return callHooks(false, batch, opts, cb)
  }

  db.del = function (key, opts, cb) {
    var batch = [{key: key, type: 'del'}]
    return callHooks(false, batch, opts, cb)
  }

  db.batch = function (batch, opts, cb) {
    return callHooks(true, batch, opts, cb)
  }
}

},{"string-range":33}],33:[function(require,module,exports){

//force to a valid range
var range = exports.range = function (obj) {
  return null == obj ? {} : 'string' === typeof range ? {
      min: range, max: range + '\xff'
    } :  obj
}

//turn into a sub range.
var prefix = exports.prefix = function (range, within, term) {
  range = exports.range(range)
  var _range = {}
  term = term || '\xff'
  if(range instanceof RegExp || 'function' == typeof range) {
    _range.min = within
    _range.max   = within + term,
    _range.inner = function (k) {
      var j = k.substring(within.length)
      if(range.test)
        return range.test(j)
      return range(j)
    }
  }
  else if('object' === typeof range) {
    _range.min = within + (range.min || range.start || '')
    _range.max = within + (range.max || range.end   || (term || '~'))
    _range.reverse = !!range.reverse
  }
  return _range
}

//return a function that checks a range
var checker = exports.checker = function (range) {
  if(!range) range = {}

  if ('string' === typeof range)
    return function (key) {
      return key.indexOf(range) == 0
    }
  else if(range instanceof RegExp)
    return function (key) {
      return range.test(key)
    }
  else if('object' === typeof range)
    return function (key) {
      var min = range.min || range.start
      var max = range.max || range.end

      // fixes keys passed as ints from sublevels
      key = String(key)

      return (
        !min || key >= min
      ) && (
        !max || key <= max
      ) && (
        !range.inner || (
          range.inner.test 
            ? range.inner.test(key)
            : range.inner(key)
        )
      )
    }
  else if('function' === typeof range)
    return range
}
//check if a key is within a range.
var satifies = exports.satisfies = function (key, range) {
  return checker(range)(key)
}



},{}],34:[function(require,module,exports){
module.exports = hasKeys

function hasKeys(source) {
    return source !== null &&
        (typeof source === "object" ||
        typeof source === "function")
}

},{}],35:[function(require,module,exports){
var Keys = require("object-keys")
var hasKeys = require("./has-keys")

module.exports = extend

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        if (!hasKeys(source)) {
            continue
        }

        var keys = Keys(source)

        for (var j = 0; j < keys.length; j++) {
            var name = keys[j]
            target[name] = source[name]
        }
    }

    return target
}

},{"./has-keys":34,"object-keys":36}],36:[function(require,module,exports){
module.exports = Object.keys || require('./shim');


},{"./shim":39}],37:[function(require,module,exports){

var hasOwn = Object.prototype.hasOwnProperty;
var toString = Object.prototype.toString;

module.exports = function forEach (obj, fn, ctx) {
    if (toString.call(fn) !== '[object Function]') {
        throw new TypeError('iterator must be a function');
    }
    var l = obj.length;
    if (l === +l) {
        for (var i = 0; i < l; i++) {
            fn.call(ctx, obj[i], i, obj);
        }
    } else {
        for (var k in obj) {
            if (hasOwn.call(obj, k)) {
                fn.call(ctx, obj[k], k, obj);
            }
        }
    }
};


},{}],38:[function(require,module,exports){

/**!
 * is
 * the definitive JavaScript type testing library
 * 
 * @copyright 2013 Enrico Marino
 * @license MIT
 */

var objProto = Object.prototype;
var owns = objProto.hasOwnProperty;
var toString = objProto.toString;
var isActualNaN = function (value) {
  return value !== value;
};
var NON_HOST_TYPES = {
  "boolean": 1,
  "number": 1,
  "string": 1,
  "undefined": 1
};

/**
 * Expose `is`
 */

var is = module.exports = {};

/**
 * Test general.
 */

/**
 * is.type
 * Test if `value` is a type of `type`.
 *
 * @param {Mixed} value value to test
 * @param {String} type type
 * @return {Boolean} true if `value` is a type of `type`, false otherwise
 * @api public
 */

is.a =
is.type = function (value, type) {
  return typeof value === type;
};

/**
 * is.defined
 * Test if `value` is defined.
 *
 * @param {Mixed} value value to test
 * @return {Boolean} true if 'value' is defined, false otherwise
 * @api public
 */

is.defined = function (value) {
  return value !== undefined;
};

/**
 * is.empty
 * Test if `value` is empty.
 *
 * @param {Mixed} value value to test
 * @return {Boolean} true if `value` is empty, false otherwise
 * @api public
 */

is.empty = function (value) {
  var type = toString.call(value);
  var key;

  if ('[object Array]' === type || '[object Arguments]' === type) {
    return value.length === 0;
  }

  if ('[object Object]' === type) {
    for (key in value) if (owns.call(value, key)) return false;
    return true;
  }

  if ('[object String]' === type) {
    return '' === value;
  }

  return false;
};

/**
 * is.equal
 * Test if `value` is equal to `other`.
 *
 * @param {Mixed} value value to test
 * @param {Mixed} other value to compare with
 * @return {Boolean} true if `value` is equal to `other`, false otherwise
 */

is.equal = function (value, other) {
  var type = toString.call(value)
  var key;

  if (type !== toString.call(other)) {
    return false;
  }

  if ('[object Object]' === type) {
    for (key in value) {
      if (!is.equal(value[key], other[key])) {
        return false;
      }
    }
    return true;
  }

  if ('[object Array]' === type) {
    key = value.length;
    if (key !== other.length) {
      return false;
    }
    while (--key) {
      if (!is.equal(value[key], other[key])) {
        return false;
      }
    }
    return true;
  }

  if ('[object Function]' === type) {
    return value.prototype === other.prototype;
  }

  if ('[object Date]' === type) {
    return value.getTime() === other.getTime();
  }

  return value === other;
};

/**
 * is.hosted
 * Test if `value` is hosted by `host`.
 *
 * @param {Mixed} value to test
 * @param {Mixed} host host to test with
 * @return {Boolean} true if `value` is hosted by `host`, false otherwise
 * @api public
 */

is.hosted = function (value, host) {
  var type = typeof host[value];
  return type === 'object' ? !!host[value] : !NON_HOST_TYPES[type];
};

/**
 * is.instance
 * Test if `value` is an instance of `constructor`.
 *
 * @param {Mixed} value value to test
 * @return {Boolean} true if `value` is an instance of `constructor`
 * @api public
 */

is.instance = is['instanceof'] = function (value, constructor) {
  return value instanceof constructor;
};

/**
 * is.null
 * Test if `value` is null.
 *
 * @param {Mixed} value value to test
 * @return {Boolean} true if `value` is null, false otherwise
 * @api public
 */

is['null'] = function (value) {
  return value === null;
};

/**
 * is.undefined
 * Test if `value` is undefined.
 *
 * @param {Mixed} value value to test
 * @return {Boolean} true if `value` is undefined, false otherwise
 * @api public
 */

is.undefined = function (value) {
  return value === undefined;
};

/**
 * Test arguments.
 */

/**
 * is.arguments
 * Test if `value` is an arguments object.
 *
 * @param {Mixed} value value to test
 * @return {Boolean} true if `value` is an arguments object, false otherwise
 * @api public
 */

is.arguments = function (value) {
  var isStandardArguments = '[object Arguments]' === toString.call(value);
  var isOldArguments = !is.array(value) && is.arraylike(value) && is.object(value) && is.fn(value.callee);
  return isStandardArguments || isOldArguments;
};

/**
 * Test array.
 */

/**
 * is.array
 * Test if 'value' is an array.
 *
 * @param {Mixed} value value to test
 * @return {Boolean} true if `value` is an array, false otherwise
 * @api public
 */

is.array = function (value) {
  return '[object Array]' === toString.call(value);
};

/**
 * is.arguments.empty
 * Test if `value` is an empty arguments object.
 *
 * @param {Mixed} value value to test
 * @return {Boolean} true if `value` is an empty arguments object, false otherwise
 * @api public
 */
is.arguments.empty = function (value) {
  return is.arguments(value) && value.length === 0;
};

/**
 * is.array.empty
 * Test if `value` is an empty array.
 *
 * @param {Mixed} value value to test
 * @return {Boolean} true if `value` is an empty array, false otherwise
 * @api public
 */
is.array.empty = function (value) {
  return is.array(value) && value.length === 0;
};

/**
 * is.arraylike
 * Test if `value` is an arraylike object.
 *
 * @param {Mixed} value value to test
 * @return {Boolean} true if `value` is an arguments object, false otherwise
 * @api public
 */

is.arraylike = function (value) {
  return !!value && !is.boolean(value)
    && owns.call(value, 'length')
    && isFinite(value.length)
    && is.number(value.length)
    && value.length >= 0;
};

/**
 * Test boolean.
 */

/**
 * is.boolean
 * Test if `value` is a boolean.
 *
 * @param {Mixed} value value to test
 * @return {Boolean} true if `value` is a boolean, false otherwise
 * @api public
 */

is.boolean = function (value) {
  return '[object Boolean]' === toString.call(value);
};

/**
 * is.false
 * Test if `value` is false.
 *
 * @param {Mixed} value value to test
 * @return {Boolean} true if `value` is false, false otherwise
 * @api public
 */

is['false'] = function (value) {
  return is.boolean(value) && (value === false || value.valueOf() === false);
};

/**
 * is.true
 * Test if `value` is true.
 *
 * @param {Mixed} value value to test
 * @return {Boolean} true if `value` is true, false otherwise
 * @api public
 */

is['true'] = function (value) {
  return is.boolean(value) && (value === true || value.valueOf() === true);
};

/**
 * Test date.
 */

/**
 * is.date
 * Test if `value` is a date.
 *
 * @param {Mixed} value value to test
 * @return {Boolean} true if `value` is a date, false otherwise
 * @api public
 */

is.date = function (value) {
  return '[object Date]' === toString.call(value);
};

/**
 * Test element.
 */

/**
 * is.element
 * Test if `value` is an html element.
 *
 * @param {Mixed} value value to test
 * @return {Boolean} true if `value` is an HTML Element, false otherwise
 * @api public
 */

is.element = function (value) {
  return value !== undefined
    && typeof HTMLElement !== 'undefined'
    && value instanceof HTMLElement
    && value.nodeType === 1;
};

/**
 * Test error.
 */

/**
 * is.error
 * Test if `value` is an error object.
 *
 * @param {Mixed} value value to test
 * @return {Boolean} true if `value` is an error object, false otherwise
 * @api public
 */

is.error = function (value) {
  return '[object Error]' === toString.call(value);
};

/**
 * Test function.
 */

/**
 * is.fn / is.function (deprecated)
 * Test if `value` is a function.
 *
 * @param {Mixed} value value to test
 * @return {Boolean} true if `value` is a function, false otherwise
 * @api public
 */

is.fn = is['function'] = function (value) {
  var isAlert = typeof window !== 'undefined' && value === window.alert;
  return isAlert || '[object Function]' === toString.call(value);
};

/**
 * Test number.
 */

/**
 * is.number
 * Test if `value` is a number.
 *
 * @param {Mixed} value value to test
 * @return {Boolean} true if `value` is a number, false otherwise
 * @api public
 */

is.number = function (value) {
  return '[object Number]' === toString.call(value);
};

/**
 * is.infinite
 * Test if `value` is positive or negative infinity.
 *
 * @param {Mixed} value value to test
 * @return {Boolean} true if `value` is positive or negative Infinity, false otherwise
 * @api public
 */
is.infinite = function (value) {
  return value === Infinity || value === -Infinity;
};

/**
 * is.decimal
 * Test if `value` is a decimal number.
 *
 * @param {Mixed} value value to test
 * @return {Boolean} true if `value` is a decimal number, false otherwise
 * @api public
 */

is.decimal = function (value) {
  return is.number(value) && !isActualNaN(value) && !is.infinite(value) && value % 1 !== 0;
};

/**
 * is.divisibleBy
 * Test if `value` is divisible by `n`.
 *
 * @param {Number} value value to test
 * @param {Number} n dividend
 * @return {Boolean} true if `value` is divisible by `n`, false otherwise
 * @api public
 */

is.divisibleBy = function (value, n) {
  var isDividendInfinite = is.infinite(value);
  var isDivisorInfinite = is.infinite(n);
  var isNonZeroNumber = is.number(value) && !isActualNaN(value) && is.number(n) && !isActualNaN(n) && n !== 0;
  return isDividendInfinite || isDivisorInfinite || (isNonZeroNumber && value % n === 0);
};

/**
 * is.int
 * Test if `value` is an integer.
 *
 * @param value to test
 * @return {Boolean} true if `value` is an integer, false otherwise
 * @api public
 */

is.int = function (value) {
  return is.number(value) && !isActualNaN(value) && value % 1 === 0;
};

/**
 * is.maximum
 * Test if `value` is greater than 'others' values.
 *
 * @param {Number} value value to test
 * @param {Array} others values to compare with
 * @return {Boolean} true if `value` is greater than `others` values
 * @api public
 */

is.maximum = function (value, others) {
  if (isActualNaN(value)) {
    throw new TypeError('NaN is not a valid value');
  } else if (!is.arraylike(others)) {
    throw new TypeError('second argument must be array-like');
  }
  var len = others.length;

  while (--len >= 0) {
    if (value < others[len]) {
      return false;
    }
  }

  return true;
};

/**
 * is.minimum
 * Test if `value` is less than `others` values.
 *
 * @param {Number} value value to test
 * @param {Array} others values to compare with
 * @return {Boolean} true if `value` is less than `others` values
 * @api public
 */

is.minimum = function (value, others) {
  if (isActualNaN(value)) {
    throw new TypeError('NaN is not a valid value');
  } else if (!is.arraylike(others)) {
    throw new TypeError('second argument must be array-like');
  }
  var len = others.length;

  while (--len >= 0) {
    if (value > others[len]) {
      return false;
    }
  }

  return true;
};

/**
 * is.nan
 * Test if `value` is not a number.
 *
 * @param {Mixed} value value to test
 * @return {Boolean} true if `value` is not a number, false otherwise
 * @api public
 */

is.nan = function (value) {
  return !is.number(value) || value !== value;
};

/**
 * is.even
 * Test if `value` is an even number.
 *
 * @param {Number} value value to test
 * @return {Boolean} true if `value` is an even number, false otherwise
 * @api public
 */

is.even = function (value) {
  return is.infinite(value) || (is.number(value) && value === value && value % 2 === 0);
};

/**
 * is.odd
 * Test if `value` is an odd number.
 *
 * @param {Number} value value to test
 * @return {Boolean} true if `value` is an odd number, false otherwise
 * @api public
 */

is.odd = function (value) {
  return is.infinite(value) || (is.number(value) && value === value && value % 2 !== 0);
};

/**
 * is.ge
 * Test if `value` is greater than or equal to `other`.
 *
 * @param {Number} value value to test
 * @param {Number} other value to compare with
 * @return {Boolean}
 * @api public
 */

is.ge = function (value, other) {
  if (isActualNaN(value) || isActualNaN(other)) {
    throw new TypeError('NaN is not a valid value');
  }
  return !is.infinite(value) && !is.infinite(other) && value >= other;
};

/**
 * is.gt
 * Test if `value` is greater than `other`.
 *
 * @param {Number} value value to test
 * @param {Number} other value to compare with
 * @return {Boolean}
 * @api public
 */

is.gt = function (value, other) {
  if (isActualNaN(value) || isActualNaN(other)) {
    throw new TypeError('NaN is not a valid value');
  }
  return !is.infinite(value) && !is.infinite(other) && value > other;
};

/**
 * is.le
 * Test if `value` is less than or equal to `other`.
 *
 * @param {Number} value value to test
 * @param {Number} other value to compare with
 * @return {Boolean} if 'value' is less than or equal to 'other'
 * @api public
 */

is.le = function (value, other) {
  if (isActualNaN(value) || isActualNaN(other)) {
    throw new TypeError('NaN is not a valid value');
  }
  return !is.infinite(value) && !is.infinite(other) && value <= other;
};

/**
 * is.lt
 * Test if `value` is less than `other`.
 *
 * @param {Number} value value to test
 * @param {Number} other value to compare with
 * @return {Boolean} if `value` is less than `other`
 * @api public
 */

is.lt = function (value, other) {
  if (isActualNaN(value) || isActualNaN(other)) {
    throw new TypeError('NaN is not a valid value');
  }
  return !is.infinite(value) && !is.infinite(other) && value < other;
};

/**
 * is.within
 * Test if `value` is within `start` and `finish`.
 *
 * @param {Number} value value to test
 * @param {Number} start lower bound
 * @param {Number} finish upper bound
 * @return {Boolean} true if 'value' is is within 'start' and 'finish'
 * @api public
 */
is.within = function (value, start, finish) {
  if (isActualNaN(value) || isActualNaN(start) || isActualNaN(finish)) {
    throw new TypeError('NaN is not a valid value');
  } else if (!is.number(value) || !is.number(start) || !is.number(finish)) {
    throw new TypeError('all arguments must be numbers');
  }
  var isAnyInfinite = is.infinite(value) || is.infinite(start) || is.infinite(finish);
  return isAnyInfinite || (value >= start && value <= finish);
};

/**
 * Test object.
 */

/**
 * is.object
 * Test if `value` is an object.
 *
 * @param {Mixed} value value to test
 * @return {Boolean} true if `value` is an object, false otherwise
 * @api public
 */

is.object = function (value) {
  return value && '[object Object]' === toString.call(value);
};

/**
 * is.hash
 * Test if `value` is a hash - a plain object literal.
 *
 * @param {Mixed} value value to test
 * @return {Boolean} true if `value` is a hash, false otherwise
 * @api public
 */

is.hash = function (value) {
  return is.object(value) && value.constructor === Object && !value.nodeType && !value.setInterval;
};

/**
 * Test regexp.
 */

/**
 * is.regexp
 * Test if `value` is a regular expression.
 *
 * @param {Mixed} value value to test
 * @return {Boolean} true if `value` is a regexp, false otherwise
 * @api public
 */

is.regexp = function (value) {
  return '[object RegExp]' === toString.call(value);
};

/**
 * Test string.
 */

/**
 * is.string
 * Test if `value` is a string.
 *
 * @param {Mixed} value value to test
 * @return {Boolean} true if 'value' is a string, false otherwise
 * @api public
 */

is.string = function (value) {
  return '[object String]' === toString.call(value);
};


},{}],39:[function(require,module,exports){
(function () {
	"use strict";

	// modified from https://github.com/kriskowal/es5-shim
	var has = Object.prototype.hasOwnProperty,
		is = require('is'),
		forEach = require('foreach'),
		hasDontEnumBug = !({'toString': null}).propertyIsEnumerable('toString'),
		dontEnums = [
			"toString",
			"toLocaleString",
			"valueOf",
			"hasOwnProperty",
			"isPrototypeOf",
			"propertyIsEnumerable",
			"constructor"
		],
		keysShim;

	keysShim = function keys(object) {
		if (!is.object(object) && !is.array(object)) {
			throw new TypeError("Object.keys called on a non-object");
		}

		var name, theKeys = [];
		for (name in object) {
			if (has.call(object, name)) {
				theKeys.push(name);
			}
		}

		if (hasDontEnumBug) {
			forEach(dontEnums, function (dontEnum) {
				if (has.call(object, dontEnum)) {
					theKeys.push(dontEnum);
				}
			});
		}
		return theKeys;
	};

	module.exports = keysShim;
}());


},{"foreach":37,"is":38}],40:[function(require,module,exports){
var EventEmitter = require('events').EventEmitter
var inherits     = require('util').inherits
var ranges       = require('string-range')
var fixRange     = require('level-fix-range')
var xtend        = require('xtend')
var Batch        = require('./batch')

inherits(SubDB, EventEmitter)

function SubDB (db, prefix, options) {
  if('string' === typeof options) {
    console.error('db.sublevel(name, seperator<string>) is depreciated')
    console.error('use db.sublevel(name, {sep: separator})) if you must')
    options = {sep: options}
  }
  if(!(this instanceof SubDB)) return new SubDB(db, prefix, options)
  if(!db)     throw new Error('must provide db')
  if(!prefix) throw new Error('must provide prefix')

  options = options || {}
  options.sep = options.sep || '\xff'

  this._parent = db
  this._options = options
  this.options = options
  this._prefix = prefix
  this._root = root(this)
  db.sublevels[prefix] = this
  this.sublevels = {}
  this.methods = {}
  var self = this
  this.hooks = {
    pre: function () {
      return self.pre.apply(self, arguments)
    },
    post: function () {
      return self.post.apply(self, arguments)
    }
  }
}

var SDB = SubDB.prototype

SDB._key = function (key) {
  var sep = this._options.sep
  return sep
    + this._prefix
    + sep
    + key
}

SDB._getOptsAndCb = function (opts, cb) {
  if (typeof opts == 'function') {
    cb = opts
    opts = {}
  }
  return { opts: xtend(opts, this._options), cb: cb }
}

SDB.sublevel = function (prefix, options) {
  if(this.sublevels[prefix])
    return this.sublevels[prefix]
  return new SubDB(this, prefix, options || this._options)
}

SDB.put = function (key, value, opts, cb) {
  var res = this._getOptsAndCb(opts, cb)
  this._root.put(this.prefix(key), value, res.opts, res.cb)
}

SDB.get = function (key, opts, cb) {
  var res = this._getOptsAndCb(opts, cb)
  this._root.get(this.prefix(key), res.opts, res.cb)
}

SDB.del = function (key, opts, cb) {
  var res = this._getOptsAndCb(opts, cb)
  this._root.del(this.prefix(key), res.opts, res.cb)
}

SDB.batch = function (changes, opts, cb) {
  if(!Array.isArray(changes))
    return new Batch(this)
  var self = this,
      res = this._getOptsAndCb(opts, cb)
  changes.forEach(function (ch) {

    //OH YEAH, WE NEED TO VALIDATE THAT UPDATING THIS KEY/PREFIX IS ALLOWED
    if('string' === typeof ch.prefix)
      ch.key = ch.prefix + ch.key
    else
      ch.key = (ch.prefix || self).prefix(ch.key)

    if(ch.prefix) ch.prefix = null
  })
  this._root.batch(changes, res.opts, res.cb)
}

SDB._getKeyEncoding = function () {
  if(this.options.keyEncoding)
    return this.options.keyEncoding
  if(this._parent && this._parent._getKeyEncoding)
    return this._parent._getKeyEncoding()
}

SDB._getValueEncoding = function () {
  if(this.options.valueEncoding)
    return this.options.valueEncoding
  if(this._parent && this._parent._getValueEncoding)
    return this._parent._getValueEncoding()
}

SDB.prefix = function (key) {
  var sep = this._options.sep
  return this._parent.prefix() + sep + this._prefix + sep + (key || '')
}

SDB.keyStream =
SDB.createKeyStream = function (opts) {
  opts = opts || {}
  opts.keys = true
  opts.values = false
  return this.createReadStream(opts)
}

SDB.valueStream =
SDB.createValueStream = function (opts) {
  opts = opts || {}
  opts.keys = false
  opts.values = true
  opts.keys = false
  return this.createReadStream(opts)
}

function selectivelyMerge(_opts, opts) {
  [ 'valueEncoding'
  , 'encoding'
  , 'keyEncoding'
  , 'reverse'
  , 'values'
  , 'keys'
  , 'limit'
  , 'fillCache'
  ]
  .forEach(function (k) {
    if (opts.hasOwnProperty(k)) _opts[k] = opts[k]
  })
}

SDB.readStream =
SDB.createReadStream = function (opts) {
  opts = opts || {}
  var r = root(this)
  var p = this.prefix()

  var _opts = ranges.prefix(opts, p)
  selectivelyMerge(_opts, xtend(opts, this._options))

  var s = r.createReadStream(_opts)

  if(_opts.values === false) {
    var read = s.read
    if (read) {
      s.read = function (size) {
        var val = read.call(this, size)
        if (val) val = val.substring(p.length)
        return val
      }
    } else {
      var emit = s.emit
      s.emit = function (event, val) {
        if(event === 'data') {
          emit.call(this, 'data', val.substring(p.length))
        } else
          emit.call(this, event, val)
      }
    }
    return s
  } else if(_opts.keys === false)
    return s
  else {
    var read = s.read
    if (read) {
      s.read = function (size) {
        var d = read.call(this, size)
        if (d) d.key = d.key.substring(p.length)
        return d
      }
    } else {
      s.on('data', function (d) {
        //mutate the prefix!
        //this doesn't work for createKeyStream admittedly.
        d.key = d.key.substring(p.length)
      })
    }
    return s
  }
}


SDB.writeStream =
SDB.createWriteStream = function () {
  var r = root(this)
  var p = this.prefix()
  var ws = r.createWriteStream.apply(r, arguments)
  var write = ws.write

  var encoding = this._options.encoding
  var valueEncoding = this._options.valueEncoding
  var keyEncoding = this._options.keyEncoding

  // slight optimization, if no encoding was specified at all,
  // which will be the case most times, make write not check at all
  var nocheck = !encoding && !valueEncoding && !keyEncoding

  ws.write = nocheck
    ? function (data) {
        data.key = p + data.key
        return write.call(ws, data)
      }
    : function (data) {
        data.key = p + data.key

        // not merging all options here since this happens on every write and things could get slowed down
        // at this point we only consider encoding important to propagate
        if (encoding && typeof data.encoding === 'undefined')
          data.encoding = encoding
        if (valueEncoding && typeof data.valueEncoding === 'undefined')
          data.valueEncoding = valueEncoding
        if (keyEncoding && typeof data.keyEncoding === 'undefined')
          data.keyEncoding = keyEncoding

        return write.call(ws, data)
      }
  return ws
}

SDB.approximateSize = function () {
  var r = root(db)
  return r.approximateSize.apply(r, arguments)
}

function root(db) {
  if(!db._parent) return db
  return root(db._parent)
}

SDB.pre = function (range, hook) {
  if(!hook) hook = range, range = null
  range = ranges.prefix(range, this.prefix(), this._options.sep)
  var r = root(this._parent)
  var p = this.prefix()
  return r.hooks.pre(fixRange(range), function (ch, add, batch) {
    hook({
      key: ch.key.substring(p.length),
      value: ch.value,
      type: ch.type
    }, function (ch, _p) {
      //maybe remove the second add arg now
      //that op can have prefix?
      add(ch, ch.prefix ? _p : (_p || p))
    }, batch)
  })
}

SDB.post = function (range, hook) {
  if(!hook) hook = range, range = null
  var r = root(this._parent)
  var p = this.prefix()
  range = ranges.prefix(range, p, this._options.sep)
  return r.hooks.post(fixRange(range), function (data) {
    hook({key: data.key.substring(p.length), value: data.value, type: data.type})
  })
}

var exports = module.exports = SubDB


},{"./batch":28,"events":157,"level-fix-range":30,"string-range":33,"util":173,"xtend":35}],41:[function(require,module,exports){

/*
 * superlevel
 * https://github.com/randymized/level-superlevel
 *
 * Copyright (c) 2013 Randy McLaughlin
 * Licensed under the MIT license.
 */

'use strict';

var superlevel = require( './lib/level-superlevel.js' );

module.exports = superlevel;

},{"./lib/level-superlevel.js":42}],42:[function(require,module,exports){

/*
 * level-superlevel
 * https://github.com/randymized/level-superlevel
 *
 * Copyright (c) 2013 Randy McLaughlin
 * Licensed under the MIT license.
 */

'use strict';

var crypto= require('crypto');
var superlevel;

module.exports = superlevel = function(db,options) {
  function Superlevel() {}
  Superlevel.prototype.createReadStream = function(options) {
    return db.createReadStream(options);
  };
  Superlevel.prototype.createKeyStream = function(options) {
    return db.createKeyStream(options);
  };
  Superlevel.prototype.createValueStream = function(options) {
    return db.createValueStream(options);
  };
  Superlevel.prototype.get = function(key,options,cb) {
    return db.get(key,options,cb);
  };
  if (options && options.writable) {
    Superlevel.prototype.createWriteStream = function(options) {
      return db.createWriteStream(options);
    };
    Superlevel.prototype.put = function(key,value,options,cb) {
      return db.put(key,value,options,cb);
    };
    Superlevel.prototype.del = function(key,options,cb) {
      return db.del(key,options,cb);
    };
    Superlevel.prototype.batch = function(array,options,cb) {
      return db.batch(array,options,cb);
    };
  }
  db.superlevel= new Superlevel();
  return db;
};

},{"crypto":152}],43:[function(require,module,exports){
const after    = require('after')
    , xtend    = require('xtend')
    , sublevel = require('level-sublevel')

    , DEFAULT_FREQUENCY = 10000

var startTtl = function (db, checkFrequency) {
      db._ttl.intervalId = setInterval(function () {
        var batch    = []
          , subBatch = []
          , query = {
                keyEncoding: 'utf8'
              , valueEncoding: 'utf8'
              , end: String(Date.now())
            }

        db._ttl._checkInProgress = true
        db._ttl.sub.createReadStream(query)
          .on('data', function (data) {
            subBatch.push({ type: 'del', key: data.value })
            subBatch.push({ type: 'del', key: data.key })
            batch.push({ type: 'del', key: data.value })
          })
          .on('error', db.emit.bind(db, 'error'))
          .on('end', function () {
            if (batch.length) {
              db._ttl.sub.batch(
                  subBatch
                , { keyEncoding: 'utf8' }
                , function (err) {
                    if (err)
                      db.emit('error', err)
                  }
              )
              db._ttl.batch(
                  batch
                , { keyEncoding: 'utf8' }
                , function (err) {
                    if (err)
                      db.emit('error', err)
                  }
              )
            }
          })
          .on('close', function () {
            db._ttl._checkInProgress = false
            if (db._ttl._stopAfterCheck) {
              stopTtl(db, db._ttl._stopAfterCheck)
              db._ttl._stopAfterCheck = null
            }
          })
      }, checkFrequency)
    }

  , stopTtl = function (db, callback) {
      // can't close a db while an interator is in progress
      // so if one is, defer
      if (db._ttl._checkInProgress)
        return db._ttl._stopAfterCheck = callback
      clearInterval(db._ttl.intervalId)
      callback && callback()
    }

  , ttlon = function ttlon (db, keys, ttl, callback) {
      var exp   = String(Date.now() + ttl)
        , batch = []

      if (!Array.isArray(keys))
        keys = [ keys ]

      ttloff(db, keys, function () {
        keys.forEach(function (key) {
          if (typeof key != 'string')
            key = key.toString()
          batch.push({ type: 'put', key: key               , value: exp })
          batch.push({ type: 'put', key: exp + '\xff' + key, value: key })
        })

        if (!batch.length)
          return callback && callback()

        db._ttl.sub.batch(
            batch
          , { keyEncoding: 'utf8', valueEncoding: 'utf8' }
          , function (err) {
              if (err)
                db.emit('error', err)
              callback && callback()
            }
        )
      })
    }

  , ttloff = function ttloff (db, keys, callback) {
      if (!Array.isArray(keys))
        keys = [ keys ]

      var batch = []
        , done  = after(keys.length, function (err) {
            if (err)
              db.emit('error', err)

            if (!batch.length)
              return callback && callback()

            db._ttl.sub.batch(
                batch
              , { keyEncoding: 'utf8', valueEncoding: 'utf8' }
              , function (err) {
                  if (err)
                    db.emit('error', err)
                  callback && callback()
                }
            )
          })

      keys.forEach(function (key) {
        if (typeof key != 'string')
          key = key.toString()

        db._ttl.sub.get(
            key
          , { keyEncoding: 'utf8', valueEncoding: 'utf8' }
          , function (err, exp) {
              if (!err && exp > 0) {
                batch.push({ type: 'del', key: key })
                batch.push({ type: 'del', key: exp + '\xff' + key })
              }
              done(err && err.name != 'NotFoundError' && err)
            }
        )
      })
    }

  , put = function (db, key, value, options, callback) {
      var ttl
        , done
        , _callback = callback

      if (typeof options == 'object' && (ttl = options.ttl) > 0
          && key !== null && key !== undefined
          && value !== null && value !== undefined) {

        done = after(2, _callback || function () {})
        callback = done
        ttlon(db, key, options.ttl, done)
      }

      db._ttl.put.call(db, key, value, options, callback)
    }

  , ttl = function (db, key, ttl, callback) {
      if (ttl > 0 && key !== null && key !== undefined)
        ttlon(db, key, ttl, callback)
    }

  , del = function (db, key, options, callback) {
      var done
        , _callback = callback
      if (key !== null && key !== undefined) {
        done = after(2, _callback || function () {})
        callback = done
        ttloff(db, key, done)
      }

      db._ttl.del.call(db, key, options, callback)
    }

  , batch = function (db, arr, options, callback) {
      var ttl
        , done
        , on
        , off
        , _callback = callback

      if (typeof options == 'object' && (ttl = options.ttl) > 0 && Array.isArray(arr)) {
        done = after(3, _callback || function () {})
        callback = done

        on  = []
        off = []
        arr.forEach(function (entry) {
          if (!entry || entry.key === null || entry.key === undefined)
            return

          if (entry.type == 'put' && entry.value !== null && entry.value !== undefined)
            on.push(entry.key)
          if (entry.type == 'del')
            off.push(entry.key)
        })

        if (on.length)
          ttlon(db, on, options.ttl, done)
        else
          done()
        if (off.length)
          ttloff(db, off, done)
        else
          done()
      }

      db._ttl.batch.call(db, arr, options, callback)
    }

  , close = function (db, callback) {
      stopTtl(db, function () {
        if (db._ttl && typeof db._ttl.close == 'function')
          return db._ttl.close.call(db, callback)
        callback && callback()
      })
    }

  , setup = function (db, options) {
      if (db._ttl)
        return

      options = xtend({
          methodPrefix   : ''
        , sublevel       : 'ttl'
        , checkFrequency : DEFAULT_FREQUENCY
      }, options)

      db = sublevel(db)

      db._ttl = {
          put   : db.put
        , del   : db.del
        , batch : db.batch
        , close : db.close
        , sub   : db.sublevel(options.sublevel)
      }

      db[options.methodPrefix + 'put']   = put.bind(null, db)
      db[options.methodPrefix + 'del']   = del.bind(null, db)
      db[options.methodPrefix + 'batch'] = batch.bind(null, db)
      db[options.methodPrefix + 'ttl']   = ttl.bind(null, db)
      db[options.methodPrefix + 'stop']  = stopTtl.bind(null, db)
      // we must intercept close()
      db.close                           = close.bind(null, db)

      startTtl(db, options.checkFrequency)

      return db
    }

module.exports = setup

},{"after":44,"level-sublevel":29,"xtend":46}],44:[function(require,module,exports){
module.exports = after

function after(count, callback, err_cb) {
    var bail = false
    err_cb = err_cb || noop
    proxy.count = count

    return (count === 0) ? callback() : proxy

    function proxy(err, result) {
        if (proxy.count <= 0) {
            throw new Error('after called too many times')
        }
        --proxy.count

        // after first error, rest are passed to err_cb
        if (err) {
            bail = true
            callback(err)
            // future error callbacks will go to error handler
            callback = err_cb
        } else if (proxy.count === 0 && !bail) {
            callback(null, result)
        }
    }
}

function noop() {}

},{}],45:[function(require,module,exports){
module.exports=require(34)
},{}],46:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"./has-keys":45,"object-keys":48}],47:[function(require,module,exports){
var hasOwn = Object.prototype.hasOwnProperty;
var toString = Object.prototype.toString;

var isFunction = function (fn) {
	var isFunc = (typeof fn === 'function' && !(fn instanceof RegExp)) || toString.call(fn) === '[object Function]';
	if (!isFunc && typeof window !== 'undefined') {
		isFunc = fn === window.setTimeout || fn === window.alert || fn === window.confirm || fn === window.prompt;
	}
	return isFunc;
};

module.exports = function forEach(obj, fn) {
	if (!isFunction(fn)) {
		throw new TypeError('iterator must be a function');
	}
	var i, k,
		isString = typeof obj === 'string',
		l = obj.length,
		context = arguments.length > 2 ? arguments[2] : null;
	if (l === +l) {
		for (i = 0; i < l; i++) {
			if (context === null) {
				fn(isString ? obj.charAt(i) : obj[i], i, obj);
			} else {
				fn.call(context, isString ? obj.charAt(i) : obj[i], i, obj);
			}
		}
	} else {
		for (k in obj) {
			if (hasOwn.call(obj, k)) {
				if (context === null) {
					fn(obj[k], k, obj);
				} else {
					fn.call(context, obj[k], k, obj);
				}
			}
		}
	}
};


},{}],48:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"./shim":50}],49:[function(require,module,exports){
var toString = Object.prototype.toString;

module.exports = function isArguments(value) {
	var str = toString.call(value);
	var isArguments = str === '[object Arguments]';
	if (!isArguments) {
		isArguments = str !== '[object Array]'
			&& value !== null
			&& typeof value === 'object'
			&& typeof value.length === 'number'
			&& value.length >= 0
			&& toString.call(value.callee) === '[object Function]';
	}
	return isArguments;
};


},{}],50:[function(require,module,exports){
(function () {
	"use strict";

	// modified from https://github.com/kriskowal/es5-shim
	var has = Object.prototype.hasOwnProperty,
		toString = Object.prototype.toString,
		forEach = require('./foreach'),
		isArgs = require('./isArguments'),
		hasDontEnumBug = !({'toString': null}).propertyIsEnumerable('toString'),
		hasProtoEnumBug = (function () {}).propertyIsEnumerable('prototype'),
		dontEnums = [
			"toString",
			"toLocaleString",
			"valueOf",
			"hasOwnProperty",
			"isPrototypeOf",
			"propertyIsEnumerable",
			"constructor"
		],
		keysShim;

	keysShim = function keys(object) {
		var isObject = object !== null && typeof object === 'object',
			isFunction = toString.call(object) === '[object Function]',
			isArguments = isArgs(object),
			theKeys = [];

		if (!isObject && !isFunction && !isArguments) {
			throw new TypeError("Object.keys called on a non-object");
		}

		if (isArguments) {
			forEach(object, function (value) {
				theKeys.push(value);
			});
		} else {
			var name,
				skipProto = hasProtoEnumBug && isFunction;

			for (name in object) {
				if (!(skipProto && name === 'prototype') && has.call(object, name)) {
					theKeys.push(name);
				}
			}
		}

		if (hasDontEnumBug) {
			var ctor = object.constructor,
				skipConstructor = ctor && ctor.prototype === object;

			forEach(dontEnums, function (dontEnum) {
				if (!(skipConstructor && dontEnum === 'constructor') && has.call(object, dontEnum)) {
					theKeys.push(dontEnum);
				}
			});
		}
		return theKeys;
	};

	module.exports = keysShim;
}());


},{"./foreach":47,"./isArguments":49}],51:[function(require,module,exports){
/* Copyright (c) 2012-2013 LevelUP contributors
 * See list at <https://github.com/rvagg/node-levelup#contributing>
 * MIT +no-false-attribs License
 * <https://github.com/rvagg/node-levelup/blob/master/LICENSE>
 */

var util          = require('./util')
  , WriteError    = require('./errors').WriteError

  , getOptions    = util.getOptions
  , dispatchError = util.dispatchError

function Batch (levelup) {
  this._levelup = levelup
  this.batch = levelup.db.batch()
  this.ops = []
}

Batch.prototype.put = function (key_, value_, options) {
  options = getOptions(this._levelup, options)

  var key   = util.encodeKey(key_, options)
    , value = util.encodeValue(value_, options)

  try {
    this.batch.put(key, value)
  } catch (e) {
    throw new WriteError(e)
  }
  this.ops.push({ type : 'put', key : key, value : value })

  return this
}

Batch.prototype.del = function (key_, options) {
  options = getOptions(this._levelup, options)

  var key = util.encodeKey(key_, options)

  try {
    this.batch.del(key)
  } catch (err) {
    throw new WriteError(err)
  }
  this.ops.push({ type : 'del', key : key })

  return this
}

Batch.prototype.clear = function () {
  try {
    this.batch.clear()
  } catch (err) {
    throw new WriteError(err)
  }

  this.ops = []
  return this
}

Batch.prototype.write = function (callback) {
  var levelup = this._levelup
    , ops     = this.ops

  try {
    this.batch.write(function (err) {
      if (err)
        return dispatchError(levelup, new WriteError(err), callback)
      levelup.emit('batch', ops)
      if (callback)
        callback()
    })
  } catch (err) {
    throw new WriteError(err)
  }
}

module.exports = Batch

},{"./errors":52,"./util":55}],52:[function(require,module,exports){
/* Copyright (c) 2012-2013 LevelUP contributors
 * See list at <https://github.com/rvagg/node-levelup#contributing>
 * MIT +no-false-attribs License
 * <https://github.com/rvagg/node-levelup/blob/master/LICENSE>
 */

var createError   = require('errno').create
  , LevelUPError  = createError('LevelUPError')
  , NotFoundError = createError('NotFoundError', LevelUPError)

NotFoundError.prototype.notFound = true
NotFoundError.prototype.status   = 404

module.exports = {
    LevelUPError        : LevelUPError
  , InitializationError : createError('InitializationError', LevelUPError)
  , OpenError           : createError('OpenError', LevelUPError)
  , ReadError           : createError('ReadError', LevelUPError)
  , WriteError          : createError('WriteError', LevelUPError)
  , NotFoundError       : NotFoundError
  , EncodingError       : createError('EncodingError', LevelUPError)
}
},{"errno":89}],53:[function(require,module,exports){
var process=require("__browserify_process");/* Copyright (c) 2012-2013 LevelUP contributors
 * See list at <https://github.com/rvagg/node-levelup#contributing>
 * MIT +no-false-attribs License
 * <https://github.com/rvagg/node-levelup/blob/master/LICENSE>
 */

var EventEmitter   = require('events').EventEmitter
  , inherits       = require('util').inherits
  , extend         = require('xtend')
  , prr            = require('prr')
  , DeferredLevelDOWN = require('deferred-leveldown')

  , WriteError     = require('./errors').WriteError
  , ReadError      = require('./errors').ReadError
  , NotFoundError  = require('./errors').NotFoundError
  , OpenError      = require('./errors').OpenError
  , EncodingError  = require('./errors').EncodingError
  , InitializationError = require('./errors').InitializationError

  , ReadStream     = require('./read-stream')
  , WriteStream    = require('./write-stream')
  , util           = require('./util')
  , Batch          = require('./batch')

  , getOptions     = util.getOptions
  , defaultOptions = util.defaultOptions
  , getLevelDOWN   = util.getLevelDOWN
  , dispatchError  = util.dispatchError

function getCallback (options, callback) {
  return typeof options == 'function' ? options : callback
}

// Possible LevelUP#_status values:
//  - 'new'     - newly created, not opened or closed
//  - 'opening' - waiting for the database to be opened, post open()
//  - 'open'    - successfully opened the database, available for use
//  - 'closing' - waiting for the database to be closed, post close()
//  - 'closed'  - database has been successfully closed, should not be
//                 used except for another open() operation

function LevelUP (location, options, callback) {
  if (!(this instanceof LevelUP))
    return new LevelUP(location, options, callback)

  var error

  EventEmitter.call(this)
  this.setMaxListeners(Infinity)

  if (typeof location == 'function') {
    options = typeof options == 'object' ? options : {}
    options.db = location
    location = null
  } else if (typeof location == 'object' && typeof location.db == 'function') {
    options = location
    location = null
  }

  if (typeof options == 'function') {
    callback = options
    options  = {}
  }

  if ((!options || typeof options.db != 'function') && typeof location != 'string') {
    error = new InitializationError(
        'Must provide a location for the database')
    if (callback) {
      return process.nextTick(function () {
        callback(error)
      })
    }
    throw error
  }

  options      = getOptions(this, options)
  this.options = extend(defaultOptions, options)
  this._status = 'new'
  // set this.location as enumerable but not configurable or writable
  prr(this, 'location', location, 'e')

  this.open(callback)
}

inherits(LevelUP, EventEmitter)

LevelUP.prototype.open = function (callback) {
  var self = this
    , dbFactory
    , db

  if (this.isOpen()) {
    if (callback)
      process.nextTick(function () { callback(null, self) })
    return this
  }

  if (this._isOpening()) {
    return callback && this.once(
        'open'
      , function () { callback(null, self) }
    )
  }

  this.emit('opening')

  this._status = 'opening'
  this.db      = new DeferredLevelDOWN(this.location)
  dbFactory    = this.options.db || getLevelDOWN()
  db           = dbFactory(this.location)

  db.open(this.options, function (err) {
    if (err) {
      return dispatchError(self, new OpenError(err), callback)
    } else {
      self.db.setDb(db)
      self.db = db
      self._status = 'open'
      if (callback)
        callback(null, self)
      self.emit('open')
      self.emit('ready')
    }
  })
}

LevelUP.prototype.close = function (callback) {
  var self = this

  if (this.isOpen()) {
    this._status = 'closing'
    this.db.close(function () {
      self._status = 'closed'
      self.emit('closed')
      if (callback)
        callback.apply(null, arguments)
    })
    this.emit('closing')
    this.db = null
  } else if (this._status == 'closed' && callback) {
    return process.nextTick(callback)
  } else if (this._status == 'closing' && callback) {
    this.once('closed', callback)
  } else if (this._isOpening()) {
    this.once('open', function () {
      self.close(callback)
    })
  }
}

LevelUP.prototype.isOpen = function () {
  return this._status == 'open'
}

LevelUP.prototype._isOpening = function () {
  return this._status == 'opening'
}

LevelUP.prototype.isClosed = function () {
  return (/^clos/).test(this._status)
}

LevelUP.prototype.get = function (key_, options, callback) {
  var self = this
    , key

  callback = getCallback(options, callback)

  if (typeof callback != 'function') {
    return dispatchError(
        this
      , new ReadError('get() requires key and callback arguments')
    )
  }

  if (!this._isOpening() && !this.isOpen()) {
    return dispatchError(
        this
      , new ReadError('Database is not open')
      , callback
    )
  }

  options = util.getOptions(this, options)
  key = util.encodeKey(key_, options)

  options.asBuffer = util.isValueAsBuffer(options)

  this.db.get(key, options, function (err, value) {
    if (err) {
      if ((/notfound/i).test(err)) {
        err = new NotFoundError(
            'Key not found in database [' + key_ + ']', err)
      } else {
        err = new ReadError(err)
      }
      return dispatchError(self, err, callback)
    }
    if (callback) {
      try {
        value = util.decodeValue(value, options)
      } catch (e) {
        return callback(new EncodingError(e))
      }
      callback(null, value)
    }
  })
}

LevelUP.prototype.put = function (key_, value_, options, callback) {
  var self = this
    , key
    , value

  callback = getCallback(options, callback)

  if (key_ === null || key_ === undefined
        || value_ === null || value_ === undefined) {
    return dispatchError(
        this
       , new WriteError('put() requires key and value arguments')
       , callback
    )
  }

  if (!this._isOpening() && !this.isOpen()) {
    return dispatchError(
        this
      , new WriteError('Database is not open')
      , callback
    )
  }

  options = getOptions(this, options)
  key     = util.encodeKey(key_, options)
  value   = util.encodeValue(value_, options)

  this.db.put(key, value, options, function (err) {
    if (err) {
      return dispatchError(self, new WriteError(err), callback)
    } else {
      self.emit('put', key_, value_)
      if (callback)
        callback()
    }
  })
}

LevelUP.prototype.del = function (key_, options, callback) {
  var self = this
    , key

  callback = getCallback(options, callback)

  if (key_ === null || key_ === undefined) {
    return dispatchError(
        this
      , new WriteError('del() requires a key argument')
      , callback
    )
  }

  if (!this._isOpening() && !this.isOpen()) {
    return dispatchError(
        this
      , new WriteError('Database is not open')
      , callback
    )
  }

  options = getOptions(this, options)
  key     = util.encodeKey(key_, options)

  this.db.del(key, options, function (err) {
    if (err) {
      return dispatchError(self, new WriteError(err), callback)
    } else {
      self.emit('del', key_)
      if (callback)
        callback()
    }
  })
}

LevelUP.prototype.batch = function (arr_, options, callback) {
  var self = this
    , keyEnc
    , valueEnc
    , arr

  if (!arguments.length)
    return new Batch(this)

  callback = getCallback(options, callback)

  if (!Array.isArray(arr_)) {
    return dispatchError(
        this
      , new WriteError('batch() requires an array argument')
      , callback
    )
  }

  if (!this._isOpening() && !this.isOpen()) {
    return dispatchError(
        this
      , new WriteError('Database is not open')
      , callback
    )
  }

  options  = getOptions(this, options)
  keyEnc   = options.keyEncoding
  valueEnc = options.valueEncoding

  arr = arr_.map(function (e) {
    if (e.type === undefined || e.key === undefined)
      return {}

    // inherit encoding
    var kEnc = e.keyEncoding || keyEnc
      , vEnc = e.valueEncoding || e.encoding || valueEnc
      , o

    // If we're not dealing with plain utf8 strings or plain
    // Buffers then we have to do some work on the array to
    // encode the keys and/or values. This includes JSON types.

    if (kEnc != 'utf8' && kEnc != 'binary'
        || vEnc != 'utf8' && vEnc != 'binary') {
      o = {
          type: e.type
        , key: util.encodeKey(e.key, options, e)
      }

      if (e.value !== undefined)
        o.value = util.encodeValue(e.value, options, e)

      return o
    } else {
      return e
    }
  })

  this.db.batch(arr, options, function (err) {
    if (err) {
      return dispatchError(self, new WriteError(err), callback)
    } else {
      self.emit('batch', arr_)
      if (callback)
        callback()
    }
  })
}

// DEPRECATED: prefer accessing LevelDOWN for this: db.db.approximateSize()
LevelUP.prototype.approximateSize = function (start_, end_, callback) {
  var self = this
    , start
    , end

  if (start_ === null || start_ === undefined
        || end_ === null || end_ === undefined
        || typeof callback != 'function') {
    return dispatchError(
        this
      , new ReadError('approximateSize() requires start, end and callback arguments')
      , callback
    )
  }

  start = util.encodeKey(start_, this.options)
  end   = util.encodeKey(end_, this.options)

  if (!this._isOpening() && !this.isOpen()) {
    return dispatchError(
        this
      , new WriteError('Database is not open')
      , callback
    )
  }

  this.db.approximateSize(start, end, function (err, size) {
    if (err) {
      return dispatchError(self, new OpenError(err), callback)
    } else if (callback) {
      callback(null, size)
    }
  })
}

LevelUP.prototype.readStream =
LevelUP.prototype.createReadStream = function (options) {
  var self = this
  options = extend(this.options, options)
  return new ReadStream(
      options
    , this
    , function (options) {
        return self.db.iterator(options)
      }
  )
}

LevelUP.prototype.keyStream =
LevelUP.prototype.createKeyStream = function (options) {
  return this.createReadStream(extend(options, { keys: true, values: false }))
}

LevelUP.prototype.valueStream =
LevelUP.prototype.createValueStream = function (options) {
  return this.createReadStream(extend(options, { keys: false, values: true }))
}

LevelUP.prototype.writeStream =
LevelUP.prototype.createWriteStream = function (options) {
  return new WriteStream(extend(options), this)
}

LevelUP.prototype.toString = function () {
  return 'LevelUP'
}

function utilStatic (name) {
  return function (location, callback) {
    getLevelDOWN()[name](location, callback || function () {})
  }
}

module.exports         = LevelUP
module.exports.copy    = util.copy
// DEPRECATED: prefer accessing LevelDOWN for this: require('leveldown').destroy()
module.exports.destroy = utilStatic('destroy')
// DEPRECATED: prefer accessing LevelDOWN for this: require('leveldown').repair()
module.exports.repair  = utilStatic('repair')

},{"./batch":51,"./errors":52,"./read-stream":54,"./util":55,"./write-stream":56,"__browserify_process":160,"deferred-leveldown":71,"events":157,"prr":90,"util":173,"xtend":99}],54:[function(require,module,exports){
/* Copyright (c) 2012-2013 LevelUP contributors
 * See list at <https://github.com/rvagg/node-levelup#contributing>
 * MIT +no-false-attribs License <https://github.com/rvagg/node-levelup/blob/master/LICENSE>
 */

// NOTE: we are fixed to readable-stream@1.0.x for now
// for pure Streams2 across Node versions
var Readable      = require('readable-stream').Readable
  , inherits      = require('util').inherits
  , extend        = require('xtend')
  , EncodingError = require('./errors').EncodingError
  , util          = require('./util')

  , defaultOptions = { keys: true, values: true }

  , makeKeyValueData = function (key, value) {
      return {
          key: util.decodeKey(key, this._options)
        , value: util.decodeValue(value, this._options)
      }
    }
  , makeKeyData = function (key) {
      return util.decodeKey(key, this._options)
    }
  , makeValueData = function (_, value) {
      return util.decodeValue(value, this._options)
    }
  , makeNoData = function () { return null }

function ReadStream (options, db, iteratorFactory) {
  if (!(this instanceof ReadStream))
    return new ReadStream(options, db, iteratorFactory)

  Readable.call(this, { objectMode: true, highWaterMark: options.highWaterMark })

  // purely to keep `db` around until we're done so it's not GCed if the user doesn't keep a ref
  this._db = db

  options = this._options = extend(defaultOptions, options)

  this._keyEncoding   = options.keyEncoding   || options.encoding
  this._valueEncoding = options.valueEncoding || options.encoding

  if (typeof this._options.start != 'undefined')
    this._options.start = util.encodeKey(this._options.start, this._options)
  if (typeof this._options.end != 'undefined')
    this._options.end = util.encodeKey(this._options.end, this._options)
  if (typeof this._options.limit != 'number')
    this._options.limit = -1

  this._options.keyAsBuffer   = util.isKeyAsBuffer(this._options)

  this._options.valueAsBuffer = util.isValueAsBuffer(this._options)

  this._makeData = this._options.keys && this._options.values
    ? makeKeyValueData : this._options.keys
      ? makeKeyData : this._options.values
        ? makeValueData : makeNoData

  var self = this
  if (!this._db.isOpen()) {
    this._db.once('ready', function () {
      self._iterator = iteratorFactory(self._options)
    })
  } else
    this._iterator = iteratorFactory(this._options)
}

inherits(ReadStream, Readable)

ReadStream.prototype._read = function read () {
  var self = this
  if (!self._db.isOpen()) {
    return self._db.once('ready', function () { read.call(self) })
  }
  if (self._destroyed)
    return
 
  self._iterator.next(function(err, key, value) {
    if (err || (key === undefined && value === undefined)) {
      if (!err && !self._destroyed)
        self.push(null)
      return self._cleanup(err)
    }

    try {
      value = self._makeData(key, value)
    } catch (e) {
      return self._cleanup(new EncodingError(e))
    }
    if (!self._destroyed)
      self.push(value)
  })
}

ReadStream.prototype._cleanup = function (err) {
  if (this._destroyed)
    return

  this._destroyed = true

  var self = this
  if (err)
    self.emit('error', err)

  self._iterator.end(function () {
    self._iterator = null
    self.emit('close')
  })
}

ReadStream.prototype.destroy = function () {
  this._cleanup()
}

ReadStream.prototype.toString = function () {
  return 'LevelUP.ReadStream'
}

module.exports = ReadStream

},{"./errors":52,"./util":55,"readable-stream":97,"util":173,"xtend":99}],55:[function(require,module,exports){
/* Copyright (c) 2012-2013 LevelUP contributors
 * See list at <https://github.com/rvagg/node-levelup#contributing>
 * MIT +no-false-attribs License
 * <https://github.com/rvagg/node-levelup/blob/master/LICENSE>
 */

var extend        = require('xtend')
  , LevelUPError  = require('./errors').LevelUPError
  , bops          = require('bops')

  , encodingNames = [
        'hex'
      , 'utf8'
      , 'utf-8'
      , 'ascii'
      , 'binary'
      , 'base64'
      , 'ucs2'
      , 'ucs-2'
      , 'utf16le'
      , 'utf-16le'
    ]

  , defaultOptions = {
        createIfMissing : true
      , errorIfExists   : false
      , keyEncoding     : 'utf8'
      , valueEncoding   : 'utf8'
      , compression     : true
    }

  , leveldown

  , encodings = (function () {
      function isBinary (data) {
        return data === undefined || data === null || bops.is(data)
      }

      var encodings = {}
      encodings.utf8 = encodings['utf-8'] = {
          encode : function (data) {
            return isBinary(data) ? data : String(data)
          }
        , decode : function (data) { return data }
        , buffer : false
        , type   : 'utf8'
      }
      encodings.json = {
          encode : JSON.stringify
        , decode : JSON.parse
        , buffer : false
        , type   : 'json'
      }
      encodingNames.forEach(function (type) {
        if (encodings[type])
          return
        encodings[type] = {
            encode : function (data) {
              return isBinary(data) ? data : bops.from(data, type)
            }
          , decode : function (buffer) {
              return bops.from(buffer, type)
            }
          , buffer : true
          , type   : type // useful for debugging purposes
        }
      })
      return encodings
    })()

  , encodingOpts = (function () {
      var eo = {}
      encodingNames.forEach(function (e) {
        eo[e] = { valueEncoding : e }
      })
      return eo
    }())

function copy (srcdb, dstdb, callback) {
  srcdb.readStream()
    .pipe(dstdb.writeStream())
    .on('close', callback ? callback : function () {})
    .on('error', callback ? callback : function (err) { throw err })
}

function getOptions (levelup, options) {
  var s = typeof options == 'string' // just an encoding
  if (!s && options && options.encoding && !options.valueEncoding)
    options.valueEncoding = options.encoding
  return extend(
      (levelup && levelup.options) || {}
    , s ? encodingOpts[options] || encodingOpts[defaultOptions.valueEncoding]
        : options
  )
}

function getLevelDOWN () {
  if (leveldown)
    return leveldown

  var requiredVersion       = require('../package.json').devDependencies.leveldown
    , missingLevelDOWNError = 'Could not locate LevelDOWN, try `npm install leveldown`'
    , leveldownVersion

  try {
    leveldownVersion = require('leveldown/package').version
  } catch (e) {
    throw new LevelUPError(missingLevelDOWNError)
  }

  if (!require('semver').satisfies(leveldownVersion, requiredVersion)) {
    throw new LevelUPError(
        'Installed version of LevelDOWN ('
      + leveldownVersion
      + ') does not match required version ('
      + requiredVersion
      + ')'
    )
  }

  try {
    return leveldown = require('leveldown')
  } catch (e) {
    throw new LevelUPError(missingLevelDOWNError)
  }
}

function dispatchError (levelup, error, callback) {
  return typeof callback == 'function'
    ? callback(error)
    : levelup.emit('error', error)
}

function getKeyEncoder (options, op) {
  var type = ((op && op.keyEncoding) || options.keyEncoding) || 'utf8'
  return encodings[type] || type
}

function getValueEncoder (options, op) {
  var type = (((op && (op.valueEncoding || op.encoding))
      || options.valueEncoding || options.encoding)) || 'utf8'
  return encodings[type] || type
}

function encodeKey (key, options, op) {
  return getKeyEncoder(options, op).encode(key)
}

function encodeValue (value, options, op) {
  return getValueEncoder(options, op).encode(value)
}

function decodeKey (key, options) {
  return getKeyEncoder(options).decode(key)
}

function decodeValue (value, options) {
  return getValueEncoder(options).decode(value)
}

function isValueAsBuffer (options, op) {
  return getValueEncoder(options, op).buffer
}

function isKeyAsBuffer (options, op) {
  return getKeyEncoder(options, op).buffer
}

module.exports = {
    defaultOptions  : defaultOptions
  , copy            : copy
  , getOptions      : getOptions
  , getLevelDOWN    : getLevelDOWN
  , dispatchError   : dispatchError
  , encodeKey       : encodeKey
  , encodeValue     : encodeValue
  , isValueAsBuffer : isValueAsBuffer
  , isKeyAsBuffer   : isKeyAsBuffer
  , decodeValue     : decodeValue
  , decodeKey       : decodeKey
}

},{"../package.json":104,"./errors":52,"bops":57,"leveldown":150,"leveldown/package":150,"semver":150,"xtend":99}],56:[function(require,module,exports){
var process=require("__browserify_process");/* Copyright (c) 2012-2013 LevelUP contributors
 * See list at <https://github.com/rvagg/node-levelup#contributing>
 * MIT +no-false-attribs License
 * <https://github.com/rvagg/node-levelup/blob/master/LICENSE>
 */

var Stream       = require('stream').Stream
  , inherits     = require('util').inherits
  , extend       = require('xtend')
  , concatStream = require('concat-stream')

  , setImmediate = process.nextTick

  , getOptions   = require('./util').getOptions

  , defaultOptions = { type: 'put' }

function WriteStream (options, db) {
  if (!(this instanceof WriteStream))
    return new WriteStream(options, db)

  Stream.call(this)
  this._options = extend(defaultOptions, getOptions(db, options))
  this._db      = db
  this._buffer  = []
  this._status  = 'init'
  this._end     = false
  this.writable = true
  this.readable = false

  var self = this
    , ready = function () {
        if (!self.writable)
          return
        self._status = 'ready'
        self.emit('ready')
        self._process()
      }

  if (db.isOpen())
    setImmediate(ready)
  else
    db.once('ready', ready)
}

inherits(WriteStream, Stream)

WriteStream.prototype.write = function (data) {
  if (!this.writable)
    return false
  this._buffer.push(data)
  if (this._status != 'init')
    this._processDelayed()
  if (this._options.maxBufferLength &&
      this._buffer.length > this._options.maxBufferLength) {
    this._writeBlock = true
    return false
  }
  return true
}

WriteStream.prototype.end = function (data) {
  var self = this
  if (data)
    this.write(data)
  setImmediate(function () {
    self._end = true
    self._process()
  })
}

WriteStream.prototype.destroy = function () {
  this.writable = false
  this.end()
}

WriteStream.prototype.destroySoon = function () {
  this.end()
}

WriteStream.prototype.add = function (entry) {
  if (!entry.props)
    return
  if (entry.props.Directory)
    entry.pipe(this._db.writeStream(this._options))
  else if (entry.props.File || entry.File || entry.type == 'File')
    this._write(entry)
  return true
}

WriteStream.prototype._processDelayed = function () {
  var self = this
  setImmediate(function () {
    self._process()
  })
}

WriteStream.prototype._process = function () {
  var buffer
    , self = this

    , cb = function (err) {
        if (!self.writable)
          return
        if (self._status != 'closed')
          self._status = 'ready'
        if (err) {
          self.writable = false
          return self.emit('error', err)
        }
        self._process()
      }

  if (self._status != 'ready' && self.writable) {
    if (self._buffer.length && self._status != 'closed')
      self._processDelayed()
    return
  }

  if (self._buffer.length && self.writable) {
    self._status = 'writing'
    buffer       = self._buffer
    self._buffer = []

    self._db.batch(buffer.map(function (d) {
      return {
          type          : d.type || self._options.type
        , key           : d.key
        , value         : d.value
        , keyEncoding   : d.keyEncoding || self._options.keyEncoding
        , valueEncoding : d.valueEncoding
            || d.encoding
            || self._options.valueEncoding
      }
    }), cb)

    if (self._writeBlock) {
      self._writeBlock = false
      self.emit('drain')
    }

    // don't allow close until callback has returned
    return
  }

  if (self._end && self._status != 'closed') {
    self._status  = 'closed'
    self.writable = false
    self.emit('close')
  }
}

WriteStream.prototype._write = function (entry) {
  var key = entry.path || entry.props.path
    , self = this

  if (!key)
    return

  entry.pipe(concatStream(function (err, data) {
    if (err) {
      self.writable = false
      return self.emit('error', err)
    }

    if (self._options.fstreamRoot &&
        key.indexOf(self._options.fstreamRoot) > -1)
      key = key.substr(self._options.fstreamRoot.length + 1)

    self.write({ key: key, value: data })
  }))
}

WriteStream.prototype.toString = function () {
  return 'LevelUP.WriteStream'
}

module.exports = WriteStream

},{"./util":55,"__browserify_process":160,"concat-stream":70,"stream":165,"util":173,"xtend":99}],57:[function(require,module,exports){
var proto = {}
module.exports = proto

proto.from = require('./from.js')
proto.to = require('./to.js')
proto.is = require('./is.js')
proto.subarray = require('./subarray.js')
proto.join = require('./join.js')
proto.copy = require('./copy.js')
proto.create = require('./create.js')

mix(require('./read.js'), proto)
mix(require('./write.js'), proto)

function mix(from, into) {
  for(var key in from) {
    into[key] = from[key]
  }
}

},{"./copy.js":60,"./create.js":61,"./from.js":62,"./is.js":63,"./join.js":64,"./read.js":66,"./subarray.js":67,"./to.js":68,"./write.js":69}],58:[function(require,module,exports){
(function (exports) {
	'use strict';

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	function b64ToByteArray(b64) {
		var i, j, l, tmp, placeHolders, arr;
	
		if (b64.length % 4 > 0) {
			throw 'Invalid string. Length must be a multiple of 4';
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		placeHolders = b64.indexOf('=');
		placeHolders = placeHolders > 0 ? b64.length - placeHolders : 0;

		// base64 is 4/3 + up to two characters of the original data
		arr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length;

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);
			arr.push((tmp & 0xFF0000) >> 16);
			arr.push((tmp & 0xFF00) >> 8);
			arr.push(tmp & 0xFF);
		}

		if (placeHolders === 2) {
			tmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);
			arr.push(tmp & 0xFF);
		} else if (placeHolders === 1) {
			tmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);
			arr.push((tmp >> 8) & 0xFF);
			arr.push(tmp & 0xFF);
		}

		return arr;
	}

	function uint8ToBase64(uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length;

		function tripletToBase64 (num) {
			return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
		};

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
			output += tripletToBase64(temp);
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1];
				output += lookup[temp >> 2];
				output += lookup[(temp << 4) & 0x3F];
				output += '==';
				break;
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);
				output += lookup[temp >> 10];
				output += lookup[(temp >> 4) & 0x3F];
				output += lookup[(temp << 2) & 0x3F];
				output += '=';
				break;
		}

		return output;
	}

	module.exports.toByteArray = b64ToByteArray;
	module.exports.fromByteArray = uint8ToBase64;
}());

},{}],59:[function(require,module,exports){
module.exports = to_utf8

var out = []
  , col = []
  , fcc = String.fromCharCode
  , mask = [0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01]
  , unmask = [
      0x00
    , 0x01
    , 0x02 | 0x01
    , 0x04 | 0x02 | 0x01
    , 0x08 | 0x04 | 0x02 | 0x01
    , 0x10 | 0x08 | 0x04 | 0x02 | 0x01
    , 0x20 | 0x10 | 0x08 | 0x04 | 0x02 | 0x01
    , 0x40 | 0x20 | 0x10 | 0x08 | 0x04 | 0x02 | 0x01
  ]

function to_utf8(bytes, start, end) {
  start = start === undefined ? 0 : start
  end = end === undefined ? bytes.length : end

  var idx = 0
    , hi = 0x80
    , collecting = 0
    , pos
    , by

  col.length =
  out.length = 0

  while(idx < bytes.length) {
    by = bytes[idx]
    if(!collecting && by & hi) {
      pos = find_pad_position(by)
      collecting += pos
      if(pos < 8) {
        col[col.length] = by & unmask[6 - pos]
      }
    } else if(collecting) {
      col[col.length] = by & unmask[6]
      --collecting
      if(!collecting && col.length) {
        out[out.length] = fcc(reduced(col, pos))
        col.length = 0
      }
    } else { 
      out[out.length] = fcc(by)
    }
    ++idx
  }
  if(col.length && !collecting) {
    out[out.length] = fcc(reduced(col, pos))
    col.length = 0
  }
  return out.join('')
}

function find_pad_position(byt) {
  for(var i = 0; i < 7; ++i) {
    if(!(byt & mask[i])) {
      break
    }
  }
  return i
}

function reduced(list) {
  var out = 0
  for(var i = 0, len = list.length; i < len; ++i) {
    out |= list[i] << ((len - i - 1) * 6)
  }
  return out
}

},{}],60:[function(require,module,exports){
module.exports = copy

var slice = [].slice

function copy(source, target, target_start, source_start, source_end) {
  target_start = arguments.length < 3 ? 0 : target_start
  source_start = arguments.length < 4 ? 0 : source_start
  source_end = arguments.length < 5 ? source.length : source_end

  if(source_end === source_start) {
    return
  }

  if(target.length === 0 || source.length === 0) {
    return
  }

  if(source_end > source.length) {
    source_end = source.length
  }

  if(target.length - target_start < source_end - source_start) {
    source_end = target.length - target_start + source_start
  }

  if(source.buffer !== target.buffer) {
    return fast_copy(source, target, target_start, source_start, source_end)
  }
  return slow_copy(source, target, target_start, source_start, source_end)
}

function fast_copy(source, target, target_start, source_start, source_end) {
  var len = (source_end - source_start) + target_start

  for(var i = target_start, j = source_start;
      i < len;
      ++i,
      ++j) {
    target[i] = source[j]
  }
}

function slow_copy(from, to, j, i, jend) {
  // the buffers could overlap.
  var iend = jend + i
    , tmp = new Uint8Array(slice.call(from, i, iend))
    , x = 0

  for(; i < iend; ++i, ++x) {
    to[j++] = tmp[x]
  }
}

},{}],61:[function(require,module,exports){
module.exports = function(size) {
  return new Uint8Array(size)
}

},{}],62:[function(require,module,exports){
module.exports = from

var base64 = require('base64-js')

var decoders = {
    hex: from_hex
  , utf8: from_utf
  , base64: from_base64
}

function from(source, encoding) {
  if(Array.isArray(source)) {
    return new Uint8Array(source)
  }

  return decoders[encoding || 'utf8'](source)
}

function from_hex(str) {
  var size = str.length / 2
    , buf = new Uint8Array(size)
    , character = ''

  for(var i = 0, len = str.length; i < len; ++i) {
    character += str.charAt(i)

    if(i > 0 && (i % 2) === 1) {
      buf[i>>>1] = parseInt(character, 16)
      character = '' 
    }
  }

  return buf 
}

function from_utf(str) {
  var arr = []
    , code

  for(var i = 0, len = str.length; i < len; ++i) {
    code = fixed_cca(str, i)

    if(code === false) {
      continue
    }

    if(code < 0x80) {
      arr[arr.length] = code

      continue
    }

    codepoint_to_bytes(arr, code)
  }

  return new Uint8Array(arr)
}

function codepoint_to_bytes(arr, code) {
  // find MSB, use that to determine byte count
  var copy_code = code
    , bit_count = 0
    , byte_count
    , prefix
    , _byte
    , pos

  do {
    ++bit_count
  } while(copy_code >>>= 1)

  byte_count = Math.ceil((bit_count - 1) / 5) | 0
  prefix = [0, 0, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc][byte_count]
  pos = [0, 0, 3, 4, 5, 6, 7][byte_count]

  _byte |= prefix

  bit_count = (7 - pos) + 6 * (byte_count - 1)

  while(bit_count) {
    _byte |= +!!(code & (1 << bit_count)) << (7 - pos)
    ++pos

    if(pos % 8 === 0) {
      arr[arr.length] = _byte
      _byte = 0x80
      pos = 2
    }

    --bit_count
  }

  if(pos) {
    _byte |= +!!(code & 1) << (7 - pos)
    arr[arr.length] = _byte
  }
}

function pad(str) {
  while(str.length < 8) {
    str = '0' + str
  }

  return str
}

function fixed_cca(str, idx) {
  idx = idx || 0

  var code = str.charCodeAt(idx)
    , lo
    , hi

  if(0xD800 <= code && code <= 0xDBFF) {
    lo = str.charCodeAt(idx + 1)
    hi = code

    if(isNaN(lo)) {
      throw new Error('High surrogate not followed by low surrogate')
    }

    return ((hi - 0xD800) * 0x400) + (lo - 0xDC00) + 0x10000
  }

  if(0xDC00 <= code && code <= 0xDFFF) {
    return false
  }

  return code
}

function from_base64(str) {
  return new Uint8Array(base64.toByteArray(str)) 
}

},{"base64-js":58}],63:[function(require,module,exports){

module.exports = function(buffer) {
  return buffer instanceof Uint8Array;
}

},{}],64:[function(require,module,exports){
module.exports = join

function join(targets, hint) {
  if(!targets.length) {
    return new Uint8Array(0)
  }

  var len = hint !== undefined ? hint : get_length(targets)
    , out = new Uint8Array(len)
    , cur = targets[0]
    , curlen = cur.length
    , curidx = 0
    , curoff = 0
    , i = 0

  while(i < len) {
    if(curoff === curlen) {
      curoff = 0
      ++curidx
      cur = targets[curidx]
      curlen = cur && cur.length
      continue
    }
    out[i++] = cur[curoff++] 
  }

  return out
}

function get_length(targets) {
  var size = 0
  for(var i = 0, len = targets.length; i < len; ++i) {
    size += targets[i].byteLength
  }
  return size
}

},{}],65:[function(require,module,exports){
var proto
  , map

module.exports = proto = {}

map = typeof WeakMap === 'undefined' ? null : new WeakMap

proto.get = !map ? no_weakmap_get : get

function no_weakmap_get(target) {
  return new DataView(target.buffer, 0)
}

function get(target) {
  var out = map.get(target.buffer)
  if(!out) {
    map.set(target.buffer, out = new DataView(target.buffer, 0))
  }
  return out
}

},{}],66:[function(require,module,exports){
module.exports = {
    readUInt8:      read_uint8
  , readInt8:       read_int8
  , readUInt16LE:   read_uint16_le
  , readUInt32LE:   read_uint32_le
  , readInt16LE:    read_int16_le
  , readInt32LE:    read_int32_le
  , readFloatLE:    read_float_le
  , readDoubleLE:   read_double_le
  , readUInt16BE:   read_uint16_be
  , readUInt32BE:   read_uint32_be
  , readInt16BE:    read_int16_be
  , readInt32BE:    read_int32_be
  , readFloatBE:    read_float_be
  , readDoubleBE:   read_double_be
}

var map = require('./mapped.js')

function read_uint8(target, at) {
  return target[at]
}

function read_int8(target, at) {
  var v = target[at];
  return v < 0x80 ? v : v - 0x100
}

function read_uint16_le(target, at) {
  var dv = map.get(target);
  return dv.getUint16(at + target.byteOffset, true)
}

function read_uint32_le(target, at) {
  var dv = map.get(target);
  return dv.getUint32(at + target.byteOffset, true)
}

function read_int16_le(target, at) {
  var dv = map.get(target);
  return dv.getInt16(at + target.byteOffset, true)
}

function read_int32_le(target, at) {
  var dv = map.get(target);
  return dv.getInt32(at + target.byteOffset, true)
}

function read_float_le(target, at) {
  var dv = map.get(target);
  return dv.getFloat32(at + target.byteOffset, true)
}

function read_double_le(target, at) {
  var dv = map.get(target);
  return dv.getFloat64(at + target.byteOffset, true)
}

function read_uint16_be(target, at) {
  var dv = map.get(target);
  return dv.getUint16(at + target.byteOffset, false)
}

function read_uint32_be(target, at) {
  var dv = map.get(target);
  return dv.getUint32(at + target.byteOffset, false)
}

function read_int16_be(target, at) {
  var dv = map.get(target);
  return dv.getInt16(at + target.byteOffset, false)
}

function read_int32_be(target, at) {
  var dv = map.get(target);
  return dv.getInt32(at + target.byteOffset, false)
}

function read_float_be(target, at) {
  var dv = map.get(target);
  return dv.getFloat32(at + target.byteOffset, false)
}

function read_double_be(target, at) {
  var dv = map.get(target);
  return dv.getFloat64(at + target.byteOffset, false)
}

},{"./mapped.js":65}],67:[function(require,module,exports){
module.exports = subarray

function subarray(buf, from, to) {
  return buf.subarray(from || 0, to || buf.length)
}

},{}],68:[function(require,module,exports){
module.exports = to

var base64 = require('base64-js')
  , toutf8 = require('to-utf8')

var encoders = {
    hex: to_hex
  , utf8: to_utf
  , base64: to_base64
}

function to(buf, encoding) {
  return encoders[encoding || 'utf8'](buf)
}

function to_hex(buf) {
  var str = ''
    , byt

  for(var i = 0, len = buf.length; i < len; ++i) {
    byt = buf[i]
    str += ((byt & 0xF0) >>> 4).toString(16)
    str += (byt & 0x0F).toString(16)
  }

  return str
}

function to_utf(buf) {
  return toutf8(buf)
}

function to_base64(buf) {
  return base64.fromByteArray(buf)
}


},{"base64-js":58,"to-utf8":59}],69:[function(require,module,exports){
module.exports = {
    writeUInt8:      write_uint8
  , writeInt8:       write_int8
  , writeUInt16LE:   write_uint16_le
  , writeUInt32LE:   write_uint32_le
  , writeInt16LE:    write_int16_le
  , writeInt32LE:    write_int32_le
  , writeFloatLE:    write_float_le
  , writeDoubleLE:   write_double_le
  , writeUInt16BE:   write_uint16_be
  , writeUInt32BE:   write_uint32_be
  , writeInt16BE:    write_int16_be
  , writeInt32BE:    write_int32_be
  , writeFloatBE:    write_float_be
  , writeDoubleBE:   write_double_be
}

var map = require('./mapped.js')

function write_uint8(target, value, at) {
  return target[at] = value
}

function write_int8(target, value, at) {
  return target[at] = value < 0 ? value + 0x100 : value
}

function write_uint16_le(target, value, at) {
  var dv = map.get(target);
  return dv.setUint16(at + target.byteOffset, value, true)
}

function write_uint32_le(target, value, at) {
  var dv = map.get(target);
  return dv.setUint32(at + target.byteOffset, value, true)
}

function write_int16_le(target, value, at) {
  var dv = map.get(target);
  return dv.setInt16(at + target.byteOffset, value, true)
}

function write_int32_le(target, value, at) {
  var dv = map.get(target);
  return dv.setInt32(at + target.byteOffset, value, true)
}

function write_float_le(target, value, at) {
  var dv = map.get(target);
  return dv.setFloat32(at + target.byteOffset, value, true)
}

function write_double_le(target, value, at) {
  var dv = map.get(target);
  return dv.setFloat64(at + target.byteOffset, value, true)
}

function write_uint16_be(target, value, at) {
  var dv = map.get(target);
  return dv.setUint16(at + target.byteOffset, value, false)
}

function write_uint32_be(target, value, at) {
  var dv = map.get(target);
  return dv.setUint32(at + target.byteOffset, value, false)
}

function write_int16_be(target, value, at) {
  var dv = map.get(target);
  return dv.setInt16(at + target.byteOffset, value, false)
}

function write_int32_be(target, value, at) {
  var dv = map.get(target);
  return dv.setInt32(at + target.byteOffset, value, false)
}

function write_float_be(target, value, at) {
  var dv = map.get(target);
  return dv.setFloat32(at + target.byteOffset, value, false)
}

function write_double_be(target, value, at) {
  var dv = map.get(target);
  return dv.setFloat64(at + target.byteOffset, value, false)
}

},{"./mapped.js":65}],70:[function(require,module,exports){
var Buffer=require("__browserify_Buffer");var stream = require('stream')
var util = require('util')

function ConcatStream(cb) {
  stream.Stream.call(this)
  this.writable = true
  if (cb) this.cb = cb
  this.body = []
  this.on('error', function(err) {
    if (this.cb) this.cb(err)
  })
}

util.inherits(ConcatStream, stream.Stream)

ConcatStream.prototype.write = function(chunk) {
  this.body.push(chunk)
}

ConcatStream.prototype.destroy = function() {}

ConcatStream.prototype.arrayConcat = function(arrs) {
  if (arrs.length === 0) return []
  if (arrs.length === 1) return arrs[0]
  return arrs.reduce(function (a, b) { return a.concat(b) })
}

ConcatStream.prototype.isArray = function(arr) {
  return Array.isArray(arr)
}

ConcatStream.prototype.getBody = function () {
  if (this.body.length === 0) return
  if (typeof(this.body[0]) === "string") return this.body.join('')
  if (this.isArray(this.body[0])) return this.arrayConcat(this.body)
  if (typeof(Buffer) !== "undefined" && Buffer.isBuffer(this.body[0])) {
    return Buffer.concat(this.body)
  }
  return this.body
}

ConcatStream.prototype.end = function() {
  if (this.cb) this.cb(false, this.getBody())
}

module.exports = function(cb) {
  return new ConcatStream(cb)
}

module.exports.ConcatStream = ConcatStream

},{"__browserify_Buffer":159,"stream":165,"util":173}],71:[function(require,module,exports){
var process=require("__browserify_process");var util              = require('util')
  , bops              = require('bops')
  , AbstractLevelDOWN = require('abstract-leveldown').AbstractLevelDOWN

function DeferredLevelDOWN (location) {
  AbstractLevelDOWN.call(this, typeof location == 'string' ? location : '') // optional location, who cares?
  this._db         = undefined
  this._operations = []
}

util.inherits(DeferredLevelDOWN, AbstractLevelDOWN)

// called by LevelUP when we have a real DB to take its place
DeferredLevelDOWN.prototype.setDb = function (db) {
  this._db = db
  this._operations.forEach(function (op) {
    db[op.method].apply(db, op.args)
  })
}

DeferredLevelDOWN.prototype._open = function (options, callback) {
  return process.nextTick(callback)
}

// queue a new deferred operation
DeferredLevelDOWN.prototype._operation = function (method, args) {
  if (this._db)
    return this._db[method].apply(this._db, args)
  this._operations.push({ method: method, args: args })
}

// deferrables
'put get del batch approximateSize'.split(' ').forEach(function (m) {
  DeferredLevelDOWN.prototype['_' + m] = function () {
    this._operation(m, arguments)
  }
})

DeferredLevelDOWN.prototype._isBuffer = function (obj) {
  return bops.is(obj)
}

// don't need to implement this as LevelUP's ReadStream checks for 'ready' state
DeferredLevelDOWN.prototype._iterator = function () {
  throw new TypeError('not implemented')
}

module.exports = DeferredLevelDOWN
},{"__browserify_process":160,"abstract-leveldown":74,"bops":75,"util":173}],72:[function(require,module,exports){
var process=require("__browserify_process");/* Copyright (c) 2013 Rod Vagg, MIT License */

function AbstractChainedBatch (db) {
  this._db         = db
  this._operations = []
  this._written    = false
}

AbstractChainedBatch.prototype._checkWritten = function () {
  if (this._written)
    throw new Error('write() already called on this batch')
}

AbstractChainedBatch.prototype.put = function (key, value) {
  this._checkWritten()

  var err = this._db._checkKeyValue(key, 'key', this._db._isBuffer)
  if (err) throw err
  err = this._db._checkKeyValue(value, 'value', this._db._isBuffer)
  if (err) throw err

  if (!this._db._isBuffer(key)) key = String(key)
  if (!this._db._isBuffer(value)) value = String(value)

  if (typeof this._put == 'function' )
    this._put(key, value)
  else
    this._operations.push({ type: 'put', key: key, value: value })

  return this
}

AbstractChainedBatch.prototype.del = function (key) {
  this._checkWritten()

  var err = this._db._checkKeyValue(key, 'key', this._db._isBuffer)
  if (err) throw err

  if (!this._db._isBuffer(key)) key = String(key)

  if (typeof this._del == 'function' )
    this._del(key)
  else
    this._operations.push({ type: 'del', key: key })

  return this
}

AbstractChainedBatch.prototype.clear = function () {
  this._checkWritten()

  this._operations = []

  if (typeof this._clear == 'function' )
    this._clear()

  return this
}

AbstractChainedBatch.prototype.write = function (options, callback) {
  this._checkWritten()

  if (typeof options == 'function')
    callback = options
  if (typeof callback != 'function')
    throw new Error('write() requires a callback argument')
  if (typeof options != 'object')
    options = {}

  this._written = true

  if (typeof this._write == 'function' )
    return this._write(callback)

  if (typeof this._db._batch == 'function')
    return this._db._batch(this._operations, options, callback)

  process.nextTick(callback)
}

module.exports = AbstractChainedBatch
},{"__browserify_process":160}],73:[function(require,module,exports){
var process=require("__browserify_process");/* Copyright (c) 2013 Rod Vagg, MIT License */

function AbstractIterator (db) {
  this.db = db
  this._ended = false
  this._nexting = false
}

AbstractIterator.prototype.next = function (callback) {
  var self = this

  if (typeof callback != 'function')
    throw new Error('next() requires a callback argument')

  if (self._ended)
    return callback(new Error('cannot call next() after end()'))
  if (self._nexting)
    return callback(new Error('cannot call next() before previous next() has completed'))

  self._nexting = true
  if (typeof self._next == 'function') {
    return self._next(function () {
      self._nexting = false
      callback.apply(null, arguments)
    })
  }

  process.nextTick(function () {
    self._nexting = false
    callback()
  })
}

AbstractIterator.prototype.end = function (callback) {
  if (typeof callback != 'function')
    throw new Error('end() requires a callback argument')

  if (this._ended)
    return callback(new Error('end() already called on iterator'))

  this._ended = true

  if (typeof this._end == 'function')
    return this._end(callback)

  process.nextTick(callback)
}

module.exports = AbstractIterator

},{"__browserify_process":160}],74:[function(require,module,exports){
var process=require("__browserify_process"),Buffer=require("__browserify_Buffer");/* Copyright (c) 2013 Rod Vagg, MIT License */

var AbstractIterator     = require('./abstract-iterator')
  , AbstractChainedBatch = require('./abstract-chained-batch')

function AbstractLevelDOWN (location) {
  if (!arguments.length || location === undefined)
    throw new Error('constructor requires at least a location argument')

  if (typeof location != 'string')
    throw new Error('constructor requires a location string argument')

  this.location = location
}

AbstractLevelDOWN.prototype.open = function (options, callback) {
  if (typeof options == 'function')
    callback = options
  if (typeof callback != 'function')
    throw new Error('open() requires a callback argument')
  if (typeof options != 'object')
    options = {}

  if (typeof this._open == 'function')
    return this._open(options, callback)

  process.nextTick(callback)
}

AbstractLevelDOWN.prototype.close = function (callback) {
  if (typeof callback != 'function')
    throw new Error('close() requires a callback argument')

  if (typeof this._close == 'function')
    return this._close(callback)

  process.nextTick(callback)
}

AbstractLevelDOWN.prototype.get = function (key, options, callback) {
  var self = this
  if (typeof options == 'function')
    callback = options
  if (typeof callback != 'function')
    throw new Error('get() requires a callback argument')
  var err = self._checkKeyValue(key, 'key', self._isBuffer)
  if (err) return callback(err)
  if (!self._isBuffer(key)) key = String(key)
  if (typeof options != 'object')
    options = {}

  if (typeof self._get == 'function')
    return self._get(key, options, callback)

  process.nextTick(function () { callback(new Error('NotFound')) })
}

AbstractLevelDOWN.prototype.put = function (key, value, options, callback) {
  if (typeof options == 'function')
    callback = options
  if (typeof callback != 'function')
    throw new Error('put() requires a callback argument')
  var err = this._checkKeyValue(key, 'key', this._isBuffer)
  if (err) return callback(err)
  err = this._checkKeyValue(value, 'value', this._isBuffer)
  if (err) return callback(err)
  if (!this._isBuffer(key)) key = String(key)
  // coerce value to string in node, dont touch it in browser
  // (indexeddb can store any JS type)
  if (!this._isBuffer(value) && !process.browser) value = String(value)
  if (typeof options != 'object')
    options = {}
  if (typeof this._put == 'function')
    return this._put(key, value, options, callback)

  process.nextTick(callback)
}

AbstractLevelDOWN.prototype.del = function (key, options, callback) {
  if (typeof options == 'function')
    callback = options
  if (typeof callback != 'function')
    throw new Error('del() requires a callback argument')
  var err = this._checkKeyValue(key, 'key', this._isBuffer)
  if (err) return callback(err)
  if (!this._isBuffer(key)) key = String(key)
  if (typeof options != 'object')
    options = {}


  if (typeof this._del == 'function')
    return this._del(key, options, callback)

  process.nextTick(callback)
}

AbstractLevelDOWN.prototype.batch = function (array, options, callback) {
  if (!arguments.length)
    return this._chainedBatch()

  if (typeof options == 'function')
    callback = options
  if (typeof callback != 'function')
    throw new Error('batch(array) requires a callback argument')
  if (!Array.isArray(array))
    return callback(new Error('batch(array) requires an array argument'))
  if (typeof options != 'object')
    options = {}

  var i = 0
    , l = array.length
    , e
    , err

  for (; i < l; i++) {
    e = array[i]
    if (typeof e != 'object') continue;

    err = this._checkKeyValue(e.type, 'type', this._isBuffer)
    if (err) return callback(err)

    err = this._checkKeyValue(e.key, 'key', this._isBuffer)
    if (err) return callback(err)

    if (e.type == 'put') {
      err = this._checkKeyValue(e.value, 'value', this._isBuffer)
      if (err) return callback(err)
    }
  }

  if (typeof this._batch == 'function')
    return this._batch(array, options, callback)

  process.nextTick(callback)
}

AbstractLevelDOWN.prototype.approximateSize = function (start, end, callback) {
  if (start == null || end == null || typeof start == 'function' || typeof end == 'function')
    throw new Error('approximateSize() requires valid `start`, `end` and `callback` arguments')
  if (typeof callback != 'function')
    throw new Error('approximateSize() requires a callback argument')

  if (!this._isBuffer(start)) start = String(start)
  if (!this._isBuffer(end)) end = String(end)
  if (typeof this._approximateSize == 'function')
    return this._approximateSize(start, end, callback)

  process.nextTick(function () { callback(null, 0) })
}

AbstractLevelDOWN.prototype.iterator = function (options) {
  if (typeof options != 'object')
    options = {}

  if (typeof this._iterator == 'function')
    return this._iterator(options)

  return new AbstractIterator(this)
}

AbstractLevelDOWN.prototype._chainedBatch = function () {
  return new AbstractChainedBatch(this)
}

AbstractLevelDOWN.prototype._isBuffer = function (obj) {
  return Buffer.isBuffer(obj)
}

AbstractLevelDOWN.prototype._checkKeyValue = function (obj, type) {
  if (obj === null || obj === undefined)
    return new Error(type + ' cannot be `null` or `undefined`')
  if (obj === null || obj === undefined)
    return new Error(type + ' cannot be `null` or `undefined`')
  if (this._isBuffer(obj)) {
    if (obj.length === 0)
      return new Error(type + ' cannot be an empty Buffer')
  } else if (String(obj) === '')
    return new Error(type + ' cannot be an empty String')
}

module.exports.AbstractLevelDOWN    = AbstractLevelDOWN
module.exports.AbstractIterator     = AbstractIterator
module.exports.AbstractChainedBatch = AbstractChainedBatch

},{"./abstract-chained-batch":72,"./abstract-iterator":73,"__browserify_Buffer":159,"__browserify_process":160}],75:[function(require,module,exports){
arguments[4][57][0].apply(exports,arguments)
},{"./copy.js":78,"./create.js":79,"./from.js":80,"./is.js":81,"./join.js":82,"./read.js":84,"./subarray.js":85,"./to.js":86,"./write.js":87}],76:[function(require,module,exports){
module.exports=require(58)
},{}],77:[function(require,module,exports){
module.exports=require(59)
},{}],78:[function(require,module,exports){
module.exports=require(60)
},{}],79:[function(require,module,exports){
module.exports=require(61)
},{}],80:[function(require,module,exports){
module.exports = from

var base64 = require('base64-js')

var decoders = {
    hex: from_hex
  , utf8: from_utf
  , base64: from_base64
}

function from(source, encoding) {
  if(Array.isArray(source)) {
    return new Uint8Array(source)
  }

  return decoders[encoding || 'utf8'](source)
}

function from_hex(str) {
  var size = str.length / 2
    , buf = new Uint8Array(size)
    , character = ''

  for(var i = 0, len = str.length; i < len; ++i) {
    character += str.charAt(i)

    if(i > 0 && (i % 2) === 1) {
      buf[i>>>1] = parseInt(character, 16)
      character = '' 
    }
  }

  return buf 
}

function from_utf(str) {
  var bytes = []
    , tmp
    , ch

  for(var i = 0, len = str.length; i < len; ++i) {
    ch = str.charCodeAt(i)
    if(ch & 0x80) {
      tmp = encodeURIComponent(str.charAt(i)).substr(1).split('%')
      for(var j = 0, jlen = tmp.length; j < jlen; ++j) {
        bytes[bytes.length] = parseInt(tmp[j], 16)
      }
    } else {
      bytes[bytes.length] = ch 
    }
  }

  return new Uint8Array(bytes)
}

function from_base64(str) {
  return new Uint8Array(base64.toByteArray(str)) 
}

},{"base64-js":76}],81:[function(require,module,exports){
module.exports=require(63)
},{}],82:[function(require,module,exports){
module.exports=require(64)
},{}],83:[function(require,module,exports){
module.exports=require(65)
},{}],84:[function(require,module,exports){
module.exports=require(66)
},{"./mapped.js":83}],85:[function(require,module,exports){
module.exports=require(67)
},{}],86:[function(require,module,exports){
module.exports=require(68)
},{"base64-js":76,"to-utf8":77}],87:[function(require,module,exports){
module.exports=require(69)
},{"./mapped.js":83}],88:[function(require,module,exports){
const prr = require('prr')

function init (type, message, cause) {
  prr(this, {
      type    : type
    , name    : type
      // can be passed just a 'cause'
    , cause   : typeof message != 'string' ? message : cause
    , message : !!message && typeof message != 'string' ? message.message : message

  }, 'ewr')
}

// generic prototype, not intended to be actually used - helpful for `instanceof`
function CustomError (message, cause) {
  Error.call(this)
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, arguments.callee)
  init.call(this, 'CustomError', message, cause)
}

CustomError.prototype = new Error()

function createError (errno, type, proto) {
  var err = function (message, cause) {
    init.call(this, type, message, cause)
    //TODO: the specificity here is stupid, errno should be available everywhere
    if (type == 'FilesystemError') {
      this.code    = this.cause.code
      this.path    = this.cause.path
      this.errno   = this.cause.errno
      this.message =
        (errno.errno[this.cause.errno]
          ? errno.errno[this.cause.errno].description
          : this.cause.message)
        + (this.cause.path ? ' [' + this.cause.path + ']' : '')
    }
    Error.call(this)
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, arguments.callee)
  }
  err.prototype = !!proto ? new proto() : new CustomError()
  return err
}

module.exports = function (errno) {
  var ce = function (type, proto) {
    return createError(errno, type, proto)
  }
  return {
      CustomError     : CustomError
    , FilesystemError : ce('FilesystemError')
    , createError     : ce
  }
}

},{"prr":90}],89:[function(require,module,exports){
var all = module.exports.all = [
 {
  "errno": -1,
  "code": "UNKNOWN",
  "description": "unknown error"
 },
 {
  "errno": 0,
  "code": "OK",
  "description": "success"
 },
 {
  "errno": 1,
  "code": "EOF",
  "description": "end of file"
 },
 {
  "errno": 2,
  "code": "EADDRINFO",
  "description": "getaddrinfo error"
 },
 {
  "errno": 3,
  "code": "EACCES",
  "description": "permission denied"
 },
 {
  "errno": 4,
  "code": "EAGAIN",
  "description": "resource temporarily unavailable"
 },
 {
  "errno": 5,
  "code": "EADDRINUSE",
  "description": "address already in use"
 },
 {
  "errno": 6,
  "code": "EADDRNOTAVAIL",
  "description": "address not available"
 },
 {
  "errno": 7,
  "code": "EAFNOSUPPORT",
  "description": "address family not supported"
 },
 {
  "errno": 8,
  "code": "EALREADY",
  "description": "connection already in progress"
 },
 {
  "errno": 9,
  "code": "EBADF",
  "description": "bad file descriptor"
 },
 {
  "errno": 10,
  "code": "EBUSY",
  "description": "resource busy or locked"
 },
 {
  "errno": 11,
  "code": "ECONNABORTED",
  "description": "software caused connection abort"
 },
 {
  "errno": 12,
  "code": "ECONNREFUSED",
  "description": "connection refused"
 },
 {
  "errno": 13,
  "code": "ECONNRESET",
  "description": "connection reset by peer"
 },
 {
  "errno": 14,
  "code": "EDESTADDRREQ",
  "description": "destination address required"
 },
 {
  "errno": 15,
  "code": "EFAULT",
  "description": "bad address in system call argument"
 },
 {
  "errno": 16,
  "code": "EHOSTUNREACH",
  "description": "host is unreachable"
 },
 {
  "errno": 17,
  "code": "EINTR",
  "description": "interrupted system call"
 },
 {
  "errno": 18,
  "code": "EINVAL",
  "description": "invalid argument"
 },
 {
  "errno": 19,
  "code": "EISCONN",
  "description": "socket is already connected"
 },
 {
  "errno": 20,
  "code": "EMFILE",
  "description": "too many open files"
 },
 {
  "errno": 21,
  "code": "EMSGSIZE",
  "description": "message too long"
 },
 {
  "errno": 22,
  "code": "ENETDOWN",
  "description": "network is down"
 },
 {
  "errno": 23,
  "code": "ENETUNREACH",
  "description": "network is unreachable"
 },
 {
  "errno": 24,
  "code": "ENFILE",
  "description": "file table overflow"
 },
 {
  "errno": 25,
  "code": "ENOBUFS",
  "description": "no buffer space available"
 },
 {
  "errno": 26,
  "code": "ENOMEM",
  "description": "not enough memory"
 },
 {
  "errno": 27,
  "code": "ENOTDIR",
  "description": "not a directory"
 },
 {
  "errno": 28,
  "code": "EISDIR",
  "description": "illegal operation on a directory"
 },
 {
  "errno": 29,
  "code": "ENONET",
  "description": "machine is not on the network"
 },
 {
  "errno": 31,
  "code": "ENOTCONN",
  "description": "socket is not connected"
 },
 {
  "errno": 32,
  "code": "ENOTSOCK",
  "description": "socket operation on non-socket"
 },
 {
  "errno": 33,
  "code": "ENOTSUP",
  "description": "operation not supported on socket"
 },
 {
  "errno": 34,
  "code": "ENOENT",
  "description": "no such file or directory"
 },
 {
  "errno": 35,
  "code": "ENOSYS",
  "description": "function not implemented"
 },
 {
  "errno": 36,
  "code": "EPIPE",
  "description": "broken pipe"
 },
 {
  "errno": 37,
  "code": "EPROTO",
  "description": "protocol error"
 },
 {
  "errno": 38,
  "code": "EPROTONOSUPPORT",
  "description": "protocol not supported"
 },
 {
  "errno": 39,
  "code": "EPROTOTYPE",
  "description": "protocol wrong type for socket"
 },
 {
  "errno": 40,
  "code": "ETIMEDOUT",
  "description": "connection timed out"
 },
 {
  "errno": 41,
  "code": "ECHARSET",
  "description": "invalid Unicode character"
 },
 {
  "errno": 42,
  "code": "EAIFAMNOSUPPORT",
  "description": "address family for hostname not supported"
 },
 {
  "errno": 44,
  "code": "EAISERVICE",
  "description": "servname not supported for ai_socktype"
 },
 {
  "errno": 45,
  "code": "EAISOCKTYPE",
  "description": "ai_socktype not supported"
 },
 {
  "errno": 46,
  "code": "ESHUTDOWN",
  "description": "cannot send after transport endpoint shutdown"
 },
 {
  "errno": 47,
  "code": "EEXIST",
  "description": "file already exists"
 },
 {
  "errno": 48,
  "code": "ESRCH",
  "description": "no such process"
 },
 {
  "errno": 49,
  "code": "ENAMETOOLONG",
  "description": "name too long"
 },
 {
  "errno": 50,
  "code": "EPERM",
  "description": "operation not permitted"
 },
 {
  "errno": 51,
  "code": "ELOOP",
  "description": "too many symbolic links encountered"
 },
 {
  "errno": 52,
  "code": "EXDEV",
  "description": "cross-device link not permitted"
 },
 {
  "errno": 53,
  "code": "ENOTEMPTY",
  "description": "directory not empty"
 },
 {
  "errno": 54,
  "code": "ENOSPC",
  "description": "no space left on device"
 },
 {
  "errno": 55,
  "code": "EIO",
  "description": "i/o error"
 },
 {
  "errno": 56,
  "code": "EROFS",
  "description": "read-only file system"
 },
 {
  "errno": 57,
  "code": "ENODEV",
  "description": "no such device"
 },
 {
  "errno": 58,
  "code": "ESPIPE",
  "description": "invalid seek"
 },
 {
  "errno": 59,
  "code": "ECANCELED",
  "description": "operation canceled"
 }
]


module.exports.errno = {
    '-1': all[0]
  , '0': all[1]
  , '1': all[2]
  , '2': all[3]
  , '3': all[4]
  , '4': all[5]
  , '5': all[6]
  , '6': all[7]
  , '7': all[8]
  , '8': all[9]
  , '9': all[10]
  , '10': all[11]
  , '11': all[12]
  , '12': all[13]
  , '13': all[14]
  , '14': all[15]
  , '15': all[16]
  , '16': all[17]
  , '17': all[18]
  , '18': all[19]
  , '19': all[20]
  , '20': all[21]
  , '21': all[22]
  , '22': all[23]
  , '23': all[24]
  , '24': all[25]
  , '25': all[26]
  , '26': all[27]
  , '27': all[28]
  , '28': all[29]
  , '29': all[30]
  , '31': all[31]
  , '32': all[32]
  , '33': all[33]
  , '34': all[34]
  , '35': all[35]
  , '36': all[36]
  , '37': all[37]
  , '38': all[38]
  , '39': all[39]
  , '40': all[40]
  , '41': all[41]
  , '42': all[42]
  , '44': all[43]
  , '45': all[44]
  , '46': all[45]
  , '47': all[46]
  , '48': all[47]
  , '49': all[48]
  , '50': all[49]
  , '51': all[50]
  , '52': all[51]
  , '53': all[52]
  , '54': all[53]
  , '55': all[54]
  , '56': all[55]
  , '57': all[56]
  , '58': all[57]
  , '59': all[58]
}


module.exports.code = {
    'UNKNOWN': all[0]
  , 'OK': all[1]
  , 'EOF': all[2]
  , 'EADDRINFO': all[3]
  , 'EACCES': all[4]
  , 'EAGAIN': all[5]
  , 'EADDRINUSE': all[6]
  , 'EADDRNOTAVAIL': all[7]
  , 'EAFNOSUPPORT': all[8]
  , 'EALREADY': all[9]
  , 'EBADF': all[10]
  , 'EBUSY': all[11]
  , 'ECONNABORTED': all[12]
  , 'ECONNREFUSED': all[13]
  , 'ECONNRESET': all[14]
  , 'EDESTADDRREQ': all[15]
  , 'EFAULT': all[16]
  , 'EHOSTUNREACH': all[17]
  , 'EINTR': all[18]
  , 'EINVAL': all[19]
  , 'EISCONN': all[20]
  , 'EMFILE': all[21]
  , 'EMSGSIZE': all[22]
  , 'ENETDOWN': all[23]
  , 'ENETUNREACH': all[24]
  , 'ENFILE': all[25]
  , 'ENOBUFS': all[26]
  , 'ENOMEM': all[27]
  , 'ENOTDIR': all[28]
  , 'EISDIR': all[29]
  , 'ENONET': all[30]
  , 'ENOTCONN': all[31]
  , 'ENOTSOCK': all[32]
  , 'ENOTSUP': all[33]
  , 'ENOENT': all[34]
  , 'ENOSYS': all[35]
  , 'EPIPE': all[36]
  , 'EPROTO': all[37]
  , 'EPROTONOSUPPORT': all[38]
  , 'EPROTOTYPE': all[39]
  , 'ETIMEDOUT': all[40]
  , 'ECHARSET': all[41]
  , 'EAIFAMNOSUPPORT': all[42]
  , 'EAISERVICE': all[43]
  , 'EAISOCKTYPE': all[44]
  , 'ESHUTDOWN': all[45]
  , 'EEXIST': all[46]
  , 'ESRCH': all[47]
  , 'ENAMETOOLONG': all[48]
  , 'EPERM': all[49]
  , 'ELOOP': all[50]
  , 'EXDEV': all[51]
  , 'ENOTEMPTY': all[52]
  , 'ENOSPC': all[53]
  , 'EIO': all[54]
  , 'EROFS': all[55]
  , 'ENODEV': all[56]
  , 'ESPIPE': all[57]
  , 'ECANCELED': all[58]
}


module.exports.custom = require("./custom")(module.exports)
module.exports.create = module.exports.custom.createError
},{"./custom":88}],90:[function(require,module,exports){
/*!
  * prr
  * (c) 2013 Rod Vagg <rod@vagg.org>
  * https://github.com/rvagg/prr
  * License: MIT
  */

(function (name, context, definition) {
  if (typeof module != 'undefined' && module.exports)
    module.exports = definition()
  else
    context[name] = definition()
})('prr', this, function() {

  var setProperty = typeof Object.defineProperty == 'function'
      ? function (obj, key, options) {
          Object.defineProperty(obj, key, options)
          return obj
        }
      : function (obj, key, options) { // < es5
          obj[key] = options.value
          return obj
        }

    , makeOptions = function (value, options) {
        var oo = typeof options == 'object'
          , os = !oo && typeof options == 'string'
          , op = function (p) {
              return oo
                ? !!options[p]
                : os
                  ? options.indexOf(p[0]) > -1
                  : false
            }

        return {
            enumerable   : op('enumerable')
          , configurable : op('configurable')
          , writable     : op('writable')
          , value        : value
        }
      }

    , prr = function (obj, key, value, options) {
        var k

        options = makeOptions(value, options)

        if (typeof key == 'object') {
          for (k in key) {
            if (Object.hasOwnProperty.call(key, k)) {
              options.value = key[k]
              setProperty(obj, k, options)
            }
          }
          return obj
        }

        return setProperty(obj, key, options)
      }

  return prr
})
},{}],91:[function(require,module,exports){
var process=require("__browserify_process");// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

module.exports = Duplex;
var util = require('util');
var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

Object.keys(Writable.prototype).forEach(function(method) {
  if (!Duplex.prototype[method])
    Duplex.prototype[method] = Writable.prototype[method];
});

function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false)
    this.readable = false;

  if (options && options.writable === false)
    this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false)
    this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended)
    return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  process.nextTick(this.end.bind(this));
}

},{"./_stream_readable":93,"./_stream_writable":95,"__browserify_process":160,"util":173}],92:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

module.exports = PassThrough;

var Transform = require('./_stream_transform');
var util = require('util');
util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};

},{"./_stream_transform":94,"util":173}],93:[function(require,module,exports){
var process=require("__browserify_process"),Buffer=require("__browserify_Buffer");// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Readable;
Readable.ReadableState = ReadableState;

var EE = require('events').EventEmitter;
if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
  return emitter.listeners(type).length;
};
var Stream = require('stream');
var util = require('util');
var StringDecoder;

util.inherits(Readable, Stream);

function ReadableState(options, stream) {
  options = options || {};

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.buffer = [];
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = false;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // In streams that never have any data, and do push(null) right away,
  // the consumer can miss the 'end' event if they do some I/O before
  // consuming the stream.  So, we don't emit('end') until some reading
  // happens.
  this.calledRead = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, becuase any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;


  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder)
      StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  if (!(this instanceof Readable))
    return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
  var state = this._readableState;

  if (typeof chunk === 'string' && !state.objectMode) {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = new Buffer(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (chunk === null || chunk === undefined) {
    state.reading = false;
    if (!state.ended)
      onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var e = new Error('stream.unshift() after end event');
      stream.emit('error', e);
    } else {
      if (state.decoder && !addToFront && !encoding)
        chunk = state.decoder.write(chunk);

      // update the buffer info.
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront) {
        state.buffer.unshift(chunk);
      } else {
        state.reading = false;
        state.buffer.push(chunk);
      }

      if (state.needReadable)
        emitReadable(stream);

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}



// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended &&
         (state.needReadable ||
          state.length < state.highWaterMark ||
          state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
  if (!StringDecoder)
    StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
};

// Don't raise the hwm > 128MB
var MAX_HWM = 0x800000;
function roundUpToNextPowerOf2(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2
    n--;
    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
    n++;
  }
  return n;
}

function howMuchToRead(n, state) {
  if (state.length === 0 && state.ended)
    return 0;

  if (state.objectMode)
    return n === 0 ? 0 : 1;

  if (isNaN(n) || n === null) {
    // only flow one buffer at a time
    if (state.flowing && state.buffer.length)
      return state.buffer[0].length;
    else
      return state.length;
  }

  if (n <= 0)
    return 0;

  // If we're asking for more than the target buffer level,
  // then raise the water mark.  Bump up to the next highest
  // power of 2, to prevent increasing it excessively in tiny
  // amounts.
  if (n > state.highWaterMark)
    state.highWaterMark = roundUpToNextPowerOf2(n);

  // don't have that much.  return null, unless we've ended.
  if (n > state.length) {
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    } else
      return state.length;
  }

  return n;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
  var state = this._readableState;
  state.calledRead = true;
  var nOrig = n;

  if (typeof n !== 'number' || n > 0)
    state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 &&
      state.needReadable &&
      (state.length >= state.highWaterMark || state.ended)) {
    emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0)
      endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;

  // if we currently have less than the highWaterMark, then also read some
  if (state.length - n <= state.highWaterMark)
    doRead = true;

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading)
    doRead = false;

  if (doRead) {
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0)
      state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read called its callback synchronously, then `reading`
  // will be false, and we need to re-evaluate how much data we
  // can return to the user.
  if (doRead && !state.reading)
    n = howMuchToRead(nOrig, state);

  var ret;
  if (n > 0)
    ret = fromList(n, state);
  else
    ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended)
    state.needReadable = true;

  // If we happened to read() exactly the remaining amount in the
  // buffer, and the EOF has been seen at this point, then make sure
  // that we emit 'end' on the very next tick.
  if (state.ended && !state.endEmitted && state.length === 0)
    endReadable(this);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!Buffer.isBuffer(chunk) &&
      'string' !== typeof chunk &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode &&
      !er) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}


function onEofChunk(stream, state) {
  if (state.decoder && !state.ended) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // if we've ended and we have some data left, then emit
  // 'readable' now to make sure it gets picked up.
  if (state.length > 0)
    emitReadable(stream);
  else
    endReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (state.emittedReadable)
    return;

  state.emittedReadable = true;
  if (state.sync)
    process.nextTick(function() {
      emitReadable_(stream);
    });
  else
    emitReadable_(stream);
}

function emitReadable_(stream) {
  stream.emit('readable');
}


// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(function() {
      maybeReadMore_(stream, state);
    });
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended &&
         state.length < state.highWaterMark) {
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
  this.emit('error', new Error('not implemented'));
};

Readable.prototype.pipe = function(dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;

  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
              dest !== process.stdout &&
              dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted)
    process.nextTick(endFn);
  else
    src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    if (readable !== src) return;
    cleanup();
  }

  function onend() {
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  function cleanup() {
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (!dest._writableState || dest._writableState.needDrain)
      ondrain();
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    unpipe();
    dest.removeListener('error', onerror);
    if (EE.listenerCount(dest, 'error') === 0)
      dest.emit('error', er);
  }
  // This is a brutally ugly hack to make sure that our error handler
  // is attached before any userland ones.  NEVER DO THIS.
  if (!dest._events || !dest._events.error)
    dest.on('error', onerror);
  else if (Array.isArray(dest._events.error))
    dest._events.error.unshift(onerror);
  else
    dest._events.error = [onerror, dest._events.error];



  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    // the handler that waits for readable events after all
    // the data gets sucked out in flow.
    // This would be easier to follow with a .once() handler
    // in flow(), but that is too slow.
    this.on('readable', pipeOnReadable);

    state.flowing = true;
    process.nextTick(function() {
      flow(src);
    });
  }

  return dest;
};

function pipeOnDrain(src) {
  return function() {
    var dest = this;
    var state = src._readableState;
    state.awaitDrain--;
    if (state.awaitDrain === 0)
      flow(src);
  };
}

function flow(src) {
  var state = src._readableState;
  var chunk;
  state.awaitDrain = 0;

  function write(dest, i, list) {
    var written = dest.write(chunk);
    if (false === written) {
      state.awaitDrain++;
    }
  }

  while (state.pipesCount && null !== (chunk = src.read())) {

    if (state.pipesCount === 1)
      write(state.pipes, 0, null);
    else
      state.pipes.forEach(write);

    src.emit('data', chunk);

    // if anyone needs a drain, then we have to wait for that.
    if (state.awaitDrain > 0)
      return;
  }

  // if every destination was unpiped, either before entering this
  // function, or in the while loop, then stop flowing.
  //
  // NB: This is a pretty rare edge case.
  if (state.pipesCount === 0) {
    state.flowing = false;

    // if there were data event listeners added, then switch to old mode.
    if (EE.listenerCount(src, 'data') > 0)
      emitDataEvents(src);
    return;
  }

  // at this point, no one needed a drain, so we just ran out of data
  // on the next readable event, start it over again.
  state.ranOut = true;
}

function pipeOnReadable() {
  if (this._readableState.ranOut) {
    this._readableState.ranOut = false;
    flow(this);
  }
}


Readable.prototype.unpipe = function(dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0)
    return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes)
      return this;

    if (!dest)
      dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    this.removeListener('readable', pipeOnReadable);
    state.flowing = false;
    if (dest)
      dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    this.removeListener('readable', pipeOnReadable);
    state.flowing = false;

    for (var i = 0; i < len; i++)
      dests[i].emit('unpipe', this);
    return this;
  }

  // try to find the right one.
  var i = state.pipes.indexOf(dest);
  if (i === -1)
    return this;

  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1)
    state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data' && !this._readableState.flowing)
    emitDataEvents(this);

  if (ev === 'readable' && this.readable) {
    var state = this._readableState;
    if (!state.readableListening) {
      state.readableListening = true;
      state.emittedReadable = false;
      state.needReadable = true;
      if (!state.reading) {
        this.read(0);
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
  emitDataEvents(this);
  this.read(0);
  this.emit('resume');
};

Readable.prototype.pause = function() {
  emitDataEvents(this, true);
  this.emit('pause');
};

function emitDataEvents(stream, startPaused) {
  var state = stream._readableState;

  if (state.flowing) {
    // https://github.com/isaacs/readable-stream/issues/16
    throw new Error('Cannot switch to old mode now.');
  }

  var paused = startPaused || false;
  var readable = false;

  // convert to an old-style stream.
  stream.readable = true;
  stream.pipe = Stream.prototype.pipe;
  stream.on = stream.addListener = Stream.prototype.on;

  stream.on('readable', function() {
    readable = true;

    var c;
    while (!paused && (null !== (c = stream.read())))
      stream.emit('data', c);

    if (c === null) {
      readable = false;
      stream._readableState.needReadable = true;
    }
  });

  stream.pause = function() {
    paused = true;
    this.emit('pause');
  };

  stream.resume = function() {
    paused = false;
    if (readable)
      process.nextTick(function() {
        stream.emit('readable');
      });
    else
      this.read(0);
    this.emit('resume');
  };

  // now make it start, just in case it hadn't already.
  stream.emit('readable');
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function() {
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length)
        self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function(chunk) {
    if (state.decoder)
      chunk = state.decoder.write(chunk);
    if (!chunk || !state.objectMode && !chunk.length)
      return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (typeof stream[i] === 'function' &&
        typeof this[i] === 'undefined') {
      this[i] = function(method) { return function() {
        return stream[method].apply(stream, arguments);
      }}(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  events.forEach(function(ev) {
    stream.on(ev, self.emit.bind(self, ev));
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function(n) {
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};



// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
function fromList(n, state) {
  var list = state.buffer;
  var length = state.length;
  var stringMode = !!state.decoder;
  var objectMode = !!state.objectMode;
  var ret;

  // nothing in the list, definitely empty.
  if (list.length === 0)
    return null;

  if (length === 0)
    ret = null;
  else if (objectMode)
    ret = list.shift();
  else if (!n || n >= length) {
    // read it all, truncate the array.
    if (stringMode)
      ret = list.join('');
    else
      ret = Buffer.concat(list, length);
    list.length = 0;
  } else {
    // read just some of it.
    if (n < list[0].length) {
      // just take a part of the first list item.
      // slice is the same for buffers and strings.
      var buf = list[0];
      ret = buf.slice(0, n);
      list[0] = buf.slice(n);
    } else if (n === list[0].length) {
      // first list is a perfect match
      ret = list.shift();
    } else {
      // complex case.
      // we have enough to cover it, but it spans past the first buffer.
      if (stringMode)
        ret = '';
      else
        ret = new Buffer(n);

      var c = 0;
      for (var i = 0, l = list.length; i < l && c < n; i++) {
        var buf = list[0];
        var cpy = Math.min(n - c, buf.length);

        if (stringMode)
          ret += buf.slice(0, cpy);
        else
          buf.copy(ret, c, 0, cpy);

        if (cpy < buf.length)
          list[0] = buf.slice(cpy);
        else
          list.shift();

        c += cpy;
      }
    }
  }

  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0)
    throw new Error('endReadable called on non-empty stream');

  if (!state.endEmitted && state.calledRead) {
    state.ended = true;
    process.nextTick(function() {
      // Check that we didn't get one last unshift.
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');
      }
    });
  }
}

},{"__browserify_Buffer":159,"__browserify_process":160,"events":157,"stream":165,"string_decoder/":96,"util":173}],94:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

module.exports = Transform;

var Duplex = require('./_stream_duplex');
var util = require('util');
util.inherits(Transform, Duplex);


function TransformState(options, stream) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb)
    return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined)
    stream.push(data);

  if (cb)
    cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}


function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);

  Duplex.call(this, options);

  var ts = this._transformState = new TransformState(options, this);

  // when the writable side finishes, then flush out anything remaining.
  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  this.once('finish', function() {
    if ('function' === typeof this._flush)
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}

Transform.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function(chunk, encoding, cb) {
  throw new Error('not implemented');
};

Transform.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform ||
        rs.needReadable ||
        rs.length < rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function(n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};


function done(stream, er) {
  if (er)
    return stream.emit('error', er);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var rs = stream._readableState;
  var ts = stream._transformState;

  if (ws.length)
    throw new Error('calling transform done when ws.length != 0');

  if (ts.transforming)
    throw new Error('calling transform done when still transforming');

  return stream.push(null);
}

},{"./_stream_duplex":91,"util":173}],95:[function(require,module,exports){
var process=require("__browserify_process"),Buffer=require("__browserify_Buffer");// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, cb), and it'll handle all
// the drain event emission and buffering.

module.exports = Writable;
Writable.WritableState = WritableState;

var util = require('util');
var assert = require('assert');
var Stream = require('stream');

util.inherits(Writable, Stream);

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
}

function WritableState(options, stream) {
  options = options || {};

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, becuase any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function(er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.buffer = [];
}

function Writable(options) {
  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) && !(this instanceof require('./_stream_duplex')))
    return new Writable(options);

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
  this.emit('error', new Error('Cannot pipe. Not readable.'));
};


function writeAfterEnd(stream, state, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  process.nextTick(function() {
    cb(er);
  });
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  if (!Buffer.isBuffer(chunk) &&
      'string' !== typeof chunk &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode) {
    var er = new TypeError('Invalid non-string/buffer chunk');
    stream.emit('error', er);
    process.nextTick(function() {
      cb(er);
    });
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function(chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (Buffer.isBuffer(chunk))
    encoding = 'buffer';
  else if (!encoding)
    encoding = state.defaultEncoding;

  if (typeof cb !== 'function')
    cb = function() {};

  if (state.ended)
    writeAfterEnd(this, state, cb);
  else if (validChunk(this, state, chunk, cb))
    ret = writeOrBuffer(this, state, chunk, encoding, cb);

  return ret;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode &&
      state.decodeStrings !== false &&
      typeof chunk === 'string') {
    chunk = new Buffer(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);
  if (Buffer.isBuffer(chunk))
    encoding = 'buffer';
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret)
    state.needDrain = true;

  if (state.writing)
    state.buffer.push(new WriteReq(chunk, encoding, cb));
  else
    doWrite(stream, state, len, chunk, encoding, cb);

  return ret;
}

function doWrite(stream, state, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  if (sync)
    process.nextTick(function() {
      cb(er);
    });
  else
    cb(er);

  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er)
    onwriteError(stream, state, sync, er, cb);
  else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(stream, state);

    if (!finished && !state.bufferProcessing && state.buffer.length)
      clearBuffer(stream, state);

    if (sync) {
      process.nextTick(function() {
        afterWrite(stream, state, finished, cb);
      });
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream, state);
  cb();
  if (finished)
    finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}


// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;

  for (var c = 0; c < state.buffer.length; c++) {
    var entry = state.buffer[c];
    var chunk = entry.chunk;
    var encoding = entry.encoding;
    var cb = entry.callback;
    var len = state.objectMode ? 1 : chunk.length;

    doWrite(stream, state, len, chunk, encoding, cb);

    // if we didn't call the onwrite immediately, then
    // it means that we need to wait until it does.
    // also, that means that the chunk and cb are currently
    // being processed, so move the buffer counter past them.
    if (state.writing) {
      c++;
      break;
    }
  }

  state.bufferProcessing = false;
  if (c < state.buffer.length)
    state.buffer = state.buffer.slice(c);
  else
    state.buffer.length = 0;
}

Writable.prototype._write = function(chunk, encoding, cb) {
  cb(new Error('not implemented'));
};

Writable.prototype.end = function(chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (typeof chunk !== 'undefined' && chunk !== null)
    this.write(chunk, encoding);

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished)
    endWritable(this, state, cb);
};


function needFinish(stream, state) {
  return (state.ending &&
          state.length === 0 &&
          !state.finished &&
          !state.writing);
}

function finishMaybe(stream, state) {
  var need = needFinish(stream, state);
  if (need) {
    state.finished = true;
    stream.emit('finish');
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished)
      process.nextTick(cb);
    else
      stream.once('finish', cb);
  }
  state.ended = true;
}

},{"./_stream_duplex":91,"__browserify_Buffer":159,"__browserify_process":160,"assert":149,"stream":165,"util":173}],96:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = require('buffer').Buffer;

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  this.charBuffer = new Buffer(6);
  this.charReceived = 0;
  this.charLength = 0;
};


StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  var offset = 0;

  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var i = (buffer.length >= this.charLength - this.charReceived) ?
                this.charLength - this.charReceived :
                buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, offset, i);
    this.charReceived += (i - offset);
    offset = i;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (i == buffer.length) return charStr;

    // otherwise cut off the characters end from the beginning of this buffer
    buffer = buffer.slice(i, buffer.length);
    break;
  }

  var lenIncomplete = this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - lenIncomplete, end);
    this.charReceived = lenIncomplete;
    end -= lenIncomplete;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    this.charBuffer.write(charStr.charAt(charStr.length - 1), this.encoding);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }

  return i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  var incomplete = this.charReceived = buffer.length % 2;
  this.charLength = incomplete ? 2 : 0;
  return incomplete;
}

function base64DetectIncompleteChar(buffer) {
  var incomplete = this.charReceived = buffer.length % 3;
  this.charLength = incomplete ? 3 : 0;
  return incomplete;
}

},{"buffer":161}],97:[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":91,"./lib/_stream_passthrough.js":92,"./lib/_stream_readable.js":93,"./lib/_stream_transform.js":94,"./lib/_stream_writable.js":95}],98:[function(require,module,exports){
module.exports=require(34)
},{}],99:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"./has-keys":98,"object-keys":101}],100:[function(require,module,exports){
module.exports=require(47)
},{}],101:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"./shim":103}],102:[function(require,module,exports){
module.exports=require(49)
},{}],103:[function(require,module,exports){
module.exports=require(50)
},{"./foreach":100,"./isArguments":102}],104:[function(require,module,exports){
module.exports={
  "name": "levelup",
  "description": "Fast & simple storage - a Node.js-style LevelDB wrapper",
  "version": "0.18.2",
  "contributors": [
    {
      "name": "Rod Vagg",
      "email": "r@va.gg",
      "url": "https://github.com/rvagg"
    },
    {
      "name": "John Chesley",
      "email": "john@chesl.es",
      "url": "https://github.com/chesles/"
    },
    {
      "name": "Jake Verbaten",
      "email": "raynos2@gmail.com",
      "url": "https://github.com/raynos"
    },
    {
      "name": "Dominic Tarr",
      "email": "dominic.tarr@gmail.com",
      "url": "https://github.com/dominictarr"
    },
    {
      "name": "Max Ogden",
      "email": "max@maxogden.com",
      "url": "https://github.com/maxogden"
    },
    {
      "name": "Lars-Magnus Skog",
      "email": "lars.magnus.skog@gmail.com",
      "url": "https://github.com/ralphtheninja"
    },
    {
      "name": "David Björklund",
      "email": "david.bjorklund@gmail.com",
      "url": "https://github.com/kesla"
    },
    {
      "name": "Julian Gruber",
      "email": "julian@juliangruber.com",
      "url": "https://github.com/juliangruber"
    },
    {
      "name": "Paolo Fragomeni",
      "email": "paolo@async.ly",
      "url": "https://github.com/hij1nx"
    },
    {
      "name": "Anton Whalley",
      "email": "anton.whalley@nearform.com",
      "url": "https://github.com/No9"
    },
    {
      "name": "Matteo Collina",
      "email": "matteo.collina@gmail.com",
      "url": "https://github.com/mcollina"
    },
    {
      "name": "Pedro Teixeira",
      "email": "pedro.teixeira@gmail.com",
      "url": "https://github.com/pgte"
    },
    {
      "name": "James Halliday",
      "email": "mail@substack.net",
      "url": "https://github.com/substack"
    }
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/rvagg/node-levelup.git"
  },
  "homepage": "https://github.com/rvagg/node-levelup",
  "keywords": [
    "leveldb",
    "stream",
    "database",
    "db",
    "store",
    "storage",
    "json"
  ],
  "main": "lib/levelup.js",
  "dependencies": {
    "errno": "~0.1.0",
    "concat-stream": "~0.1.1",
    "readable-stream": "~1.0.17",
    "xtend": "~2.1.1",
    "prr": "~0.0.0",
    "semver": "~2.2.1",
    "bops": "~0.1.0",
    "deferred-leveldown": "~0.1.0"
  },
  "devDependencies": {
    "leveldown": "~0.10.0",
    "bustermove": "*",
    "tap": "*",
    "referee": "*",
    "rimraf": "*",
    "async": "*",
    "fstream": "*",
    "tar": "*",
    "mkfiletree": "*",
    "readfiletree": "*",
    "slow-stream": ">=0.0.4",
    "delayed": "*",
    "boganipsum": "*",
    "du": "*",
    "memdown": "*",
    "msgpack-js": "*"
  },
  "browser": {
    "leveldown": false,
    "leveldown/package": false,
    "semver": false
  },
  "scripts": {
    "test": "tap test/*-test.js --stderr",
    "functionaltests": "node ./test/functional/fstream-test.js && node ./test/functional/binary-data-test.js && node ./test/functional/compat-test.js",
    "alltests": "npm test && npm run-script functionaltests"
  },
  "license": "MIT",
  "readme": "LevelUP\n=======\n\n![LevelDB Logo](https://twimg0-a.akamaihd.net/profile_images/3360574989/92fc472928b444980408147e5e5db2fa_bigger.png)\n\nFast & simple storage - a Node.js-style LevelDB wrapper\n-------------------------------------------------------\n\n[![Build Status](https://secure.travis-ci.org/rvagg/node-levelup.png)](http://travis-ci.org/rvagg/node-levelup)\n\n[![NPM](https://nodei.co/npm/levelup.png?stars&downloads)](https://nodei.co/npm/levelup/) [![NPM](https://nodei.co/npm-dl/levelup.png)](https://nodei.co/npm/levelup/)\n\n\n  * <a href=\"#intro\">Introduction</a>\n  * <a href=\"#leveldown\">Relationship to LevelDOWN</a>\n  * <a href=\"#platforms\">Tested &amp; supported platforms</a>\n  * <a href=\"#basic\">Basic usage</a>\n  * <a href=\"#api\">API</a>\n  * <a href=\"#events\">Events</a>\n  * <a href=\"#json\">JSON data</a>\n  * <a href=\"#custom_encodings\">Custom encodings</a>\n  * <a href=\"#extending\">Extending LevelUP</a>\n  * <a href=\"#multiproc\">Multi-process access</a>\n  * <a href=\"#support\">Getting support</a>\n  * <a href=\"#contributing\">Contributing</a>\n  * <a href=\"#licence\">Licence &amp; copyright</a>\n\n<a name=\"intro\"></a>\nIntroduction\n------------\n\n**[LevelDB](http://code.google.com/p/leveldb/)** is a simple key/value data store built by Google, inspired by BigTable. It's used in Google Chrome and many other products. LevelDB supports arbitrary byte arrays as both keys and values, singular *get*, *put* and *delete* operations, *batched put and delete*, bi-directional iterators and simple compression using the very fast [Snappy](http://code.google.com/p/snappy/) algorithm.\n\n**LevelUP** aims to expose the features of LevelDB in a **Node.js-friendly way**. All standard `Buffer` encoding types are supported, as is a special JSON encoding. LevelDB's iterators are exposed as a Node.js-style **readable stream** a matching **writeable stream** converts writes to *batch* operations.\n\nLevelDB stores entries **sorted lexicographically by keys**. This makes LevelUP's <a href=\"#createReadStream\"><code>ReadStream</code></a> interface a very powerful query mechanism.\n\n**LevelUP** is an **OPEN Open Source Project**, see the <a href=\"#contributing\">Contributing</a> section to find out what this means.\n\n<a name=\"leveldown\"></a>\nRelationship to LevelDOWN\n-------------------------\n\nLevelUP is designed to be backed by **[LevelDOWN](https://github.com/rvagg/node-leveldown/)** which provides a pure C++ binding to LevelDB and can be used as a stand-alone package if required.\n\n**As of version 0.9, LevelUP no longer requires LevelDOWN as a dependency so you must `npm install leveldown` when you install LevelUP.**\n\nLevelDOWN is now optional because LevelUP can be used with alternative backends, such as **[level.js](https://github.com/maxogden/level.js)** in the browser or [MemDOWN](https://github.com/rvagg/node-memdown) for a pure in-memory store.\n\nLevelUP will look for LevelDOWN and throw an error if it can't find it in its Node `require()` path. It will also tell you if the installed version of LevelDOWN is incompatible.\n\n**The [level](https://github.com/level/level) package is available as an alternative installation mechanism.** Install it instead to automatically get both LevelUP & LevelDOWN. It exposes LevelUP on its export (i.e. you can `var leveldb = require('level')`).\n\n\n<a name=\"platforms\"></a>\nTested & supported platforms\n----------------------------\n\n  * **Linux**: including ARM platforms such as Raspberry Pi *and Kindle!*\n  * **Mac OS**\n  * **Solaris**: including Joyent's SmartOS & Nodejitsu\n  * **Windows**: Node 0.10 and above only. See installation instructions for *node-gyp's* dependencies [here](https://github.com/TooTallNate/node-gyp#installation), you'll need these (free) components from Microsoft to compile and run any native Node add-on in Windows.\n\n<a name=\"basic\"></a>\nBasic usage\n-----------\n\nFirst you need to install LevelUP!\n\n```sh\n$ npm install levelup leveldown\n```\n\nOr\n\n```sh\n$ npm install level\n```\n\n*(this second option requires you to use LevelUP by calling `var levelup = require('level')`)*\n\n\nAll operations are asynchronous although they don't necessarily require a callback if you don't need to know when the operation was performed.\n\n```js\nvar levelup = require('levelup')\n\n// 1) Create our database, supply location and options.\n//    This will create or open the underlying LevelDB store.\nvar db = levelup('./mydb')\n\n// 2) put a key & value\ndb.put('name', 'LevelUP', function (err) {\n  if (err) return console.log('Ooops!', err) // some kind of I/O error\n\n  // 3) fetch by key\n  db.get('name', function (err, value) {\n    if (err) return console.log('Ooops!', err) // likely the key was not found\n\n    // ta da!\n    console.log('name=' + value)\n  })\n})\n```\n\n<a name=\"api\"></a>\n## API\n\n  * <a href=\"#ctor\"><code><b>levelup()</b></code></a>\n  * <a href=\"#open\"><code>db.<b>open()</b></code></a>\n  * <a href=\"#close\"><code>db.<b>close()</b></code></a>\n  * <a href=\"#put\"><code>db.<b>put()</b></code></a>\n  * <a href=\"#get\"><code>db.<b>get()</b></code></a>\n  * <a href=\"#del\"><code>db.<b>del()</b></code></a>\n  * <a href=\"#batch\"><code>db.<b>batch()</b></code> *(array form)*</a>\n  * <a href=\"#batch_chained\"><code>db.<b>batch()</b></code> *(chained form)*</a>\n  * <a href=\"#isOpen\"><code>db.<b>isOpen()</b></code></a>\n  * <a href=\"#isClosed\"><code>db.<b>isClosed()</b></code></a>\n  * <a href=\"#createReadStream\"><code>db.<b>createReadStream()</b></code></a>\n  * <a href=\"#createKeyStream\"><code>db.<b>createKeyStream()</b></code></a>\n  * <a href=\"#createValueStream\"><code>db.<b>createValueStream()</b></code></a>\n  * <a href=\"#createWriteStream\"><code>db.<b>createWriteStream()</b></code></a>\n\n### Special operations exposed by LevelDOWN\n\n  * <a href=\"#approximateSize\"><code>db.db.<b>approximateSize()</b></code></a>\n  * <a href=\"#getProperty\"><code>db.db.<b>getProperty()</b></code></a>\n  * <a href=\"#destroy\"><code><b>leveldown.destroy()</b></code></a>\n  * <a href=\"#repair\"><code><b>leveldown.repair()</b></code></a>\n\n\n--------------------------------------------------------\n<a name=\"ctor\"></a>\n### levelup(location[, options[, callback]])\n### levelup(options[, callback ])\n### levelup(db[, callback ])\n<code>levelup()</code> is the main entry point for creating a new LevelUP instance and opening the underlying store with LevelDB.\n\nThis function returns a new instance of LevelUP and will also initiate an <a href=\"#open\"><code>open()</code></a> operation. Opening the database is an asynchronous operation which will trigger your callback if you provide one. The callback should take the form: `function (err, db) {}` where the `db` is the LevelUP instance. If you don't provide a callback, any read & write operations are simply queued internally until the database is fully opened.\n\nThis leads to two alternative ways of managing a new LevelUP instance:\n\n```js\nlevelup(location, options, function (err, db) {\n  if (err) throw err\n  db.get('foo', function (err, value) {\n    if (err) return console.log('foo does not exist')\n    console.log('got foo =', value)\n  })\n})\n\n// vs the equivalent:\n\nvar db = levelup(location, options) // will throw if an error occurs\ndb.get('foo', function (err, value) {\n  if (err) return console.log('foo does not exist')\n  console.log('got foo =', value)\n})\n```\n\nThe `location` argument is available as a read-only property on the returned LevelUP instance.\n\nThe `levelup(options, callback)` form (with optional `callback`) is only available where you provide a valid `'db'` property on the options object (see below). Only for back-ends that don't require a `location` argument, such as [MemDOWN](https://github.com/rvagg/memdown).\n\nFor example:\n\n```js\nvar levelup = require('levelup')\nvar memdown = require('memdown')\nvar db = levelup({ db: memdown })\n```\n\nThe `levelup(db, callback)` form (with optional `callback`) is only available where `db` is a factory function, as would be provided as a `'db'` property on an `options` object (see below). Only for back-ends that don't require a `location` argument, such as [MemDOWN](https://github.com/rvagg/memdown).\n\nFor example:\n\n```js\nvar levelup = require('levelup')\nvar memdown = require('memdown')\nvar db = levelup(memdown)\n```\n\n#### `options`\n\n`levelup()` takes an optional options object as its second argument; the following properties are accepted:\n\n* `'createIfMissing'` *(boolean, default: `true`)*: If `true`, will initialise an empty database at the specified location if one doesn't already exist. If `false` and a database doesn't exist you will receive an error in your `open()` callback and your database won't open.\n\n* `'errorIfExists'` *(boolean, default: `false`)*: If `true`, you will receive an error in your `open()` callback if the database exists at the specified location.\n\n* `'compression'` *(boolean, default: `true`)*: If `true`, all *compressible* data will be run through the Snappy compression algorithm before being stored. Snappy is very fast and shouldn't gain much speed by disabling so leave this on unless you have good reason to turn it off.\n\n* `'cacheSize'` *(number, default: `8 * 1024 * 1024`)*: The size (in bytes) of the in-memory [LRU](http://en.wikipedia.org/wiki/Cache_algorithms#Least_Recently_Used) cache with frequently used uncompressed block contents. \n\n* `'keyEncoding'` and `'valueEncoding'` *(string, default: `'utf8'`)*: The encoding of the keys and values passed through Node.js' `Buffer` implementation (see [Buffer#toString()](http://nodejs.org/docs/latest/api/buffer.html#buffer_buf_tostring_encoding_start_end)).\n  <p><code>'utf8'</code> is the default encoding for both keys and values so you can simply pass in strings and expect strings from your <code>get()</code> operations. You can also pass <code>Buffer</code> objects as keys and/or values and conversion will be performed.</p>\n  <p>Supported encodings are: hex, utf8, ascii, binary, base64, ucs2, utf16le.</p>\n  <p><code>'json'</code> encoding is also supported, see below.</p>\n\n* `'db'` *(object, default: LevelDOWN)*: LevelUP is backed by [LevelDOWN](https://github.com/rvagg/node-leveldown/) to provide an interface to LevelDB. You can completely replace the use of LevelDOWN by providing a \"factory\" function that will return a LevelDOWN API compatible object given a `location` argument. For further information, see [MemDOWN](https://github.com/rvagg/node-memdown/), a fully LevelDOWN API compatible replacement that uses a memory store rather than LevelDB. Also see [Abstract LevelDOWN](http://github.com/rvagg/node-abstract-leveldown), a partial implementation of the LevelDOWN API that can be used as a base prototype for a LevelDOWN substitute.\n\nAdditionally, each of the main interface methods accept an optional options object that can be used to override `'keyEncoding'` and `'valueEncoding'`.\n\n--------------------------------------------------------\n<a name=\"open\"></a>\n### db.open([callback])\n<code>open()</code> opens the underlying LevelDB store. In general **you should never need to call this method directly** as it's automatically called by <a href=\"#ctor\"><code>levelup()</code></a>.\n\nHowever, it is possible to *reopen* a database after it has been closed with <a href=\"#close\"><code>close()</code></a>, although this is not generally advised.\n\n--------------------------------------------------------\n<a name=\"close\"></a>\n### db.close([callback])\n<code>close()</code> closes the underlying LevelDB store. The callback will receive any error encountered during closing as the first argument.\n\nYou should always clean up your LevelUP instance by calling `close()` when you no longer need it to free up resources. A LevelDB store cannot be opened by multiple instances of LevelDB/LevelUP simultaneously.\n\n--------------------------------------------------------\n<a name=\"put\"></a>\n### db.put(key, value[, options][, callback])\n<code>put()</code> is the primary method for inserting data into the store. Both the `key` and `value` can be arbitrary data objects.\n\nThe callback argument is optional but if you don't provide one and an error occurs then expect the error to be thrown.\n\n#### `options`\n\nEncoding of the `key` and `value` objects will adhere to `'keyEncoding'` and `'valueEncoding'` options provided to <a href=\"#ctor\"><code>levelup()</code></a>, although you can provide alternative encoding settings in the options for `put()` (it's recommended that you stay consistent in your encoding of keys and values in a single store).\n\nIf you provide a `'sync'` value of `true` in your `options` object, LevelDB will perform a synchronous write of the data; although the operation will be asynchronous as far as Node is concerned. Normally, LevelDB passes the data to the operating system for writing and returns immediately, however a synchronous write will use `fsync()` or equivalent so your callback won't be triggered until the data is actually on disk. Synchronous filesystem writes are **significantly** slower than asynchronous writes but if you want to be absolutely sure that the data is flushed then you can use `'sync': true`.\n\n--------------------------------------------------------\n<a name=\"get\"></a>\n### db.get(key[, options][, callback])\n<code>get()</code> is the primary method for fetching data from the store. The `key` can be an arbitrary data object. If it doesn't exist in the store then the callback will receive an error as its first argument. A not-found err object will be of type `'NotFoundError'` so you can `err.type == 'NotFoundError'` or you can perform a truthy test on the property `err.notFound`.\n\n```js\ndb.get('foo', function (err, value) {\n  if (err) {\n    if (err.notFound) {\n      // handle a 'NotFoundError' here\n      return\n    }\n    // I/O or other error, pass it up the callback chain\n    return callback(err)\n  }\n\n  // .. handle `value` here\n})\n```\n\n#### `options`\n\nEncoding of the `key` object will adhere to the `'keyEncoding'` option provided to <a href=\"#ctor\"><code>levelup()</code></a>, although you can provide alternative encoding settings in the options for `get()` (it's recommended that you stay consistent in your encoding of keys and values in a single store).\n\nLevelDB will by default fill the in-memory LRU Cache with data from a call to get. Disabling this is done by setting `fillCache` to `false`. \n\n--------------------------------------------------------\n<a name=\"del\"></a>\n### db.del(key[, options][, callback])\n<code>del()</code> is the primary method for removing data from the store.\n\n#### `options`\n\nEncoding of the `key` object will adhere to the `'keyEncoding'` option provided to <a href=\"#ctor\"><code>levelup()</code></a>, although you can provide alternative encoding settings in the options for `del()` (it's recommended that you stay consistent in your encoding of keys and values in a single store).\n\nA `'sync'` option can also be passed, see <a href=\"#put\"><code>put()</code></a> for details on how this works.\n\n--------------------------------------------------------\n<a name=\"batch\"></a>\n### db.batch(array[, options][, callback]) *(array form)*\n<code>batch()</code> can be used for very fast bulk-write operations (both *put* and *delete*). The `array` argument should contain a list of operations to be executed sequentially, although as a whole they are performed as an atomic operation inside LevelDB. Each operation is contained in an object having the following properties: `type`, `key`, `value`, where the *type* is either `'put'` or `'del'`. In the case of `'del'` the `'value'` property is ignored. Any entries with a `'key'` of `null` or `undefined` will cause an error to be returned on the `callback` and any `'type': 'put'` entry with a `'value'` of `null` or `undefined` will return an error.\n\n```js\nvar ops = [\n    { type: 'del', key: 'father' }\n  , { type: 'put', key: 'name', value: 'Yuri Irsenovich Kim' }\n  , { type: 'put', key: 'dob', value: '16 February 1941' }\n  , { type: 'put', key: 'spouse', value: 'Kim Young-sook' }\n  , { type: 'put', key: 'occupation', value: 'Clown' }\n]\n\ndb.batch(ops, function (err) {\n  if (err) return console.log('Ooops!', err)\n  console.log('Great success dear leader!')\n})\n```\n\n#### `options`\n\nSee <a href=\"#put\"><code>put()</code></a> for a discussion on the `options` object. You can overwrite default `'keyEncoding'` and `'valueEncoding'` and also specify the use of `sync` filesystem operations.\n\nIn addition to encoding options for the whole batch you can also overwrite the encoding per operation, like:\n\n```js\nvar ops = [{\n    type          : 'put'\n  , key           : new Buffer([1, 2, 3])\n  , value         : { some: 'json' }\n  , keyEncoding   : 'binary'\n  , valueEncoding : 'json'\n}]\n```\n\n--------------------------------------------------------\n<a name=\"batch_chained\"></a>\n### db.batch() *(chained form)*\n<code>batch()</code>, when called with no arguments will return a `Batch` object which can be used to build, and eventually commit, an atomic LevelDB batch operation. Depending on how it's used, it is possible to obtain greater performance when using the chained form of `batch()` over the array form.\n\n```js\ndb.batch()\n  .del('father')\n  .put('name', 'Yuri Irsenovich Kim')\n  .put('dob', '16 February 1941')\n  .put('spouse', 'Kim Young-sook')\n  .put('occupation', 'Clown')\n  .write(function () { console.log('Done!') })\n```\n\n<b><code>batch.put(key, value[, options])</code></b>\n\nQueue a *put* operation on the current batch, not committed until a `write()` is called on the batch.\n\nThe optional `options` argument can be used to override the default `'keyEncoding'` and/or `'valueEncoding'`.\n\nThis method may `throw` a `WriteError` if there is a problem with your put (such as the `value` being `null` or `undefined`).\n\n<b><code>batch.del(key[, options])</code></b>\n\nQueue a *del* operation on the current batch, not committed until a `write()` is called on the batch.\n\nThe optional `options` argument can be used to override the default `'keyEncoding'`.\n\nThis method may `throw` a `WriteError` if there is a problem with your delete.\n\n<b><code>batch.clear()</code></b>\n\nClear all queued operations on the current batch, any previous operations will be discarded.\n\n<b><code>batch.write([callback])</code></b>\n\nCommit the queued operations for this batch. All operations not *cleared* will be written to the database atomically, that is, they will either all succeed or fail with no partial commits. The optional `callback` will be called when the operation has completed with an *error* argument if an error has occurred; if no `callback` is supplied and an error occurs then this method will `throw` a `WriteError`.\n\n\n--------------------------------------------------------\n<a name=\"isOpen\"></a>\n### db.isOpen()\n\nA LevelUP object can be in one of the following states:\n\n  * *\"new\"*     - newly created, not opened or closed\n  * *\"opening\"* - waiting for the database to be opened\n  * *\"open\"*    - successfully opened the database, available for use\n  * *\"closing\"* - waiting for the database to be closed\n  * *\"closed\"*  - database has been successfully closed, should not be used\n\n`isOpen()` will return `true` only when the state is \"open\".\n\n--------------------------------------------------------\n<a name=\"isClosed\"></a>\n### db.isClosed()\n\n*See <a href=\"#put\"><code>isOpen()</code></a>*\n\n`isClosed()` will return `true` only when the state is \"closing\" *or* \"closed\", it can be useful for determining if read and write operations are permissible.\n\n--------------------------------------------------------\n<a name=\"createReadStream\"></a>\n### db.createReadStream([options])\n\nYou can obtain a **ReadStream** of the full database by calling the `createReadStream()` method. The resulting stream is a complete Node.js-style [Readable Stream](http://nodejs.org/docs/latest/api/stream.html#stream_readable_stream) where `'data'` events emit objects with `'key'` and `'value'` pairs.\n\n```js\ndb.createReadStream()\n  .on('data', function (data) {\n    console.log(data.key, '=', data.value)\n  })\n  .on('error', function (err) {\n    console.log('Oh my!', err)\n  })\n  .on('close', function () {\n    console.log('Stream closed')\n  })\n  .on('end', function () {\n    console.log('Stream closed')\n  })\n```\n\nThe standard `pause()`, `resume()` and `destroy()` methods are implemented on the ReadStream, as is `pipe()` (see below). `'data'`, '`error'`, `'end'` and `'close'` events are emitted.\n\nAdditionally, you can supply an options object as the first parameter to `createReadStream()` with the following options:\n\n* `'start'`: the key you wish to start the read at. By default it will start at the beginning of the store. Note that the *start* doesn't have to be an actual key that exists, LevelDB will simply find the *next* key, greater than the key you provide.\n\n* `'end'`: the key you wish to end the read on. By default it will continue until the end of the store. Again, the *end* doesn't have to be an actual key as an (inclusive) `<=`-type operation is performed to detect the end. You can also use the `destroy()` method instead of supplying an `'end'` parameter to achieve the same effect.\n\n* `'reverse'` *(boolean, default: `false`)*: a boolean, set to true if you want the stream to go in reverse order. Beware that due to the way LevelDB works, a reverse seek will be slower than a forward seek.\n\n* `'keys'` *(boolean, default: `true`)*: whether the `'data'` event should contain keys. If set to `true` and `'values'` set to `false` then `'data'` events will simply be keys, rather than objects with a `'key'` property. Used internally by the `createKeyStream()` method.\n\n* `'values'` *(boolean, default: `true`)*: whether the `'data'` event should contain values. If set to `true` and `'keys'` set to `false` then `'data'` events will simply be values, rather than objects with a `'value'` property. Used internally by the `createValueStream()` method.\n\n* `'limit'` *(number, default: `-1`)*: limit the number of results collected by this stream. This number represents a *maximum* number of results and may not be reached if you get to the end of the store or your `'end'` value first. A value of `-1` means there is no limit.\n\n* `'fillCache'` *(boolean, default: `false`)*: wheather LevelDB's LRU-cache should be filled with data read.\n\n* `'keyEncoding'` / `'valueEncoding'` *(string)*: the encoding applied to each read piece of data.\n\n--------------------------------------------------------\n<a name=\"createKeyStream\"></a>\n### db.createKeyStream([options])\n\nA **KeyStream** is a **ReadStream** where the `'data'` events are simply the keys from the database so it can be used like a traditional stream rather than an object stream.\n\nYou can obtain a KeyStream either by calling the `createKeyStream()` method on a LevelUP object or by passing passing an options object to `createReadStream()` with `keys` set to `true` and `values` set to `false`.\n\n```js\ndb.createKeyStream()\n  .on('data', function (data) {\n    console.log('key=', data)\n  })\n\n// same as:\ndb.createReadStream({ keys: true, values: false })\n  .on('data', function (data) {\n    console.log('key=', data)\n  })\n```\n\n--------------------------------------------------------\n<a name=\"createValueStream\"></a>\n### db.createValueStream([options])\n\nA **ValueStream** is a **ReadStream** where the `'data'` events are simply the values from the database so it can be used like a traditional stream rather than an object stream.\n\nYou can obtain a ValueStream either by calling the `createValueStream()` method on a LevelUP object or by passing passing an options object to `createReadStream()` with `values` set to `true` and `keys` set to `false`.\n\n```js\ndb.createValueStream()\n  .on('data', function (data) {\n    console.log('value=', data)\n  })\n\n// same as:\ndb.createReadStream({ keys: false, values: true })\n  .on('data', function (data) {\n    console.log('value=', data)\n  })\n```\n\n--------------------------------------------------------\n<a name=\"createWriteStream\"></a>\n### db.createWriteStream([options])\n\nA **WriteStream** can be obtained by calling the `createWriteStream()` method. The resulting stream is a complete Node.js-style [Writable Stream](http://nodejs.org/docs/latest/api/stream.html#stream_writable_stream) which accepts objects with `'key'` and `'value'` pairs on its `write()` method.\n\nThe WriteStream will buffer writes and submit them as a `batch()` operations where writes occur *within the same tick*.\n\n```js\nvar ws = db.createWriteStream()\n\nws.on('error', function (err) {\n  console.log('Oh my!', err)\n})\nws.on('close', function () {\n  console.log('Stream closed')\n})\n\nws.write({ key: 'name', value: 'Yuri Irsenovich Kim' })\nws.write({ key: 'dob', value: '16 February 1941' })\nws.write({ key: 'spouse', value: 'Kim Young-sook' })\nws.write({ key: 'occupation', value: 'Clown' })\nws.end()\n```\n\nThe standard `write()`, `end()`, `destroy()` and `destroySoon()` methods are implemented on the WriteStream. `'drain'`, `'error'`, `'close'` and `'pipe'` events are emitted.\n\nYou can specify encodings both for the whole stream and individual entries:\n\nTo set the encoding for the whole stream, provide an options object as the first parameter to `createWriteStream()` with `'keyEncoding'` and/or `'valueEncoding'`.\n\nTo set the encoding for an individual entry:\n\n```js\nwriteStream.write({\n    key           : new Buffer([1, 2, 3])\n  , value         : { some: 'json' }\n  , keyEncoding   : 'binary'\n  , valueEncoding : 'json'\n})\n```\n\n#### write({ type: 'put' })\n\nIf individual `write()` operations are performed with a `'type'` property of `'del'`, they will be passed on as `'del'` operations to the batch.\n\n```js\nvar ws = db.createWriteStream()\n\nws.on('error', function (err) {\n  console.log('Oh my!', err)\n})\nws.on('close', function () {\n  console.log('Stream closed')\n})\n\nws.write({ type: 'del', key: 'name' })\nws.write({ type: 'del', key: 'dob' })\nws.write({ type: 'put', key: 'spouse' })\nws.write({ type: 'del', key: 'occupation' })\nws.end()\n```\n\n#### db.createWriteStream({ type: 'del' })\n\nIf the *WriteStream* is created with a `'type'` option of `'del'`, all `write()` operations will be interpreted as `'del'`, unless explicitly specified as `'put'`.\n\n```js\nvar ws = db.createWriteStream({ type: 'del' })\n\nws.on('error', function (err) {\n  console.log('Oh my!', err)\n})\nws.on('close', function () {\n  console.log('Stream closed')\n})\n\nws.write({ key: 'name' })\nws.write({ key: 'dob' })\n// but it can be overridden\nws.write({ type: 'put', key: 'spouse', value: 'Ri Sol-ju' })\nws.write({ key: 'occupation' })\nws.end()\n```\n\n#### Pipes and Node Stream compatibility\n\nA ReadStream can be piped directly to a WriteStream, allowing for easy copying of an entire database. A simple `copy()` operation is included in LevelUP that performs exactly this on two open databases:\n\n```js\nfunction copy (srcdb, dstdb, callback) {\n  srcdb.createReadStream().pipe(dstdb.createWriteStream()).on('close', callback)\n}\n```\n\nThe ReadStream is also [fstream](https://github.com/isaacs/fstream)-compatible which means you should be able to pipe to and from fstreams. So you can serialize and deserialize an entire database to a directory where keys are filenames and values are their contents, or even into a *tar* file using [node-tar](https://github.com/isaacs/node-tar). See the [fstream functional test](https://github.com/rvagg/node-levelup/blob/master/test/functional/fstream-test.js) for an example. *(Note: I'm not really sure there's a great use-case for this but it's a fun example and it helps to harden the stream implementations.)*\n\nKeyStreams and ValueStreams can be treated like standard streams of raw data. If `'keyEncoding'` or `'valueEncoding'` is set to `'binary'` the `'data'` events will simply be standard Node `Buffer` objects straight out of the data store.\n\n\n--------------------------------------------------------\n<a name='approximateSize'></a>\n### db.db.approximateSize(start, end, callback)\n<code>approximateSize()</code> can used to get the approximate number of bytes of file system space used by the range `[start..end)`. The result may not include recently written data.\n\n```js\nvar db = require('level')('./huge.db')\n\ndb.db.approximateSize('a', 'c', function (err, size) {\n  if (err) return console.error('Ooops!', err)\n  console.log('Approximate size of range is %d', size)\n})\n```\n\n**Note:** `approximateSize()` is available via [LevelDOWN](https://github.com/rvagg/node-leveldown/), which by default is accessible as the `db` property of your LevelUP instance. This is a specific LevelDB operation and is not likely to be available where you replace LevelDOWN with an alternative back-end via the `'db'` option.\n\n\n--------------------------------------------------------\n<a name='getProperty'></a>\n### db.db.getProperty(property)\n<code>getProperty</code> can be used to get internal details from LevelDB. When issued with a valid property string, a readable string will be returned (this method is synchronous).\n\nCurrently, the only valid properties are:\n\n* <b><code>'leveldb.num-files-at-levelN'</code></b>: returns the number of files at level *N*, where N is an integer representing a valid level (e.g. \"0\").\n\n* <b><code>'leveldb.stats'</code></b>: returns a multi-line string describing statistics about LevelDB's internal operation.\n\n* <b><code>'leveldb.sstables'</code></b>: returns a multi-line string describing all of the *sstables* that make up contents of the current database.\n\n\n```js\nvar db = require('level')('./huge.db')\nconsole.log(db.db.getProperty('leveldb.num-files-at-level3'))\n// → '243'\n```\n\n**Note:** `getProperty()` is available via [LevelDOWN](https://github.com/rvagg/node-leveldown/), which by default is accessible as the `db` property of your LevelUP instance. This is a specific LevelDB operation and is not likely to be available where you replace LevelDOWN with an alternative back-end via the `'db'` option.\n\n\n--------------------------------------------------------\n<a name=\"destroy\"></a>\n### leveldown.destroy(location, callback)\n<code>destroy()</code> is used to completely remove an existing LevelDB database directory. You can use this function in place of a full directory *rm* if you want to be sure to only remove LevelDB-related files. If the directory only contains LevelDB files, the directory itself will be removed as well. If there are additional, non-LevelDB files in the directory, those files, and the directory, will be left alone.\n\nThe callback will be called when the destroy operation is complete, with a possible `error` argument.\n\n**Note:** `destroy()` is available via [LevelDOWN](https://github.com/rvagg/node-leveldown/) which you will have to have available to `require()`, e.g.:\n\n```js\nrequire('leveldown').destroy('./huge.db', function () { console.log('done!') })\n```\n\n--------------------------------------------------------\n<a name=\"repair\"></a>\n### leveldown.repair(location, callback)\n<code>repair()</code> can be used to attempt a restoration of a damaged LevelDB store. From the LevelDB documentation:\n\n> If a DB cannot be opened, you may attempt to call this method to resurrect as much of the contents of the database as possible. Some data may be lost, so be careful when calling this function on a database that contains important information.\n\nYou will find information on the *repair* operation in the *LOG* file inside the store directory. \n\nA `repair()` can also be used to perform a compaction of the LevelDB log into table files.\n\nThe callback will be called when the repair operation is complete, with a possible `error` argument.\n\n**Note:** `destroy()` is available via [LevelDOWN](https://github.com/rvagg/node-leveldown/) which you will have to have available to `require()`, e.g.:\n\n```js\nrequire('leveldown').repair('./huge.db', function () { console.log('done!') })\n```\n\n--------------------------------------------------------\n\n<a name=\"events\"></a>\nEvents\n------\n\nLevelUP emits events when the callbacks to the corresponding methods are called.\n\n* `db.emit('put', key, value)` emitted when a new value is `'put'`\n* `db.emit('del', key)` emitted when a value is deleted\n* `db.emit('batch', ary)` emitted when a batch operation has executed\n* `db.emit('ready')` emitted when the database has opened (`'open'` is synonym)\n* `db.emit('closed')` emitted when the database has closed\n* `db.emit('opening')` emitted when the database is opening\n* `db.emit('closing')` emitted when the database is closing\n\nIf you do not pass a callback to an async function, and there is an error, LevelUP will `emit('error', err)` instead.\n\n<a name=\"json\"></a>\nJSON data\n---------\n\nYou specify `'json'` encoding for both keys and/or values, you can then supply JavaScript objects to LevelUP and receive them from all fetch operations, including ReadStreams. LevelUP will automatically *stringify* your objects and store them as *utf8* and parse the strings back into objects before passing them back to you.\n\n<a name=\"custom_encodings\"></a>\nCustom encodings\n----------------\n\nA custom encoding may be provided by passing in an object as an value for `keyEncoding` or `valueEncoding` (wherever accepted), it must have the following properties:\n\n```js\n{\n    encode : function (val) { ... }\n  , decode : function (val) { ... }\n  , buffer : boolean // encode returns a buffer-like and decode accepts a buffer\n  , type   : String  // name of this encoding type.\n}\n```\n\n*\"buffer-like\"* means either a `Buffer` if running in Node, or a Uint8Array if in a browser. Use [bops](https://github.com/chrisdickinson/bops) to get portable binary operations.\n\n<a name=\"extending\"></a>\nExtending LevelUP\n-----------------\n\nA list of <a href=\"https://github.com/rvagg/node-levelup/wiki/Modules\"><b>Node.js LevelDB modules and projects</b></a> can be found in the wiki.\n\nWhen attempting to extend the functionality of LevelUP, it is recommended that you consider using [level-hooks](https://github.com/dominictarr/level-hooks) and/or [level-sublevel](https://github.com/dominictarr/level-sublevel). **level-sublevel** is particularly helpful for keeping additional, extension-specific, data in a LevelDB store. It allows you to partition a LevelUP instance into multiple sub-instances that each correspond to discrete namespaced key ranges.\n\n<a name=\"multiproc\"></a>\nMulti-process access\n--------------------\n\nLevelDB is thread-safe but is **not** suitable for accessing with multiple processes. You should only ever have a LevelDB database open from a single Node.js process. Node.js clusters are made up of multiple processes so a LevelUP instance cannot be shared between them either.\n\nSee the <a href=\"https://github.com/rvagg/node-levelup/wiki/Modules\"><b>wiki</b></a> for some LevelUP extensions, including [multilevel](https://github.com/juliangruber/multilevel), that may help if you require a single data store to be shared across processes.\n\n<a name=\"support\"></a>\nGetting support\n---------------\n\nThere are multiple ways you can find help in using LevelDB in Node.js:\n\n * **IRC:** you'll find an active group of LevelUP users in the **##leveldb** channel on Freenode, including most of the contributors to this project.\n * **Mailing list:** there is an active [Node.js LevelDB](https://groups.google.com/forum/#!forum/node-levelup) Google Group.\n * **GitHub:** you're welcome to open an issue here on this GitHub repository if you have a question.\n\n<a name=\"contributing\"></a>\nContributing\n------------\n\nLevelUP is an **OPEN Open Source Project**. This means that:\n\n> Individuals making significant and valuable contributions are given commit-access to the project to contribute as they see fit. This project is more like an open wiki than a standard guarded open source project.\n\nSee the [CONTRIBUTING.md](https://github.com/rvagg/node-levelup/blob/master/CONTRIBUTING.md) file for more details.\n\n### Contributors\n\nLevelUP is only possible due to the excellent work of the following contributors:\n\n<table><tbody>\n<tr><th align=\"left\">Rod Vagg</th><td><a href=\"https://github.com/rvagg\">GitHub/rvagg</a></td><td><a href=\"http://twitter.com/rvagg\">Twitter/@rvagg</a></td></tr>\n<tr><th align=\"left\">John Chesley</th><td><a href=\"https://github.com/chesles/\">GitHub/chesles</a></td><td><a href=\"http://twitter.com/chesles\">Twitter/@chesles</a></td></tr>\n<tr><th align=\"left\">Jake Verbaten</th><td><a href=\"https://github.com/raynos\">GitHub/raynos</a></td><td><a href=\"http://twitter.com/raynos2\">Twitter/@raynos2</a></td></tr>\n<tr><th align=\"left\">Dominic Tarr</th><td><a href=\"https://github.com/dominictarr\">GitHub/dominictarr</a></td><td><a href=\"http://twitter.com/dominictarr\">Twitter/@dominictarr</a></td></tr>\n<tr><th align=\"left\">Max Ogden</th><td><a href=\"https://github.com/maxogden\">GitHub/maxogden</a></td><td><a href=\"http://twitter.com/maxogden\">Twitter/@maxogden</a></td></tr>\n<tr><th align=\"left\">Lars-Magnus Skog</th><td><a href=\"https://github.com/ralphtheninja\">GitHub/ralphtheninja</a></td><td><a href=\"http://twitter.com/ralphtheninja\">Twitter/@ralphtheninja</a></td></tr>\n<tr><th align=\"left\">David Björklund</th><td><a href=\"https://github.com/kesla\">GitHub/kesla</a></td><td><a href=\"http://twitter.com/david_bjorklund\">Twitter/@david_bjorklund</a></td></tr>\n<tr><th align=\"left\">Julian Gruber</th><td><a href=\"https://github.com/juliangruber\">GitHub/juliangruber</a></td><td><a href=\"http://twitter.com/juliangruber\">Twitter/@juliangruber</a></td></tr>\n<tr><th align=\"left\">Paolo Fragomeni</th><td><a href=\"https://github.com/hij1nx\">GitHub/hij1nx</a></td><td><a href=\"http://twitter.com/hij1nx\">Twitter/@hij1nx</a></td></tr>\n<tr><th align=\"left\">Anton Whalley</th><td><a href=\"https://github.com/No9\">GitHub/No9</a></td><td><a href=\"https://twitter.com/antonwhalley\">Twitter/@antonwhalley</a></td></tr>\n<tr><th align=\"left\">Matteo Collina</th><td><a href=\"https://github.com/mcollina\">GitHub/mcollina</a></td><td><a href=\"https://twitter.com/matteocollina\">Twitter/@matteocollina</a></td></tr>\n<tr><th align=\"left\">Pedro Teixeira</th><td><a href=\"https://github.com/pgte\">GitHub/pgte</a></td><td><a href=\"https://twitter.com/pgte\">Twitter/@pgte</a></td></tr>\n<tr><th align=\"left\">James Halliday</th><td><a href=\"https://github.com/substack\">GitHub/substack</a></td><td><a href=\"https://twitter.com/substack\">Twitter/@substack</a></td></tr>\n</tbody></table>\n\n### Windows\n\nA large portion of the Windows support comes from code by [Krzysztof Kowalczyk](http://blog.kowalczyk.info/) [@kjk](https://twitter.com/kjk), see his Windows LevelDB port [here](http://code.google.com/r/kkowalczyk-leveldb/). If you're using LevelUP on Windows, you should give him your thanks!\n\n\n<a name=\"licence\"></a>\nLicence &amp; copyright\n-------------------\n\nCopyright (c) 2012-2013 LevelUP contributors (listed above).\n\nLevelUP is licensed under an MIT +no-false-attribs license. All rights not explicitly granted in the MIT license are reserved. See the included LICENSE file for more details.\n\n=======\n*LevelUP builds on the excellent work of the LevelDB and Snappy teams from Google and additional contributors. LevelDB and Snappy are both issued under the [New BSD Licence](http://opensource.org/licenses/BSD-3-Clause).*\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/rvagg/node-levelup/issues"
  },
  "_id": "levelup@0.18.2",
  "_from": "levelup@*"
}

},{}],105:[function(require,module,exports){
var process=require("__browserify_process");var util              = require('util')
  , bops              = require('bops')
  , AbstractLevelDOWN = require('abstract-leveldown').AbstractLevelDOWN
  , AbstractIterator  = require('abstract-leveldown').AbstractIterator
  , noop              = function () {}
  , setImmediate      = process.nextTick

function toKey (key) {
  return typeof key == 'string' ? '$' + key : JSON.stringify(key)
}

function sortedIndexOf (arr, item) {
  var low = 0, high = arr.length, mid
  while (low < high) {
    mid = (low + high) >>> 1
    arr[mid] < item ? low = mid + 1 : high = mid
  }
  return low
}

function MemIterator (db, options) {
  AbstractIterator.call(this, db)
  this._reverse = options.reverse
  this._limit   = options.limit
  this._count   = 0
  this._end     = options.end
  this._start   = options.start
  this._gt      = options.gt
  this._gte     = options.gte
  this._lt      = options.lt
  this._lte     = options.lte

  var i

  if (this._start) {
    for (i = 0; i < this.db._keys.length; i++) {
      if (this.db._keys[i] >= this._start) {
        this._pos = i
        if (this.db._keys[i] != this._start) {
          if (this._reverse) {
            // going backwards and key doesn't match, jump back one
            --this._pos
          }
        } else {
          if (options.exclusiveStart) {
            // key matches but it's a gt or lt
            this._pos += (this._reverse ? -1 : 1)
          }
        }
        break
      }
    }

    if (this._pos == null && !this._reverse) // no matching keys, non starter
      this._pos = -1
  }

  if (!options.start || !this._pos)
    this._pos = this._reverse ? this.db._keys.length - 1 : 0
}

util.inherits(MemIterator, AbstractIterator)

MemIterator.prototype._next = function (callback) {
  var self  = this
    , key   = self.db._keys[self._pos]
    , value

  if (self._pos >= self.db._keys.length || self._pos < 0)
    return setImmediate(callback)

  if (!!self._end && (self._reverse ? key < self._end : key > self._end))
    return setImmediate(callback)


  if (!!self._limit && self._limit > 0 && self._count++ >= self._limit)
    return setImmediate(callback)

  if (  (this._lt  && key >= this._lt)
     || (this._lte && key > this._lte)
     || (this._gt  && key <= this._gt)
     || (this._gte && key < this._gte))
    return setImmediate(callback)

  value = self.db._store[toKey(key)]
  self._pos += self._reverse ? -1 : 1

  setImmediate(function () { callback(null, key, value) })
}

function MemDOWN (location) {
  if (!(this instanceof MemDOWN))
    return new MemDOWN(location)

  AbstractLevelDOWN.call(this, typeof location == 'string' ? location : '')
  this._store = {}
  this._keys  = []
}

util.inherits(MemDOWN, AbstractLevelDOWN)

MemDOWN.prototype._open = function (options, callback) {
  var self = this
  setImmediate(function () { callback(null, self) })
}

MemDOWN.prototype._put = function (key, value, options, callback) {
  var ix = sortedIndexOf(this._keys, key)
  if (this._keys[ix] != key)
    this._keys.splice(ix, 0, key)
  key = toKey(key) // safety, to avoid key='__proto__'-type skullduggery 
  this._store[key] = value
  setImmediate(callback)
}

MemDOWN.prototype._get = function (key, options, callback) {
  var value = this._store[toKey(key)]
  if (value === undefined) {
    // 'NotFound' error, consistent with LevelDOWN API
    return setImmediate(function () { callback(new Error('NotFound')) })
  }
  if (options.asBuffer !== false && !bops.is(value))
    value = bops.from(String(value))
  setImmediate(function () {
    callback(null, value)
  })
}

MemDOWN.prototype._del = function (key, options, callback) {
  var ix = sortedIndexOf(this._keys, key)
  if (this._keys[ix] == key)
    this._keys.splice(ix, 1)
  delete this._store[toKey(key)]
  setImmediate(callback)
}

MemDOWN.prototype._batch = function (array, options, callback) {
  var err
    , i = 0
    , key
    , value

  if (Array.isArray(array)) {
    for (; i < array.length; i++) {
      if (array[i]) {
        key = bops.is(array[i].key) ? array[i].key : String(array[i].key)
        err = this._checkKeyValue(key, 'key')
        if (err) return setImmediate(function () { callback(err) })
        if (array[i].type === 'del') {
          this._del(array[i].key, options, noop)
        } else if (array[i].type === 'put') {
          value = bops.is(array[i].value) ? array[i].value : String(array[i].value)
          err = this._checkKeyValue(value, 'value')
          if (err) return setImmediate(function () { callback(err) })
          this._put(key, value, options, noop)
        }
      }
    }
  }
  setImmediate(callback)
}

MemDOWN.prototype._iterator = function (options) {
  return new MemIterator(this, options)
}

MemDOWN.prototype._isBuffer = function (obj) {
  return bops.is(obj)
}

module.exports = MemDOWN

},{"__browserify_process":160,"abstract-leveldown":108,"bops":115,"util":173}],106:[function(require,module,exports){
module.exports=require(72)
},{"__browserify_process":160}],107:[function(require,module,exports){
module.exports=require(73)
},{"__browserify_process":160}],108:[function(require,module,exports){
var process=require("__browserify_process"),Buffer=require("__browserify_Buffer");/* Copyright (c) 2013 Rod Vagg, MIT License */

var xtend                = require('xtend')
  , AbstractIterator     = require('./abstract-iterator')
  , AbstractChainedBatch = require('./abstract-chained-batch')

function AbstractLevelDOWN (location) {
  if (!arguments.length || location === undefined)
    throw new Error('constructor requires at least a location argument')

  if (typeof location != 'string')
    throw new Error('constructor requires a location string argument')

  this.location = location
}

AbstractLevelDOWN.prototype.open = function (options, callback) {
  if (typeof options == 'function')
    callback = options

  if (typeof callback != 'function')
    throw new Error('open() requires a callback argument')

  if (typeof options != 'object')
    options = {}

  if (typeof this._open == 'function')
    return this._open(options, callback)

  process.nextTick(callback)
}

AbstractLevelDOWN.prototype.close = function (callback) {
  if (typeof callback != 'function')
    throw new Error('close() requires a callback argument')

  if (typeof this._close == 'function')
    return this._close(callback)

  process.nextTick(callback)
}

AbstractLevelDOWN.prototype.get = function (key, options, callback) {
  var err

  if (typeof options == 'function')
    callback = options

  if (typeof callback != 'function')
    throw new Error('get() requires a callback argument')

  if (err = this._checkKeyValue(key, 'key', this._isBuffer))
    return callback(err)

  if (!this._isBuffer(key))
    key = String(key)

  if (typeof options != 'object')
    options = {}

  if (typeof this._get == 'function')
    return this._get(key, options, callback)

  process.nextTick(function () { callback(new Error('NotFound')) })
}

AbstractLevelDOWN.prototype.put = function (key, value, options, callback) {
  var err

  if (typeof options == 'function')
    callback = options

  if (typeof callback != 'function')
    throw new Error('put() requires a callback argument')

  if (err = this._checkKeyValue(key, 'key', this._isBuffer))
    return callback(err)

  if (err = this._checkKeyValue(value, 'value', this._isBuffer))
    return callback(err)

  if (!this._isBuffer(key))
    key = String(key)

  // coerce value to string in node, don't touch it in browser
  // (indexeddb can store any JS type)
  if (!this._isBuffer(value) && !process.browser)
    value = String(value)

  if (typeof options != 'object')
    options = {}

  if (typeof this._put == 'function')
    return this._put(key, value, options, callback)

  process.nextTick(callback)
}

AbstractLevelDOWN.prototype.del = function (key, options, callback) {
  var err

  if (typeof options == 'function')
    callback = options

  if (typeof callback != 'function')
    throw new Error('del() requires a callback argument')

  if (err = this._checkKeyValue(key, 'key', this._isBuffer))
    return callback(err)

  if (!this._isBuffer(key))
    key = String(key)

  if (typeof options != 'object')
    options = {}

  if (typeof this._del == 'function')
    return this._del(key, options, callback)

  process.nextTick(callback)
}

AbstractLevelDOWN.prototype.batch = function (array, options, callback) {
  if (!arguments.length)
    return this._chainedBatch()

  if (typeof options == 'function')
    callback = options

  if (typeof callback != 'function')
    throw new Error('batch(array) requires a callback argument')

  if (!Array.isArray(array))
    return callback(new Error('batch(array) requires an array argument'))

  if (typeof options != 'object')
    options = {}

  var i = 0
    , l = array.length
    , e
    , err

  for (; i < l; i++) {
    e = array[i]
    if (typeof e != 'object')
      continue

    if (err = this._checkKeyValue(e.type, 'type', this._isBuffer))
      return callback(err)

    if (err = this._checkKeyValue(e.key, 'key', this._isBuffer))
      return callback(err)

    if (e.type == 'put') {
      if (err = this._checkKeyValue(e.value, 'value', this._isBuffer))
        return callback(err)
    }
  }

  if (typeof this._batch == 'function')
    return this._batch(array, options, callback)

  process.nextTick(callback)
}

//TODO: remove from here, not a necessary primitive
AbstractLevelDOWN.prototype.approximateSize = function (start, end, callback) {
  if (   start == null
      || end == null
      || typeof start == 'function'
      || typeof end == 'function') {
    throw new Error('approximateSize() requires valid `start`, `end` and `callback` arguments')
  }

  if (typeof callback != 'function')
    throw new Error('approximateSize() requires a callback argument')

  if (!this._isBuffer(start))
    start = String(start)

  if (!this._isBuffer(end))
    end = String(end)

  if (typeof this._approximateSize == 'function')
    return this._approximateSize(start, end, callback)

  process.nextTick(function () {
    callback(null, 0)
  })
}

AbstractLevelDOWN.prototype._setupIteratorOptions = function (options) {
  var self = this

  options = xtend(options)

  ;[ 'start', 'end', 'gt', 'gte', 'lt', 'lte' ].forEach(function (o) {
    if (options[o] && self._isBuffer(options[o]) && options[o].length === 0)
      delete options[o]
  })

  options.reverse = !!options.reverse

  // fix `start` so it takes into account gt, gte, lt, lte as appropriate
  if (options.reverse && options.lt)
    options.start = options.lt
  if (options.reverse && options.lte)
    options.start = options.lte
  if (!options.reverse && options.gt)
    options.start = options.gt
  if (!options.reverse && options.gte)
    options.start = options.gte

  if ((options.reverse && options.lt && !options.lte)
    || (!options.reverse && options.gt && !options.gte))
    options.exclusiveStart = true // start should *not* include matching key

  return options
}

AbstractLevelDOWN.prototype.iterator = function (options) {
  if (typeof options != 'object')
    options = {}

  options = this._setupIteratorOptions(options)

  if (typeof this._iterator == 'function')
    return this._iterator(options)

  return new AbstractIterator(this)
}

AbstractLevelDOWN.prototype._chainedBatch = function () {
  return new AbstractChainedBatch(this)
}

AbstractLevelDOWN.prototype._isBuffer = function (obj) {
  return Buffer.isBuffer(obj)
}

AbstractLevelDOWN.prototype._checkKeyValue = function (obj, type) {
  if (obj === null || obj === undefined)
    return new Error(type + ' cannot be `null` or `undefined`')

  if (obj === null || obj === undefined)
    return new Error(type + ' cannot be `null` or `undefined`')

  if (this._isBuffer(obj)) {
    if (obj.length === 0)
      return new Error(type + ' cannot be an empty Buffer')
  } else if (String(obj) === '')
    return new Error(type + ' cannot be an empty String')
}

module.exports.AbstractLevelDOWN    = AbstractLevelDOWN
module.exports.AbstractIterator     = AbstractIterator
module.exports.AbstractChainedBatch = AbstractChainedBatch

},{"./abstract-chained-batch":106,"./abstract-iterator":107,"__browserify_Buffer":159,"__browserify_process":160,"xtend":110}],109:[function(require,module,exports){
module.exports=require(34)
},{}],110:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"./has-keys":109,"object-keys":112}],111:[function(require,module,exports){
module.exports=require(47)
},{}],112:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"./shim":114}],113:[function(require,module,exports){
module.exports=require(49)
},{}],114:[function(require,module,exports){
module.exports=require(50)
},{"./foreach":111,"./isArguments":113}],115:[function(require,module,exports){
arguments[4][57][0].apply(exports,arguments)
},{"./copy.js":118,"./create.js":119,"./from.js":120,"./is.js":121,"./join.js":122,"./read.js":124,"./subarray.js":125,"./to.js":126,"./write.js":127}],116:[function(require,module,exports){
module.exports=require(58)
},{}],117:[function(require,module,exports){
module.exports=require(59)
},{}],118:[function(require,module,exports){
module.exports=require(60)
},{}],119:[function(require,module,exports){
module.exports=require(61)
},{}],120:[function(require,module,exports){
module.exports=require(62)
},{"base64-js":116}],121:[function(require,module,exports){
module.exports=require(63)
},{}],122:[function(require,module,exports){
module.exports=require(64)
},{}],123:[function(require,module,exports){
module.exports=require(65)
},{}],124:[function(require,module,exports){
module.exports=require(66)
},{"./mapped.js":123}],125:[function(require,module,exports){
module.exports=require(67)
},{}],126:[function(require,module,exports){
module.exports=require(68)
},{"base64-js":116,"to-utf8":117}],127:[function(require,module,exports){
module.exports=require(69)
},{"./mapped.js":123}],128:[function(require,module,exports){
var Buffer=require("__browserify_Buffer");/**
 * Copyright (C) 2013 Regents of the University of California.
 * @author: Wentao Shang
 * See COPYING for copyright and distribution information.
 */

// Library namespace
var ndn = ndn || {};

var exports = ndn;


// Factory method to create node.js compatible ndnbuf objects
var ndnbuf = function ndnbuf(data, format)
{
  var obj;

  if (typeof data == 'number')
    obj = new Uint8Array(data);
  else if (typeof data == 'string') {
    if (format == null || format == 'utf8') {
      var utf8 = ndnbuf.str2rstr_utf8(data);
      obj = new Uint8Array(utf8.length);
      for (var i = 0; i < utf8.length; i++)
        obj[i] = utf8.charCodeAt(i);
    }
    else if (format == 'binary') {
      obj = new Uint8Array(data.length);
      for (var i = 0; i < data.length; i++)
        obj[i] = data.charCodeAt(i);
    }
    else if (format == 'hex') {
      obj = new Uint8Array(Math.floor(data.length / 2));
      var i = 0;
      data.replace(/(..)/g, function(ss) {
        obj[i++] = parseInt(ss, 16);
      });
    }
    else if (format == 'base64') {
      var hex = b64tohex(data);
      obj = new Uint8Array(Math.floor(hex.length / 2));
      var i = 0;
      hex.replace(/(..)/g, function(ss) {
        obj[i++] = parseInt(ss, 16);
      });
    }
    else
      throw new Error('Buffer: unknown encoding format ' + format);
  }
  else if (typeof data == 'object' && (data instanceof Uint8Array || data instanceof ndnbuf)) {
    // The second argument is a boolean for "copy", default true.
    if (format == false)
      obj = data.subarray(0);
    else
      obj = new Uint8Array(data);
  }
  else if (typeof data == 'object' && data instanceof ArrayBuffer)
    // Copy.
    obj = new Uint8Array(data);
  else if (typeof data == 'object')
    // Assume component is a byte array.  We can't check instanceof Array because
    //   this doesn't work in JavaScript if the array comes from a different module.
    obj = new Uint8Array(data);
  else
    throw new Error('Buffer: unknown data type.');

  try {
    obj.__proto__ = ndnbuf.prototype;
  } catch(ex) {
    throw new Error("Buffer: Set obj.__proto__ exception: " + ex);
  }

  obj.__proto__.toString = function(encoding) {
    if (encoding == null) {
      var ret = "";
      for (var i = 0; i < this.length; i++)
        ret += String.fromCharCode(this[i]);
      return ret;
    }

    var ret = "";
    for (var i = 0; i < this.length; i++)
      ret += (this[i] < 16 ? "0" : "") + this[i].toString(16);

    if (encoding == 'hex')
      return ret;
    else if (encoding == 'base64')
      return hex2b64(ret);
    else
      throw new Error('ndnbuf.toString: unknown encoding format ' + encoding);
  };

  obj.__proto__.slice = function(begin, end) {
    if (end !== undefined)
      return new ndnbuf(this.subarray(begin, end), false);
    else
      return new ndnbuf(this.subarray(begin), false);
  };

  obj.__proto__.copy = function(target, targetStart) {
    if (targetStart !== undefined)
      target.set(this, targetStart);
    else
      target.set(this);
  };

  return obj;
};

ndnbuf.prototype = Uint8Array.prototype;

ndnbuf.concat = function(arrays)
{
  var totalLength = 0;
  for (var i = 0; i < arrays.length; ++i)
    totalLength += arrays[i].length;

  var result = new ndnbuf(totalLength);
  var offset = 0;
  for (var i = 0; i < arrays.length; ++i) {
    result.set(arrays[i], offset);
    offset += arrays[i].length;
  }
  return result;
};

ndnbuf.str2rstr_utf8 = function(input)
{
  var output = "";
  var i = -1;
  var x, y;

  while (++i < input.length)
  {
    // Decode utf-16 surrogate pairs
    x = input.charCodeAt(i);
    y = i + 1 < input.length ? input.charCodeAt(i + 1) : 0;
    if (0xD800 <= x && x <= 0xDBFF && 0xDC00 <= y && y <= 0xDFFF)
    {
      x = 0x10000 + ((x & 0x03FF) << 10) + (y & 0x03FF);
      i++;
    }

    // Encode output as utf-8
    if (x <= 0x7F)
      output += String.fromCharCode(x);
    else if (x <= 0x7FF)
      output += String.fromCharCode(0xC0 | ((x >>> 6 ) & 0x1F),
                                    0x80 | ( x         & 0x3F));
    else if (x <= 0xFFFF)
      output += String.fromCharCode(0xE0 | ((x >>> 12) & 0x0F),
                                    0x80 | ((x >>> 6 ) & 0x3F),
                                    0x80 | ( x         & 0x3F));
    else if (x <= 0x1FFFFF)
      output += String.fromCharCode(0xF0 | ((x >>> 18) & 0x07),
                                    0x80 | ((x >>> 12) & 0x3F),
                                    0x80 | ((x >>> 6 ) & 0x3F),
                                    0x80 | ( x         & 0x3F));
  }
  return output;
};

exports.ndnbuf = ndnbuf

// Factory method to create hasher objects
ndn.createHash = function(alg)
{
  if (alg != 'sha256')
    throw new Error('createHash: unsupported algorithm.');

  var obj = {};

  obj.md = new KJUR.crypto.MessageDigest({alg: "sha256", prov: "cryptojs"});

  obj.update = function(buf) {
    this.md.updateHex(buf.toString('hex'));
  };

  obj.digest = function() {
    return new ndnbuf(this.md.digest(), 'hex');
  };

  return obj;
};

// Factory method to create RSA signer objects
ndn.createSign = function(alg)
{
  if (alg != 'RSA-SHA256')
    throw new Error('createSign: unsupported algorithm.');

  var obj = {};

  obj.arr = [];

  obj.update = function(buf) {
    this.arr.push(buf);
  };

  obj.sign = function(keypem) {
    var rsa = new RSAKey();
    rsa.readPrivateKeyFromPEMString(keypem);
    var signer = new KJUR.crypto.Signature({alg: "SHA256withRSA", prov: "cryptojs/jsrsa"});
    signer.initSign(rsa);
    for (var i = 0; i < this.arr.length; ++i)
      signer.updateHex(this.arr[i].toString('hex'));

    return new ndnbuf(signer.sign(), 'hex');
  };

  return obj;
};

// Factory method to create RSA verifier objects
ndn.createVerify = function(alg)
{
  if (alg != 'RSA-SHA256')
    throw new Error('createSign: unsupported algorithm.');

  var obj = {};

  obj.arr = [];

  obj.update = function(buf) {
    this.arr.push(buf);
  };

  var getSubjectPublicKeyPosFromHex = function(hPub) {
    var a = ASN1HEX.getPosArrayOfChildren_AtObj(hPub, 0);
    if (a.length != 2)
      return -1;
    var pBitString = a[1];
    if (hPub.substring(pBitString, pBitString + 2) != '03')
      return -1;
    var pBitStringV = ASN1HEX.getStartPosOfV_AtObj(hPub, pBitString);
    if (hPub.substring(pBitStringV, pBitStringV + 2) != '00')
      return -1;
    return pBitStringV + 2;
  };

  var readPublicDER = function(pub_der) {
    var hex = pub_der.toString('hex');
    var p = getSubjectPublicKeyPosFromHex(hex);
    var a = ASN1HEX.getPosArrayOfChildren_AtObj(hex, p);
    if (a.length != 2)
      return null;
    var hN = ASN1HEX.getHexOfV_AtObj(hex, a[0]);
    var hE = ASN1HEX.getHexOfV_AtObj(hex, a[1]);
    var rsaKey = new RSAKey();
    rsaKey.setPublic(hN, hE);
    return rsaKey;
  };

  obj.verify = function(keypem, sig) {
    var key = new ndn.Key();
    key.fromPemString(keypem);

    var rsa = readPublicDER(key.publicToDER());
    var signer = new KJUR.crypto.Signature({alg: "SHA256withRSA", prov: "cryptojs/jsrsa"});
    signer.initVerifyByPublicKey(rsa);
    for (var i = 0; i < this.arr.length; i++)
      signer.updateHex(this.arr[i].toString('hex'));
    var hSig = sig.toString('hex');
    return signer.verify(hSig);
  };

  return obj;
};
/**
 * Copyright (C) 2013 Regents of the University of California.
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 */

/**
 * The Log class holds the global static variable LOG.
 */
var Log = function Log()
{
}

exports.Log = Log;

/**
 * LOG is the level for logging debugging statements.  0 means no log messages.
 * @type Number
 */
var LOG = 0;
/**
 * Copyright (C) 2013 Regents of the University of California.
 * @author: Meki Cheraoui
 * See COPYING for copyright and distribution information.
 * This class contains all NDNx tags
 */


var NDNProtocolDTags = {

  /**
   * Note if you add one of these, add it to the reverse string map as well.
   * Emphasize getting the work done at compile time over trying to make something
   * flexible and developer error-proof.
   */

   Any : 13,
   Name : 14,
   Component : 15,
   Certificate : 16,
   Collection : 17,
   CompleteName : 18,
   Content : 19,
   SignedInfo : 20,
   ContentDigest : 21,
   ContentHash : 22,
   Count : 24,
   Header : 25,
   Interest : 26,  /* 20090915 */
   Key : 27,
   KeyLocator : 28,
   KeyName : 29,
   Length : 30,
   Link : 31,
   LinkAuthenticator : 32,
   NameComponentCount : 33,  /* DeprecatedInInterest */
   RootDigest : 36,
   Signature : 37,
   Start : 38,
   Timestamp : 39,
   Type : 40,
   Nonce : 41,
   Scope : 42,
   Exclude : 43,
   Bloom : 44,
   BloomSeed : 45,
   AnswerOriginKind : 47,
   InterestLifetime : 48,
   Witness : 53,
   SignatureBits : 54,
   DigestAlgorithm : 55,
   BlockSize : 56,
   FreshnessSeconds : 58,
   FinalBlockID : 59,
   PublisherPublicKeyDigest : 60,
   PublisherCertificateDigest : 61,
   PublisherIssuerKeyDigest : 62,
   PublisherIssuerCertificateDigest : 63,
   Data : 64,  /* 20090915 */
   WrappedKey : 65,
   WrappingKeyIdentifier : 66,
   WrapAlgorithm : 67,
   KeyAlgorithm : 68,
   Label : 69,
   EncryptedKey : 70,
   EncryptedNonceKey : 71,
   WrappingKeyName : 72,
   Action : 73,
   FaceID : 74,
   IPProto : 75,
   Host : 76,
   Port : 77,
   MulticastInterface : 78,
   ForwardingFlags : 79,
   FaceInstance : 80,
   ForwardingEntry : 81,
   MulticastTTL : 82,
   MinSuffixComponents : 83,
   MaxSuffixComponents : 84,
   ChildSelector : 85,
   RepositoryInfo : 86,
   Version : 87,
   RepositoryVersion : 88,
   GlobalPrefix : 89,
   LocalName : 90,
   Policy : 91,
   Namespace : 92,
   GlobalPrefixName : 93,
   PolicyVersion : 94,
   KeyValueSet : 95,
   KeyValuePair : 96,
   IntegerValue : 97,
   DecimalValue : 98,
   StringValue : 99,
   BinaryValue : 100,
   NameValue : 101,
   Entry : 102,
   ACL : 103,
   ParameterizedName : 104,
   Prefix : 105,
   Suffix : 106,
   Root : 107,
   ProfileName : 108,
   Parameters : 109,
   InfoString : 110,
  // 111 unallocated
   StatusResponse : 112,
   StatusCode : 113,
   StatusText : 114,

  // Sync protocol
   SyncNode : 115,
   SyncNodeKind : 116,
   SyncNodeElement : 117,
   SyncVersion : 118,
   SyncNodeElements : 119,
   SyncContentHash : 120,
   SyncLeafCount : 121,
   SyncTreeDepth : 122,
   SyncByteCount : 123,
   ConfigSlice : 124,
   ConfigSliceList : 125,
   ConfigSliceOp : 126,

  // Remember to keep in sync with schema/tagnames.csvsdict
   NDNProtocolDataUnit : 17702112,
   NDNPROTOCOL_DATA_UNIT : "NDNProtocolDataUnit"
};

exports.NDNProtocolDTags = NDNProtocolDTags;

var NDNProtocolDTagsStrings = [
  null, null, null, null, null, null, null, null, null, null, null,
  null, null,
  "Any", "Name", "Component", "Certificate", "Collection", "CompleteName",
  "Content", "SignedInfo", "ContentDigest", "ContentHash", null, "Count", "Header",
  "Interest", "Key", "KeyLocator", "KeyName", "Length", "Link", "LinkAuthenticator",
  "NameComponentCount", null, null, "RootDigest", "Signature", "Start", "Timestamp", "Type",
  "Nonce", "Scope", "Exclude", "Bloom", "BloomSeed", null, "AnswerOriginKind",
  "InterestLifetime", null, null, null, null, "Witness", "SignatureBits", "DigestAlgorithm", "BlockSize",
  null, "FreshnessSeconds", "FinalBlockID", "PublisherPublicKeyDigest", "PublisherCertificateDigest",
  "PublisherIssuerKeyDigest", "PublisherIssuerCertificateDigest", "Data",
  "WrappedKey", "WrappingKeyIdentifier", "WrapAlgorithm", "KeyAlgorithm", "Label",
  "EncryptedKey", "EncryptedNonceKey", "WrappingKeyName", "Action", "FaceID", "IPProto",
  "Host", "Port", "MulticastInterface", "ForwardingFlags", "FaceInstance",
  "ForwardingEntry", "MulticastTTL", "MinSuffixComponents", "MaxSuffixComponents", "ChildSelector",
  "RepositoryInfo", "Version", "RepositoryVersion", "GlobalPrefix", "LocalName",
  "Policy", "Namespace", "GlobalPrefixName", "PolicyVersion", "KeyValueSet", "KeyValuePair",
  "IntegerValue", "DecimalValue", "StringValue", "BinaryValue", "NameValue", "Entry",
  "ACL", "ParameterizedName", "Prefix", "Suffix", "Root", "ProfileName", "Parameters",
  "InfoString", null,
    "StatusResponse", "StatusCode", "StatusText", "SyncNode", "SyncNodeKind", "SyncNodeElement",
    "SyncVersion", "SyncNodeElements", "SyncContentHash", "SyncLeafCount", "SyncTreeDepth", "SyncByteCount",
    "ConfigSlice", "ConfigSliceList", "ConfigSliceOp" ];

exports.NDNProtocolDTagsStrings = NDNProtocolDTagsStrings;
/**
 * Copyright (C) 2013 Regents of the University of California.
 * @author: Meki Cheraoui
 * See COPYING for copyright and distribution information.
 * This class represents NDNTime Objects
 */


/**
 * @constructor
 */
var NDNTime = function NDNTime(input)
{
  this.NANOS_MAX = 999877929;

  if (typeof input =='number')
    this.msec = input;
  else {
    if (LOG > 1) console.log('UNRECOGNIZED TYPE FOR TIME');
  }
};

exports.NDNTime = NDNTime;

NDNTime.prototype.getJavascriptDate = function()
{
  var d = new Date();
  d.setTime(this.msec);
  return d
};
/**
 * Copyright (C) 2013 Regents of the University of California.
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 * This is the closure class for use in expressInterest to re express with exponential falloff.
 */


/**
 * Create a new ExponentialReExpressClosure where upcall responds to UPCALL_INTEREST_TIMED_OUT
 *   by expressing the interest again with double the interestLifetime. If the interesLifetime goes
 *   over maxInterestLifetime, then call callerClosure.upcall with UPCALL_INTEREST_TIMED_OUT.
 * When upcall is not UPCALL_INTEREST_TIMED_OUT, just call callerClosure.upcall.
 * @constructor
 * @param {Closure} callerClosure
 * @param {Object} settings if not null, an associative array with the following defaults:
 * {
 *   maxInterestLifetime: 16000 // milliseconds
 * }
 */
var ExponentialReExpressClosure = function ExponentialReExpressClosure(callerClosure, settings)
{
  // Inherit from Closure.
  Closure.call(this);

  this.callerClosure = callerClosure;
  settings = (settings || {});
  this.maxInterestLifetime = (settings.maxInterestLifetime || 16000);
};

exports.ExponentialReExpressClosure = ExponentialReExpressClosure;

/**
 * Wrap this.callerClosure to responds to UPCALL_INTEREST_TIMED_OUT
 *   by expressing the interest again as described in the constructor.
 */
ExponentialReExpressClosure.prototype.upcall = function(kind, upcallInfo)
{
  try {
    if (kind == Closure.UPCALL_INTEREST_TIMED_OUT) {
      var interestLifetime = upcallInfo.interest.interestLifetime;
      if (interestLifetime == null)
        return this.callerClosure.upcall(Closure.UPCALL_INTEREST_TIMED_OUT, upcallInfo);

      var nextInterestLifetime = interestLifetime * 2;
      if (nextInterestLifetime > this.maxInterestLifetime)
        return this.callerClosure.upcall(Closure.UPCALL_INTEREST_TIMED_OUT, upcallInfo);

      var nextInterest = upcallInfo.interest.clone();
      nextInterest.interestLifetime = nextInterestLifetime;
      // TODO: Use expressInterest with callbacks, not Closure.
      upcallInfo.face.expressInterest(nextInterest.name, this, nextInterest);
      return Closure.RESULT_OK;
    }
    else
      return this.callerClosure.upcall(kind, upcallInfo);
  } catch (ex) {
    console.log("ExponentialReExpressClosure.upcall exception: " + ex);
    return Closure.RESULT_ERR;
  }
};
/**
 * Copyright (C) 2013 Regents of the University of California.
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 * Encapsulate a ndnbuf and support dynamic reallocation.
 */

/**
 * Create a DynamicBuffer where this.array is a ndnbuf of size length.
 * The methods will update this.length.
 * To access the array, use this.array or call slice.
 * @constructor
 * @param {number} length the initial length of the array.  If null, use a default.
 */
var DynamicBuffer = function DynamicBuffer(length)
{
  if (!length)
    length = 16;

  this.array = new ndnbuf(length);
  this.length = length;
};

exports.DynamicBuffer = DynamicBuffer;

/**
 * Ensure that this.array has the length, reallocate and copy if necessary.
 * Update this.length which may be greater than length.
 */
DynamicBuffer.prototype.ensureLength = function(length)
{
  if (this.array.length >= length)
    return;

  // See if double is enough.
  var newLength = this.array.length * 2;
  if (length > newLength)
    // The needed length is much greater, so use it.
    newLength = length;

  var newArray = new ndnbuf(newLength);
  this.array.copy(newArray);
  this.array = newArray;
  this.length = newLength;
};

/**
 * Copy the value to this.array at offset, reallocating if necessary.
 */
DynamicBuffer.prototype.set = function(value, offset)
{
  this.ensureLength(value.length + offset);

  if (typeof value == 'object' && value instanceof ndnbuf)
    value.copy(this.array, offset);
  else
    // Need to make value a ndnbuf to copy.
    new ndnbuf(value).copy(this.array, offset);
};

/**
 * Return this.array.slice(begin, end);
 */
DynamicBuffer.prototype.slice = function(begin, end)
{
  return this.array.slice(begin, end);
};
/**
 * This class contains utilities to help parse the data
 *
 * Copyright (C) 2013 Regents of the University of California.
 * @author: Meki Cheraoui
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 */

/**
 * A DataUtils has static methods for converting data.
 * @constructor
 */
var DataUtils = function DataUtils()
{
};

exports.DataUtils = DataUtils;

/*
 * NOTE THIS IS CURRENTLY NOT BEING USED
 *
 */

DataUtils.keyStr = "ABCDEFGHIJKLMNOP" +
                   "QRSTUVWXYZabcdef" +
                   "ghijklmnopqrstuv" +
                   "wxyz0123456789+/" +
                   "=";

/**
 * Raw String to Base 64
 */
DataUtils.stringtoBase64 = function stringtoBase64(input)
{
   //input = escape(input);
   var output = "";
   var chr1, chr2, chr3 = "";
   var enc1, enc2, enc3, enc4 = "";
   var i = 0;

   do {
    chr1 = input.charCodeAt(i++);
    chr2 = input.charCodeAt(i++);
    chr3 = input.charCodeAt(i++);

    enc1 = chr1 >> 2;
    enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
    enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
    enc4 = chr3 & 63;

    if (isNaN(chr2))
       enc3 = enc4 = 64;
    else if (isNaN(chr3))
       enc4 = 64;

    output = output +
       DataUtils.keyStr.charAt(enc1) +
       DataUtils.keyStr.charAt(enc2) +
       DataUtils.keyStr.charAt(enc3) +
       DataUtils.keyStr.charAt(enc4);
    chr1 = chr2 = chr3 = "";
    enc1 = enc2 = enc3 = enc4 = "";
   } while (i < input.length);

   return output;
};

/**
 * Base 64 to Raw String
 */
DataUtils.base64toString = function base64toString(input)
{
  var output = "";
  var chr1, chr2, chr3 = "";
  var enc1, enc2, enc3, enc4 = "";
  var i = 0;

  // remove all characters that are not A-Z, a-z, 0-9, +, /, or =
  var base64test = /[^A-Za-z0-9\+\/\=]/g;
  /* Test for invalid characters. */
  if (base64test.exec(input)) {
    alert("There were invalid base64 characters in the input text.\n" +
          "Valid base64 characters are A-Z, a-z, 0-9, '+', '/',and '='\n" +
          "Expect errors in decoding.");
  }

  input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

  do {
    enc1 = DataUtils.keyStr.indexOf(input.charAt(i++));
    enc2 = DataUtils.keyStr.indexOf(input.charAt(i++));
    enc3 = DataUtils.keyStr.indexOf(input.charAt(i++));
    enc4 = DataUtils.keyStr.indexOf(input.charAt(i++));

    chr1 = (enc1 << 2) | (enc2 >> 4);
    chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
    chr3 = ((enc3 & 3) << 6) | enc4;

    output = output + String.fromCharCode(chr1);

    if (enc3 != 64)
      output = output + String.fromCharCode(chr2);

    if (enc4 != 64)
      output = output + String.fromCharCode(chr3);

    chr1 = chr2 = chr3 = "";
    enc1 = enc2 = enc3 = enc4 = "";
  } while (i < input.length);

  return output;
};

/**
 * ndnbuf to Hex String
 */
DataUtils.toHex = function(ndnbuf)
{
  return ndnbuf.toString('hex');
};

/**
 * Raw string to hex string.
 */
DataUtils.stringToHex = function(args)
{
  var ret = "";
  for (var i = 0; i < args.length; ++i) {
    var value = args.charCodeAt(i);
    ret += (value < 16 ? "0" : "") + value.toString(16);
  }
  return ret;
};

/**
 * ndnbuf to raw string.
 */
DataUtils.toString = function(ndnbuf)
{
  return ndnbuf.toString();
};

/**
 * Hex String to ndnbuf.
 */
DataUtils.toNumbers = function(str)
{
  return new ndnbuf(str, 'hex');
};

/**
 * Hex String to raw string.
 */
DataUtils.hexToRawString = function(str)
{
  if (typeof str =='string') {
  var ret = "";
  str.replace(/(..)/g, function(s) {
    ret += String.fromCharCode(parseInt(s, 16));
  });
  return ret;
  }
};

/**
 * Raw String to ndnbuf.
 */
DataUtils.toNumbersFromString = function(str)
{
  return new ndnbuf(str, 'binary');
};

/**
 * Encode str as utf8 and return as ndnbuf.
 */
DataUtils.stringToUtf8Array = function(str)
{
  return new ndnbuf(str, 'utf8');
};

/**
 * arrays is an array of ndnbuf. Return a new ndnbuf which is the concatenation of all.
 */
DataUtils.concatArrays = function(arrays)
{
  return ndnbuf.concat(arrays);
};

// TODO: Take ndnbuf and use TextDecoder when available.
DataUtils.decodeUtf8 = function(utftext)
{
  var string = "";
  var i = 0;
  var c = 0;
    var c1 = 0;
    var c2 = 0;

  while (i < utftext.length) {
    c = utftext.charCodeAt(i);

    if (c < 128) {
      string += String.fromCharCode(c);
      i++;
    }
    else if (c > 191 && c < 224) {
      c2 = utftext.charCodeAt(i + 1);
      string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
      i += 2;
    }
    else {
      c2 = utftext.charCodeAt(i+1);
      var c3 = utftext.charCodeAt(i+2);
      string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
      i += 3;
    }
  }

  return string;
};

/**
 * Return true if a1 and a2 are the same length with equal elements.
 */
DataUtils.arraysEqual = function(a1, a2)
{
  // A simple sanity check that it is an array.
  if (!a1.slice)
    throw new Error("DataUtils.arraysEqual: a1 is not an array");
  if (!a2.slice)
    throw new Error("DataUtils.arraysEqual: a2 is not an array");

  if (a1.length != a2.length)
    return false;

  for (var i = 0; i < a1.length; ++i) {
    if (a1[i] != a2[i])
      return false;
  }

  return true;
};

/**
 * Convert the big endian ndnbuf to an unsigned int.
 * Don't check for overflow.
 */
DataUtils.bigEndianToUnsignedInt = function(bytes)
{
  var result = 0;
  for (var i = 0; i < bytes.length; ++i) {
    result <<= 8;
    result += bytes[i];
  }
  return result;
};

/**
 * Convert the int value to a new big endian ndnbuf and return.
 * If value is 0 or negative, return new ndnbuf(0).
 */
DataUtils.nonNegativeIntToBigEndian = function(value)
{
  value = Math.round(value);
  if (value <= 0)
    return new ndnbuf(0);

  // Assume value is not over 64 bits.
  var size = 8;
  var result = new ndnbuf(size);
  var i = 0;
  while (value != 0) {
    ++i;
    result[size - i] = value & 0xff;
    value >>= 8;
  }
  return result.slice(size - i, size);
};

/**
 * Modify array to randomly shuffle the elements.
 */
DataUtils.shuffle = function(array)
{
  for (var i = array.length - 1; i >= 1; --i) {
    // j is from 0 to i.
    var j = Math.floor(Math.random() * (i + 1));
    var temp = array[i];
    array[i] = array[j];
    array[j] = temp;
  }
};
/*
 * Date Format 1.2.3
 * (c) 2007-2009 Steven Levithan <stevenlevithan.com>
 * MIT license
 *
 * Includes enhancements by Scott Trenda <scott.trenda.net>
 * and Kris Kowal <cixar.com/~kris.kowal/>
 *
 * Accepts a date, a mask, or a date and a mask.
 * Returns a formatted version of the given date.
 * The date defaults to the current date/time.
 * The mask defaults to dateFormat.masks.default.
 */

var DateFormat = function()
{
  var  token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZ]|"[^"]*"|'[^']*'/g,
    timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g,
    timezoneClip = /[^-+\dA-Z]/g,
    pad = function(val, len) {
      val = String(val);
      len = len || 2;
      while (val.length < len) val = "0" + val;
      return val;
    };

  // Regexes and supporting functions are cached through closure
  return function(date, mask, utc) {
    var dF = dateFormat;

    // You can't provide utc if you skip other args (use the "UTC:" mask prefix)
    if (arguments.length == 1 && Object.prototype.toString.call(date) == "[object String]" && !/\d/.test(date)) {
      mask = date;
      date = undefined;
    }

    // Passing date through Date applies Date.parse, if necessary
    date = date ? new Date(date) : new Date;
    if (isNaN(date)) throw SyntaxError("invalid date");

    mask = String(dF.masks[mask] || mask || dF.masks["default"]);

    // Allow setting the utc argument via the mask
    if (mask.slice(0, 4) == "UTC:") {
      mask = mask.slice(4);
      utc = true;
    }

    var  _ = utc ? "getUTC" : "get",
      d = date[_ + "Date"](),
      D = date[_ + "Day"](),
      m = date[_ + "Month"](),
      y = date[_ + "FullYear"](),
      H = date[_ + "Hours"](),
      M = date[_ + "Minutes"](),
      s = date[_ + "Seconds"](),
      L = date[_ + "Milliseconds"](),
      o = utc ? 0 : date.getTimezoneOffset(),
      flags = {
        d:    d,
        dd:   pad(d),
        ddd:  dF.i18n.dayNames[D],
        dddd: dF.i18n.dayNames[D + 7],
        m:    m + 1,
        mm:   pad(m + 1),
        mmm:  dF.i18n.monthNames[m],
        mmmm: dF.i18n.monthNames[m + 12],
        yy:   String(y).slice(2),
        yyyy: y,
        h:    H % 12 || 12,
        hh:   pad(H % 12 || 12),
        H:    H,
        HH:   pad(H),
        M:    M,
        MM:   pad(M),
        s:    s,
        ss:   pad(s),
        l:    pad(L, 3),
        L:    pad(L > 99 ? Math.round(L / 10) : L),
        t:    H < 12 ? "a"  : "p",
        tt:   H < 12 ? "am" : "pm",
        T:    H < 12 ? "A"  : "P",
        TT:   H < 12 ? "AM" : "PM",
        Z:    utc ? "UTC" : (String(date).match(timezone) || [""]).pop().replace(timezoneClip, ""),
        o:    (o > 0 ? "-" : "+") + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),
        S:    ["th", "st", "nd", "rd"][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10]
      };

    return mask.replace(token, function($0) {
      return $0 in flags ? flags[$0] : $0.slice(1, $0.length - 1);
    });
  };
}();

// Some common format strings
DateFormat.masks = {
  "default":      "ddd mmm dd yyyy HH:MM:ss",
  shortDate:      "m/d/yy",
  mediumDate:     "mmm d, yyyy",
  longDate:       "mmmm d, yyyy",
  fullDate:       "dddd, mmmm d, yyyy",
  shortTime:      "h:MM TT",
  mediumTime:     "h:MM:ss TT",
  longTime:       "h:MM:ss TT Z",
  isoDate:        "yyyy-mm-dd",
  isoTime:        "HH:MM:ss",
  isoDateTime:    "yyyy-mm-dd'T'HH:MM:ss",
  isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'"
};

// Internationalization strings
DateFormat.i18n = {
  dayNames: [
    "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat",
    "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"
  ],
  monthNames: [
    "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
    "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"
  ]
};

// For convenience...
Date.prototype.format = function(mask, utc) {
  return dateFormat(this, mask, utc);
};
/**
 * This class is used to encode ndnb binary elements (blob, type/value pairs).
 *
 * Copyright (C) 2013 Regents of the University of California.
 * @author: Meki Cheraoui
 * See COPYING for copyright and distribution information.
 */


var XML_EXT = 0x00;

var XML_TAG = 0x01;

var XML_DTAG = 0x02;

var XML_ATTR = 0x03;

var XML_DATTR = 0x04;

var XML_BLOB = 0x05;

var XML_UDATA = 0x06;

var XML_CLOSE = 0x0;

var XML_SUBTYPE_PROCESSING_INSTRUCTIONS = 16;


var XML_TT_BITS = 3;
var XML_TT_MASK = ((1 << XML_TT_BITS) - 1);
var XML_TT_VAL_BITS = XML_TT_BITS + 1;
var XML_TT_VAL_MASK = ((1 << (XML_TT_VAL_BITS)) - 1);
var XML_REG_VAL_BITS = 7;
var XML_REG_VAL_MASK = ((1 << XML_REG_VAL_BITS) - 1);
var XML_TT_NO_MORE = (1 << XML_REG_VAL_BITS); // 0x80
var BYTE_MASK = 0xFF;
var LONG_BYTES = 8;
var LONG_BITS = 64;

var bits_11 = 0x0000007FF;
var bits_18 = 0x00003FFFF;
var bits_32 = 0x0FFFFFFFF;

/**
 * @constructor
 */
var BinaryXMLEncoder = function BinaryXMLEncoder(initiaLength)
{
  if (!initiaLength)
    initiaLength = 16;

  this.ostream = new DynamicBuffer(initiaLength);
  this.offset = 0;
  this.CODEC_NAME = "Binary";
};

exports.BinaryXMLEncoder = BinaryXMLEncoder;

/**
 * Encode utf8Content as utf8 and write to the output ndnbuf as a UDATA.
 * @param {string} utf8Content The string to convert to utf8.
 */
BinaryXMLEncoder.prototype.writeUString = function(utf8Content)
{
  this.encodeUString(utf8Content, XML_UDATA);
};

BinaryXMLEncoder.prototype.writeBlob = function(
    /*Buffer*/ binaryContent)
{
  if (LOG >3) console.log(binaryContent);

  this.encodeBlob(binaryContent, binaryContent.length);
};

/**
 * Write an element start header using DTAG with the tag to the output ndnbuf.
 * @param {number} tag The DTAG tag.
 */
BinaryXMLEncoder.prototype.writeElementStartDTag = function(tag)
{
  this.encodeTypeAndVal(XML_DTAG, tag);
};

/**
 * @deprecated Use writeElementStartDTag.  Binary XML string tags and attributes are not used by any NDN encodings and
 * support is not maintained in the code base.
 */
BinaryXMLEncoder.prototype.writeStartElement = function(
  /*String*/ tag,
  /*TreeMap<String,String>*/ attributes)
{
  /*Long*/ var dictionaryVal = tag; //stringToTag(tag);

  if (null == dictionaryVal)
    this.encodeUString(tag, XML_TAG);
  else
    this.encodeTypeAndVal(XML_DTAG, dictionaryVal);

  if (null != attributes)
    this.writeAttributes(attributes);
};

/**
 * Write an element close to the output ndnbuf.
 */
BinaryXMLEncoder.prototype.writeElementClose = function()
{
  this.ostream.ensureLength(this.offset + 1);
  this.ostream.array[this.offset] = XML_CLOSE;
  this.offset += 1;
};

/**
 * @deprecated Use writeElementClose.
 */
BinaryXMLEncoder.prototype.writeEndElement = function()
{
  this.writeElementClose();
};

/**
 * @deprecated Binary XML string tags and attributes are not used by any NDN encodings and support is not maintained in the code base.
 */
BinaryXMLEncoder.prototype.writeAttributes = function(/*TreeMap<String,String>*/ attributes)
{
  if (null == attributes)
    return;

  // the keySet of a TreeMap is sorted.

  for (var i = 0; i< attributes.length;i++) {
    var strAttr = attributes[i].k;
    var strValue = attributes[i].v;

    var dictionaryAttr = stringToTag(strAttr);
    if (null == dictionaryAttr)
      // not in dictionary, encode as attr
      // compressed format wants length of tag represented as length-1
      // to save that extra bit, as tag cannot be 0 length.
      // encodeUString knows to do that.
      this.encodeUString(strAttr, XML_ATTR);
    else
      this.encodeTypeAndVal(XML_DATTR, dictionaryAttr);

    // Write value
    this.encodeUString(strValue);
  }
};

//returns a string
stringToTag = function(/*long*/ tagVal)
{
  if (tagVal >= 0 && tagVal < NDNProtocolDTagsStrings.length)
    return NDNProtocolDTagsStrings[tagVal];
  else if (tagVal == NDNProtocolDTags.NDNProtocolDataUnit)
    return NDNProtocolDTags.NDNPROTOCOL_DATA_UNIT;

  return null;
};

//returns a Long
tagToString =  function(/*String*/ tagName)
{
  // the slow way, but right now we don't care.... want a static lookup for the forward direction
  for (var i = 0; i < NDNProtocolDTagsStrings.length; ++i) {
    if (null != NDNProtocolDTagsStrings[i] && NDNProtocolDTagsStrings[i] == tagName)
      return i;
  }

  if (NDNProtocolDTags.NDNPROTOCOL_DATA_UNIT == tagName)
    return NDNProtocolDTags.NDNProtocolDataUnit;

  return null;
};

/**
 * Write an element start header using DTAG with the tag to the output ndnbuf, then the content as explained below,
 * then an element close.
 * @param {number} tag The DTAG tag.
 * @param {number|string|Buffer} content If contentis a number, convert it to a string and call writeUString.  If content is a string,
 * call writeUString.  Otherwise, call writeBlob.
 */
BinaryXMLEncoder.prototype.writeDTagElement = function(tag, content)
{
  this.writeElementStartDTag(tag);

  if (typeof content === 'number')
    this.writeUString(content.toString());
  else if (typeof content === 'string')
    this.writeUString(content);
  else
    this.writeBlob(content);

  this.writeElementClose();
};

/**
 * @deprecated Use writeDTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and
 * support is not maintained in the code base.
 * If Content is a string, then encode as utf8 and write UDATA.
 */
BinaryXMLEncoder.prototype.writeElement = function(
    //long
    tag,
    //byte[]
    Content,
    //TreeMap<String, String>
    attributes)
{
  this.writeStartElement(tag, attributes);
  // Will omit if 0-length

  if (typeof Content === 'number') {
    if (LOG > 4) console.log('GOING TO WRITE THE NUMBER .charCodeAt(0) ' + Content.toString().charCodeAt(0));
    if (LOG > 4) console.log('GOING TO WRITE THE NUMBER ' + Content.toString());
    if (LOG > 4) console.log('type of number is ' + typeof Content.toString());

    this.writeUString(Content.toString());
  }
  else if (typeof Content === 'string') {
    if (LOG > 4) console.log('GOING TO WRITE THE STRING  ' + Content);
    if (LOG > 4) console.log('type of STRING is ' + typeof Content);

    this.writeUString(Content);
  }
  else {
    if (LOG > 4) console.log('GOING TO WRITE A BLOB  ' + Content);

    this.writeBlob(Content);
  }

  this.writeElementClose();
};

var TypeAndVal = function TypeAndVal(_type,_val)
{
  this.type = _type;
  this.val = _val;
};

BinaryXMLEncoder.prototype.encodeTypeAndVal = function(
    //int
    type,
    //long
    val)
{
  if (LOG > 4) console.log('Encoding type '+ type+ ' and value '+ val);

  if (LOG > 4) console.log('OFFSET IS ' + this.offset);

  if (type > XML_UDATA || type < 0 || val < 0)
    throw new Error("Tag and value must be positive, and tag valid.");

  // Encode backwards. Calculate how many bytes we need:
  var numEncodingBytes = this.numEncodingBytes(val);
  this.ostream.ensureLength(this.offset + numEncodingBytes);

  // Bottom 4 bits of val go in last byte with tag.
  this.ostream.array[this.offset + numEncodingBytes - 1] =
    //(byte)
      (BYTE_MASK &
          (((XML_TT_MASK & type) |
           ((XML_TT_VAL_MASK & val) << XML_TT_BITS))) |
           XML_TT_NO_MORE); // set top bit for last byte
  val = val >>> XML_TT_VAL_BITS;

  // Rest of val goes into preceding bytes, 7 bits per byte, top bit
  // is "more" flag.
  var i = this.offset + numEncodingBytes - 2;
  while (0 != val && i >= this.offset) {
    this.ostream.array[i] = //(byte)
        (BYTE_MASK & (val & XML_REG_VAL_MASK)); // leave top bit unset
    val = val >>> XML_REG_VAL_BITS;
    --i;
  }

  if (val != 0)
    throw new Error("This should not happen: miscalculated encoding");

  this.offset+= numEncodingBytes;

  return numEncodingBytes;
};

/**
 * Encode ustring as utf8.
 */
BinaryXMLEncoder.prototype.encodeUString = function(
    //String
    ustring,
    //byte
    type)
{
  if (null == ustring)
    return;
  if (type == XML_TAG || type == XML_ATTR && ustring.length == 0)
    return;

  if (LOG > 3) console.log("The string to write is ");
  if (LOG > 3) console.log(ustring);

  var strBytes = DataUtils.stringToUtf8Array(ustring);

  this.encodeTypeAndVal(type,
            (((type == XML_TAG) || (type == XML_ATTR)) ?
                (strBytes.length-1) :
                strBytes.length));

  if (LOG > 3) console.log("THE string to write is ");

  if (LOG > 3) console.log(strBytes);

  this.writeString(strBytes);
  this.offset+= strBytes.length;
};


BinaryXMLEncoder.prototype.encodeBlob = function(
    //Buffer
    blob,
    //int
    length)
{
  if (null == blob)
    return;

  if (LOG > 4) console.log('LENGTH OF XML_BLOB IS '+length);

  this.encodeTypeAndVal(XML_BLOB, length);
  this.writeBlobArray(blob);
  this.offset += length;
};

var ENCODING_LIMIT_1_BYTE = ((1 << (XML_TT_VAL_BITS)) - 1);
var ENCODING_LIMIT_2_BYTES = ((1 << (XML_TT_VAL_BITS + XML_REG_VAL_BITS)) - 1);
var ENCODING_LIMIT_3_BYTES = ((1 << (XML_TT_VAL_BITS + 2 * XML_REG_VAL_BITS)) - 1);

BinaryXMLEncoder.prototype.numEncodingBytes = function(
    //long
    x)
{
  if (x <= ENCODING_LIMIT_1_BYTE) return (1);
  if (x <= ENCODING_LIMIT_2_BYTES) return (2);
  if (x <= ENCODING_LIMIT_3_BYTES) return (3);

  var numbytes = 1;

  // Last byte gives you XML_TT_VAL_BITS
  // Remainder each give you XML_REG_VAL_BITS
  x = x >>> XML_TT_VAL_BITS;
  while (x != 0) {
        numbytes++;
    x = x >>> XML_REG_VAL_BITS;
  }
  return (numbytes);
};

/**
 * Write an element start header using DTAG with the tag to the output ndnbuf, then the dateTime
   * as a big endian BLOB converted to 4096 ticks per second, then an element close.
 * @param {number} tag The DTAG tag.
 * @param {NDNTime} dateTime
 */
BinaryXMLEncoder.prototype.writeDateTimeDTagElement = function(tag, dateTime)
{
  //parse to hex
  var binarydate =  Math.round((dateTime.msec/1000) * 4096).toString(16)  ;
  if (binarydate.length % 2 == 1)
    binarydate = '0' + binarydate;

  this.writeDTagElement(tag, DataUtils.toNumbers(binarydate));
};

/**
 * @deprecated Use writeDateTimeDTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and
 * support is not maintained in the code base.
 */
BinaryXMLEncoder.prototype.writeDateTime = function(
    //String
    tag,
    //NDNTime
    dateTime)
{
  //parse to hex
  var binarydate =  Math.round((dateTime.msec/1000) * 4096).toString(16)  ;
  if (binarydate.length % 2 == 1)
    binarydate = '0' + binarydate;

  this.writeElement(tag, DataUtils.toNumbers(binarydate));
};

// This does not update this.offset.
BinaryXMLEncoder.prototype.writeString = function(input)
{
  if (typeof input === 'string') {
    if (LOG > 4) console.log('GOING TO WRITE A STRING');
    if (LOG > 4) console.log(input);

    this.ostream.ensureLength(this.offset + input.length);
    for (var i = 0; i < input.length; i++) {
      if (LOG > 4) console.log('input.charCodeAt(i)=' + input.charCodeAt(i));
      this.ostream.array[this.offset + i] = (input.charCodeAt(i));
    }
  }
  else
  {
    if (LOG > 4) console.log('GOING TO WRITE A STRING IN BINARY FORM');
    if (LOG > 4) console.log(input);

    this.writeBlobArray(input);
  }
};

BinaryXMLEncoder.prototype.writeBlobArray = function(
    //Buffer
    blob)
{
  if (LOG > 4) console.log('GOING TO WRITE A BLOB');

  this.ostream.set(blob, this.offset);
};

BinaryXMLEncoder.prototype.getReducedOstream = function()
{
  return this.ostream.slice(0, this.offset);
};
/**
 * This class is used to decode ndnb binary elements (blob, type/value pairs).
 *
 * Copyright (C) 2013 Regents of the University of California.
 * @author: Meki Cheraoui
 * See COPYING for copyright and distribution information.
 */


var XML_EXT = 0x00;

var XML_TAG = 0x01;

var XML_DTAG = 0x02;

var XML_ATTR = 0x03;

var XML_DATTR = 0x04;

var XML_BLOB = 0x05;

var XML_UDATA = 0x06;

var XML_CLOSE = 0x0;

var XML_SUBTYPE_PROCESSING_INSTRUCTIONS = 16;


var XML_TT_BITS = 3;
var XML_TT_MASK = ((1 << XML_TT_BITS) - 1);
var XML_TT_VAL_BITS = XML_TT_BITS + 1;
var XML_TT_VAL_MASK = ((1 << (XML_TT_VAL_BITS)) - 1);
var XML_REG_VAL_BITS = 7;
var XML_REG_VAL_MASK = ((1 << XML_REG_VAL_BITS) - 1);
var XML_TT_NO_MORE = (1 << XML_REG_VAL_BITS); // 0x80
var BYTE_MASK = 0xFF;
var LONG_BYTES = 8;
var LONG_BITS = 64;

var bits_11 = 0x0000007FF;
var bits_18 = 0x00003FFFF;
var bits_32 = 0x0FFFFFFFF;



//returns a string
tagToString = function(/*long*/ tagVal)
{
  if (tagVal >= 0 && tagVal < NDNProtocolDTagsStrings.length) {
    return NDNProtocolDTagsStrings[tagVal];
  }
  else if (tagVal == NDNProtocolDTags.NDNProtocolDataUnit) {
    return NDNProtocolDTags.NDNPROTOCOL_DATA_UNIT;
  }

  return null;
};

//returns a Long
stringToTag =  function(/*String*/ tagName)
{
  // the slow way, but right now we don't care.... want a static lookup for the forward direction
  for (var i=0; i < NDNProtocolDTagsStrings.length; ++i) {
    if (null != NDNProtocolDTagsStrings[i] && NDNProtocolDTagsStrings[i] == tagName)
      return i;
  }
  if (NDNProtocolDTags.NDNPROTOCOL_DATA_UNIT == tagName) {
    return NDNProtocolDTags.NDNProtocolDataUnit;
  }

  return null;
};

/**
 * @constructor
 */
var BinaryXMLDecoder = function BinaryXMLDecoder(input)
{
  var MARK_LEN=512;
  var DEBUG_MAX_LEN =  32768;

  this.input = input;
  this.offset = 0;
  // peekDTag sets and checks this, and readElementStartDTag uses it to avoid reading again.
  this.previouslyPeekedDTagStartOffset = -1;
};

exports.BinaryXMLDecoder = BinaryXMLDecoder;

/**
 * Decode the header from the input starting at its position, expecting the type to be DTAG and the value to be expectedTag.
   * Update the input's offset.
 * @param {number} expectedTag The expected value for DTAG.
 */
BinaryXMLDecoder.prototype.readElementStartDTag = function(expectedTag)
{
  if (this.offset == this.previouslyPeekedDTagStartOffset) {
    // peekDTag already decoded this DTag.
    if (this.previouslyPeekedDTag != expectedTag)
      throw new ContentDecodingException(new Error("Did not get the expected DTAG " + expectedTag + ", got " + this.previouslyPeekedDTag));

    // Fast forward past the header.
    this.offset = this.previouslyPeekedDTagEndOffset;
  }
  else {
    var typeAndValue = this.decodeTypeAndVal();
    if (typeAndValue == null || typeAndValue.type() != XML_DTAG)
      throw new ContentDecodingException(new Error("Header type is not a DTAG"));

    if (typeAndValue.val() != expectedTag)
      throw new ContentDecodingException(new Error("Expected start element: " + expectedTag + " got: " + typeAndValue.val()));
  }
};

/**
 * @deprecated Use readElementStartDTag. Binary XML string tags and attributes are not used by any NDN encodings and
 * support is not maintained in the code base.
 */
BinaryXMLDecoder.prototype.readStartElement = function(
    //String
    startTag,
    //TreeMap<String, String>
    attributes)
{
  //TypeAndVal
  var tv = this.decodeTypeAndVal();

  if (null == tv)
    throw new ContentDecodingException(new Error("Expected start element: " + startTag + " got something not a tag."));

  //String
  var decodedTag = null;

  if (tv.type() == XML_TAG) {
    // Tag value represents length-1 as tags can never be empty.
    var valval;

    if (typeof tv.val() == 'string')
      valval = (parseInt(tv.val())) + 1;
    else
      valval = (tv.val())+ 1;

    decodedTag = this.decodeUString(valval);
  }
  else if (tv.type() == XML_DTAG)
    decodedTag = tv.val();

  if (null ==  decodedTag || decodedTag != startTag) {
    console.log('expecting '+ startTag + ' but got '+ decodedTag);
    throw new ContentDecodingException(new Error("Expected start element: " + startTag + " got: " + decodedTag + "(" + tv.val() + ")"));
  }

  // DKS: does not read attributes out of stream if caller doesn't
  // ask for them. Should possibly peek and skip over them regardless.
  // TODO: fix this
  if (null != attributes)
    readAttributes(attributes);
};

/**
 * @deprecated Binary XML string tags and attributes are not used by any NDN encodings and support is not maintained in the code base.
 */
BinaryXMLDecoder.prototype.readAttributes = function(
  // array of [attributeName, attributeValue]
  attributes)
{
  if (null == attributes)
    return;

  try {
    // Now need to get attributes.
    //TypeAndVal
    var nextTV = this.peekTypeAndVal();

    while (null != nextTV && (XML_ATTR == nextTV.type() || XML_DATTR == nextTV.type())) {
      // Decode this attribute. First, really read the type and value.
      //this.TypeAndVal
      var thisTV = this.decodeTypeAndVal();

      //String
      var attributeName = null;
      if (XML_ATTR == thisTV.type()) {
        // Tag value represents length-1 as attribute names cannot be empty.
        var valval ;
        if (typeof thisTV.val() == 'string')
          valval = (parseInt(thisTV.val())) + 1;
        else
          valval = (thisTV.val())+ 1;

        attributeName = this.decodeUString(valval);
      }
      else if (XML_DATTR == thisTV.type()) {
        // DKS TODO are attributes same or different dictionary?
        attributeName = tagToString(thisTV.val());
        if (null == attributeName)
          throw new ContentDecodingException(new Error("Unknown DATTR value" + thisTV.val()));
      }

      // Attribute values are always UDATA
      //String
      var attributeValue = this.decodeUString();

      attributes.push([attributeName, attributeValue]);
      nextTV = this.peekTypeAndVal();
    }
  }
  catch (e) {
    throw new ContentDecodingException(new Error("readStartElement", e));
  }
};

/**
 * @deprecated Use peekDTag.  Binary XML string tags and attributes are not used by any NDN encodings and
 * support is not maintained in the code base.
 */
BinaryXMLDecoder.prototype.peekStartElementAsString = function()
{
  //String
  var decodedTag = null;
  var previousOffset = this.offset;
  try {
    // Have to distinguish genuine errors from wrong tags. Could either use
    // a special exception subtype, or redo the work here.
    //this.TypeAndVal
    var tv = this.decodeTypeAndVal();

    if (null != tv) {
      if (tv.type() == XML_TAG) {
        // Tag value represents length-1 as tags can never be empty.
        var valval ;
        if (typeof tv.val() == 'string')
          valval = (parseInt(tv.val())) + 1;
        else
          valval = (tv.val())+ 1;

        decodedTag = this.decodeUString(valval);
      }
      else if (tv.type() == XML_DTAG)
        decodedTag = tagToString(tv.val());
    } // else, not a type and val, probably an end element. rewind and return false.
  }
  catch (e) {
  }
  finally {
    try {
      this.offset = previousOffset;
    }
    catch (e) {
      Log.logStackTrace(Log.FAC_ENCODING, Level.WARNING, e);
      throw new ContentDecodingException(new Error("Cannot reset stream! " + e.getMessage(), e));
    }
  }

  return decodedTag;
};

/**
 * Decode the header from the input starting at its position, and if it is a DTAG where the value is the expectedTag,
 * then set return true.  Do not update the input's offset.
 * @param {number} expectedTag The expected value for DTAG.
 * @returns {boolean} True if the tag is the expected tag, otherwise false.
 */
BinaryXMLDecoder.prototype.peekDTag = function(expectedTag)
{
  if (this.offset == this.previouslyPeekedDTagStartOffset)
    // We already decoded this DTag.
    return this.previouslyPeekedDTag == expectedTag;
  else {
    // First check if it is an element close (which cannot be the expected tag).
    if (this.input[this.offset] == XML_CLOSE)
      return false;

    var saveOffset = this.offset;
    var typeAndValue = this.decodeTypeAndVal();
    // readElementStartDTag will use this to fast forward.
    this.previouslyPeekedDTagEndOffset = this.offset;
    // Restore the position.
    this.offset = saveOffset;

    if (typeAndValue != null && typeAndValue.type() == XML_DTAG) {
      this.previouslyPeekedDTagStartOffset = saveOffset;
      this.previouslyPeekedDTag = typeAndValue.val();

      return typeAndValue.val() == expectedTag;
    }
    else
      return false;
  }
};

/**
 * @deprecated Use peekDTag.  Binary XML string tags and attributes are not used by any NDN encodings and
 * support is not maintained in the code base.
 */
BinaryXMLDecoder.prototype.peekStartElement = function(
    //String
    startTag)
{
  //String
  if (typeof startTag == 'string') {
    var decodedTag = this.peekStartElementAsString();

    if (null !=  decodedTag && decodedTag == startTag)
      return true;

    return false;
  }
  else if (typeof startTag == 'number') {
    var decodedTag = this.peekStartElementAsLong();
    if (null !=  decodedTag && decodedTag == startTag)
      return true;

    return false;
  }
  else
    throw new ContentDecodingException(new Error("SHOULD BE STRING OR NUMBER"));
};

/**
 * @deprecated Use peekDTag.  Binary XML string tags and attributes are not used by any NDN encodings and
 * support is not maintained in the code base.
 */
BinaryXMLDecoder.prototype.peekStartElementAsLong = function()
{
  //Long
  var decodedTag = null;
  var previousOffset = this.offset;

  try {
    // Have to distinguish genuine errors from wrong tags. Could either use
    // a special exception subtype, or redo the work here.
    //this.TypeAndVal
    var tv = this.decodeTypeAndVal();

    if (null != tv) {
      if (tv.type() == XML_TAG) {
        if (tv.val() + 1 > DEBUG_MAX_LEN)
          throw new ContentDecodingException(new Error("Decoding error: length " + tv.val()+1 + " longer than expected maximum length!"));

        var valval;
        if (typeof tv.val() == 'string')
          valval = (parseInt(tv.val())) + 1;
        else
          valval = (tv.val())+ 1;

        // Tag value represents length-1 as tags can never be empty.
        //String
        var strTag = this.decodeUString(valval);

        decodedTag = stringToTag(strTag);
      }
      else if (tv.type() == XML_DTAG)
        decodedTag = tv.val();
    } // else, not a type and val, probably an end element. rewind and return false.

  }
  catch (e) {
  }
  finally {
    try {
      //this.input.reset();
      this.offset = previousOffset;
    } catch (e) {
      Log.logStackTrace(Log.FAC_ENCODING, Level.WARNING, e);
      throw new Error("Cannot reset stream! " + e.getMessage(), e);
    }
  }

  return decodedTag;
};

/**
 * Decode the header from the input starting its offset, expecting the type to be DTAG and the value to be expectedTag.
 * Then read one item of any type (presumably BLOB, UDATA, TAG or ATTR) and return a
 * ndnbuf. However, if allowNull is true, then the item may be absent.
 * Finally, read the element close.  Update the input's offset.
 * @param {number} expectedTag The expected value for DTAG.
 * @param {boolean} allowNull True if the binary item may be missing.
 * @returns {Buffer} A ndnbuf which is a slice on the data inside the input ndnbuf. However,
 * if allowNull is true and the binary data item is absent, then return null.
 */
BinaryXMLDecoder.prototype.readBinaryDTagElement = function(expectedTag, allowNull)
{
  this.readElementStartDTag(expectedTag);
  return this.readBlob(allowNull);
};

/**
 * @deprecated Use readBinaryDTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and
 * support is not maintained in the code base.
 */
BinaryXMLDecoder.prototype.readBinaryElement = function(
    //long
    startTag,
    //TreeMap<String, String>
    attributes,
    //boolean
    allowNull)
{
  this.readStartElement(startTag, attributes);
  return this.readBlob(allowNull);
};

/**
 * Read one byte from the input starting at its offset, expecting it to be the element close.
 * Update the input's offset.
 */
BinaryXMLDecoder.prototype.readElementClose = function()
{
  var next = this.input[this.offset++];
  if (next != XML_CLOSE)
    throw new ContentDecodingException(new Error("Expected end element, got: " + next));
};

/**
 * @deprecated Use readElementClose.
 */
BinaryXMLDecoder.prototype.readEndElement = function()
{
  if (LOG > 4) console.log('this.offset is '+this.offset);

  var next = this.input[this.offset];

  this.offset++;

  if (LOG > 4) console.log('XML_CLOSE IS '+XML_CLOSE);
  if (LOG > 4) console.log('next is '+next);

  if (next != XML_CLOSE) {
    console.log("Expected end element, got: " + next);
    throw new ContentDecodingException(new Error("Expected end element, got: " + next));
  }
};

//String
BinaryXMLDecoder.prototype.readUString = function()
{
  //String
  var ustring = this.decodeUString();
  this.readElementClose();
  return ustring;
};

/**
 * Read a blob as well as the end element. Returns a ndnbuf (or null for missing blob).
 * If the blob is missing and allowNull is false (default), throw an exception.  Otherwise,
 *   just read the end element and return null.
 */
BinaryXMLDecoder.prototype.readBlob = function(allowNull)
{
  if (this.input[this.offset] == XML_CLOSE && allowNull) {
    this.readElementClose();
    return null;
  }

  var blob = this.decodeBlob();
  this.readElementClose();
  return blob;
};

/**
 * Decode the header from the input starting at its offset, expecting the type to be
 * DTAG and the value to be expectedTag.  Then read one item, parse it as an unsigned
 * big endian integer in 4096 ticks per second, and convert it to and NDNTime object.
 * Finally, read the element close.  Update the input's offset.
 * @param {number} expectedTag The expected value for DTAG.
 * @returns {NDNTime} The dateTime value.
 */
BinaryXMLDecoder.prototype.readDateTimeDTagElement = function(expectedTag)
{
  var byteTimestamp = this.readBinaryDTagElement(expectedTag);
  byteTimestamp = DataUtils.toHex(byteTimestamp);
  byteTimestamp = parseInt(byteTimestamp, 16);

  var lontimestamp = (byteTimestamp/ 4096) * 1000;

  var timestamp = new NDNTime(lontimestamp);
  if (null == timestamp)
    throw new ContentDecodingException(new Error("Cannot parse timestamp: " + DataUtils.printHexBytes(byteTimestamp)));

  return timestamp;
};

/**
 * @deprecated Use readDateTimeDTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and
 * support is not maintained in the code base.
 */
BinaryXMLDecoder.prototype.readDateTime = function(
  //long
  startTag)
{
  var byteTimestamp = this.readBinaryElement(startTag);
  byteTimestamp = DataUtils.toHex(byteTimestamp);
  byteTimestamp = parseInt(byteTimestamp, 16);

  var lontimestamp = (byteTimestamp/ 4096) * 1000;

  if (LOG > 4) console.log('DECODED DATE WITH VALUE');
  if (LOG > 4) console.log(lontimestamp);

  //NDNTime
  var timestamp = new NDNTime(lontimestamp);
  if (null == timestamp)
    throw new ContentDecodingException(new Error("Cannot parse timestamp: " + DataUtils.printHexBytes(byteTimestamp)));

  return timestamp;
};

BinaryXMLDecoder.prototype.decodeTypeAndVal = function()
{

  /*int*/ var type = -1;
  /*long*/ var val = 0;
  /*boolean*/ var more = true;

  do {
    var next = this.input[this.offset ];
    if (next == null)
      // Quit the loop.
      return null;

    if (next < 0)
      return null;

    if (0 == next && 0 == val)
      return null;

    more = (0 == (next & XML_TT_NO_MORE));

    if  (more) {
      val = val << XML_REG_VAL_BITS;
      val |= (next & XML_REG_VAL_MASK);
    }
    else {
      type = next & XML_TT_MASK;
      val = val << XML_TT_VAL_BITS;
      val |= ((next >>> XML_TT_BITS) & XML_TT_VAL_MASK);
    }

    this.offset++;
  } while (more);

  if (LOG > 4) console.log('TYPE is '+ type + ' VAL is '+ val);

  return new TypeAndVal(type, val);
};

//TypeAndVal
BinaryXMLDecoder.prototype.peekTypeAndVal = function()
{
  //TypeAndVal
  var tv = null;
  var previousOffset = this.offset;

  try {
    tv = this.decodeTypeAndVal();
  }
  finally {
    this.offset = previousOffset;
  }

  return tv;
};

//Buffer
BinaryXMLDecoder.prototype.decodeBlob = function(
    //int
    blobLength)
{
  if (null == blobLength) {
    //TypeAndVal
    var tv = this.decodeTypeAndVal();

    var valval ;
    if (typeof tv.val() == 'string')
      valval = (parseInt(tv.val()));
    else
      valval = (tv.val());

    return this.decodeBlob(valval);
  }

  //Buffer
  var bytes = new ndnbuf(this.input.slice(this.offset, this.offset+ blobLength));
  this.offset += blobLength;

  return bytes;
};

//String
BinaryXMLDecoder.prototype.decodeUString = function(
    //int
    byteLength)
{
  if (null == byteLength) {
    var tempStreamPosition = this.offset;

    //TypeAndVal
    var tv = this.decodeTypeAndVal();

    if (LOG > 4) console.log('TV is '+tv);
    if (LOG > 4) console.log(tv);

    if (LOG > 4) console.log('Type of TV is '+typeof tv);

    // if we just have closers left, will get back null
    if (null == tv || XML_UDATA != tv.type()) {
      this.offset = tempStreamPosition;
      return "";
    }

    return this.decodeUString(tv.val());
  }
  else {
    //Buffer
    var stringBytes = this.decodeBlob(byteLength);

    // TODO: Should this parse as UTF8?
    return DataUtils.toString(stringBytes);
  }
};

//OBject containg a pair of type and value
var TypeAndVal = function TypeAndVal(_type,_val)
{
  this.t = _type;
  this.v = _val;
};

TypeAndVal.prototype.type = function()
{
  return this.t;
};

TypeAndVal.prototype.val = function()
{
  return this.v;
};

/**
 * Decode the header from the input starting its offset, expecting the type to be DTAG and the value to be expectedTag.
 * Then read one UDATA item, parse it as a decimal integer and return the integer. Finally, read the element close.  Update the input's offset.
 * @param {number} expectedTag The expected value for DTAG.
 * @returns {number} The parsed integer.
 */
BinaryXMLDecoder.prototype.readIntegerDTagElement = function(expectedTag)
{
  return parseInt(this.readUTF8DTagElement(expectedTag));
};

/**
 * @deprecated Use readIntegerDTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and
 * support is not maintained in the code base.
 */
BinaryXMLDecoder.prototype.readIntegerElement = function(
  //String
  startTag)
{
  //String
  if (LOG > 4) console.log('READING INTEGER '+ startTag);
  if (LOG > 4) console.log('TYPE OF '+ typeof startTag);

  var strVal = this.readUTF8Element(startTag);

  return parseInt(strVal);
};

/**
 * Decode the header from the input starting its offset, expecting the type to be DTAG and the value to be expectedTag.
 * Then read one UDATA item and return a string. Finally, read the element close.  Update the input's offset.
 * @param {number} expectedTag The expected value for DTAG.
 * @returns {string} The UDATA string.
 */
BinaryXMLDecoder.prototype.readUTF8DTagElement = function(expectedTag)
{
  this.readElementStartDTag(expectedTag);
  return this.readUString();;
};

/**
 * @deprecated Use readUTF8DTagElement.  Binary XML string tags and attributes are not used by any NDN encodings and
 * support is not maintained in the code base.
 */
BinaryXMLDecoder.prototype.readUTF8Element = function(
    //String
    startTag,
    //TreeMap<String, String>
    attributes)
{
  //throws Error where name == "ContentDecodingException"

  // can't use getElementText, can't get attributes
  this.readStartElement(startTag, attributes);
  //String
  var strElementText = this.readUString();
  return strElementText;
};

/**
 * Set the offset into the input, used for the next read.
 * @param {number} offset The new offset.
 */
BinaryXMLDecoder.prototype.seek = function(offset)
{
  this.offset = offset;
};

/*
 * Call with: throw new ContentDecodingException(new Error("message")).
 */
function ContentDecodingException(error)
{
  this.message = error.message;
  // Copy lineNumber, etc. from where new Error was called.
  for (var prop in error)
      this[prop] = error[prop];
}
ContentDecodingException.prototype = new Error();
ContentDecodingException.prototype.name = "ContentDecodingException";
/**
 * This class uses BinaryXMLDecoder to follow the structure of a ndnb binary element to
 * determine its end.
 *
 * Copyright (C) 2013 Regents of the University of California.
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 */


var XML_EXT = 0x00;
var XML_TAG = 0x01;
var XML_DTAG = 0x02;
var XML_ATTR = 0x03;
var XML_DATTR = 0x04;
var XML_BLOB = 0x05;
var XML_UDATA = 0x06;
var XML_CLOSE = 0x0;

var XML_SUBTYPE_PROCESSING_INSTRUCTIONS = 16;

var XML_TT_BITS = 3;
var XML_TT_MASK = ((1 << XML_TT_BITS) - 1);
var XML_TT_VAL_BITS = XML_TT_BITS + 1;
var XML_TT_VAL_MASK = ((1 << (XML_TT_VAL_BITS)) - 1);
var XML_REG_VAL_BITS = 7;
var XML_REG_VAL_MASK = ((1 << XML_REG_VAL_BITS) - 1);
var XML_TT_NO_MORE = (1 << XML_REG_VAL_BITS); // 0x80

/**
 * @constructor
 */
var BinaryXMLStructureDecoder = function BinaryXMLDecoder()
{
  this.gotElementEnd = false;
  this.offset = 0;
  this.level = 0;
  this.state = BinaryXMLStructureDecoder.READ_HEADER_OR_CLOSE;
  this.headerLength = 0;
  this.useHeaderBuffer = false;
  this.headerBuffer = new DynamicBuffer(5);
  this.nBytesToRead = 0;
};

exports.BinaryXMLStructureDecoder = BinaryXMLStructureDecoder;

BinaryXMLStructureDecoder.READ_HEADER_OR_CLOSE = 0;
BinaryXMLStructureDecoder.READ_BYTES = 1;

/**
 * Continue scanning input starting from this.offset.  If found the end of the element
 *   which started at offset 0 then return true, else false.
 * If this returns false, you should read more into input and call again.
 * You have to pass in input each time because the array could be reallocated.
 * This throws an exception for badly formed ndnb.
 */
BinaryXMLStructureDecoder.prototype.findElementEnd = function(
  // ndnbuf
  input)
{
  if (this.gotElementEnd)
    // Someone is calling when we already got the end.
    return true;

  var decoder = new BinaryXMLDecoder(input);

  while (true) {
    if (this.offset >= input.length)
      // All the cases assume we have some input.
      return false;

    switch (this.state) {
      case BinaryXMLStructureDecoder.READ_HEADER_OR_CLOSE:
        // First check for XML_CLOSE.
        if (this.headerLength == 0 && input[this.offset] == XML_CLOSE) {
          ++this.offset;
          // Close the level.
          --this.level;
          if (this.level == 0) {
            // Finished.
            this.gotElementEnd = true;
            return true;
          }
          if (this.level < 0)
            throw new Error("BinaryXMLStructureDecoder: Unexpected close tag at offset " + (this.offset - 1));

          // Get ready for the next header.
          this.startHeader();
          break;
        }

        var startingHeaderLength = this.headerLength;
        while (true) {
          if (this.offset >= input.length) {
            // We can't get all of the header bytes from this input. Save in headerBuffer.
            this.useHeaderBuffer = true;
            var nNewBytes = this.headerLength - startingHeaderLength;
            this.headerBuffer.set(input.slice(this.offset - nNewBytes, nNewBytes), startingHeaderLength);

            return false;
          }
          var headerByte = input[this.offset++];
          ++this.headerLength;
          if (headerByte & XML_TT_NO_MORE)
            // Break and read the header.
            break;
        }

        var typeAndVal;
        if (this.useHeaderBuffer) {
          // Copy the remaining bytes into headerBuffer.
          nNewBytes = this.headerLength - startingHeaderLength;
          this.headerBuffer.set(input.slice(this.offset - nNewBytes, nNewBytes), startingHeaderLength);

          typeAndVal = new BinaryXMLDecoder(this.headerBuffer.array).decodeTypeAndVal();
        }
        else {
          // We didn't have to use the headerBuffer.
          decoder.seek(this.offset - this.headerLength);
          typeAndVal = decoder.decodeTypeAndVal();
        }

        if (typeAndVal == null)
          throw new Error("BinaryXMLStructureDecoder: Can't read header starting at offset " +
                          (this.offset - this.headerLength));

        // Set the next state based on the type.
        var type = typeAndVal.t;
        if (type == XML_DATTR)
          // We already consumed the item. READ_HEADER_OR_CLOSE again.
          // ndnb has rules about what must follow an attribute, but we are just scanning.
          this.startHeader();
        else if (type == XML_DTAG || type == XML_EXT) {
          // Start a new level and READ_HEADER_OR_CLOSE again.
          ++this.level;
          this.startHeader();
        }
        else if (type == XML_TAG || type == XML_ATTR) {
          if (type == XML_TAG)
            // Start a new level and read the tag.
            ++this.level;
          // Minimum tag or attribute length is 1.
          this.nBytesToRead = typeAndVal.v + 1;
          this.state = BinaryXMLStructureDecoder.READ_BYTES;
          // ndnb has rules about what must follow an attribute, but we are just scanning.
        }
        else if (type == XML_BLOB || type == XML_UDATA) {
          this.nBytesToRead = typeAndVal.v;
          this.state = BinaryXMLStructureDecoder.READ_BYTES;
        }
        else
          throw new Error("BinaryXMLStructureDecoder: Unrecognized header type " + type);
        break;

      case BinaryXMLStructureDecoder.READ_BYTES:
        var nRemainingBytes = input.length - this.offset;
        if (nRemainingBytes < this.nBytesToRead) {
          // Need more.
          this.offset += nRemainingBytes;
          this.nBytesToRead -= nRemainingBytes;
          return false;
        }
        // Got the bytes.  Read a new header or close.
        this.offset += this.nBytesToRead;
        this.startHeader();
        break;

      default:
        // We don't expect this to happen.
        throw new Error("BinaryXMLStructureDecoder: Unrecognized state " + this.state);
    }
  }
};

/**
 * Set the state to READ_HEADER_OR_CLOSE and set up to start reading the header
 */
BinaryXMLStructureDecoder.prototype.startHeader = function()
{
  this.headerLength = 0;
  this.useHeaderBuffer = false;
  this.state = BinaryXMLStructureDecoder.READ_HEADER_OR_CLOSE;
};

/**
 *  Set the offset into the input, used for the next read.
 */
BinaryXMLStructureDecoder.prototype.seek = function(offset)
{
  this.offset = offset;
};
/**
 * Copyright (C) 2013 Regents of the University of California.
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 * This class represents Interest Objects
 */

/**
 * Create a WireFormat base class where the encode and decode methods throw an error. You should use a derived class like BinaryXmlWireFormat.
 * @constructor
 */
var WireFormat = function WireFormat() {
};

exports.WireFormat = WireFormat;

/**
 * The override method in the derived class should encode the interest and return a ndnbuf.
 * @param {Interest} interest
 * @returns {Buffer}
 * @throws Error This always throws an "unimplemented" error. The derived class should override.
 */
WireFormat.prototype.encodeInterest = function(interest)
{
  throw new Error("encodeInterest is unimplemented in the base WireFormat class.  You should use a derived class.");
};

/**
 * The override method in the derived class should decode the input and put the result in interest.
 * @param {Interest} interest
 * @param {Buffer} input
 * @throws Error This always throws an "unimplemented" error. The derived class should override.
 */
WireFormat.prototype.decodeInterest = function(interest, input)
{
  throw new Error("decodeInterest is unimplemented in the base WireFormat class.  You should use a derived class.");
};

/**
 * The override method in the derived class should encode the data and return a ndnbuf.
 * @param {Data} data
 * @returns {Buffer}
 * @throws Error This always throws an "unimplemented" error. The derived class should override.
 */
WireFormat.prototype.encodeData = function(data)
{
  throw new Error("encodeData is unimplemented in the base WireFormat class.  You should use a derived class.");
};

/**
 * The override method in the derived class should decode the input and put the result in data.
 * @param {Data} data
 * @param {Buffer} input
 * @throws Error This always throws an "unimplemented" error. The derived class should override.
 */
WireFormat.prototype.decodeData = function(data, input)
{
  throw new Error("decodeData is unimplemented in the base WireFormat class.  You should use a derived class.");
};


/**
 * Copyright (C) 2013 Regents of the University of California.
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 */


/**
 * A BinaryXmlElementReader lets you call onReceivedData multiple times which uses a
 * BinaryXMLStructureDecoder to detect the end of a binary XML element and calls
 * elementListener.onReceivedElement(element) with the element.
 * This handles the case where a single call to onReceivedData may contain multiple elements.
 * @constructor
 * @param {{onReceivedElement:function}} elementListener
 */
var BinaryXmlElementReader = function BinaryXmlElementReader(elementListener)
{
  this.elementListener = elementListener;
  this.dataParts = [];
  this.structureDecoder = new BinaryXMLStructureDecoder();
};

exports.BinaryXmlElementReader = BinaryXmlElementReader;

BinaryXmlElementReader.prototype.onReceivedData = function(/* ndnbuf */ data)
{
  // Process multiple objects in the data.
  while (true) {
    // Scan the input to check if a whole ndnb object has been read.
    this.structureDecoder.seek(0);
    if (this.structureDecoder.findElementEnd(data)) {
      // Got the remainder of an object.  Report to the caller.
      this.dataParts.push(data.slice(0, this.structureDecoder.offset));
      var element = DataUtils.concatArrays(this.dataParts);
      this.dataParts = [];
      try {
        this.elementListener.onReceivedElement(element);
      } catch (ex) {
          console.log("BinaryXmlElementReader: ignoring exception from onReceivedElement: " + ex);
      }

      // Need to read a new object.
      data = data.slice(this.structureDecoder.offset, data.length);
      this.structureDecoder = new BinaryXMLStructureDecoder();
      if (data.length == 0)
        // No more data in the packet.
        return;

      // else loop back to decode.
    }
    else {
      // Save for a later call to concatArrays so that we only copy data once.
      this.dataParts.push(data);
      if (LOG > 3) console.log('Incomplete packet received. Length ' + data.length + '. Wait for more input.');
        return;
    }
  }
};
/**
 * Copyright (C) 2013 Regents of the University of California.
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 */

/**
 * Create a context for getting the response from the name enumeration command, as neede by getComponents.
 * (To do name enumeration, call the static method NameEnumeration.getComponents.)
 * @param {Face} face The Face object for using expressInterest.
 * @param {function} onComponents The onComponents callback given to getComponents.
 */
var NameEnumeration = function NameEnumeration(face, onComponents)
{
  this.face = face;
  this.onComponents = onComponents;
  this.contentParts = [];

  var self = this;
  this.onData = function(interest, data) { self.processData(data); };
  this.onTimeout = function(interest) { self.processTimeout(); };
};

exports.NameEnumeration = NameEnumeration;

/**
 * Use the name enumeration protocol to get the child components of the name prefix.
 * @param {Face} face The Face object for using expressInterest.
 * @param {Name} name The name prefix for finding the child components.
 * @param {function} onComponents On getting the response, this calls onComponents(components) where
 * components is an array of ndnbuf name components.  If there is no response, this calls onComponents(null).
 */
NameEnumeration.getComponents = function(face, prefix, onComponents)
{
  var command = new Name(prefix);
  // Add %C1.E.be
  command.add([0xc1, 0x2e, 0x45, 0x2e, 0x62, 0x65])

  var enumeration = new NameEnumeration(face, onComponents);
  face.expressInterest(command, enumeration.onData, enumeration.onTimeout);
};









/**
 * Create a closure for getting the response from the name enumeration command.
 * @param {Face} face The Face object for using expressInterest.
 * @param {function} onComponents The onComponents callback given to getComponents.
 */
NameEnumeration.Closure = function NameEnumerationClosure(face, onComponents)
{
  // Inherit from Closure.
  Closure.call(this);

  this.face = face;
  this.onComponents = onComponents;
  this.contentParts = [];

  var enumeration = new NameEnumeration(face, onComponents);
  face.expressInterest(command, enumeration.onData, enumeration.onTimeout);
};

/**
 * Parse the response from the name enumeration command and call this.onComponents.
 * @param {Data} data
 */
NameEnumeration.prototype.processData = function(data)
{
  try {
    if (!NameEnumeration.endsWithSegmentNumber(data.name))
      // We don't expect a name without a segment number.  Treat it as a bad packet.
      this.onComponents(null);
    else {
      var segmentNumber = DataUtils.bigEndianToUnsignedInt
          (data.name.get(data.name.size() - 1).getValue());

      // Each time we get a segment, we put it in contentParts, so its length follows the segment numbers.
      var expectedSegmentNumber = this.contentParts.length;
      if (segmentNumber != expectedSegmentNumber)
        // Try again to get the expected segment.  This also includes the case where the first segment is not segment 0.
        this.face.expressInterest
          (data.name.getPrefix(-1).addSegment(expectedSegmentNumber), this.onData, this.onTimeout);
      else {
        // Save the content and check if we are finished.
        this.contentParts.push(data.content);

        if (data.signedInfo != null && data.signedInfo.finalBlockID != null) {
          var finalSegmentNumber = DataUtils.bigEndianToUnsignedInt(data.signedInfo.finalBlockID);
          if (segmentNumber == finalSegmentNumber) {
            // We are finished.  Parse and return the result.
            this.onComponents(NameEnumeration.parseComponents(Buffer.concat(this.contentParts)));
            return;
          }
        }

        // Fetch the next segment.
        this.face.expressInterest
          (data.name.getPrefix(-1).addSegment(expectedSegmentNumber + 1), this.onData, this.onTimeout);
      }
    }
  } catch (ex) {
    console.log("NameEnumeration: ignoring exception: " + ex);
  }
};

/**
 * Just call onComponents(null).
 */
NameEnumeration.prototype.processTimeout = function()
{
  try {
    this.onComponents(null);
  } catch (ex) {
    console.log("NameEnumeration: ignoring exception: " + ex);
  }
};

/**
 * Parse the content as a name enumeration response and return an array of components.  This makes a copy of the component.
 * @param {Uint8Array} content The content to parse.
 * @returns {Array<Buffer>} The array of components.
 */
NameEnumeration.parseComponents = function(content)
{
  var components = [];
  var decoder = new BinaryXMLDecoder(content);

  decoder.readElementStartDTag(NDNProtocolDTags.Collection);

  while (decoder.peekDTag(NDNProtocolDTags.Link)) {
    decoder.readElementStartDTag(NDNProtocolDTags.Link);
    decoder.readElementStartDTag(NDNProtocolDTags.Name);

    components.push(new ndnbuf(decoder.readBinaryDTagElement(NDNProtocolDTags.Component)));

    decoder.readElementClose();
    decoder.readElementClose();
  }

  decoder.readElementClose();
  return components;
};

/**
 * Check if the last component in the name is a segment number.
 * TODO: Move to Name class.
 * @param {Name} name
 * @returns {Boolean} True if the name ends with a segment number, otherwise false.
 */
NameEnumeration.endsWithSegmentNumber = function(name) {
  return name.components != null && name.size() >= 1 &&
         name.get(name.size() - 1).getValue().length >= 1 &&
         name.get(name.size() - 1).getValue()[0] == 0;
};
/**
 * Copyright (C) 2013 Regents of the University of California.
 * @author: Wentao Shang
 * See COPYING for copyright and distribution information.
 */

/**
 * @constructor
 */
var WebSocketTransport = function WebSocketTransport()
{
  if (!WebSocket)
    throw new Error("WebSocket support is not available on this platform.");

  this.ws = null;
  this.connectedHost = null; // Read by Face.
  this.connectedPort = null; // Read by Face.
  this.elementReader = null;
  this.defaultGetHostAndPort = Face.makeShuffledGetHostAndPort
    (["A.ws.ndn.ucla.edu", "B.ws.ndn.ucla.edu", "C.ws.ndn.ucla.edu", "D.ws.ndn.ucla.edu",
      "E.ws.ndn.ucla.edu"],
     9696);
};

exports.WebSocketTransport = WebSocketTransport;

/**
 * Connect to the host and port in face.  This replaces a previous connection and sets connectedHost
 *   and connectedPort.  Once connected, call onopenCallback().
 * Listen on the port to read an entire binary XML encoded element and call
 *    face.onReceivedElement(element).
 */
WebSocketTransport.prototype.connect = function(face, onopenCallback)
{
  if (this.ws != null)
    delete this.ws;

  this.ws = new WebSocket('ws://' + face.host + ':' + face.port);
  if (LOG > 0) console.log('ws connection created.');
    this.connectedHost = face.host;
    this.connectedPort = face.port;

  this.ws.binaryType = "arraybuffer";

  this.elementReader = new BinaryXmlElementReader(face);
  var self = this;
  this.ws.onmessage = function(ev) {
    var result = ev.data;
    //console.log('RecvHandle called.');

    if (result == null || result == undefined || result == "") {
      console.log('INVALID ANSWER');
    }
    else if (result instanceof ArrayBuffer) {
      var bytearray = new ndnbuf(result);

      if (LOG > 3) console.log('BINARY RESPONSE IS ' + bytearray.toString('hex'));

      try {
        // Find the end of the binary XML element and call face.onReceivedElement.
        self.elementReader.onReceivedData(bytearray);
      } catch (ex) {
        console.log("NDN.ws.onmessage exception: " + ex);
        return;
      }
    }
  }

  this.ws.onopen = function(ev) {
    if (LOG > 3) console.log(ev);
    if (LOG > 3) console.log('ws.onopen: WebSocket connection opened.');
    if (LOG > 3) console.log('ws.onopen: ReadyState: ' + this.readyState);
    // Face.registerPrefix will fetch the ndndid when needed.

    onopenCallback();
  }

  this.ws.onerror = function(ev) {
    console.log('ws.onerror: ReadyState: ' + this.readyState);
    console.log(ev);
    console.log('ws.onerror: WebSocket error: ' + ev.data);
  }

  this.ws.onclose = function(ev) {
    console.log('ws.onclose: WebSocket connection closed.');
    self.ws = null;

    // Close Face when WebSocket is closed
    face.readyStatus = Face.CLOSED;
    face.onclose();
    //console.log("NDN.onclose event fired.");
  }
};

/**
 * Send the Uint8Array data.
 */
WebSocketTransport.prototype.send = function(data)
{
  if (this.ws != null) {
    // If we directly use data.buffer to feed ws.send(),
    // WebSocket may end up sending a packet with 10000 bytes of data.
    // That is, WebSocket will flush the entire ndnbuf
    // regardless of the offset of the Uint8Array. So we have to create
    // a new Uint8Array ndnbuf with just the right size and copy the
    // content from binaryInterest to the new ndnbuf.
    //    ---Wentao
    var bytearray = new Uint8Array(data.length);
    bytearray.set(data);
    this.ws.send(bytearray.buffer);
    if (LOG > 3) console.log('ws.send() returned.');
  }
  else
    console.log('WebSocket connection is not established.');
};
/**
 * Copyright (C) 2013 Regents of the University of California.
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 */

// The Face constructor uses TcpTransport by default which is not available in the browser, so override to WebSocketTransport.
TcpTransport = WebSocketTransport;
/**
 * Copyright (C) 2013 Regents of the University of California.
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 * Provide the callback closure for the async communication methods in the Face class.
 * This is a port of Closure.py from PyNDN, written by:
 * Derek Kulinski <takeda@takeda.tk>
 * Jeff Burke <jburke@ucla.edu>
 */

/**
 * A subclass of Closure is passed to expressInterest and registerPrefix.
 * @deprecated You should use the forms of expressInterest and registerPrefix which use callbacks instead of Closure.
 * @constructor
 */
var Closure = function Closure()
{
  // I don't think storing Face's closure is needed
  // and it creates a reference loop, as of now both
  // of those variables are never set -- Derek
  //
  // Use instance variables to return data to callback
  this.ndn_data = null;  // this holds the ndn_closure
  this.ndn_data_dirty = false;
};

exports.Closure = Closure;

// Upcall result
Closure.RESULT_ERR               = -1; // upcall detected an error
Closure.RESULT_OK                =  0; // normal upcall return
Closure.RESULT_REEXPRESS         =  1; // reexpress the same interest again
Closure.RESULT_INTEREST_CONSUMED =  2; // upcall claims to consume interest
Closure.RESULT_VERIFY            =  3; // force an unverified result to be verified
Closure.RESULT_FETCHKEY          =  4; // get the key in the key locator and re-call the interest
                                       //   with the key available in the local storage

// Upcall kind
Closure.UPCALL_FINAL              = 0; // handler is about to be deregistered
Closure.UPCALL_INTEREST           = 1; // incoming interest
Closure.UPCALL_CONSUMED_INTEREST  = 2; // incoming interest, someone has answered
Closure.UPCALL_CONTENT            = 3; // incoming verified content
Closure.UPCALL_INTEREST_TIMED_OUT = 4; // interest timed out
Closure.UPCALL_CONTENT_UNVERIFIED = 5; // content that has not been verified
Closure.UPCALL_CONTENT_BAD        = 6; // verification failed

/**
 * Override this in your subclass.
 * If you're getting strange errors in upcall()
 * check your code whether you're returning a value.
 */
Closure.prototype.upcall = function(kind, upcallInfo)
{
  //dump('upcall ' + this + " " + kind + " " + upcallInfo + "\n");
  return Closure.RESULT_OK;
};

/**
 * An UpcallInfo is passed to Closure.upcall.
 * @constructor
 */
var UpcallInfo = function UpcallInfo(face, interest, matchedComps, data)
{
  this.face = face;  // Face object (not used)
  this.ndn = face;   // deprecated
  this.interest = interest;  // Interest object
  this.matchedComps = matchedComps;  // int
  this.data = data;  // Data
  this.contentObject = data; // deprecated.  Include for backward compatibility.
};

UpcallInfo.prototype.toString = function()
{
  var ret = "face = " + this.face;
  ret += "\nInterest = " + this.interest;
  ret += "\nmatchedComps = " + this.matchedComps;
  ret += "\nData: " + this.data;
  return ret;
};

exports.UpcallInfo = UpcallInfo;
/**
 * Copyright (C) 2013 Regents of the University of California.
 * @author: Meki Cheraoui
 * See COPYING for copyright and distribution information.
 * This class represents PublisherPublicKeyDigest Objects
 */


/**
 * @constructor
 */
var PublisherPublicKeyDigest = function PublisherPublicKeyDigest(pkd)
{
 this.PUBLISHER_ID_LEN = 512/8;
 this.publisherPublicKeyDigest = pkd;
};

exports.PublisherPublicKeyDigest = PublisherPublicKeyDigest;

PublisherPublicKeyDigest.prototype.from_ndnb = function(decoder)
{
  this.publisherPublicKeyDigest = decoder.readBinaryDTagElement(this.getElementLabel());

  if (LOG > 4) console.log('Publisher public key digest is ' + this.publisherPublicKeyDigest);

  if (null == this.publisherPublicKeyDigest)
    throw new Error("Cannot parse publisher key digest.");

  //TODO check if the length of the PublisherPublicKeyDigest is correct (Security reason)

  if (this.publisherPublicKeyDigest.length != this.PUBLISHER_ID_LEN) {
    if (LOG > 0)
      console.log('LENGTH OF PUBLISHER ID IS WRONG! Expected ' + this.PUBLISHER_ID_LEN + ", got " + this.publisherPublicKeyDigest.length);

    //this.publisherPublicKeyDigest = new PublisherPublicKeyDigest(this.PublisherPublicKeyDigest).PublisherKeyDigest;
  }
};

PublisherPublicKeyDigest.prototype.to_ndnb= function(encoder)
{
  //TODO Check that the ByteArray for the key is present
  if (!this.validate())
    throw new Error("Cannot encode : field values missing.");

  if (LOG > 3) console.log('PUBLISHER KEY DIGEST IS'+this.publisherPublicKeyDigest);
  encoder.writeDTagElement(this.getElementLabel(), this.publisherPublicKeyDigest);
};

PublisherPublicKeyDigest.prototype.getElementLabel = function() { return NDNProtocolDTags.PublisherPublicKeyDigest; };

PublisherPublicKeyDigest.prototype.validate = function()
{
    return null != this.publisherPublicKeyDigest;
};
/**
 * Copyright (C) 2013 Regents of the University of California.
 * @author: Meki Cheraoui
 * See COPYING for copyright and distribution information.
 * This class represents Publisher and PublisherType Objects
 */

/**
 * @constructor
 */
var PublisherType = function PublisherType(tag)
{
  this.KEY = NDNProtocolDTags.PublisherPublicKeyDigest;
  this.CERTIFICATE = NDNProtocolDTags.PublisherCertificateDigest;
  this.ISSUER_KEY = NDNProtocolDTags.PublisherIssuerKeyDigest;
  this.ISSUER_CERTIFICATE = NDNProtocolDTags.PublisherIssuerCertificateDigest;

  this.Tag = tag;
};

/**
 * @constructor
 */
var PublisherID = function PublisherID()
{
  this.PUBLISHER_ID_DIGEST_ALGORITHM = "SHA-256";
  this.PUBLISHER_ID_LEN = 256/8;

  //TODO, implement publisherID creation and key creation

  //TODO implement generatePublicKeyDigest
  this.publisherID =null;//= generatePublicKeyDigest(key);//ByteArray

  //TODO implement generate key
  //CryptoUtil.generateKeyID(PUBLISHER_ID_DIGEST_ALGORITHM, key);
  this.publisherType = null;//isIssuer ? PublisherType.ISSUER_KEY : PublisherType.KEY;//publisher Type
};

exports.PublisherID = PublisherID;

PublisherID.prototype.from_ndnb = function(decoder)
{
  // We have a choice here of one of 4 binary element types.
  var nextTag = PublisherID.peekAndGetNextDTag(decoder);

  this.publisherType = new PublisherType(nextTag);

  if (nextTag < 0)
    throw new Error("Invalid publisher ID, got unexpected type");

  this.publisherID = decoder.readBinaryDTagElement(nextTag);
  if (null == this.publisherID)
    throw new ContentDecodingException(new Error("Cannot parse publisher ID of type : " + nextTag + "."));
};

PublisherID.prototype.to_ndnb = function(encoder)
{
  if (!this.validate())
    throw new Error("Cannot encode " + this.getClass().getName() + ": field values missing.");

  encoder.writeDTagElement(this.getElementLabel(), this.publisherID);
};

/**
 * Peek the next DTag in the decoder and return it if it is a PublisherID DTag.
 * @param {BinaryXMLDecoder} decoder The BinaryXMLDecoder with the input to decode.
 * @returns {number} The PublisherID DTag or -1 if it is not one of them.
 */
PublisherID.peekAndGetNextDTag = function(decoder)
{
  if (decoder.peekDTag(NDNProtocolDTags.PublisherPublicKeyDigest))
    return             NDNProtocolDTags.PublisherPublicKeyDigest;
  if (decoder.peekDTag(NDNProtocolDTags.PublisherCertificateDigest))
    return             NDNProtocolDTags.PublisherCertificateDigest;
  if (decoder.peekDTag(NDNProtocolDTags.PublisherIssuerKeyDigest))
    return             NDNProtocolDTags.PublisherIssuerKeyDigest;
  if (decoder.peekDTag(NDNProtocolDTags.PublisherIssuerCertificateDigest))
    return             NDNProtocolDTags.PublisherIssuerCertificateDigest;

  return -1;
};

PublisherID.peek = function(/* XMLDecoder */ decoder)
{
  return PublisherID.peekAndGetNextDTag(decoder) >= 0;
};

PublisherID.prototype.getElementLabel = function()
{
  return this.publisherType.Tag;
};

PublisherID.prototype.validate = function()
{
  return null != id() && null != type();
};
/**
 * Copyright (C) 2013 Regents of the University of California.
 * @author: Meki Cheraoui, Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 * This class represents a Name as an array of components where each is a byte array.
 */

/**
 * Create a new Name from components.
 *
 * @constructor
 * @param {string|Name|Array<string|Array<number>|ArrayBuffer|Buffer|Name>} components if a string, parse it as a URI.  If a Name, add a deep copy of its components.
 * Otherwise it is an array of components which are appended according to Name.append, so
 * convert each and store it as an array of ndnbuf.  If a component is a string, encode as utf8.
 */
var Name = function Name(components)
{
  if (typeof components == 'string') {
    if (LOG > 3) console.log('Content Name String ' + components);
    this.components = Name.createNameArray(components);
  }
  else if (typeof components === 'object') {
    this.components = [];
    if (components instanceof Name)
      this.append(components);
    else {
      for (var i = 0; i < components.length; ++i)
        this.append(components[i]);
    }
  }
  else if (components== null)
    this.components =[];
  else
    if (LOG > 1) console.log("NO CONTENT NAME GIVEN");
};

exports.Name = Name;

/**
 *
 * @constructor
 * Create a new Name.Component with a copy of the given value.
 * @param {Name.Component|String|Array<number>|ArrayBuffer|Buffer} value If the value is a string, encode it as utf8 (but don't unescape).
 */
Name.Component = function NameComponent(value)
{
  if (typeof value == 'string')
    this.value = DataUtils.stringToUtf8Array(value);
  else if (typeof value == 'object' && value instanceof Name.Component)
    this.value = new ndnbuf(value.value);
  else if (typeof value == 'object' && value instanceof ndnbuf)
    this.value = new ndnbuf(value);
  else if (typeof value == 'object' && typeof ArrayBuffer != 'undefined' &&  value instanceof ArrayBuffer) {
    // Make a copy.  Don't use ArrayBuffer.slice since it isn't always supported.
    this.value = new ndnbuf(new ArrayBuffer(value.byteLength));
    this.value.set(new ndnbuf(value));
  }
  else if (typeof value == 'object')
    // Assume value is a byte array.  We can't check instanceof Array because
    //   this doesn't work in JavaScript if the array comes from a different module.
    this.value = new ndnbuf(value);
  else
    throw new Error("Name.Component constructor: Invalid type");
}

/**
 * Get the component value.
 * @returns {Buffer} The component value.
 */
Name.Component.prototype.getValue = function()
{
  return this.value;
}

/**
 * Convert this component value to a string by escaping characters according to the NDN URI Scheme.
 * This also adds "..." to a value with zero or more ".".
 * @returns {string} The escaped string.
 */
Name.Component.prototype.toEscapedString = function()
{
  return Name.toEscapedString(this.value);
}

/**
 * @deprecated Use toUri.
 */
Name.prototype.getName = function()
{
  return this.toUri();
};

/** Parse uri as a URI and return an array of ndnbuf components.
 */
Name.createNameArray = function(uri)
{
  uri = uri.trim();
  if (uri.length <= 0)
    return [];

  var iColon = uri.indexOf(':');
  if (iColon >= 0) {
    // Make sure the colon came before a '/'.
    var iFirstSlash = uri.indexOf('/');
    if (iFirstSlash < 0 || iColon < iFirstSlash)
      // Omit the leading protocol such as ndn:
      uri = uri.substr(iColon + 1, uri.length - iColon - 1).trim();
  }

  if (uri[0] == '/') {
    if (uri.length >= 2 && uri[1] == '/') {
      // Strip the authority following "//".
      var iAfterAuthority = uri.indexOf('/', 2);
      if (iAfterAuthority < 0)
        // Unusual case: there was only an authority.
        return [];
      else
        uri = uri.substr(iAfterAuthority + 1, uri.length - iAfterAuthority - 1).trim();
    }
    else
      uri = uri.substr(1, uri.length - 1).trim();
  }

  var array = uri.split('/');

  // Unescape the components.
  for (var i = 0; i < array.length; ++i) {
    var value = Name.fromEscapedString(array[i]);

    if (value == null) {
      // Ignore the illegal componenent.  This also gets rid of a trailing '/'.
      array.splice(i, 1);
      --i;
      continue;
    }
    else
      array[i] = new Name.Component(value);
  }

  return array;
};

Name.prototype.from_ndnb = function(/*XMLDecoder*/ decoder)
{
  decoder.readElementStartDTag(this.getElementLabel());

  this.components = [];

  while (decoder.peekDTag(NDNProtocolDTags.Component))
    this.append(decoder.readBinaryDTagElement(NDNProtocolDTags.Component));

  decoder.readElementClose();
};

Name.prototype.to_ndnb = function(/*XMLEncoder*/ encoder)
{
  if (this.components == null)
    throw new Error("CANNOT ENCODE EMPTY CONTENT NAME");

  encoder.writeElementStartDTag(this.getElementLabel());
  var count = this.size();
  for (var i=0; i < count; i++)
    encoder.writeDTagElement(NDNProtocolDTags.Component, this.components[i].getValue());

  encoder.writeElementClose();
};

Name.prototype.getElementLabel = function()
{
  return NDNProtocolDTags.Name;
};

/**
 * Convert the component to a ndnbuf and append to this Name.
 * Return this Name object to allow chaining calls to add.
 * @param {Name.Component|String|Array<number>|ArrayBuffer|Buffer|Name} component If a component is a string, encode as utf8 (but don't unescape).
 * @returns {Name}
 */
Name.prototype.append = function(component)
{
  if (typeof component == 'object' && component instanceof Name) {
    var components;
    if (component == this)
      // special case, when we need to create a copy
      components = this.components.slice(0, this.components.length);
    else
      components = component.components;

    for (var i = 0; i < components.length; ++i)
      this.components.push(new Name.Component(components[i]));
  }
  else
    // Just use the Name.Component constructor.
    this.components.push(new Name.Component(component));

  return this;
};

/**
 * @deprecated Use append.
 */
Name.prototype.add = function(component)
{
  return this.append(component);
};

/**
 * Return the escaped name string according to "NDNx URI Scheme".
 * @returns {String}
 */
Name.prototype.toUri = function()
{
  if (this.size() == 0)
    return "/";

  var result = "";

  for (var i = 0; i < this.size(); ++i)
    result += "/"+ Name.toEscapedString(this.components[i].getValue());

  return result;
};

/**
 * @deprecated Use toUri.
 */
Name.prototype.to_uri = function()
{
  return this.toUri();
};

/**
 * Append a component that represents a segment number
 *
 * This component has a special format handling:
 * - if number is zero, then %00 is added
 * - if number is between 1 and 255, %00%01 .. %00%FF is added
 * - ...
 * @param {number} number the segment number (integer is expected)
 * @returns {Name}
 */
Name.prototype.appendSegment = function(number)
{
  var segmentNumberBigEndian = DataUtils.nonNegativeIntToBigEndian(number);
  // Put a 0 byte in front.
  var segmentNumberComponent = new ndnbuf(segmentNumberBigEndian.length + 1);
  segmentNumberComponent[0] = 0;
  segmentNumberBigEndian.copy(segmentNumberComponent, 1);

  this.components.push(new Name.Component(segmentNumberComponent));
  return this;
};

/**
 * @deprecated Use appendSegment.
 */
Name.prototype.addSegment = function(number)
{
  return this.appendSegment(number);
};

/**
 * Get a new name, constructed as a subset of components.
 * @param {number} iStartComponent The index if the first component to get.
 * @param {number} (optional) nComponents The number of components starting at iStartComponent.  If omitted,
 * return components starting at iStartComponent until the end of the name.
 * @returns {Name} A new name.
 */
Name.prototype.getSubName = function(iStartComponent, nComponents)
{
  if (nComponents == undefined)
    nComponents = this.components.length - iStartComponent;

  var result = new Name();

  var iEnd = iStartComponent + nComponents;
  for (var i = iStartComponent; i < iEnd && i < this.components.length; ++i)
    result.components.push(this.components[i]);

  return result;
};

/**
 * Return a new Name with the first nComponents components of this Name.
 * @param {number} nComponents The number of prefix components.  If nComponents is -N then return the prefix up
 * to name.size() - N. For example getPrefix(-1) returns the name without the final component.
 * @returns {Name} A new name.
 */
Name.prototype.getPrefix = function(nComponents)
{
  if (nComponents < 0)
    return this.getSubName(0, this.components.length + nComponents);
  else
    return this.getSubName(0, nComponents);
};

/**
 * @brief Get prefix of the name, containing less minusComponents right components
 * @param minusComponents number of components to cut from the back
 */
Name.prototype.cut = function(minusComponents)
{
  return new Name(this.components.slice(0, this.components.length - minusComponents));
};

/**
 * Return the number of name components.
 * @returns {number}
 */
Name.prototype.size = function()
{
  return this.components.length;
};

/**
 * Return a new Name.Component of the component at the given index.  To get just the component value, use get(i).getValue().
 * @param {Number} i The index of the component, starting from 0.  However, if i is negative, return the component
 * at size() - (-i).
 * @returns {Name.Component}
 */
Name.prototype.get = function(i)
{
  if (i >= 0) {
    if (i >= this.components.length)
      throw new Error("Name.get: Index is out of bounds");

    return new Name.Component(this.components[i]);
  }
  else {
    // Negative index.
    if (i < -this.components.length)
      throw new Error("Name.get: Index is out of bounds");

    return new Name.Component(this.components[this.components.length - (-i)]);
  }
};

/**
 * @deprecated Use size().
 */
Name.prototype.getComponentCount = function()
{
  return this.components.length;
};

/**
 * @deprecated To get just the component value, use get(i).getValue().
 */
Name.prototype.getComponent = function(i)
{
  return new ndnbuf(this.components[i].getValue());
};

/**
 * The "file name" in a name is the last component that isn't blank and doesn't start with one of the
 *   special marker octets (for version, etc.).  Return the index in this.components of
 *   the file name, or -1 if not found.
 */
Name.prototype.indexOfFileName = function()
{
  for (var i = this.size() - 1; i >= 0; --i) {
    var component = this.components[i].getValue();
    if (component.length <= 0)
      continue;

    if (component[0] == 0 || component[0] == 0xC0 || component[0] == 0xC1 ||
        (component[0] >= 0xF5 && component[0] <= 0xFF))
      continue;

    return i;
  }

  return -1;
};

/**
 * Return true if this Name has the same components as name.
 */
Name.prototype.equals = function(name)
{
  if (this.components.length != name.components.length)
    return false;

  // Start from the last component because they are more likely to differ.
  for (var i = this.components.length - 1; i >= 0; --i) {
    if (!DataUtils.arraysEqual(this.components[i].getValue(), name.components[i].getValue()))
      return false;
  }

  return true;
};

/**
 * @deprecated Use equals.
 */
Name.prototype.equalsName = function(name)
{
  return this.equals(name);
};

/**
 * Find the last component in name that has a ContentDigest and return the digest value as ndnbuf,
 *   or null if not found.  See Name.getComponentContentDigestValue.
 */
Name.prototype.getContentDigestValue = function()
{
  for (var i = this.size() - 1; i >= 0; --i) {
    var digestValue = Name.getComponentContentDigestValue(this.components[i]);
    if (digestValue != null)
      return digestValue;
  }

  return null;
};

/**
 * If component is a ContentDigest, return the digest value as a ndnbuf slice (don't modify!).
 * If not a ContentDigest, return null.
 * A ContentDigest component is Name.ContentDigestPrefix + 32 bytes + Name.ContentDigestSuffix.
 */
Name.getComponentContentDigestValue = function(component)
{
  if (typeof component == 'object' && component instanceof Name.Component)
    component = component.getValue();

  var digestComponentLength = Name.ContentDigestPrefix.length + 32 + Name.ContentDigestSuffix.length;
  // Check for the correct length and equal ContentDigestPrefix and ContentDigestSuffix.
  if (component.length == digestComponentLength &&
      DataUtils.arraysEqual(component.slice(0, Name.ContentDigestPrefix.length),
                            Name.ContentDigestPrefix) &&
      DataUtils.arraysEqual(component.slice
         (component.length - Name.ContentDigestSuffix.length, component.length),
                            Name.ContentDigestSuffix))
   return component.slice(Name.ContentDigestPrefix.length, Name.ContentDigestPrefix.length + 32);
 else
   return null;
};

// Meta GUID "%C1.M.G%C1" + ContentDigest with a 32 byte BLOB.
Name.ContentDigestPrefix = new ndnbuf([0xc1, 0x2e, 0x4d, 0x2e, 0x47, 0xc1, 0x01, 0xaa, 0x02, 0x85]);
Name.ContentDigestSuffix = new ndnbuf([0x00]);


/**
 * Return value as an escaped string according to "NDNx URI Scheme".
 * We can't use encodeURIComponent because that doesn't encode all the characters we want to.
 * @param {Buffer|Name.Component} component The value or Name.Component to escape.
 * @returns {string} The escaped string.
 */
Name.toEscapedString = function(value)
{
  if (typeof value == 'object' && value instanceof Name.Component)
    value = value.getValue();

  var result = "";
  var gotNonDot = false;
  for (var i = 0; i < value.length; ++i) {
    if (value[i] != 0x2e) {
      gotNonDot = true;
      break;
    }
  }
  if (!gotNonDot) {
    // Special case for component of zero or more periods.  Add 3 periods.
    result = "...";
    for (var i = 0; i < value.length; ++i)
      result += ".";
  }
  else {
    for (var i = 0; i < value.length; ++i) {
      var x = value[i];
      // Check for 0-9, A-Z, a-z, (+), (-), (.), (_)
      if (x >= 0x30 && x <= 0x39 || x >= 0x41 && x <= 0x5a ||
          x >= 0x61 && x <= 0x7a || x == 0x2b || x == 0x2d ||
          x == 0x2e || x == 0x5f)
        result += String.fromCharCode(x);
      else
        result += "%" + (x < 16 ? "0" : "") + x.toString(16).toUpperCase();
    }
  }
  return result;
};

/**
 * Return a ndnbuf byte array by decoding the escapedString according to "NDNx URI Scheme".
 * If escapedString is "", "." or ".." then return null, which means to skip the component in the name.
 * @param {string} escapedString The escaped string to decode.
 * @returns {Buffer} The byte array, or null which means to skip the component in the name.
 */
Name.fromEscapedString = function(escapedString)
{
  var value = unescape(escapedString.trim());

  if (value.match(/[^.]/) == null) {
    // Special case for value of only periods.
    if (value.length <= 2)
      // Zero, one or two periods is illegal.  Ignore this componenent to be
      //   consistent with the C implementation.
      return null;
    else
      // Remove 3 periods.
      return DataUtils.toNumbersFromString(value.substr(3, value.length - 3));
  }
  else
    return DataUtils.toNumbersFromString(value);
};

/**
 * Return true if the N components of this name are the same as the first N components of the given name.
 * @param {Name} name The name to check.
 * @returns {Boolean} true if this matches the given name.  This always returns true if this name is empty.
 */
Name.prototype.match = function(name)
{
  var i_name = this.components;
  var o_name = name.components;

  // This name is longer than the name we are checking it against.
  if (i_name.length > o_name.length)
    return false;

  // Check if at least one of given components doesn't match.
  for (var i = 0; i < i_name.length; ++i) {
    if (!DataUtils.arraysEqual(i_name[i].getValue(), o_name[i].getValue()))
      return false;
  }

  return true;
};
/**
 * Copyright (C) 2013 Regents of the University of California.
 * @author: Meki Cheraoui
 * See COPYING for copyright and distribution information.
 */


/**
 * @constructor
 */
var KeyManager = function KeyManager()
{
  this.certificate =
  "MIIBmzCCAQQCCQC32FyQa61S7jANBgkqhkiG9w0BAQUFADASMRAwDgYDVQQDEwd" +
  "heGVsY2R2MB4XDTEyMDQyODIzNDQzN1oXDTEyMDUyODIzNDQzN1owEjEQMA4GA1" +
  "UEAxMHYXhlbGNkdjCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA4X0wp9goq" +
  "xuECxdULcr2IHr9Ih4Iaypg0Wy39URIup8/CLzQmdsh3RYqd55hqonu5VTTpH3i" +
  "MLx6xZDVJAZ8OJi7pvXcQ2C4Re2kjL2c8SanI0RfDhlS1zJadfr1VhRPmpivcYa" +
  "wJ4aFuOLAi+qHFxtN7lhcGCgpW1OV60oXd58CAwEAATANBgkqhkiG9w0BAQUFAA" +
  "OBgQDLOrA1fXzSrpftUB5Ro6DigX1Bjkf7F5Bkd69hSVp+jYeJFBBlsILQAfSxU" +
  "ZPQtD+2Yc3iCmSYNyxqu9PcufDRJlnvB7PG29+L3y9lR37tetzUV9eTscJ7rdp8" +
  "Wt6AzpW32IJ/54yKNfP7S6ZIoIG+LP6EIxq6s8K1MXRt8uBJKw==";

  // Public Key
    this.publicKey =
  "-----BEGIN PUBLIC KEY-----\n" +
  "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDhfTCn2CirG4QLF1QtyvYgev0i\n" +
  "HghrKmDRbLf1REi6nz8IvNCZ2yHdFip3nmGqie7lVNOkfeIwvHrFkNUkBnw4mLum\n" +
  "9dxDYLhF7aSMvZzxJqcjRF8OGVLXMlp1+vVWFE+amK9xhrAnhoW44sCL6ocXG03u\n" +
  "WFwYKClbU5XrShd3nwIDAQAB\n" +
  "-----END PUBLIC KEY-----";
  // Private Key
    this.privateKey =
  "-----BEGIN RSA PRIVATE KEY-----\n" +
  "MIICXQIBAAKBgQDhfTCn2CirG4QLF1QtyvYgev0iHghrKmDRbLf1REi6nz8IvNCZ\n" +
  "2yHdFip3nmGqie7lVNOkfeIwvHrFkNUkBnw4mLum9dxDYLhF7aSMvZzxJqcjRF8O\n" +
  "GVLXMlp1+vVWFE+amK9xhrAnhoW44sCL6ocXG03uWFwYKClbU5XrShd3nwIDAQAB\n" +
  "AoGAGkv6T6jC3WmhFZYL6CdCWvlc6gysmKrhjarrLTxgavtFY6R5g2ft5BXAsCCV\n" +
  "bUkWxkIFSKqxpVNl0gKZCNGEzPDN6mHJOQI/h0rlxNIHAuGfoAbCzALnqmyZivhJ\n" +
  "APGijAyKuU9tczsst5+Kpn+bn7ehzHQuj7iwJonS5WbojqECQQD851K8TpW2GrRi\n" +
  "zNgG4dx6orZxAaon/Jnl8lS7soXhllQty7qG+oDfzznmdMsiznCqEABzHUUKOVGE\n" +
  "9RWPN3aRAkEA5D/w9N55d0ibnChFJlc8cUAoaqH+w+U3oQP2Lb6AZHJpLptN4y4b\n" +
  "/uf5d4wYU5/i/gC7SSBH3wFhh9bjRLUDLwJAVOx8vN0Kqt7myfKNbCo19jxjVSlA\n" +
  "8TKCn1Oznl/BU1I+rC4oUaEW25DjmX6IpAR8kq7S59ThVSCQPjxqY/A08QJBAIRa\n" +
  "F2zGPITQk3r/VumemCvLWiRK/yG0noc9dtibqHOWbCtcXtOm/xDWjq+lis2i3ssO\n" +
  "vYrvrv0/HcDY+Dv1An0CQQCLJtMsfSg4kvG/FRY5UMhtMuwo8ovYcMXt4Xv/LWaM\n" +
  "hndD67b2UGawQCRqr5ghRTABWdDD/HuuMBjrkPsX0861\n" +
  "-----END RSA PRIVATE KEY-----";

  this.key = null;
};

/**
 * Return a Key object for the keys in this KeyManager.  This creates the Key on the first
 * call and returns a cached copy after that.
 * @returns {Key}
 */
KeyManager.prototype.getKey = function()
{
  if (this.key === null) {
    this.key = new Key();
    this.key.fromPemString(this.publicKey, this.privateKey);
  }

  return this.key;
}

var globalKeyManager = globalKeyManager || new KeyManager();
ndn.globalKeyManager = globalKeyManager
exports.globalKeyManager = globalKeyManager;
/**
 * Copyright (C) 2013 Regents of the University of California.
 * @author: Meki Cheraoui
 * See COPYING for copyright and distribution information.
 * This class represents Data Objects
 */


/**
 * Create a new Data with the optional values.
 *
 * @constructor
 * @param {Name} name
 * @param {SignedInfo} signedInfo
 * @param {Buffer} content
 */
var Data = function Data(name, signedInfo, content)
{
  if (typeof name == 'string')
    this.name = new Name(name);
  else
    //TODO Check the class of name
    this.name = name;

  this.signedInfo = signedInfo;

  if (typeof content == 'string')
    this.content = DataUtils.toNumbersFromString(content);
  else
    this.content = content;

  this.signature = new Signature();

  this.startSIG = null;
  this.endSIG = null;

  this.endContent = null;

  this.rawSignatureData = null;
};

exports.Data = Data;

Data.prototype.sign = function()
{
  var n1 = this.encodeObject(this.name);
  var n2 = this.encodeObject(this.signedInfo);
  var n3 = this.encodeContent();

  var rsa = ndn.createSign('RSA-SHA256');
  rsa.update(n1);
  rsa.update(n2);
  rsa.update(n3);

  var sig = new ndnbuf(rsa.sign(ndn.globalKeyManager.privateKey));

  this.signature.signature = sig;
};

Data.prototype.verify = function(/*Key*/ key)
{
  if (key == null || key.publicKeyPem == null)
    throw new Error('Cannot verify Data without a public key.');

  var verifier = ndn.createVerify('RSA-SHA256');
  verifier.update(this.rawSignatureData);
  return verifier.verify(key.publicKeyPem, this.signature.signature);
};

Data.prototype.encodeObject = function encodeObject(obj)
{
  var enc = new BinaryXMLEncoder();
  obj.to_ndnb(enc);
  var num = enc.getReducedOstream();

  return num;
};

Data.prototype.encodeContent = function encodeContent()
{
  var enc = new BinaryXMLEncoder();
  enc.writeDTagElement(NDNProtocolDTags.Content, this.content);
  var num = enc.getReducedOstream();

  return num;
};

Data.prototype.saveRawData = function(bytes)
{
  var sigBits = bytes.slice(this.startSIG, this.endSIG);
  this.rawSignatureData = new ndnbuf(sigBits);
};

Data.prototype.getElementLabel = function() { return NDNProtocolDTags.Data; };

/**
 * Create a new Signature with the optional values.
 * @constructor
 */
var Signature = function Signature(witness, signature, digestAlgorithm)
{
  this.witness = witness;
  this.signature = signature;
  this.digestAlgorithm = digestAlgorithm
};

exports.Signature = Signature;

Signature.prototype.from_ndnb = function(decoder)
{
  decoder.readElementStartDTag(this.getElementLabel());

  if (LOG > 4) console.log('STARTED DECODING SIGNATURE');

  if (decoder.peekDTag(NDNProtocolDTags.DigestAlgorithm)) {
    if (LOG > 4) console.log('DIGIEST ALGORITHM FOUND');
    this.digestAlgorithm = decoder.readUTF8DTagElement(NDNProtocolDTags.DigestAlgorithm);
  }
  if (decoder.peekDTag(NDNProtocolDTags.Witness)) {
    if (LOG > 4) console.log('WITNESS FOUND');
    this.witness = decoder.readBinaryDTagElement(NDNProtocolDTags.Witness);
  }

  //FORCE TO READ A SIGNATURE

  if (LOG > 4) console.log('SIGNATURE FOUND');
  this.signature = decoder.readBinaryDTagElement(NDNProtocolDTags.SignatureBits);

  decoder.readElementClose();
};

Signature.prototype.to_ndnb = function(encoder)
{
  if (!this.validate())
    throw new Error("Cannot encode: field values missing.");

  encoder.writeElementStartDTag(this.getElementLabel());

  if (null != this.digestAlgorithm && !this.digestAlgorithm.equals(NDNDigestHelper.DEFAULT_DIGEST_ALGORITHM))
    encoder.writeDTagElement(NDNProtocolDTags.DigestAlgorithm, OIDLookup.getDigestOID(this.DigestAlgorithm));

  if (null != this.witness)
    // needs to handle null witness
    encoder.writeDTagElement(NDNProtocolDTags.Witness, this.witness);

  encoder.writeDTagElement(NDNProtocolDTags.SignatureBits, this.signature);

  encoder.writeElementClose();
};

Signature.prototype.getElementLabel = function() { return NDNProtocolDTags.Signature; };

Signature.prototype.validate = function()
{
  return null != this.signature;
};

var ContentType = {DATA:0, ENCR:1, GONE:2, KEY:3, LINK:4, NACK:5};
var ContentTypeValue = {0:0x0C04C0, 1:0x10D091,2:0x18E344,3:0x28463F,4:0x2C834A,5:0x34008A};
var ContentTypeValueReverse = {0x0C04C0:0, 0x10D091:1,0x18E344:2,0x28463F:3,0x2C834A:4,0x34008A:5};

exports.ContentType = ContentType;

/**
 * Create a new SignedInfo with the optional values.
 * @constructor
 */
var SignedInfo = function SignedInfo(publisher, timestamp, type, locator, freshnessSeconds, finalBlockID)
{
  this.publisher = publisher; //publisherPublicKeyDigest
  this.timestamp=timestamp; // NDN Time
  this.type=type; // ContentType
  this.locator =locator;//KeyLocator
  this.freshnessSeconds =freshnessSeconds; // Integer
  this.finalBlockID=finalBlockID; //byte array

  this.setFields();
};

exports.SignedInfo = SignedInfo;

SignedInfo.prototype.setFields = function()
{
  var key = ndn.globalKeyManager.getKey();
  this.publisher = new PublisherPublicKeyDigest(key.getKeyID());

  var d = new Date();

  var time = d.getTime();

  this.timestamp = new NDNTime(time);

  if (LOG > 4) console.log('TIME msec is');

  if (LOG > 4) console.log(this.timestamp.msec);

  //DATA
  this.type = 0;//0x0C04C0;//ContentTypeValue[ContentType.DATA];

  if (LOG > 4) console.log('PUBLIC KEY TO WRITE TO DATA PACKET IS ');
  if (LOG > 4) console.log(key.publicToDER().toString('hex'));

  this.locator = new KeyLocator(key.publicToDER(), KeyLocatorType.KEY);
  //this.locator = new KeyLocator(DataUtils.toNumbersFromString(stringCertificate)  ,KeyLocatorType.CERTIFICATE);
};

SignedInfo.prototype.from_ndnb = function(decoder)
{
  decoder.readElementStartDTag(this.getElementLabel());

  if (decoder.peekDTag(NDNProtocolDTags.PublisherPublicKeyDigest)) {
    if (LOG > 4) console.log('DECODING PUBLISHER KEY');
    this.publisher = new PublisherPublicKeyDigest();
    this.publisher.from_ndnb(decoder);
  }

  if (decoder.peekDTag(NDNProtocolDTags.Timestamp)) {
    if (LOG > 4) console.log('DECODING TIMESTAMP');
    this.timestamp = decoder.readDateTimeDTagElement(NDNProtocolDTags.Timestamp);
  }

  if (decoder.peekDTag(NDNProtocolDTags.Type)) {
    var binType = decoder.readBinaryDTagElement(NDNProtocolDTags.Type);

    if (LOG > 4) console.log('Binary Type of of Signed Info is '+binType);

    this.type = binType;

    //TODO Implement type of Key Reading
    if (null == this.type)
      throw new Error("Cannot parse signedInfo type: bytes.");
  }
  else
    this.type = ContentType.DATA; // default

  if (decoder.peekDTag(NDNProtocolDTags.FreshnessSeconds)) {
    this.freshnessSeconds = decoder.readIntegerDTagElement(NDNProtocolDTags.FreshnessSeconds);
    if (LOG > 4) console.log('FRESHNESS IN SECONDS IS '+ this.freshnessSeconds);
  }

  if (decoder.peekDTag(NDNProtocolDTags.FinalBlockID)) {
    if (LOG > 4) console.log('DECODING FINAL BLOCKID');
    this.finalBlockID = decoder.readBinaryDTagElement(NDNProtocolDTags.FinalBlockID);
  }

  if (decoder.peekDTag(NDNProtocolDTags.KeyLocator)) {
    if (LOG > 4) console.log('DECODING KEY LOCATOR');
    this.locator = new KeyLocator();
    this.locator.from_ndnb(decoder);
  }

  decoder.readElementClose();
};

SignedInfo.prototype.to_ndnb = function(encoder)  {
  if (!this.validate())
    throw new Error("Cannot encode : field values missing.");

  encoder.writeElementStartDTag(this.getElementLabel());

  if (null != this.publisher) {
    if (LOG > 3) console.log('ENCODING PUBLISHER KEY' + this.publisher.publisherPublicKeyDigest);
    this.publisher.to_ndnb(encoder);
  }

  if (null != this.timestamp)
    encoder.writeDateTimeDTagElement(NDNProtocolDTags.Timestamp, this.timestamp);

  if (null != this.type && this.type != 0)
    encoder.writeDTagElement(NDNProtocolDTags.type, this.type);

  if (null != this.freshnessSeconds)
    encoder.writeDTagElement(NDNProtocolDTags.FreshnessSeconds, this.freshnessSeconds);

  if (null != this.finalBlockID)
    encoder.writeDTagElement(NDNProtocolDTags.FinalBlockID, this.finalBlockID);

  if (null != this.locator)
    this.locator.to_ndnb(encoder);

  encoder.writeElementClose();
};

SignedInfo.prototype.valueToType = function()
{
  return null;
};

SignedInfo.prototype.getElementLabel = function() {
  return NDNProtocolDTags.SignedInfo;
};

SignedInfo.prototype.validate = function()
{
  // We don't do partial matches any more, even though encoder/decoder
  // is still pretty generous.
  if (null ==this.publisher || null==this.timestamp ||null== this.locator)
    return false;
  return true;
};

/**
 * @deprecated Use BinaryXmlWireFormat.decodeData.
 */
Data.prototype.from_ndnb = function(/*XMLDecoder*/ decoder)
{
  BinaryXmlWireFormat.decodeData(this, decoder);
};

/**
 * @deprecated Use BinaryXmlWireFormat.encodeData.
 */
Data.prototype.to_ndnb = function(/*XMLEncoder*/ encoder)
{
  BinaryXmlWireFormat.encodeData(this, encoder);
};

/**
 * Encode this Data for a particular wire format.
 * @param {WireFormat} wireFormat if null, use BinaryXmlWireFormat.
 * @returns {Buffer}
 */
Data.prototype.encode = function(wireFormat)
{
  wireFormat = (wireFormat || BinaryXmlWireFormat.instance);
  return wireFormat.encodeData(this);
};

/**
 * Decode the input using a particular wire format and update this Data.
 * @param {Buffer} input
 * @param {WireFormat} wireFormat if null, use BinaryXmlWireFormat.
 */
Data.prototype.decode = function(input, wireFormat)
{
  wireFormat = (wireFormat || BinaryXmlWireFormat.instance);
  wireFormat.decodeData(this, input);
};

/**
 * @deprecated Use new Data.
 */
var ContentObject = function ContentObject(name, signedInfo, content)
{
  // Call the base constructor.
  Data.call(this, name, signedInfo, content);
}

ContentObject.prototype = new Data();

exports.ContentObject = ContentObject;
/**
 * Copyright (C) 2013 Regents of the University of California.
 * @author: Meki Cheraoui
 * See COPYING for copyright and distribution information.
 * This class represents Interest Objects
 */


/**
 * Create a new Interest with the optional values.
 *
 * @constructor
 * @param {Name|Interest} nameOrInterest If this is an Interest, copy values from the interest and ignore the
 * other arguments.  Otherwise this is the optional name for the new Interest.
 * @param {number} minSuffixComponents
 * @param {number} maxSuffixComponents
 * @param {Buffer} publisherPublicKeyDigest
 * @param {Exclude} exclude
 * @param {number} childSelector
 * @param {number} answerOriginKind
 * @param {number} scope
 * @param {number} interestLifetimeMilliseconds in milliseconds
 * @param {Buffer} nonce
 */
var Interest = function Interest
   (nameOrInterest, minSuffixComponents, maxSuffixComponents, publisherPublicKeyDigest, exclude,
    childSelector, answerOriginKind, scope, interestLifetimeMilliseconds, nonce)
{
  if (typeof nameOrInterest == 'object' && nameOrInterest instanceof Interest) {
    // Special case: this is a copy constructor.  Ignore all but the first argument.
    var interest = nameOrInterest;
    if (interest.name)
      // Copy the name.
      this.name = new Name(interest.name);
    this.maxSuffixComponents = interest.maxSuffixComponents;
    this.minSuffixComponents = interest.minSuffixComponents;

    this.publisherPublicKeyDigest = interest.publisherPublicKeyDigest;
    this.exclude = interest.exclude;
    this.childSelector = interest.childSelector;
    this.answerOriginKind = interest.answerOriginKind;
    this.scope = interest.scope;
    this.interestLifetime = interest.interestLifetime;
    if (interest.nonce)
      // Copy.
      this.nonce = new ndnbuf(interest.nonce);
  }
  else {
    this.name = nameOrInterest;
    this.maxSuffixComponents = maxSuffixComponents;
    this.minSuffixComponents = minSuffixComponents;

    this.publisherPublicKeyDigest = publisherPublicKeyDigest;
    this.exclude = exclude;
    this.childSelector = childSelector;
    this.answerOriginKind = answerOriginKind;
    this.scope = scope;
    this.interestLifetime = interestLifetimeMilliseconds;
    if (nonce)
      // Copy and make sure it is a ndnbuf.
      this.nonce = new ndnbuf(nonce);
  }
};

exports.Interest = Interest;

Interest.RECURSIVE_POSTFIX = "*";

Interest.CHILD_SELECTOR_LEFT = 0;
Interest.CHILD_SELECTOR_RIGHT = 1;

Interest.ANSWER_NO_CONTENT_STORE = 0;
Interest.ANSWER_CONTENT_STORE = 1;
Interest.ANSWER_GENERATED = 2;
Interest.ANSWER_STALE = 4;    // Stale answer OK
Interest.MARK_STALE = 16;    // Must have scope 0.  Michael calls this a "hack"

Interest.DEFAULT_ANSWER_ORIGIN_KIND = Interest.ANSWER_CONTENT_STORE | Interest.ANSWER_GENERATED;

/**
 * Return true if this.name.match(name) and the name conforms to the interest selectors.
 * @param {Name} name
 * @returns {boolean}
 */
Interest.prototype.matchesName = function(/*Name*/ name)
{
  if (!this.name.match(name))
    return false;

  if (this.minSuffixComponents != null &&
      // Add 1 for the implicit digest.
      !(name.size() + 1 - this.name.size() >= this.minSuffixComponents))
    return false;
  if (this.maxSuffixComponents != null &&
      // Add 1 for the implicit digest.
      !(name.size() + 1 - this.name.size() <= this.maxSuffixComponents))
    return false;
  if (this.exclude != null && name.size() > this.name.size() &&
      this.exclude.matches(name.components[this.name.size()]))
    return false;

  return true;
};

/**
 * @deprecated Use matchesName.
 */
Interest.prototype.matches_name = function(/*Name*/ name)
{
  return this.matchesName(name);
};

/**
 * Return a new Interest with the same fields as this Interest.
 * Note: This does NOT make a deep clone of the name, exclue or other objects.
 */
Interest.prototype.clone = function()
{
  return new Interest
     (this.name, this.minSuffixComponents, this.maxSuffixComponents,
      this.publisherPublicKeyDigest, this.exclude, this.childSelector, this.answerOriginKind,
      this.scope, this.interestLifetime, this.nonce);
};

Interest.prototype.setMinSuffixComponents = function(value)
{
  this.minSuffixComponents = value;
}

Interest.prototype.setMaxSuffixComponents = function(value)
{
  this.maxSuffixComponents = value;
}

Interest.prototype.setChildSelector = function(value)
{
  this.childSelector = value;
}

Interest.prototype.setAnswerOriginKind = function(value)
{
  this.answerOriginKind = value;
}

Interest.prototype.setScope = function(value)
{
  this.scope = value;
}

Interest.prototype.setInterestLifetimeMilliseconds = function(value)
{
  this.interestLifetime = value;
}

Interest.prototype.setNonce = function(value)
{
  if (value)
    // Copy and make sure it is a ndnbuf.
    this.nonce = new ndnbuf(value);
  else
    this.nonce = null;
}

/**
 * Create a new Exclude.
 * @constructor
 * @param {Array<Name.Component|Buffer|Exclude.ANY>} values (optional) An array where each element is either a Name.Component, ndnbuf component or Exclude.ANY.
 */
var Exclude = function Exclude(values)
{
  this.values = [];

  if (values) {
    for (var i = 0; i < values.length; ++i) {
      if (values[i] == Exclude.ANY)
        this.appendAny();
      else
        this.appendComponent(values[i]);
    }
  }
};

exports.Exclude = Exclude;

Exclude.ANY = "*";

/**
 * Append an Exclude.ANY element.
 * @returns This Exclude so that you can chain calls to append.
 */
Exclude.prototype.appendAny = function()
{
  this.values.push(Exclude.ANY);
  return this;
}

/**
 * Append a component entry, copying from component.
 * @param {Name.Component|Buffer} component
 * @returns This Exclude so that you can chain calls to append.
 */
Exclude.prototype.appendComponent = function(component)
{
  this.values.push(new Name.Component(component));
  return this;
}

Exclude.prototype.from_ndnb = function(/*XMLDecoder*/ decoder)
{
  decoder.readElementStartDTag(NDNProtocolDTags.Exclude);

  while (true) {
    if (decoder.peekDTag(NDNProtocolDTags.Component))
      this.appendComponent(decoder.readBinaryDTagElement(NDNProtocolDTags.Component));
    else if (decoder.peekDTag(NDNProtocolDTags.Any)) {
      decoder.readElementStartDTag(NDNProtocolDTags.Any);
      decoder.readElementClose();
      this.appendAny();
    }
    else if (decoder.peekDTag(NDNProtocolDTags.Bloom)) {
      // Skip the Bloom and treat it as Any.
      decoder.readBinaryDTagElement(NDNProtocolDTags.Bloom);
      this.appendAny();
    }
    else
      break;
  }

  decoder.readElementClose();
};

Exclude.prototype.to_ndnb = function(/*XMLEncoder*/ encoder)
{
  if (this.values == null || this.values.length == 0)
    return;

  encoder.writeElementStartDTag(NDNProtocolDTags.Exclude);

  // TODO: Do we want to order the components (except for ANY)?
  for (var i = 0; i < this.values.length; ++i) {
    if (this.values[i] == Exclude.ANY) {
      encoder.writeElementStartDTag(NDNProtocolDTags.Any);
      encoder.writeElementClose();
    }
    else
      encoder.writeDTagElement(NDNProtocolDTags.Component, this.values[i].getValue());
  }

  encoder.writeElementClose();
};

/**
 * Return a string with elements separated by "," and Exclude.ANY shown as "*".
 */
Exclude.prototype.toUri = function()
{
  if (this.values == null || this.values.length == 0)
    return "";

  var result = "";
  for (var i = 0; i < this.values.length; ++i) {
    if (i > 0)
      result += ",";

    if (this.values[i] == Exclude.ANY)
      result += "*";
    else
      result += Name.toEscapedString(this.values[i].getValue());
  }
  return result;
};

/**
 * Return true if the component matches any of the exclude criteria.
 */
Exclude.prototype.matches = function(/*Buffer*/ component)
{
  if (typeof component == 'object' && component instanceof Name.Component)
    component = component.getValue();

  for (var i = 0; i < this.values.length; ++i) {
    if (this.values[i] == Exclude.ANY) {
      var lowerBound = null;
      if (i > 0)
        lowerBound = this.values[i - 1];

      // Find the upper bound, possibly skipping over multiple ANY in a row.
      var iUpperBound;
      var upperBound = null;
      for (iUpperBound = i + 1; iUpperBound < this.values.length; ++iUpperBound) {
        if (this.values[iUpperBound] != Exclude.ANY) {
          upperBound = this.values[iUpperBound];
          break;
        }
      }

      // If lowerBound != null, we already checked component equals lowerBound on the last pass.
      // If upperBound != null, we will check component equals upperBound on the next pass.
      if (upperBound != null) {
        if (lowerBound != null) {
          if (Exclude.compareComponents(component, lowerBound) > 0 &&
              Exclude.compareComponents(component, upperBound) < 0)
            return true;
        }
        else {
          if (Exclude.compareComponents(component, upperBound) < 0)
            return true;
        }

        // Make i equal iUpperBound on the next pass.
        i = iUpperBound - 1;
      }
      else {
        if (lowerBound != null) {
            if (Exclude.compareComponents(component, lowerBound) > 0)
              return true;
        }
        else
          // this.values has only ANY.
          return true;
      }
    }
    else {
      if (DataUtils.arraysEqual(component, this.values[i].getValue()))
        return true;
    }
  }

  return false;
};

/**
 * Return -1 if component1 is less than component2, 1 if greater or 0 if equal.
 * A component is less if it is shorter, otherwise if equal length do a byte comparison.
 */
Exclude.compareComponents = function(component1, component2)
{
  if (typeof component1 == 'object' && component1 instanceof Name.Component)
    component1 = component1.getValue();
  if (typeof component2 == 'object' && component2 instanceof Name.Component)
    component2 = component2.getValue();

  if (component1.length < component2.length)
    return -1;
  if (component1.length > component2.length)
    return 1;

  for (var i = 0; i < component1.length; ++i) {
    if (component1[i] < component2[i])
      return -1;
    if (component1[i] > component2[i])
      return 1;
  }

  return 0;
};

/**
 * @deprecated Use BinaryXmlWireFormat.decodeInterest.
 */
Interest.prototype.from_ndnb = function(/*XMLDecoder*/ decoder)
{
  BinaryXmlWireFormat.decodeInterest(this, decoder);
};

/**
 * @deprecated Use BinaryXmlWireFormat.encodeInterest.
 */
Interest.prototype.to_ndnb = function(/*XMLEncoder*/ encoder)
{
  BinaryXmlWireFormat.encodeInterest(this, encoder);
};

/**
 * Encode this Interest for a particular wire format.
 * @param {WireFormat} wireFormat if null, use BinaryXmlWireFormat.
 * @returns {Buffer}
 */
Interest.prototype.encode = function(wireFormat)
{
  wireFormat = (wireFormat || BinaryXmlWireFormat.instance);
  return wireFormat.encodeInterest(this);
};

/**
 * Decode the input using a particular wire format and update this Interest.
 * @param {Buffer} input
 * @param {WireFormat} wireFormat if null, use BinaryXmlWireFormat.
 */
Interest.prototype.decode = function(input, wireFormat)
{
  wireFormat = (wireFormat || BinaryXmlWireFormat.instance);
  wireFormat.decodeInterest(this, input);
};

/**
 * Encode the name according to the "NDN URI Scheme".  If there are interest selectors, append "?" and
 * added the selectors as a query string.  For example "/test/name?ndn.ChildSelector=1".
 * @returns {string} The URI string.
 */
Interest.prototype.toUri = function()
{
  var selectors = "";

  if (this.minSuffixComponents != null)
    selectors += "&ndn.MinSuffixComponents=" + this.minSuffixComponents;
  if (this.maxSuffixComponents != null)
    selectors += "&ndn.MaxSuffixComponents=" + this.maxSuffixComponents;
  if (this.childSelector != null)
    selectors += "&ndn.ChildSelector=" + this.childSelector;
  if (this.answerOriginKind != null)
    selectors += "&ndn.AnswerOriginKind=" + this.answerOriginKind;
  if (this.scope != null)
    selectors += "&ndn.Scope=" + this.scope;
  if (this.interestLifetime != null)
    selectors += "&ndn.InterestLifetime=" + this.interestLifetime;
  if (this.publisherPublicKeyDigest != null)
    selectors += "&ndn.PublisherPublicKeyDigest=" + Name.toEscapedString(this.publisherPublicKeyDigest.publisherPublicKeyDigest);
  if (this.nonce != null)
    selectors += "&ndn.Nonce=" + Name.toEscapedString(this.nonce);
  if (this.exclude != null)
    selectors += "&ndn.Exclude=" + this.exclude.toUri();

  var result = this.name.toUri();
  if (selectors != "")
    // Replace the first & with ?.
    result += "?" + selectors.substr(1);

  return result;
};
/**
 * Copyright (C) 2013 Regents of the University of California.
 * @author: Meki Cheraoui
 * See COPYING for copyright and distribution information.
 * This class represents Key Objects
 */

/**
 * @constructor
 */
/**
 * Key
 */
var Key = function Key()
{
  this.publicKeyDer = null;     // ndnbuf
  this.publicKeyDigest = null;  // ndnbuf
  this.publicKeyPem = null;     // String
  this.privateKeyPem = null;    // String
};

exports.Key = Key;

/**
 * Helper functions to read Key fields
 * TODO: generateRSA()
 */

Key.prototype.publicToDER = function()
{
  return this.publicKeyDer;  // ndnbuf
};

Key.prototype.privateToDER = function()
{
  // Remove the '-----XXX-----' from the beginning and the end of the key
  // and also remove any \n in the key string
  var lines = this.privateKeyPem.split('\n');
  priKey = "";
  for (var i = 1; i < lines.length - 1; i++)
    priKey += lines[i];

  return new ndnbuf(priKey, 'base64');
};

Key.prototype.publicToPEM = function()
{
  return this.publicKeyPem;
};

Key.prototype.privateToPEM = function()
{
  return this.privateKeyPem;
};

Key.prototype.getKeyID = function()
{
  return this.publicKeyDigest;
};

exports.Key = Key;

Key.prototype.readDerPublicKey = function(/*Buffer*/pub_der)
{
  if (LOG > 4) console.log("Encode DER public key:\n" + pub_der.toString('hex'));

  this.publicKeyDer = pub_der;

  var hash = ndn.createHash('sha256');
  hash.update(this.publicKeyDer);
  this.publicKeyDigest = new ndnbuf(hash.digest());

  var keyStr = pub_der.toString('base64');
  var keyPem = "-----BEGIN PUBLIC KEY-----\n";
  for (var i = 0; i < keyStr.length; i += 64)
  keyPem += (keyStr.substr(i, 64) + "\n");
  keyPem += "-----END PUBLIC KEY-----";
  this.publicKeyPem = keyPem;

  if (LOG > 4) console.log("Convert public key to PEM format:\n" + this.publicKeyPem);
};

/**
 * Load RSA key pair from PEM-encoded strings.
 * Will throw an Error if both 'pub' and 'pri' are null.
 */
Key.prototype.fromPemString = function(pub, pri)
{
  if (pub == null && pri == null)
    throw new Error('Cannot create Key object if both public and private PEM string is empty.');

  // Read public key
  if (pub != null) {
    this.publicKeyPem = pub;
    if (LOG > 4) console.log("Key.publicKeyPem: \n" + this.publicKeyPem);

    // Remove the '-----XXX-----' from the beginning and the end of the public key
    // and also remove any \n in the public key string
    var lines = pub.split('\n');
    pub = "";
    for (var i = 1; i < lines.length - 1; i++)
      pub += lines[i];
    this.publicKeyDer = new ndnbuf(pub, 'base64');
    if (LOG > 4) console.log("Key.publicKeyDer: \n" + this.publicKeyDer.toString('hex'));

    var hash = ndn.createHash('sha256');
    hash.update(this.publicKeyDer);
    this.publicKeyDigest = new ndnbuf(hash.digest());
    if (LOG > 4) console.log("Key.publicKeyDigest: \n" + this.publicKeyDigest.toString('hex'));
  }

  // Read private key
  if (pri != null) {
    this.privateKeyPem = pri;
    if (LOG > 4) console.log("Key.privateKeyPem: \n" + this.privateKeyPem);
  }
};

Key.prototype.fromPem = Key.prototype.fromPemString;

/**
 * Static method that create a Key object.
 * Parameter 'obj' is a JSON object that has two properties:
 *   pub: the PEM string for the public key
 *   pri: the PEM string for the private key
 * Will throw an Error if both obj.pub and obj.pri are null.
 */
Key.createFromPEM = function(obj)
{
    var key = new Key();
    key.fromPemString(obj.pub, obj.pri);
    return key;
};

/**
 * KeyLocator
 */
var KeyLocatorType = {
  KEY:1,
  CERTIFICATE:2,
  KEYNAME:3
};

exports.KeyLocatorType = KeyLocatorType;

/**
 * @constructor
 */
var KeyLocator = function KeyLocator(input,type)
{
  this.type = type;

  if (type == KeyLocatorType.KEYNAME) {
    if (LOG > 3) console.log('KeyLocator: SET KEYNAME');
    this.keyName = input;
  }
  else if (type == KeyLocatorType.KEY) {
    if (LOG > 3) console.log('KeyLocator: SET KEY');
    this.publicKey = input;
  }
  else if (type == KeyLocatorType.CERTIFICATE) {
    if (LOG > 3) console.log('KeyLocator: SET CERTIFICATE');
    this.certificate = input;
  }
};

exports.KeyLocator = KeyLocator;

KeyLocator.prototype.from_ndnb = function(decoder) {

  decoder.readElementStartDTag(this.getElementLabel());

  if (decoder.peekDTag(NDNProtocolDTags.Key))
  {
    try {
      var encodedKey = decoder.readBinaryDTagElement(NDNProtocolDTags.Key);
      // This is a DER-encoded SubjectPublicKeyInfo.

      //TODO FIX THIS, This should create a Key Object instead of keeping bytes

      this.publicKey =   encodedKey;//CryptoUtil.getPublicKey(encodedKey);
      this.type = KeyLocatorType.KEY;

      if (LOG > 4) console.log('PUBLIC KEY FOUND: '+ this.publicKey);
    }
    catch (e) {
      throw new Error("Cannot parse key: ", e);
    }

    if (null == this.publicKey)
      throw new Error("Cannot parse key: ");
  }
  else if (decoder.peekDTag(NDNProtocolDTags.Certificate)) {
    try {
      var encodedCert = decoder.readBinaryDTagElement(NDNProtocolDTags.Certificate);

      /*
       * Certificates not yet working
       */

      this.certificate = encodedCert;
      this.type = KeyLocatorType.CERTIFICATE;

      if (LOG > 4) console.log('CERTIFICATE FOUND: '+ this.certificate);
    }
    catch (e) {
      throw new Error("Cannot decode certificate: " +  e);
    }
    if (null == this.certificate)
      throw new Error("Cannot parse certificate! ");
  } else  {
    this.type = KeyLocatorType.KEYNAME;

    this.keyName = new KeyName();
    this.keyName.from_ndnb(decoder);
  }
  decoder.readElementClose();
};

KeyLocator.prototype.to_ndnb = function(encoder)
{
  if (LOG > 4) console.log('type is is ' + this.type);
  //TODO Check if Name is missing
  if (!this.validate())
    throw new Error("Cannot encode " + this.getClass().getName() + ": field values missing.");

  //TODO FIX THIS TOO
  encoder.writeElementStartDTag(this.getElementLabel());

  if (this.type == KeyLocatorType.KEY) {
    if (LOG > 5) console.log('About to encode a public key' +this.publicKey);
    encoder.writeDTagElement(NDNProtocolDTags.Key, this.publicKey);
  }
  else if (this.type == KeyLocatorType.CERTIFICATE) {
    try {
      encoder.writeDTagElement(NDNProtocolDTags.Certificate, this.certificate);
    }
    catch (e) {
      throw new Error("CertificateEncodingException attempting to write key locator: " + e);
    }
  }
  else if (this.type == KeyLocatorType.KEYNAME)
    this.keyName.to_ndnb(encoder);

  encoder.writeElementClose();
};

KeyLocator.prototype.getElementLabel = function()
{
  return NDNProtocolDTags.KeyLocator;
};

KeyLocator.prototype.validate = function()
{
  return null != this.keyName || null != this.publicKey || null != this.certificate;
};

/**
 * KeyName is only used by KeyLocator.
 * @constructor
 */
var KeyName = function KeyName()
{
  this.contentName = this.contentName;  //contentName
  this.publisherID = this.publisherID;  //publisherID
};

exports.KeyName = KeyName;

KeyName.prototype.from_ndnb = function(decoder)
{
  decoder.readElementStartDTag(this.getElementLabel());

  this.contentName = new Name();
  this.contentName.from_ndnb(decoder);

  if (LOG > 4) console.log('KEY NAME FOUND: ');

  if (PublisherID.peek(decoder)) {
    this.publisherID = new PublisherID();
    this.publisherID.from_ndnb(decoder);
  }

  decoder.readElementClose();
};

KeyName.prototype.to_ndnb = function(encoder)
{
  if (!this.validate())
    throw new Error("Cannot encode : field values missing.");

  encoder.writeElementStartDTag(this.getElementLabel());

  this.contentName.to_ndnb(encoder);
  if (null != this.publisherID)
    this.publisherID.to_ndnb(encoder);

  encoder.writeElementClose();
};

KeyName.prototype.getElementLabel = function() { return NDNProtocolDTags.KeyName; };

KeyName.prototype.validate = function()
{
    // DKS -- do we do recursive validation?
    // null signedInfo ok
    return (null != this.contentName);
};
/**
 * Copyright (C) 2013 Regents of the University of California.
 * @author: Meki Cheraoui
 * See COPYING for copyright and distribution information.
 * This class represents Face Instances
 */


/**
 * @constructor
 */
var FaceInstance  = function FaceInstance(action, publisherPublicKeyDigest, faceID, ipProto, host, port, multicastInterface,
    multicastTTL, freshnessSeconds)
{
  this.action = action;
  this.publisherPublicKeyDigest = publisherPublicKeyDigest;
  this.faceID = faceID;
  this.ipProto = ipProto;
  this.host = host;
  this.Port = port;
  this.multicastInterface =multicastInterface;
  this.multicastTTL =multicastTTL;
  this.freshnessSeconds = freshnessSeconds;
};

exports.FaceInstance = FaceInstance;

FaceInstance.NetworkProtocol = { TCP:6, UDP:17};

/**
 * Used by NetworkObject to decode the object from a network stream.
 */
FaceInstance.prototype.from_ndnb = function(
  //XMLDecoder
  decoder)
{
  decoder.readElementStartDTag(this.getElementLabel());

  if (decoder.peekDTag(NDNProtocolDTags.Action))
    this.action = decoder.readUTF8DTagElement(NDNProtocolDTags.Action);
  if (decoder.peekDTag(NDNProtocolDTags.PublisherPublicKeyDigest)) {
    this.publisherPublicKeyDigest = new PublisherPublicKeyDigest();
    this.publisherPublicKeyDigest.from_ndnb(decoder);
  }
  if (decoder.peekDTag(NDNProtocolDTags.FaceID))
    this.faceID = decoder.readIntegerDTagElement(NDNProtocolDTags.FaceID);
  if (decoder.peekDTag(NDNProtocolDTags.IPProto)) {
    //int
    var pI = decoder.readIntegerDTagElement(NDNProtocolDTags.IPProto);

    this.ipProto = null;

    if (FaceInstance.NetworkProtocol.TCP == pI)
      this.ipProto = FaceInstance.NetworkProtocol.TCP;
    else if (FaceInstance.NetworkProtocol.UDP == pI)
      this.ipProto = FaceInstance.NetworkProtocol.UDP;
    else
      throw new Error("FaceInstance.decoder.  Invalid NDNProtocolDTags.IPProto field: " + pI);
  }

  if (decoder.peekDTag(NDNProtocolDTags.Host))
    this.host = decoder.readUTF8DTagElement(NDNProtocolDTags.Host);
  if (decoder.peekDTag(NDNProtocolDTags.Port))
    this.Port = decoder.readIntegerDTagElement(NDNProtocolDTags.Port);
  if (decoder.peekDTag(NDNProtocolDTags.MulticastInterface))
    this.multicastInterface = decoder.readUTF8DTagElement(NDNProtocolDTags.MulticastInterface);
  if (decoder.peekDTag(NDNProtocolDTags.MulticastTTL))
    this.multicastTTL = decoder.readIntegerDTagElement(NDNProtocolDTags.MulticastTTL);
  if (decoder.peekDTag(NDNProtocolDTags.FreshnessSeconds))
    this.freshnessSeconds = decoder.readIntegerDTagElement(NDNProtocolDTags.FreshnessSeconds);

  decoder.readElementClose();
};

/**
 * Used by NetworkObject to encode the object to a network stream.
 */
FaceInstance.prototype.to_ndnb = function(
  //XMLEncoder
  encoder)
{
  encoder.writeElementStartDTag(this.getElementLabel());

  if (null != this.action && this.action.length != 0)
    encoder.writeDTagElement(NDNProtocolDTags.Action, this.action);
  if (null != this.publisherPublicKeyDigest)
    this.publisherPublicKeyDigest.to_ndnb(encoder);
  if (null != this.faceID)
    encoder.writeDTagElement(NDNProtocolDTags.FaceID, this.faceID);
  if (null != this.ipProto)
    encoder.writeDTagElement(NDNProtocolDTags.IPProto, this.ipProto);
  if (null != this.host && this.host.length != 0)
    encoder.writeDTagElement(NDNProtocolDTags.Host, this.host);
  if (null != this.Port)
    encoder.writeDTagElement(NDNProtocolDTags.Port, this.Port);
  if (null != this.multicastInterface && this.multicastInterface.length != 0)
    encoder.writeDTagElement(NDNProtocolDTags.MulticastInterface, this.multicastInterface);
  if (null !=  this.multicastTTL)
    encoder.writeDTagElement(NDNProtocolDTags.MulticastTTL, this.multicastTTL);
  if (null != this.freshnessSeconds)
    encoder.writeDTagElement(NDNProtocolDTags.FreshnessSeconds, this.freshnessSeconds);

  encoder.writeElementClose();
};

FaceInstance.prototype.getElementLabel = function()
{
  return NDNProtocolDTags.FaceInstance;
};

/**
 * Copyright (C) 2013 Regents of the University of California.
 * @author: Meki Cheraoui
 * See COPYING for copyright and distribution information.
 * This class represents Forwarding Entries
 */


/**
 * Create a new ForwardingEntry with the optional arguments.
 * @constructor
 * @param {String} action
 * @param {Name} prefixName
 * @param {PublisherPublicKeyDigest} ndndId
 * @param {number} faceID
 * @param {number} flags
 * @param {number} lifetime in seconds
 */
var ForwardingEntry = function ForwardingEntry(action, prefixName, ndndId, faceID, flags, lifetime)
{
  this.action = action;
  this.prefixName = prefixName;
  this.ndndID = ndndId;
  this.faceID = faceID;
  this.flags = flags;
  this.lifetime = lifetime;
};

exports.ForwardingEntry = ForwardingEntry;

ForwardingEntry.ACTIVE         = 1;
ForwardingEntry.CHILD_INHERIT  = 2;
ForwardingEntry.ADVERTISE      = 4;
ForwardingEntry.LAST           = 8;
ForwardingEntry.CAPTURE       = 16;
ForwardingEntry.LOCAL         = 32;
ForwardingEntry.TAP           = 64;
ForwardingEntry.CAPTURE_OK   = 128;

ForwardingEntry.prototype.from_ndnb = function(
  //XMLDecoder
  decoder)
  //throws ContentDecodingException
{
  decoder.readElementStartDTag(this.getElementLabel());
  if (decoder.peekDTag(NDNProtocolDTags.Action))
    this.action = decoder.readUTF8DTagElement(NDNProtocolDTags.Action);
  if (decoder.peekDTag(NDNProtocolDTags.Name)) {
    this.prefixName = new Name();
    this.prefixName.from_ndnb(decoder) ;
  }
  if (decoder.peekDTag(NDNProtocolDTags.PublisherPublicKeyDigest)) {
    this.NdndId = new PublisherPublicKeyDigest();
    this.NdndId.from_ndnb(decoder);
  }
  if (decoder.peekDTag(NDNProtocolDTags.FaceID))
    this.faceID = decoder.readIntegerDTagElement(NDNProtocolDTags.FaceID);
  if (decoder.peekDTag(NDNProtocolDTags.ForwardingFlags))
    this.flags = decoder.readIntegerDTagElement(NDNProtocolDTags.ForwardingFlags);
  if (decoder.peekDTag(NDNProtocolDTags.FreshnessSeconds))
    this.lifetime = decoder.readIntegerDTagElement(NDNProtocolDTags.FreshnessSeconds);

  decoder.readElementClose();
};

ForwardingEntry.prototype.to_ndnb = function(
  //XMLEncoder
  encoder)
{
  encoder.writeElementStartDTag(this.getElementLabel());
  if (null != this.action && this.action.length != 0)
    encoder.writeDTagElement(NDNProtocolDTags.Action, this.action);
  if (null != this.prefixName)
    this.prefixName.to_ndnb(encoder);
  if (null != this.NdndId)
    this.NdndId.to_ndnb(encoder);
  if (null != this.faceID)
    encoder.writeDTagElement(NDNProtocolDTags.FaceID, this.faceID);
  if (null != this.flags)
    encoder.writeDTagElement(NDNProtocolDTags.ForwardingFlags, this.flags);
  if (null != this.lifetime)
    encoder.writeDTagElement(NDNProtocolDTags.FreshnessSeconds, this.lifetime);

  encoder.writeElementClose();
};

ForwardingEntry.prototype.getElementLabel = function() { return NDNProtocolDTags.ForwardingEntry; }
/**
 * Copyright (C) 2013 Regents of the University of California.
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 */


/**
 * A ForwardingFlags object holds the flags which specify how the forwarding daemon should forward an interest for
 * a registered prefix.  We use a separate ForwardingFlags object to retain future compatibility if the daemon forwarding
 * bits are changed, amended or deprecated.
 * Create a new ForwardingFlags with "active" and "childInherit" set and all other flags cleared.
 */
var ForwardingFlags = function ForwardingFlags()
{
  this.active = true;
  this.childInherit = true;
  this.advertise = false;
  this.last = false;
  this.capture = false;
  this.local = false;
  this.tap = false;
  this.captureOk = false;
}

exports.ForwardingFlags = ForwardingFlags;

/**
 * Get an integer with the bits set according to the flags as used by the ForwardingEntry message.
 * @returns {number} An integer with the bits set.
 */
ForwardingFlags.prototype.getForwardingEntryFlags = function()
{
  var result = 0;

  if (this.active)
    result |= ForwardingEntry.ACTIVE;
  if (this.childInherit)
    result |= ForwardingEntry.CHILD_INHERIT;
  if (this.advertise)
    result |= ForwardingEntry.ADVERTISE;
  if (this.last)
    result |= ForwardingEntry.LAST;
  if (this.capture)
    result |= ForwardingEntry.CAPTURE;
  if (this.local)
    result |= ForwardingEntry.LOCAL;
  if (this.tap)
    result |= ForwardingEntry.TAP;
  if (this.captureOk)
    result |= ForwardingEntry.CAPTURE_OK;

  return result;
};

/**
 * Set the flags according to the bits in forwardingEntryFlags as used by the ForwardingEntry message.
 * @param {number} forwardingEntryFlags An integer with the bits set.
 */
ForwardingFlags.prototype.setForwardingEntryFlags = function(forwardingEntryFlags)
{
  this.active = ((forwardingEntryFlags & ForwardingEntry.ACTIVE) != 0);
  this.childInherit = ((forwardingEntryFlags & ForwardingEntry.CHILD_INHERIT) != 0);
  this.advertise = ((forwardingEntryFlags & ForwardingEntry.ADVERTISE) != 0);
  this.last = ((forwardingEntryFlags & ForwardingEntry.LAST) != 0);
  this.capture = ((forwardingEntryFlags & ForwardingEntry.CAPTURE) != 0);
  this.local = ((forwardingEntryFlags & ForwardingEntry.LOCAL) != 0);
  this.tap = ((forwardingEntryFlags & ForwardingEntry.TAP) != 0);
  this.captureOk = ((forwardingEntryFlags & ForwardingEntry.CAPTURE_OK) != 0);
};

/**
 * Get the value of the "active" flag.
 * @returns {Boolean} true if the flag is set, false if it is cleared.
 */
ForwardingFlags.prototype.getActive = function() { return this.active; };

/**
 * Get the value of the "childInherit" flag.
 * @returns {Boolean} true if the flag is set, false if it is cleared.
 */
ForwardingFlags.prototype.getChildInherit = function() { return this.childInherit; };

/**
 * Get the value of the "advertise" flag.
 * @returns {Boolean} true if the flag is set, false if it is cleared.
 */
ForwardingFlags.prototype.getAdvertise = function() { return this.advertise; };

/**
 * Get the value of the "last" flag.
 * @returns {Boolean} true if the flag is set, false if it is cleared.
 */
ForwardingFlags.prototype.getLast = function() { return this.last; };

/**
 * Get the value of the "capture" flag.
 * @returns {Boolean} true if the flag is set, false if it is cleared.
 */
ForwardingFlags.prototype.getCapture = function() { return this.capture; };

/**
 * Get the value of the "local" flag.
 * @returns {Boolean} true if the flag is set, false if it is cleared.
 */
ForwardingFlags.prototype.getLocal = function() { return this.local; };

/**
 * Get the value of the "tap" flag.
 * @returns {Boolean} true if the flag is set, false if it is cleared.
 */
ForwardingFlags.prototype.getTap = function() { return this.tap; };

/**
 * Get the value of the "captureOk" flag.
 * @returns {Boolean} true if the flag is set, false if it is cleared.
 */
ForwardingFlags.prototype.getCaptureOk = function() { return this.captureOk; };

/**
 * Set the value of the "active" flag
 * @param {number} value true to set the flag, false to clear it.
 */
ForwardingFlags.prototype.setActive = function(value) { this.active = value; };

/**
 * Set the value of the "childInherit" flag
 * @param {number} value true to set the flag, false to clear it.
 */
ForwardingFlags.prototype.setChildInherit = function(value) { this.childInherit = value; };

/**
 * Set the value of the "advertise" flag
 * @param {number} value true to set the flag, false to clear it.
 */
ForwardingFlags.prototype.setAdvertise = function(value) { this.advertise = value; };

/**
 * Set the value of the "last" flag
 * @param {number} value true to set the flag, false to clear it.
 */
ForwardingFlags.prototype.setLast = function(value) { this.last = value; };

/**
 * Set the value of the "capture" flag
 * @param {number} value true to set the flag, false to clear it.
 */
ForwardingFlags.prototype.setCapture = function(value) { this.capture = value; };

/**
 * Set the value of the "local" flag
 * @param {number} value true to set the flag, false to clear it.
 */
ForwardingFlags.prototype.setLocal = function(value) { this.local = value; };

/**
 * Set the value of the "tap" flag
 * @param {number} value true to set the flag, false to clear it.
 */
ForwardingFlags.prototype.setTap = function(value) { this.tap = value; };

/**
 * Set the value of the "captureOk" flag
 * @param {number} value true to set the flag, false to clear it.
 */
ForwardingFlags.prototype.setCaptureOk = function(value) { this.captureOk = value; };
/**
 * Copyright (C) 2013 Regents of the University of California.
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * See COPYING for copyright and distribution information.
 */

/**
 * A BinaryXmlWireFormat implements the WireFormat interface for encoding and decoding in binary XML.
 * @constructor
 */
var BinaryXmlWireFormat = function BinaryXmlWireFormat()
{
  // Inherit from WireFormat.
  WireFormat.call(this);
};

exports.BinaryXmlWireFormat = BinaryXmlWireFormat;

// Default object.
BinaryXmlWireFormat.instance = new BinaryXmlWireFormat();

/**
 * Encode the interest and return a ndnbuf.
 * @param {Interest} interest
 * @returns {Buffer}
 */
BinaryXmlWireFormat.prototype.encodeInterest = function(interest)
{
  var encoder = new BinaryXMLEncoder();
  BinaryXmlWireFormat.encodeInterest(interest, encoder);
  return encoder.getReducedOstream();
};

/**
 * Decode the input and put the result in interest.
 * @param {Interest} interest
 * @param {Buffer} input
 */
BinaryXmlWireFormat.prototype.decodeInterest = function(interest, input)
{
  var decoder = new BinaryXMLDecoder(input);
  BinaryXmlWireFormat.decodeInterest(interest, decoder);
};

/**
 * Encode the data and return a ndnbuf.
 * @param {Data} data
 * @returns {Buffer}
 */
BinaryXmlWireFormat.prototype.encodeData = function(data)
{
  var encoder = new BinaryXMLEncoder(1500);
  BinaryXmlWireFormat.encodeData(data, encoder);
  return encoder.getReducedOstream();
};

/**
 * @deprecated Use encodeData(data).
 */
BinaryXmlWireFormat.prototype.encodeContentObject = function(data)
{
  return this.encodeData(data);
}

/**
 * Decode the input and put the result in data.
 * @param {Data} data
 * @param {Buffer} input
 */
BinaryXmlWireFormat.prototype.decodeData = function(data, input)
{
  var decoder = new BinaryXMLDecoder(input);
  BinaryXmlWireFormat.decodeData(data, decoder);
};

/**
 * @deprecated Use decodeData(data, input).
 */
BinaryXmlWireFormat.prototype.decodeContentObject = function(data, input)
{
  this.decodeData(data, input);
}

/**
 * Encode the interest by calling the operations on the encoder.
 * @param {Interest} interest
 * @param {BinaryXMLEncoder} encoder
 */
BinaryXmlWireFormat.encodeInterest = function(interest, encoder)
{
  encoder.writeElementStartDTag(NDNProtocolDTags.Interest);

  interest.name.to_ndnb(encoder);

  if (null != interest.minSuffixComponents)
    encoder.writeDTagElement(NDNProtocolDTags.MinSuffixComponents, interest.minSuffixComponents);

  if (null != interest.maxSuffixComponents)
    encoder.writeDTagElement(NDNProtocolDTags.MaxSuffixComponents, interest.maxSuffixComponents);

  if (null != interest.publisherPublicKeyDigest)
    interest.publisherPublicKeyDigest.to_ndnb(encoder);

  if (null != interest.exclude)
    interest.exclude.to_ndnb(encoder);

  if (null != interest.childSelector)
    encoder.writeDTagElement(NDNProtocolDTags.ChildSelector, interest.childSelector);

  if (interest.DEFAULT_ANSWER_ORIGIN_KIND != interest.answerOriginKind && interest.answerOriginKind!=null)
    encoder.writeDTagElement(NDNProtocolDTags.AnswerOriginKind, interest.answerOriginKind);

  if (null != interest.scope)
    encoder.writeDTagElement(NDNProtocolDTags.Scope, interest.scope);

  if (null != interest.interestLifetime)
    encoder.writeDTagElement(NDNProtocolDTags.InterestLifetime,
                DataUtils.nonNegativeIntToBigEndian((interest.interestLifetime / 1000.0) * 4096));

  if (null != interest.nonce)
    encoder.writeDTagElement(NDNProtocolDTags.Nonce, interest.nonce);

  encoder.writeElementClose();
};


/**
 * Use the decoder to place the result in interest.
 * @param {Interest} interest
 * @param {BinaryXMLDecoder} decoder
 */
BinaryXmlWireFormat.decodeInterest = function(interest, decoder)
{
  decoder.readElementStartDTag(NDNProtocolDTags.Interest);

  interest.name = new Name();
  interest.name.from_ndnb(decoder);

  if (decoder.peekDTag(NDNProtocolDTags.MinSuffixComponents))
    interest.minSuffixComponents = decoder.readIntegerDTagElement(NDNProtocolDTags.MinSuffixComponents);
  else
    interest.minSuffixComponents = null;

  if (decoder.peekDTag(NDNProtocolDTags.MaxSuffixComponents))
    interest.maxSuffixComponents = decoder.readIntegerDTagElement(NDNProtocolDTags.MaxSuffixComponents);
  else
    interest.maxSuffixComponents = null;

  if (decoder.peekDTag(NDNProtocolDTags.PublisherPublicKeyDigest)) {
    interest.publisherPublicKeyDigest = new PublisherPublicKeyDigest();
    interest.publisherPublicKeyDigest.from_ndnb(decoder);
  }
  else
    interest.publisherPublicKeyDigest = null;

  if (decoder.peekDTag(NDNProtocolDTags.Exclude)) {
    interest.exclude = new Exclude();
    interest.exclude.from_ndnb(decoder);
  }
  else
    interest.exclude = null;

  if (decoder.peekDTag(NDNProtocolDTags.ChildSelector))
    interest.childSelector = decoder.readIntegerDTagElement(NDNProtocolDTags.ChildSelector);
  else
    interest.childSelector = null;

  if (decoder.peekDTag(NDNProtocolDTags.AnswerOriginKind))
    interest.answerOriginKind = decoder.readIntegerDTagElement(NDNProtocolDTags.AnswerOriginKind);
  else
    interest.answerOriginKind = null;

  if (decoder.peekDTag(NDNProtocolDTags.Scope))
    interest.scope = decoder.readIntegerDTagElement(NDNProtocolDTags.Scope);
  else
    interest.scope = null;

  if (decoder.peekDTag(NDNProtocolDTags.InterestLifetime))
    interest.interestLifetime = 1000.0 * DataUtils.bigEndianToUnsignedInt
               (decoder.readBinaryDTagElement(NDNProtocolDTags.InterestLifetime)) / 4096;
  else
    interest.interestLifetime = null;

  if (decoder.peekDTag(NDNProtocolDTags.Nonce))
    interest.nonce = decoder.readBinaryDTagElement(NDNProtocolDTags.Nonce);
  else
    interest.nonce = null;

  decoder.readElementClose();
};

/**
 * Encode the data by calling the operations on the encoder.
 * @param {Data} data
 * @param {BinaryXMLEncoder} encoder
 */
BinaryXmlWireFormat.encodeData = function(data, encoder)
{
  //TODO verify name, SignedInfo and Signature is present
  encoder.writeElementStartDTag(data.getElementLabel());

  if (null != data.signature)
    data.signature.to_ndnb(encoder);

  data.startSIG = encoder.offset;

  if (null != data.name)
    data.name.to_ndnb(encoder);

  if (null != data.signedInfo)
    data.signedInfo.to_ndnb(encoder);

  encoder.writeDTagElement(NDNProtocolDTags.Content, data.content);

  data.endSIG = encoder.offset;

  encoder.writeElementClose();

  data.saveRawData(encoder.ostream);
};

/**
 * Use the decoder to place the result in data.
 * @param {Data} data
 * @param {BinaryXMLDecoder} decoder
 */
BinaryXmlWireFormat.decodeData = function(data, decoder)
{
  // TODO VALIDATE THAT ALL FIELDS EXCEPT SIGNATURE ARE PRESENT
  decoder.readElementStartDTag(data.getElementLabel());

  if (decoder.peekDTag(NDNProtocolDTags.Signature)) {
    data.signature = new Signature();
    data.signature.from_ndnb(decoder);
  }
  else
    data.signature = null;

  data.startSIG = decoder.offset;

  data.name = new Name();
  data.name.from_ndnb(decoder);

  if (decoder.peekDTag(NDNProtocolDTags.SignedInfo)) {
    data.signedInfo = new SignedInfo();
    data.signedInfo.from_ndnb(decoder);
  }
  else
    data.signedInfo = null;

  data.content = decoder.readBinaryDTagElement(NDNProtocolDTags.Content, true);

  data.endSIG = decoder.offset;

  decoder.readElementClose();

  data.saveRawData(decoder.input);
};
/**
 * This file contains utilities to help encode and decode NDN objects.
 * Copyright (C) 2013 Regents of the University of California.
 * author: Meki Cheraoui
 * See COPYING for copyright and distribution information.
 */

/**
 * An EncodingUtils has static methods for encoding data.
 * @constructor
 */
var EncodingUtils = function EncodingUtils()
{
};

exports.EncodingUtils = EncodingUtils;

EncodingUtils.encodeToHexInterest = function(interest)
{
  return DataUtils.toHex(interest.encode());
};

EncodingUtils.encodeToHexData = function(data)
{
  return DataUtils.toHex(data.encode());
};

/**
 * @deprecated Use EncodingUtils.encodeToHexData(data).
 */
EncodingUtils.encodeToHexContentObject = function(data)
{
  return EncodingUtils.encodeToHexData(data);
}

EncodingUtils.encodeForwardingEntry = function(data)
{
  var enc = new BinaryXMLEncoder();
  data.to_ndnb(enc);
  var bytes = enc.getReducedOstream();

  return bytes;
};

EncodingUtils.decodeHexFaceInstance = function(result)
{
  var numbers = DataUtils.toNumbers(result);
  var decoder = new BinaryXMLDecoder(numbers);

  if (LOG > 3) console.log('DECODING HEX FACE INSTANCE  \n'+numbers);

  var faceInstance = new FaceInstance();
  faceInstance.from_ndnb(decoder);

  return faceInstance;
};

EncodingUtils.decodeHexInterest = function(input)
{
  var interest = new Interest();
  interest.decode(DataUtils.toNumbers(input));
  return interest;
};

EncodingUtils.decodeHexData = function(input)
{
  var data = new Data();
  data.decode(DataUtils.toNumbers(input));
  return data;
};

/**
 * @deprecated Use EncodingUtils.decodeHexData(input).
 */
EncodingUtils.decodeHexContentObject = function(input)
{
  return EncodingUtils.decodeHexData(input);
}

EncodingUtils.decodeHexForwardingEntry = function(result)
{
  var numbers = DataUtils.toNumbers(result);
  var decoder = new BinaryXMLDecoder(numbers);

  if (LOG > 3) console.log('DECODED HEX FORWARDING ENTRY \n'+numbers);

  var forwardingEntry = new ForwardingEntry();
  forwardingEntry.from_ndnb(decoder);
  return forwardingEntry;
};

/**
 * Decode the ndnbuf array which holds SubjectPublicKeyInfo and return an RSAKey.
 */
EncodingUtils.decodeSubjectPublicKeyInfo = function(array)
{
  var hex = DataUtils.toHex(array).toLowerCase();
  var a = _x509_getPublicKeyHexArrayFromCertHex(hex, _x509_getSubjectPublicKeyPosFromCertHex(hex, 0));
  var rsaKey = new RSAKey();
  rsaKey.setPublic(a[0], a[1]);
  return rsaKey;
}

/**
 * Return a user friendly HTML string with the contents of data.
 * This also outputs to console.log.
 */
EncodingUtils.dataToHtml = function(/* Data */ data)
{
  var output ="";

  if (data == -1)
    output+= "NO CONTENT FOUND"
  else if (data == -2)
    output+= "CONTENT NAME IS EMPTY"
  else {
    if (data.name != null && data.name.components != null) {
      output+= "NAME: " + data.name.toUri();

      output+= "<br />";
      output+= "<br />";
    }
    if (data.content != null) {
      output += "CONTENT(ASCII): "+ DataUtils.toString(data.content);

      output+= "<br />";
      output+= "<br />";
    }
    if (data.content != null) {
      output += "CONTENT(hex): "+ DataUtils.toHex(data.content);

      output+= "<br />";
      output+= "<br />";
    }
    if (data.signature != null && data.signature.digestAlgorithm != null) {
      output += "DigestAlgorithm (hex): "+ DataUtils.toHex(data.signature.digestAlgorithm);

      output+= "<br />";
      output+= "<br />";
    }
    if (data.signature != null && data.signature.witness != null) {
      output += "Witness (hex): "+ DataUtils.toHex(data.signature.witness);

      output+= "<br />";
      output+= "<br />";
    }
    if (data.signature != null && data.signature.signature != null) {
      output += "Signature(hex): "+ DataUtils.toHex(data.signature.signature);

      output+= "<br />";
      output+= "<br />";
    }
    if (data.signedInfo != null && data.signedInfo.publisher != null && data.signedInfo.publisher.publisherPublicKeyDigest != null) {
      output += "Publisher Public Key Digest(hex): "+ DataUtils.toHex(data.signedInfo.publisher.publisherPublicKeyDigest);

      output+= "<br />";
      output+= "<br />";
    }
    if (data.signedInfo != null && data.signedInfo.timestamp != null) {
      var d = new Date();
      d.setTime(data.signedInfo.timestamp.msec);

      var bytes = [217, 185, 12, 225, 217, 185, 12, 225];

      output += "TimeStamp: "+d;
      output+= "<br />";
      output += "TimeStamp(number): "+ data.signedInfo.timestamp.msec;

      output+= "<br />";
    }
    if (data.signedInfo != null && data.signedInfo.finalBlockID != null) {
      output += "FinalBlockID: "+ DataUtils.toHex(data.signedInfo.finalBlockID);
      output+= "<br />";
    }
    if (data.signedInfo != null && data.signedInfo.locator != null && data.signedInfo.locator.type) {
      output += "keyLocator: ";
      if (data.signedInfo.locator.type == KeyLocatorType.KEY)
        output += "Key: " + DataUtils.toHex(data.signedInfo.locator.publicKey).toLowerCase() + "<br />";
      else if (data.signedInfo.locator.type == KeyLocatorType.CERTIFICATE)
        output += "Certificate: " + DataUtils.toHex(data.signedInfo.locator.certificate).toLowerCase() + "<br />";
      else if (data.signedInfo.locator.type == KeyLocatorType.KEYNAME)
        output += "KeyName: " + data.signedInfo.locator.keyName.contentName.to_uri() + "<br />";
      else
        output += "[unrecognized ndn_KeyLocatorType " + data.signedInfo.locator.type + "]<br />";
    }
    if (data.signedInfo!= null && data.signedInfo.locator!= null && data.signedInfo.locator.publicKey!= null) {
      var publickeyHex = DataUtils.toHex(data.signedInfo.locator.publicKey).toLowerCase();
      var publickeyString = DataUtils.toString(data.signedInfo.locator.publicKey);
      var signature = DataUtils.toHex(data.signature.signature).toLowerCase();
      var input = DataUtils.toString(data.rawSignatureData);

      var witHex = "";
      if (data.signature.witness != null)
        witHex = DataUtils.toHex(data.signature.witness);

      // Already showed data.signedInfo.locator.publicKey above.
      output+= "<br />";

      if (LOG > 2) console.log(" ContentName + SignedInfo + Content = "+input);
      if (LOG > 2) console.log(" PublicKeyHex = "+publickeyHex);
      if (LOG > 2) console.log(" PublicKeyString = "+publickeyString);

      if (LOG > 2) console.log(" Signature "+signature);
      if (LOG > 2) console.log(" Witness "+witHex);

      if (LOG > 2) console.log(" Signature NOW IS");

      if (LOG > 2) console.log(data.signature.signature);

      var rsakey = new Key();
      rsakey.readDerPublicKey(data.signedInfo.locator.publicKey);

      var result = data.verify(rsakey);
      if (result)
      output += 'SIGNATURE VALID';
      else
      output += 'SIGNATURE INVALID';

      output+= "<br />";
      output+= "<br />";
    }
  }

  return output;
};

/**
 * @deprecated Use return EncodingUtils.dataToHtml(data).
 */
EncodingUtils.contentObjectToHtml = function(data)
{
  return EncodingUtils.dataToHtml(data);
}

//
// Deprecated: For the browser, define these in the global scope.  Applications should access as member of EncodingUtils.
//

var encodeToHexInterest = function(interest) { return EncodingUtils.encodeToHexInterest(interest); }
var encodeToHexContentObject = function(data) { return EncodingUtils.encodeToHexData(data); }
var encodeForwardingEntry = function(data) { return EncodingUtils.encodeForwardingEntry(data); }
var decodeHexFaceInstance = function(input) { return EncodingUtils.decodeHexFaceInstance(input); }
var decodeHexInterest = function(input) { return EncodingUtils.decodeHexInterest(input); }
var decodeHexContentObject = function(input) { return EncodingUtils.decodeHexData(input); }
var decodeHexForwardingEntry = function(input) { return EncodingUtils.decodeHexForwardingEntry(input); }
var decodeSubjectPublicKeyInfo = function(input) { return EncodingUtils.decodeSubjectPublicKeyInfo(input); }
var contentObjectToHtml = function(data) { return EncodingUtils.dataToHtml(data); }

/**
 * @deprecated Use interest.encode().
 */
function encodeToBinaryInterest(interest) { return interest.encode(); }
/**
 * @deprecated Use data.encode().
 */
function encodeToBinaryContentObject(data) { return data.encode(); }
/**
 * Copyright (C) 2013 Regents of the University of California.
 * @author: Meki Cherkaoui, Jeff Thompson <jefft0@remap.ucla.edu>, Wentao Shang
 * See COPYING for copyright and distribution information.
 * This class represents the top-level object for communicating with an NDN host.
 */

/**
 * Create a new Face with the given settings.
 * This throws an exception if Face.supported is false.
 * @constructor
 * @param {Object} settings if not null, an associative array with the following defaults:
 * {
 *   getTransport: function() { return new WebSocketTransport(); }, // If in the browser.
 *              OR function() { return new TcpTransport(); },       // If in Node.js.
 *   getHostAndPort: transport.defaultGetHostAndPort, // a function, on each call it returns a new { host: host, port: port } or null if there are no more hosts.
 *   host: null, // If null, use getHostAndPort when connecting.
 *   port: 9696, // If in the browser.
 *      OR 6363, // If in Node.js.
 *   onopen: function() { if (LOG > 3) console.log("NDN connection established."); },
 *   onclose: function() { if (LOG > 3) console.log("NDN connection closed."); },
 *   verify: false // If false, don't verify and call upcall with Closure.UPCALL_CONTENT_UNVERIFIED.
 * }
 */
var Face = function Face(settings)
{
  if (!Face.supported)
    throw new Error("The necessary JavaScript support is not available on this platform.");

  settings = (settings || {});
  // For the browser, browserify-tcp-transport.js replaces TcpTransport with WebSocketTransport.
  var getTransport = (settings.getTransport || function() { return new TcpTransport(); });
  this.transport = getTransport();
  this.getHostAndPort = (settings.getHostAndPort || this.transport.defaultGetHostAndPort);
  this.host = (settings.host !== undefined ? settings.host : null);
  this.port = (settings.port || (typeof WebSocketTransport != 'undefined' ? 9696 : 6363));
  this.readyStatus = Face.UNOPEN;
  this.verify = (settings.verify !== undefined ? settings.verify : false);
  // Event handler
  this.onopen = (settings.onopen || function() { if (LOG > 3) console.log("Face connection established."); });
  this.onclose = (settings.onclose || function() { if (LOG > 3) console.log("Face connection closed."); });
  this.ndndid = null;
};

exports.Face = Face;

Face.UNOPEN = 0;  // created but not opened yet
Face.OPENED = 1;  // connection to ndnd opened
Face.CLOSED = 2;  // connection to ndnd closed

/**
 * Return true if necessary JavaScript support is available, else log an error and return false.
 */
Face.getSupported = function()
{
  try {
    var dummy = new ndnbuf(1).slice(0, 1);
  }
  catch (ex) {
    console.log("NDN not available: ndnbuf not supported. " + ex);
    return false;
  }

  return true;
};

Face.supported = Face.getSupported();

Face.ndndIdFetcher = new Name('/%C1.M.S.localhost/%C1.M.SRV/ndnd/KEY');

Face.prototype.createRoute = function(host, port)
{
  this.host=host;
  this.port=port;
};

Face.KeyStore = new Array();

var KeyStoreEntry = function KeyStoreEntry(name, rsa, time)
{
  this.keyName = name;  // KeyName
  this.rsaKey = rsa;    // RSA key
  this.timeStamp = time;  // Time Stamp
};

Face.addKeyEntry = function(/* KeyStoreEntry */ keyEntry)
{
  var result = Face.getKeyByName(keyEntry.keyName);
  if (result == null)
    Face.KeyStore.push(keyEntry);
  else
    result = keyEntry;
};

Face.getKeyByName = function(/* KeyName */ name)
{
  var result = null;

  for (var i = 0; i < Face.KeyStore.length; i++) {
    if (Face.KeyStore[i].keyName.contentName.match(name.contentName)) {
      if (result == null || Face.KeyStore[i].keyName.contentName.components.length > result.keyName.contentName.components.length)
        result = Face.KeyStore[i];
    }
  }

  return result;
};

Face.prototype.close = function()
{
  if (this.readyStatus != Face.OPENED)
    throw new Error('Cannot close because Face connection is not opened.');

  this.readyStatus = Face.CLOSED;
  this.transport.close();
};

// For fetching data
Face.PITTable = new Array();

/**
 * @constructor
 */
var PITEntry = function PITEntry(interest, closure)
{
  this.interest = interest;  // Interest
  this.closure = closure;    // Closure
  this.timerID = -1;  // Timer ID
};

/**
 * Return the entry from Face.PITTable where the name conforms to the interest selectors, and
 * the interest name is the longest that matches name.
 */
Face.getEntryForExpressedInterest = function(/*Name*/ name)
{
  var result = null;

  for (var i = 0; i < Face.PITTable.length; i++) {
    if (Face.PITTable[i].interest.matchesName(name)) {
      if (result == null || Face.PITTable[i].interest.name.components.length > result.interest.name.components.length)
        result = Face.PITTable[i];
    }
  }

  return result;
};

// For publishing data
Face.registeredPrefixTable = new Array();

/**
 * @constructor
 */
var RegisteredPrefix = function RegisteredPrefix(prefix, closure)
{
  this.prefix = prefix;        // String
  this.closure = closure;  // Closure
};

/**
 * Find the first entry from Face.registeredPrefixTable where the entry prefix is the longest that matches name.
 * @param {Name} name The name to find the PrefixEntry for (from the incoming interest packet).
 * @returns {object} The entry from Face.registeredPrefixTable, or 0 if not found.
 */
function getEntryForRegisteredPrefix(name)
{
  var iResult = -1;

  for (var i = 0; i < Face.registeredPrefixTable.length; i++) {
    if (LOG > 3) console.log("Registered prefix " + i + ": checking if " + Face.registeredPrefixTable[i].prefix + " matches " + name);
    if (Face.registeredPrefixTable[i].prefix.match(name)) {
      if (iResult < 0 ||
          Face.registeredPrefixTable[i].prefix.size() > Face.registeredPrefixTable[iResult].prefix.size())
        // Update to the longer match.
        iResult = i;
    }
  }

  if (iResult >= 0)
    return Face.registeredPrefixTable[iResult];
  else
    return null;
}

/**
 * Return a function that selects a host at random from hostList and returns { host: host, port: port }.
 * If no more hosts remain, return null.
 */
Face.makeShuffledGetHostAndPort = function(hostList, port)
{
  // Make a copy.
  hostList = hostList.slice(0, hostList.length);
  DataUtils.shuffle(hostList);

  return function() {
    if (hostList.length == 0)
      return null;

    return { host: hostList.splice(0, 1)[0], port: port };
  };
};

/**
 * Send the interest through the transport, read the entire response and call onData.
 * If the interest times out according to interest lifetime, call onTimeout (if not omitted).
 * There are two forms of expressInterest.  The first form takes the exact interest (including lifetime):
 * expressInterest(interest, onData [, onTimeout]).  The second form creates the interest from
 * a name and optional interest template:
 * expressInterest(name [, template], onData [, onTimeout]).
 * This also supports the deprecated form expressInterest(name, closure [, template]), but you should use the other forms.
 * @param {Interest} interest The Interest to send which includes the interest lifetime for the timeout.
 * @param {function} onData When a matching data packet is received, this calls onData(interest, data) where:
 *   interest is the interest given to expressInterest,
 *   data is the received Data object.
 * @param {function} onTimeout (optional) If the interest times out according to the interest lifetime,
 *   this calls onTimeout(interest) where:
 *   interest is the interest given to expressInterest.
 * @param {Name} name The Name for the interest. (only used for the second form of expressInterest).
 * @param {Interest} template (optional) If not omitted, copy the interest selectors from this Interest.
 * If omitted, use a default interest lifetime. (only used for the second form of expressInterest).
 */
Face.prototype.expressInterest = function(interestOrName, arg2, arg3, arg4)
{
  // There are several overloaded versions of expressInterest, each shown inline below.

  // expressInterest(Name name, Closure closure);                      // deprecated
  // expressInterest(Name name, Closure closure,   Interest template); // deprecated
  if (arg2 && arg2.upcall && typeof arg2.upcall == 'function') {
    // Assume arg2 is the deprecated use with Closure.
    if (arg3)
      this.expressInterestWithClosure(interestOrName, arg2, arg3);
    else
      this.expressInterestWithClosure(interestOrName, arg2);
    return;
  }

  var interest;
  var onData;
  var onTimeout;
  // expressInterest(Interest interest, function onData);
  // expressInterest(Interest interest, function onData, function onTimeout);
  if (typeof interestOrName == 'object' && interestOrName instanceof Interest) {
    // Just use a copy of the interest.
    interest = new Interest(interestOrName);
    onData = arg2;
    onTimeout = (arg3 ? arg3 : function() {});
  }
  else {
    // The first argument is a name. Make the interest from the name and possible template.
    interest = new Interest(interestOrName);
    // expressInterest(Name name, Interest template, function onData);
    // expressInterest(Name name, Interest template, function onData, function onTimeout);
    if (arg2 && typeof arg2 == 'object' && arg2 instanceof Interest) {
      var template = arg2;
      interest.minSuffixComponents = template.minSuffixComponents;
      interest.maxSuffixComponents = template.maxSuffixComponents;
      interest.publisherPublicKeyDigest = template.publisherPublicKeyDigest;
      interest.exclude = template.exclude;
      interest.childSelector = template.childSelector;
      interest.answerOriginKind = template.answerOriginKind;
      interest.scope = template.scope;
      interest.interestLifetime = template.interestLifetime;

      onData = arg3;
      onTimeout = (arg4 ? arg4 : function() {});
    }
    // expressInterest(Name name, function onData);
    // expressInterest(Name name, function onData,   function onTimeout);
    else {
      interest.interestLifetime = 4000;   // default interest timeout value in milliseconds.
      onData = arg2;
      onTimeout = (arg3 ? arg3 : function() {});
    }
  }

  // Make a Closure from the callbacks so we can use expressInterestWithClosure.
  // TODO: Convert the PIT to use callbacks, not a closure.
  this.expressInterestWithClosure(interest, new Face.CallbackClosure(onData, onTimeout), interest);
}

Face.CallbackClosure = function FaceCallbackClosure(onData, onTimeout, onInterest, prefix, transport) {
  // Inherit from Closure.
  Closure.call(this);

  this.onData = onData;
  this.onTimeout = onTimeout;
  this.onInterest = onInterest;
  this.prefix = prefix;
  this.transport = transport;
};

Face.CallbackClosure.prototype.upcall = function(kind, upcallInfo) {
  if (kind == Closure.UPCALL_CONTENT || kind == Closure.UPCALL_CONTENT_UNVERIFIED)
    this.onData(upcallInfo.interest, upcallInfo.data);
  else if (kind == Closure.UPCALL_INTEREST_TIMED_OUT)
    this.onTimeout(upcallInfo.interest);
  else if (kind == Closure.UPCALL_INTEREST)
    // Note: We never return INTEREST_CONSUMED because onInterest will send the result to the transport.
    this.onInterest(this.prefix, upcallInfo.interest, this.transport)

  return Closure.RESULT_OK;
};

/**
 * A private method to encode name as an Interest and send the it to host:port, read the entire response and call
 * closure.upcall(Closure.UPCALL_CONTENT (or Closure.UPCALL_CONTENT_UNVERIFIED),
 *                 new UpcallInfo(this, interest, 0, data)).
 * @deprecated Use expressInterest with callback functions, not Closure.
 * @param {Name} name Encode name as an Interest using the template (if supplied).
 * @param {Closure} closure
 * @param {Interest} template If not null, use its attributes.
 */
Face.prototype.expressInterestWithClosure = function(name, closure, template)
{
  var interest = new Interest(name);
  if (template != null) {
    interest.minSuffixComponents = template.minSuffixComponents;
    interest.maxSuffixComponents = template.maxSuffixComponents;
    interest.publisherPublicKeyDigest = template.publisherPublicKeyDigest;
    interest.exclude = template.exclude;
    interest.childSelector = template.childSelector;
    interest.answerOriginKind = template.answerOriginKind;
    interest.scope = template.scope;
    interest.interestLifetime = template.interestLifetime;
  }
  else
    interest.interestLifetime = 4000;   // default interest timeout value in milliseconds.

  if (this.host == null || this.port == null) {
    if (this.getHostAndPort == null)
      console.log('ERROR: host OR port NOT SET');
    else {
      var thisNDN = this;
      this.connectAndExecute(function() { thisNDN.reconnectAndExpressInterest(interest, closure); });
    }
  }
  else
    this.reconnectAndExpressInterest(interest, closure);
};

/**
 * If the host and port are different than the ones in this.transport, then call
 *   this.transport.connect to change the connection (or connect for the first time).
 * Then call expressInterestHelper.
 */
Face.prototype.reconnectAndExpressInterest = function(interest, closure)
{
  if (this.transport.connectedHost != this.host || this.transport.connectedPort != this.port) {
    var thisNDN = this;
    this.transport.connect(thisNDN, function() { thisNDN.expressInterestHelper(interest, closure); });
    this.readyStatus = Face.OPENED;
  }
  else
    this.expressInterestHelper(interest, closure);
};

/**
 * Do the work of reconnectAndExpressInterest once we know we are connected.  Set the PITTable and call
 *   this.transport.send to send the interest.
 */
Face.prototype.expressInterestHelper = function(interest, closure)
{
  var binaryInterest = interest.encode();
  var thisNDN = this;
  //TODO: check local content store first
  if (closure != null) {
    var pitEntry = new PITEntry(interest, closure);
    // TODO: This needs to be a single thread-safe transaction on a global object.
    Face.PITTable.push(pitEntry);
    closure.pitEntry = pitEntry;

    // Set interest timer.
    var timeoutMilliseconds = (interest.interestLifetime || 4000);
    var timeoutCallback = function() {
      if (LOG > 1) console.log("Interest time out: " + interest.name.toUri());

      // Remove PIT entry from Face.PITTable, even if we add it again later to re-express
      //   the interest because we don't want to match it in the mean time.
      // TODO: Make this a thread-safe operation on the global PITTable.
      var index = Face.PITTable.indexOf(pitEntry);
      if (index >= 0)
        Face.PITTable.splice(index, 1);

      // Raise closure callback
      if (closure.upcall(Closure.UPCALL_INTEREST_TIMED_OUT, new UpcallInfo(thisNDN, interest, 0, null)) == Closure.RESULT_REEXPRESS) {
        if (LOG > 1) console.log("Re-express interest: " + interest.name.toUri());
        pitEntry.timerID = setTimeout(timeoutCallback, timeoutMilliseconds);
        Face.PITTable.push(pitEntry);
        thisNDN.transport.send(binaryInterest);
      }
    };

    pitEntry.timerID = setTimeout(timeoutCallback, timeoutMilliseconds);
  }

  this.transport.send(binaryInterest);
};

/**
 * Register prefix with the connected NDN hub and call onInterest when a matching interest is received.
 * This uses the form:
 * registerPrefix(name, onInterest, onRegisterFailed [, flags]).
 * This also supports the deprecated form registerPrefix(name, closure [, intFlags]), but you should use the main form.
 * @param {Name} prefix The Name prefix.
 * @param {function} onInterest When an interest is received which matches the name prefix, this calls
 * onInterest(prefix, interest, transport) where:
 *   prefix is the prefix given to registerPrefix.
 *   interest is the received interest.
 *   transport The Transport with the connection which received the interest. You must encode a signed Data packet and send it using transport.send().
 * @param {function} onRegisterFailed If failed to retrieve the connected hub's ID or failed to register the prefix,
 * this calls onRegisterFailed(prefix) where:
 *   prefix is the prefix given to registerPrefix.
 * @param {ForwardingFlags} flags (optional) The flags for finer control of which interests are forward to the application.
 * If omitted, use the default flags defined by the default ForwardingFlags constructor.
 */
Face.prototype.registerPrefix = function(prefix, arg2, arg3, arg4)
{
  // There are several overloaded versions of registerPrefix, each shown inline below.

  // registerPrefix(Name prefix, Closure closure);            // deprecated
  // registerPrefix(Name prefix, Closure closure, int flags); // deprecated
  if (arg2 && arg2.upcall && typeof arg2.upcall == 'function') {
    // Assume arg2 is the deprecated use with Closure.
    if (arg3)
      this.registerPrefixWithClosure(prefix, arg2, arg3);
    else
      this.registerPrefixWithClosure(prefix, arg2);
    return;
  }

  // registerPrefix(Name prefix, function onInterest, function onRegisterFailed);
  // registerPrefix(Name prefix, function onInterest, function onRegisterFailed, ForwardingFlags flags);
  var onInterest = arg2;
  var onRegisterFailed = (arg3 ? arg3 : function() {});
  var intFlags = (arg4 ? arg4.getForwardingEntryFlags() : new ForwardingFlags().getForwardingEntryFlags());
  this.registerPrefixWithClosure(prefix, new Face.CallbackClosure(null, null, onInterest, prefix, this.transport),
                                 intFlags, onRegisterFailed);
}

/**
 * A private method to register the prefix with the host, receive the data and call
 * closure.upcall(Closure.UPCALL_INTEREST, new UpcallInfo(this, interest, 0, null)).
 * @deprecated Use registerPrefix with callback functions, not Closure.
 * @param {Name} prefix
 * @param {Closure} closure
 * @param {number} intFlags
 * @param {function} (optional) If called from the non-deprecated registerPrefix, call onRegisterFailed(prefix)
 * if registration fails.
 */
Face.prototype.registerPrefixWithClosure = function(prefix, closure, intFlags, onRegisterFailed)
{
  intFlags = intFlags | 3;
  var thisNDN = this;
  var onConnected = function() {
    if (thisNDN.ndndid == null) {
      // Fetch ndndid first, then register.
      var interest = new Interest(Face.ndndIdFetcher);
      interest.interestLifetime = 4000; // milliseconds
      if (LOG > 3) console.log('Expressing interest for ndndid from ndnd.');
      thisNDN.reconnectAndExpressInterest
        (interest, new Face.FetchNdndidClosure(thisNDN, prefix, closure, intFlags, onRegisterFailed));
    }
    else
      thisNDN.registerPrefixHelper(prefix, closure, intFlags);
  };

  if (this.host == null || this.port == null) {
    if (this.getHostAndPort == null)
      console.log('ERROR: host OR port NOT SET');
    else
      this.connectAndExecute(onConnected);
  }
  else
    onConnected();
};

/**
 * This is a closure to receive the Data for Face.ndndIdFetcher and call
 *   registerPrefixHelper(prefix, callerClosure, flags).
 */
Face.FetchNdndidClosure = function FetchNdndidClosure(face, prefix, callerClosure, flags, onRegisterFailed)
{
  // Inherit from Closure.
  Closure.call(this);

  this.face = face;
  this.prefix = prefix;
  this.callerClosure = callerClosure;
  this.flags = flags;
  this.onRegisterFailed = onRegisterFailed;
};

Face.FetchNdndidClosure.prototype.upcall = function(kind, upcallInfo)
{
  if (kind == Closure.UPCALL_INTEREST_TIMED_OUT) {
    console.log("Timeout while requesting the ndndid.  Cannot registerPrefix for " + this.prefix.toUri() + " .");
    if (this.onRegisterFailed)
      this.onRegisterFailed(this.prefix);
    return Closure.RESULT_OK;
  }
  if (!(kind == Closure.UPCALL_CONTENT ||
        kind == Closure.UPCALL_CONTENT_UNVERIFIED))
    // The upcall is not for us.  Don't expect this to happen.
    return Closure.RESULT_ERR;

  var data = upcallInfo.data;
  if (!data.signedInfo || !data.signedInfo.publisher || !data.signedInfo.publisher.publisherPublicKeyDigest) {
    console.log
      ("Data doesn't have a publisherPublicKeyDigest. Cannot set ndndid and registerPrefix for "
       + this.prefix.toUri() + " .");
    if (this.onRegisterFailed)
      this.onRegisterFailed(this.prefix);
  }
  else {
    if (LOG > 3) console.log('Got ndndid from ndnd.');
    this.face.ndndid = data.signedInfo.publisher.publisherPublicKeyDigest;
    if (LOG > 3) console.log(this.face.ndndid);
    this.face.registerPrefixHelper(this.prefix, this.callerClosure, this.flags);
  }

  return Closure.RESULT_OK;
};

/**
 * Do the work of registerPrefix once we know we are connected with a ndndid.
 */
Face.prototype.registerPrefixHelper = function(prefix, closure, flags)
{
  var fe = new ForwardingEntry('selfreg', prefix, null, null, flags, 2147483647);

  var encoder = new BinaryXMLEncoder();
  fe.to_ndnb(encoder);
  var bytes = encoder.getReducedOstream();

  var si = new SignedInfo();
  si.setFields();

  var data = new Data(new Name(), si, bytes);
  data.sign();
  var coBinary = data.encode();;

  var nodename = this.ndndid;
  var interestName = new Name(['ndnx', nodename, 'selfreg', coBinary]);

  var interest = new Interest(interestName);
  interest.scope = 1;
  if (LOG > 3) console.log('Send Interest registration packet.');

  Face.registeredPrefixTable.push(new RegisteredPrefix(prefix, closure));

  this.transport.send(interest.encode());
};

/**
 * This is called when an entire binary XML element is received, such as a Data or Interest.
 * Look up in the PITTable and call the closure callback.
 */
Face.prototype.onReceivedElement = function(element)
{
  if (LOG > 3) console.log('Complete element received. Length ' + element.length + '. Start decoding.');
  var decoder = new BinaryXMLDecoder(element);
  // Dispatch according to packet type
  if (decoder.peekDTag(NDNProtocolDTags.Interest)) {  // Interest packet
    if (LOG > 3) console.log('Interest packet received.');

    var interest = new Interest();
    interest.from_ndnb(decoder);
    if (LOG > 3) console.log(interest);
    if (LOG > 3) console.log(interest.name.toUri());

    var entry = getEntryForRegisteredPrefix(interest.name);
    if (entry != null) {
      if (LOG > 3) console.log("Found registered prefix for " + interest.name.toUri());
      var info = new UpcallInfo(this, interest, 0, null);
      var ret = entry.closure.upcall(Closure.UPCALL_INTEREST, info);
      if (ret == Closure.RESULT_INTEREST_CONSUMED && info.data != null)
        this.transport.send(info.data.encode());
    }
  }
  else if (decoder.peekDTag(NDNProtocolDTags.Data)) {  // Content packet
    if (LOG > 3) console.log('Data packet received.');

    var data = new Data();
    data.from_ndnb(decoder);

    var pitEntry = Face.getEntryForExpressedInterest(data.name);
    if (pitEntry != null) {
      // Cancel interest timer
      clearTimeout(pitEntry.timerID);

      // Remove PIT entry from Face.PITTable
      var index = Face.PITTable.indexOf(pitEntry);
      if (index >= 0)
        Face.PITTable.splice(index, 1);

      var currentClosure = pitEntry.closure;

      if (this.verify == false) {
        // Pass content up without verifying the signature
        currentClosure.upcall(Closure.UPCALL_CONTENT_UNVERIFIED, new UpcallInfo(this, pitEntry.interest, 0, data));
        return;
      }

      // Key verification

      // Recursive key fetching & verification closure
      var KeyFetchClosure = function KeyFetchClosure(content, closure, key, sig, wit) {
        this.data = content;  // unverified data packet object
        this.closure = closure;  // closure corresponding to the data
        this.keyName = key;  // name of current key to be fetched

        Closure.call(this);
      };

      var thisNDN = this;
      KeyFetchClosure.prototype.upcall = function(kind, upcallInfo) {
        if (kind == Closure.UPCALL_INTEREST_TIMED_OUT) {
          console.log("In KeyFetchClosure.upcall: interest time out.");
          console.log(this.keyName.contentName.toUri());
        }
        else if (kind == Closure.UPCALL_CONTENT) {
          var rsakey = new Key();
          rsakey.readDerPublicKey(upcallInfo.data.content);
          var verified = data.verify(rsakey);

          var flag = (verified == true) ? Closure.UPCALL_CONTENT : Closure.UPCALL_CONTENT_BAD;
          this.closure.upcall(flag, new UpcallInfo(thisNDN, null, 0, this.data));

          // Store key in cache
          var keyEntry = new KeyStoreEntry(keylocator.keyName, rsakey, new Date().getTime());
          Face.addKeyEntry(keyEntry);
        }
        else if (kind == Closure.UPCALL_CONTENT_BAD)
          console.log("In KeyFetchClosure.upcall: signature verification failed");
      };

      if (data.signedInfo && data.signedInfo.locator && data.signature) {
        if (LOG > 3) console.log("Key verification...");
        var sigHex = DataUtils.toHex(data.signature.signature).toLowerCase();

        var wit = null;
        if (data.signature.witness != null)
            //SWT: deprecate support for Witness decoding and Merkle hash tree verification
            currentClosure.upcall(Closure.UPCALL_CONTENT_BAD, new UpcallInfo(this, pitEntry.interest, 0, data));

        var keylocator = data.signedInfo.locator;
        if (keylocator.type == KeyLocatorType.KEYNAME) {
          if (LOG > 3) console.log("KeyLocator contains KEYNAME");

          if (keylocator.keyName.contentName.match(data.name)) {
            if (LOG > 3) console.log("Content is key itself");

            var rsakey = new Key();
            rsakey.readDerPublicKey(data.content);
            var verified = data.verify(rsakey);
            var flag = (verified == true) ? Closure.UPCALL_CONTENT : Closure.UPCALL_CONTENT_BAD;

            currentClosure.upcall(flag, new UpcallInfo(this, pitEntry.interest, 0, data));

            // SWT: We don't need to store key here since the same key will be stored again in the closure.
          }
          else {
            // Check local key store
            var keyEntry = Face.getKeyByName(keylocator.keyName);
            if (keyEntry) {
              // Key found, verify now
              if (LOG > 3) console.log("Local key cache hit");
              var rsakey = keyEntry.rsaKey;
              var verified = data.verify(rsakey);
              var flag = (verified == true) ? Closure.UPCALL_CONTENT : Closure.UPCALL_CONTENT_BAD;

              // Raise callback
              currentClosure.upcall(flag, new UpcallInfo(this, pitEntry.interest, 0, data));
            }
            else {
              // Not found, fetch now
              if (LOG > 3) console.log("Fetch key according to keylocator");
              var nextClosure = new KeyFetchClosure(data, currentClosure, keylocator.keyName, sigHex, wit);
              // TODO: Use expressInterest with callbacks, not Closure.
              this.expressInterest(keylocator.keyName.contentName.getPrefix(4), nextClosure);
            }
          }
        }
        else if (keylocator.type == KeyLocatorType.KEY) {
          if (LOG > 3) console.log("Keylocator contains KEY");

          var rsakey = new Key();
          rsakey.readDerPublicKey(keylocator.publicKey);
          var verified = data.verify(rsakey);

          var flag = (verified == true) ? Closure.UPCALL_CONTENT : Closure.UPCALL_CONTENT_BAD;
          // Raise callback
          currentClosure.upcall(Closure.UPCALL_CONTENT, new UpcallInfo(this, pitEntry.interest, 0, data));

          // Since KeyLocator does not contain key name for this key,
          // we have no way to store it as a key entry in KeyStore.
        }
        else {
          var cert = keylocator.certificate;
          console.log("KeyLocator contains CERT");
          console.log(cert);
          // TODO: verify certificate
        }
      }
    }
  }
  else
    console.log('Incoming packet is not Interest or Data. Discard now.');
};

/**
 * Assume this.getHostAndPort is not null.  This is called when this.host is null or its host
 *   is not alive.  Get a host and port, connect, then execute onConnected().
 */
Face.prototype.connectAndExecute = function(onConnected)
{
  var hostAndPort = this.getHostAndPort();
  if (hostAndPort == null) {
    console.log('ERROR: No more hosts from getHostAndPort');
    this.host = null;
    return;
  }

  if (hostAndPort.host == this.host && hostAndPort.port == this.port) {
    console.log('ERROR: The host returned by getHostAndPort is not alive: ' + this.host + ":" + this.port);
    return;
  }

  this.host = hostAndPort.host;
  this.port = hostAndPort.port;
  if (LOG>0) console.log("connectAndExecute: trying host from getHostAndPort: " + this.host);

  // Fetch any content.
  var interest = new Interest(new Name("/"));
  interest.interestLifetime = 4000; // milliseconds

  var thisNDN = this;
  var timerID = setTimeout(function() {
    if (LOG>0) console.log("connectAndExecute: timeout waiting for host " + thisNDN.host);
      // Try again.
      thisNDN.connectAndExecute(onConnected);
  }, 3000);

  this.reconnectAndExpressInterest(interest, new Face.ConnectClosure(this, onConnected, timerID));
};

/**
 * This is called by the Transport when the connection is closed by the remote host.
 */
Face.prototype.closeByTransport = function()
{
  this.readyStatus = Face.CLOSED;
  this.onclose();
};

Face.ConnectClosure = function ConnectClosure(face, onConnected, timerID)
{
  // Inherit from Closure.
  Closure.call(this);

  this.face = face;
  this.onConnected = onConnected;
  this.timerID = timerID;
};

Face.ConnectClosure.prototype.upcall = function(kind, upcallInfo)
{
  if (!(kind == Closure.UPCALL_CONTENT ||
        kind == Closure.UPCALL_CONTENT_UNVERIFIED))
    // The upcall is not for us.
    return Closure.RESULT_ERR;

  // The host is alive, so cancel the timeout and continue with onConnected().
  clearTimeout(this.timerID);

    // Call Face.onopen after success
  this.face.readyStatus = Face.OPENED;
  this.face.onopen();

  if (LOG>0) console.log("connectAndExecute: connected to host " + this.face.host);
  this.onConnected();

  return Closure.RESULT_OK;
};

/**
 * @deprecated Use new Face.
 */
var NDN = function NDN(settings)
{
  // Call the base constructor.
  Face.call(this, settings);
}

// Use dummy functions so that the Face constructor will not try to set its own defaults.
NDN.prototype = new Face({ getTransport: function(){}, getHostAndPort: function(){} });

exports.NDN = NDN;

NDN.supported = Face.supported;
NDN.UNOPEN = Face.UNOPEN;
NDN.OPENED = Face.OPENED;
NDN.CLOSED = Face.CLOSED;


module.exports = exports/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
/**
 * CryptoJS core components.
 */
var CryptoJS = CryptoJS || (function (Math, undefined) {
    /**
     * CryptoJS namespace.
     */
    var C = {};

    /**
     * Library namespace.
     */
    var C_lib = C.lib = {};

    /**
     * Base object for prototypal inheritance.
     */
    var Base = C_lib.Base = (function () {
        function F() {}

        return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function (overrides) {
                // Spawn
                F.prototype = this;
                var subtype = new F();

                // Augment
                if (overrides) {
                    subtype.mixIn(overrides);
                }

                // Create default initializer
                if (!subtype.hasOwnProperty('init')) {
                    subtype.init = function () {
                        subtype.$super.init.apply(this, arguments);
                    };
                }

                // Initializer's prototype is the subtype object
                subtype.init.prototype = subtype;

                // Reference supertype
                subtype.$super = this;

                return subtype;
            },

            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function () {
                var instance = this.extend();
                instance.init.apply(instance, arguments);

                return instance;
            },

            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function () {
            },

            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function (properties) {
                for (var propertyName in properties) {
                    if (properties.hasOwnProperty(propertyName)) {
                        this[propertyName] = properties[propertyName];
                    }
                }

                // IE won't copy toString using the loop above
                if (properties.hasOwnProperty('toString')) {
                    this.toString = properties.toString;
                }
            },

            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function () {
                return this.init.prototype.extend(this);
            }
        };
    }());

    /**
     * An array of 32-bit words.
     *
     * @property {Array} words The array of 32-bit words.
     * @property {number} sigBytes The number of significant bytes in this word array.
     */
    var WordArray = C_lib.WordArray = Base.extend({
        /**
         * Initializes a newly created word array.
         *
         * @param {Array} words (Optional) An array of 32-bit words.
         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
         *
         * @example
         *
         *     var wordArray = CryptoJS.lib.WordArray.create();
         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
         */
        init: function (words, sigBytes) {
            words = this.words = words || [];

            if (sigBytes != undefined) {
                this.sigBytes = sigBytes;
            } else {
                this.sigBytes = words.length * 4;
            }
        },

        /**
         * Converts this word array to a string.
         *
         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
         *
         * @return {string} The stringified word array.
         *
         * @example
         *
         *     var string = wordArray + '';
         *     var string = wordArray.toString();
         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
         */
        toString: function (encoder) {
            return (encoder || Hex).stringify(this);
        },

        /**
         * Concatenates a word array to this word array.
         *
         * @param {WordArray} wordArray The word array to append.
         *
         * @return {WordArray} This word array.
         *
         * @example
         *
         *     wordArray1.concat(wordArray2);
         */
        concat: function (wordArray) {
            // Shortcuts
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;

            // Clamp excess bits
            this.clamp();

            // Concat
            if (thisSigBytes % 4) {
                // Copy one byte at a time
                for (var i = 0; i < thatSigBytes; i++) {
                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
                }
            } else if (thatWords.length > 0xffff) {
                // Copy one word at a time
                for (var i = 0; i < thatSigBytes; i += 4) {
                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
                }
            } else {
                // Copy all words at once
                thisWords.push.apply(thisWords, thatWords);
            }
            this.sigBytes += thatSigBytes;

            // Chainable
            return this;
        },

        /**
         * Removes insignificant bits.
         *
         * @example
         *
         *     wordArray.clamp();
         */
        clamp: function () {
            // Shortcuts
            var words = this.words;
            var sigBytes = this.sigBytes;

            // Clamp
            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
            words.length = Math.ceil(sigBytes / 4);
        },

        /**
         * Creates a copy of this word array.
         *
         * @return {WordArray} The clone.
         *
         * @example
         *
         *     var clone = wordArray.clone();
         */
        clone: function () {
            var clone = Base.clone.call(this);
            clone.words = this.words.slice(0);

            return clone;
        },

        /**
         * Creates a word array filled with random bytes.
         *
         * @param {number} nBytes The number of random bytes to generate.
         *
         * @return {WordArray} The random word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.lib.WordArray.random(16);
         */
        random: function (nBytes) {
            var words = [];
            for (var i = 0; i < nBytes; i += 4) {
                words.push((Math.random() * 0x100000000) | 0);
            }

            return new WordArray.init(words, nBytes);
        }
    });

    /**
     * Encoder namespace.
     */
    var C_enc = C.enc = {};

    /**
     * Hex encoding strategy.
     */
    var Hex = C_enc.Hex = {
        /**
         * Converts a word array to a hex string.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @return {string} The hex string.
         *
         * @static
         *
         * @example
         *
         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
         */
        stringify: function (wordArray) {
            // Shortcuts
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;

            // Convert
            var hexChars = [];
            for (var i = 0; i < sigBytes; i++) {
                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                hexChars.push((bite >>> 4).toString(16));
                hexChars.push((bite & 0x0f).toString(16));
            }

            return hexChars.join('');
        },

        /**
         * Converts a hex string to a word array.
         *
         * @param {string} hexStr The hex string.
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
         */
        parse: function (hexStr) {
            // Shortcut
            var hexStrLength = hexStr.length;

            // Convert
            var words = [];
            for (var i = 0; i < hexStrLength; i += 2) {
                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
            }

            return new WordArray.init(words, hexStrLength / 2);
        }
    };

    /**
     * Latin1 encoding strategy.
     */
    var Latin1 = C_enc.Latin1 = {
        /**
         * Converts a word array to a Latin1 string.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @return {string} The Latin1 string.
         *
         * @static
         *
         * @example
         *
         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
         */
        stringify: function (wordArray) {
            // Shortcuts
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;

            // Convert
            var latin1Chars = [];
            for (var i = 0; i < sigBytes; i++) {
                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                latin1Chars.push(String.fromCharCode(bite));
            }

            return latin1Chars.join('');
        },

        /**
         * Converts a Latin1 string to a word array.
         *
         * @param {string} latin1Str The Latin1 string.
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
         */
        parse: function (latin1Str) {
            // Shortcut
            var latin1StrLength = latin1Str.length;

            // Convert
            var words = [];
            for (var i = 0; i < latin1StrLength; i++) {
                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
            }

            return new WordArray.init(words, latin1StrLength);
        }
    };

    /**
     * UTF-8 encoding strategy.
     */
    var Utf8 = C_enc.Utf8 = {
        /**
         * Converts a word array to a UTF-8 string.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @return {string} The UTF-8 string.
         *
         * @static
         *
         * @example
         *
         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
         */
        stringify: function (wordArray) {
            try {
                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e) {
                throw new Error('Malformed UTF-8 data');
            }
        },

        /**
         * Converts a UTF-8 string to a word array.
         *
         * @param {string} utf8Str The UTF-8 string.
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
         */
        parse: function (utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
        }
    };

    /**
     * Abstract buffered block algorithm template.
     *
     * The property blockSize must be implemented in a concrete subtype.
     *
     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
     */
    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
        /**
         * Resets this block algorithm's data buffer to its initial state.
         *
         * @example
         *
         *     bufferedBlockAlgorithm.reset();
         */
        reset: function () {
            // Initial values
            this._data = new WordArray.init();
            this._nDataBytes = 0;
        },

        /**
         * Adds new data to this block algorithm's buffer.
         *
         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
         *
         * @example
         *
         *     bufferedBlockAlgorithm._append('data');
         *     bufferedBlockAlgorithm._append(wordArray);
         */
        _append: function (data) {
            // Convert string to WordArray, else assume WordArray already
            if (typeof data == 'string') {
                data = Utf8.parse(data);
            }

            // Append
            this._data.concat(data);
            this._nDataBytes += data.sigBytes;
        },

        /**
         * Processes available data blocks.
         *
         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
         *
         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
         *
         * @return {WordArray} The processed data.
         *
         * @example
         *
         *     var processedData = bufferedBlockAlgorithm._process();
         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
         */
        _process: function (doFlush) {
            // Shortcuts
            var data = this._data;
            var dataWords = data.words;
            var dataSigBytes = data.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;

            // Count blocks ready
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
                // Round up to include partial blocks
                nBlocksReady = Math.ceil(nBlocksReady);
            } else {
                // Round down to include only full blocks,
                // less the number of blocks that must remain in the buffer
                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }

            // Count words ready
            var nWordsReady = nBlocksReady * blockSize;

            // Count bytes ready
            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

            // Process blocks
            if (nWordsReady) {
                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                    // Perform concrete-algorithm logic
                    this._doProcessBlock(dataWords, offset);
                }

                // Remove processed words
                var processedWords = dataWords.splice(0, nWordsReady);
                data.sigBytes -= nBytesReady;
            }

            // Return processed words
            return new WordArray.init(processedWords, nBytesReady);
        },

        /**
         * Creates a copy of this object.
         *
         * @return {Object} The clone.
         *
         * @example
         *
         *     var clone = bufferedBlockAlgorithm.clone();
         */
        clone: function () {
            var clone = Base.clone.call(this);
            clone._data = this._data.clone();

            return clone;
        },

        _minBufferSize: 0
    });

    /**
     * Abstract hasher template.
     *
     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
     */
    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
        /**
         * Configuration options.
         */
        cfg: Base.extend(),

        /**
         * Initializes a newly created hasher.
         *
         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
         *
         * @example
         *
         *     var hasher = CryptoJS.algo.SHA256.create();
         */
        init: function (cfg) {
            // Apply config defaults
            this.cfg = this.cfg.extend(cfg);

            // Set initial values
            this.reset();
        },

        /**
         * Resets this hasher to its initial state.
         *
         * @example
         *
         *     hasher.reset();
         */
        reset: function () {
            // Reset data buffer
            BufferedBlockAlgorithm.reset.call(this);

            // Perform concrete-hasher logic
            this._doReset();
        },

        /**
         * Updates this hasher with a message.
         *
         * @param {WordArray|string} messageUpdate The message to append.
         *
         * @return {Hasher} This hasher.
         *
         * @example
         *
         *     hasher.update('message');
         *     hasher.update(wordArray);
         */
        update: function (messageUpdate) {
            // Append
            this._append(messageUpdate);

            // Update the hash
            this._process();

            // Chainable
            return this;
        },

        /**
         * Finalizes the hash computation.
         * Note that the finalize operation is effectively a destructive, read-once operation.
         *
         * @param {WordArray|string} messageUpdate (Optional) A final message update.
         *
         * @return {WordArray} The hash.
         *
         * @example
         *
         *     var hash = hasher.finalize();
         *     var hash = hasher.finalize('message');
         *     var hash = hasher.finalize(wordArray);
         */
        finalize: function (messageUpdate) {
            // Final message update
            if (messageUpdate) {
                this._append(messageUpdate);
            }

            // Perform concrete-hasher logic
            var hash = this._doFinalize();

            return hash;
        },

        blockSize: 512/32,

        /**
         * Creates a shortcut function to a hasher's object interface.
         *
         * @param {Hasher} hasher The hasher to create a helper for.
         *
         * @return {Function} The shortcut function.
         *
         * @static
         *
         * @example
         *
         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
         */
        _createHelper: function (hasher) {
            return function (message, cfg) {
                return new hasher.init(cfg).finalize(message);
            };
        },

        /**
         * Creates a shortcut function to the HMAC's object interface.
         *
         * @param {Hasher} hasher The hasher to use in this HMAC helper.
         *
         * @return {Function} The shortcut function.
         *
         * @static
         *
         * @example
         *
         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
         */
        _createHmacHelper: function (hasher) {
            return function (message, key) {
                return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
        }
    });

    /**
     * Algorithm namespace.
     */
    var C_algo = C.algo = {};

    return C;
}(Math));
/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function (Math) {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var WordArray = C_lib.WordArray;
    var Hasher = C_lib.Hasher;
    var C_algo = C.algo;

    // Initialization and round constants tables
    var H = [];
    var K = [];

    // Compute constants
    (function () {
        function isPrime(n) {
            var sqrtN = Math.sqrt(n);
            for (var factor = 2; factor <= sqrtN; factor++) {
                if (!(n % factor)) {
                    return false;
                }
            }

            return true;
        }

        function getFractionalBits(n) {
            return ((n - (n | 0)) * 0x100000000) | 0;
        }

        var n = 2;
        var nPrime = 0;
        while (nPrime < 64) {
            if (isPrime(n)) {
                if (nPrime < 8) {
                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
                }
                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));

                nPrime++;
            }

            n++;
        }
    }());

    // Reusable object
    var W = [];

    /**
     * SHA-256 hash algorithm.
     */
    var SHA256 = C_algo.SHA256 = Hasher.extend({
        _doReset: function () {
            this._hash = new WordArray.init(H.slice(0));
        },

        _doProcessBlock: function (M, offset) {
            // Shortcut
            var H = this._hash.words;

            // Working variables
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];
            var e = H[4];
            var f = H[5];
            var g = H[6];
            var h = H[7];

            // Computation
            for (var i = 0; i < 64; i++) {
                if (i < 16) {
                    W[i] = M[offset + i] | 0;
                } else {
                    var gamma0x = W[i - 15];
                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^
                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^
                                   (gamma0x >>> 3);

                    var gamma1x = W[i - 2];
                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^
                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^
                                   (gamma1x >>> 10);

                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
                }

                var ch  = (e & f) ^ (~e & g);
                var maj = (a & b) ^ (a & c) ^ (b & c);

                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));
                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));

                var t1 = h + sigma1 + ch + K[i] + W[i];
                var t2 = sigma0 + maj;

                h = g;
                g = f;
                f = e;
                e = (d + t1) | 0;
                d = c;
                c = b;
                b = a;
                a = (t1 + t2) | 0;
            }

            // Intermediate hash value
            H[0] = (H[0] + a) | 0;
            H[1] = (H[1] + b) | 0;
            H[2] = (H[2] + c) | 0;
            H[3] = (H[3] + d) | 0;
            H[4] = (H[4] + e) | 0;
            H[5] = (H[5] + f) | 0;
            H[6] = (H[6] + g) | 0;
            H[7] = (H[7] + h) | 0;
        },

        _doFinalize: function () {
            // Shortcuts
            var data = this._data;
            var dataWords = data.words;

            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;

            // Add padding
            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;

            // Hash final blocks
            this._process();

            // Return final computed hash
            return this._hash;
        },

        clone: function () {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();

            return clone;
        }
    });

    /**
     * Shortcut function to the hasher's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     *
     * @return {WordArray} The hash.
     *
     * @static
     *
     * @example
     *
     *     var hash = CryptoJS.SHA256('message');
     *     var hash = CryptoJS.SHA256(wordArray);
     */
    C.SHA256 = Hasher._createHelper(SHA256);

    /**
     * Shortcut function to the HMAC's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     * @param {WordArray|string} key The secret key.
     *
     * @return {WordArray} The HMAC.
     *
     * @static
     *
     * @example
     *
     *     var hmac = CryptoJS.HmacSHA256(message, key);
     */
    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
}(Math));
var b64map="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var b64pad="=";

function hex2b64(h) {
  var i;
  var c;
  var ret = "";
  for(i = 0; i+3 <= h.length; i+=3) {
    c = parseInt(h.substring(i,i+3),16);
    ret += b64map.charAt(c >> 6) + b64map.charAt(c & 63);
  }
  if(i+1 == h.length) {
    c = parseInt(h.substring(i,i+1),16);
    ret += b64map.charAt(c << 2);
  }
  else if(i+2 == h.length) {
    c = parseInt(h.substring(i,i+2),16);
    ret += b64map.charAt(c >> 2) + b64map.charAt((c & 3) << 4);
  }
  if (b64pad) while((ret.length & 3) > 0) ret += b64pad;
  return ret;
}

// convert a base64 string to hex
function b64tohex(s) {
  var ret = ""
  var i;
  var k = 0; // b64 state, 0-3
  var slop;
  for(i = 0; i < s.length; ++i) {
    if(s.charAt(i) == b64pad) break;
    v = b64map.indexOf(s.charAt(i));
    if(v < 0) continue;
    if(k == 0) {
      ret += int2char(v >> 2);
      slop = v & 3;
      k = 1;
    }
    else if(k == 1) {
      ret += int2char((slop << 2) | (v >> 4));
      slop = v & 0xf;
      k = 2;
    }
    else if(k == 2) {
      ret += int2char(slop);
      ret += int2char(v >> 2);
      slop = v & 3;
      k = 3;
    }
    else {
      ret += int2char((slop << 2) | (v >> 4));
      ret += int2char(v & 0xf);
      k = 0;
    }
  }
  if(k == 1)
    ret += int2char(slop << 2);
  return ret;
}

// convert a base64 string to a byte/number array
function b64toBA(s) {
  //piggyback on b64tohex for now, optimize later
  var h = b64tohex(s);
  var i;
  var a = new Array();
  for(i = 0; 2*i < h.length; ++i) {
    a[i] = parseInt(h.substring(2*i,2*i+2),16);
  }
  return a;
}
// Depends on jsbn.js and rng.js

// Version 1.1: support utf-8 encoding in pkcs1pad2

// convert a (hex) string to a bignum object
function parseBigInt(str,r) {
  return new BigInteger(str,r);
}

function linebrk(s,n) {
  var ret = "";
  var i = 0;
  while(i + n < s.length) {
    ret += s.substring(i,i+n) + "\n";
    i += n;
  }
  return ret + s.substring(i,s.length);
}

function byte2Hex(b) {
  if(b < 0x10)
    return "0" + b.toString(16);
  else
    return b.toString(16);
}

// PKCS#1 (type 2, random) pad input string s to n bytes, and return a bigint
function pkcs1pad2(s,n) {
  if(n < s.length + 11) { // TODO: fix for utf-8
    alert("Message too long for RSA");
    return null;
  }
  var ba = new Array();
  var i = s.length - 1;
  while(i >= 0 && n > 0) {
    var c = s.charCodeAt(i--);
    if(c < 128) { // encode using utf-8
      ba[--n] = c;
    }
    else if((c > 127) && (c < 2048)) {
      ba[--n] = (c & 63) | 128;
      ba[--n] = (c >> 6) | 192;
    }
    else {
      ba[--n] = (c & 63) | 128;
      ba[--n] = ((c >> 6) & 63) | 128;
      ba[--n] = (c >> 12) | 224;
    }
  }
  ba[--n] = 0;
  var rng = new SecureRandom();
  var x = new Array();
  while(n > 2) { // random non-zero pad
    x[0] = 0;
    while(x[0] == 0) rng.nextBytes(x);
    ba[--n] = x[0];
  }
  ba[--n] = 2;
  ba[--n] = 0;
  return new BigInteger(ba);
}

// PKCS#1 (OAEP) mask generation function
function oaep_mgf1_arr(seed, len, hash)
{
    var mask = '', i = 0;

    while (mask.length < len)
    {
        mask += hash(String.fromCharCode.apply(String, seed.concat([
                (i & 0xff000000) >> 24,
                (i & 0x00ff0000) >> 16,
                (i & 0x0000ff00) >> 8,
                i & 0x000000ff])));
        i += 1;
    }

    return mask;
}

var SHA1_SIZE = 20;

// PKCS#1 (OAEP) pad input string s to n bytes, and return a bigint
function oaep_pad(s, n, hash)
{
    if (s.length + 2 * SHA1_SIZE + 2 > n)
    {
        throw "Message too long for RSA";
    }

    var PS = '', i;

    for (i = 0; i < n - s.length - 2 * SHA1_SIZE - 2; i += 1)
    {
        PS += '\x00';
    }

    var DB = rstr_sha1('') + PS + '\x01' + s;
    var seed = new Array(SHA1_SIZE);
    new SecureRandom().nextBytes(seed);

    var dbMask = oaep_mgf1_arr(seed, DB.length, hash || rstr_sha1);
    var maskedDB = [];

    for (i = 0; i < DB.length; i += 1)
    {
        maskedDB[i] = DB.charCodeAt(i) ^ dbMask.charCodeAt(i);
    }

    var seedMask = oaep_mgf1_arr(maskedDB, seed.length, rstr_sha1);
    var maskedSeed = [0];

    for (i = 0; i < seed.length; i += 1)
    {
        maskedSeed[i + 1] = seed[i] ^ seedMask.charCodeAt(i);
    }

    return new BigInteger(maskedSeed.concat(maskedDB));
}

// "empty" RSA key constructor
function RSAKey() {
  this.n = null;
  this.e = 0;
  this.d = null;
  this.p = null;
  this.q = null;
  this.dmp1 = null;
  this.dmq1 = null;
  this.coeff = null;
}

// Set the public key fields N and e from hex strings
function RSASetPublic(N,E) {
  if (typeof N !== "string")
  {
    this.n = N;
    this.e = E;
  }
  else if(N != null && E != null && N.length > 0 && E.length > 0) {
    this.n = parseBigInt(N,16);
    this.e = parseInt(E,16);
  }
  else
    alert("Invalid RSA public key");
}

// Perform raw public operation on "x": return x^e (mod n)
function RSADoPublic(x) {
  return x.modPowInt(this.e, this.n);
}

// Return the PKCS#1 RSA encryption of "text" as an even-length hex string
function RSAEncrypt(text) {
  var m = pkcs1pad2(text,(this.n.bitLength()+7)>>3);
  if(m == null) return null;
  var c = this.doPublic(m);
  if(c == null) return null;
  var h = c.toString(16);
  if((h.length & 1) == 0) return h; else return "0" + h;
}

// Return the PKCS#1 OAEP RSA encryption of "text" as an even-length hex string
function RSAEncryptOAEP(text, hash) {
  var m = oaep_pad(text, (this.n.bitLength()+7)>>3, hash);
  if(m == null) return null;
  var c = this.doPublic(m);
  if(c == null) return null;
  var h = c.toString(16);
  if((h.length & 1) == 0) return h; else return "0" + h;
}

// Return the PKCS#1 RSA encryption of "text" as a Base64-encoded string
//function RSAEncryptB64(text) {
//  var h = this.encrypt(text);
//  if(h) return hex2b64(h); else return null;
//}

// protected
RSAKey.prototype.doPublic = RSADoPublic;

// public
RSAKey.prototype.setPublic = RSASetPublic;
RSAKey.prototype.encrypt = RSAEncrypt;
RSAKey.prototype.encryptOAEP = RSAEncryptOAEP;
//RSAKey.prototype.encrypt_b64 = RSAEncryptB64;
// Depends on rsa.js and jsbn2.js

// Version 1.1: support utf-8 decoding in pkcs1unpad2

// Undo PKCS#1 (type 2, random) padding and, if valid, return the plaintext
function pkcs1unpad2(d,n) {
  var b = d.toByteArray();
  var i = 0;
  while(i < b.length && b[i] == 0) ++i;
  if(b.length-i != n-1 || b[i] != 2)
    return null;
  ++i;
  while(b[i] != 0)
    if(++i >= b.length) return null;
  var ret = "";
  while(++i < b.length) {
    var c = b[i] & 255;
    if(c < 128) { // utf-8 decode
      ret += String.fromCharCode(c);
    }
    else if((c > 191) && (c < 224)) {
      ret += String.fromCharCode(((c & 31) << 6) | (b[i+1] & 63));
      ++i;
    }
    else {
      ret += String.fromCharCode(((c & 15) << 12) | ((b[i+1] & 63) << 6) | (b[i+2] & 63));
      i += 2;
    }
  }
  return ret;
}

// PKCS#1 (OAEP) mask generation function
function oaep_mgf1_str(seed, len, hash)
{
    var mask = '', i = 0;

    while (mask.length < len)
    {
        mask += hash(seed + String.fromCharCode.apply(String, [
                (i & 0xff000000) >> 24,
                (i & 0x00ff0000) >> 16,
                (i & 0x0000ff00) >> 8,
                i & 0x000000ff]));
        i += 1;
    }

    return mask;
}

var SHA1_SIZE = 20;

// Undo PKCS#1 (OAEP) padding and, if valid, return the plaintext
function oaep_unpad(d, n, hash)
{
    d = d.toByteArray();

    var i;

    for (i = 0; i < d.length; i += 1)
    {
        d[i] &= 0xff;
    }

    while (d.length < n)
    {
        d.unshift(0);
    }

    d = String.fromCharCode.apply(String, d);

    if (d.length < 2 * SHA1_SIZE + 2)
    {
        throw "Cipher too short";
    }

    var maskedSeed = d.substr(1, SHA1_SIZE)
    var maskedDB = d.substr(SHA1_SIZE + 1);

    var seedMask = oaep_mgf1_str(maskedDB, SHA1_SIZE, hash || rstr_sha1);
    var seed = [], i;

    for (i = 0; i < maskedSeed.length; i += 1)
    {
        seed[i] = maskedSeed.charCodeAt(i) ^ seedMask.charCodeAt(i);
    }

    var dbMask = oaep_mgf1_str(String.fromCharCode.apply(String, seed),
                           d.length - SHA1_SIZE, rstr_sha1);

    var DB = [];

    for (i = 0; i < maskedDB.length; i += 1)
    {
        DB[i] = maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i);
    }

    DB = String.fromCharCode.apply(String, DB);

    if (DB.substr(0, SHA1_SIZE) !== rstr_sha1(''))
    {
        throw "Hash mismatch";
    }

    DB = DB.substr(SHA1_SIZE);

    var first_one = DB.indexOf('\x01');
    var last_zero = (first_one != -1) ? DB.substr(0, first_one).lastIndexOf('\x00') : -1;

    if (last_zero + 1 != first_one)
    {
        throw "Malformed data";
    }

    return DB.substr(first_one + 1);
}

// Set the private key fields N, e, and d from hex strings
function RSASetPrivate(N,E,D) {
  if (typeof N !== "string")
  {
    this.n = N;
    this.e = E;
    this.d = D;
  }
  else if(N != null && E != null && N.length > 0 && E.length > 0) {
    this.n = parseBigInt(N,16);
    this.e = parseInt(E,16);
    this.d = parseBigInt(D,16);
  }
  else
    alert("Invalid RSA private key");
}

// Set the private key fields N, e, d and CRT params from hex strings
function RSASetPrivateEx(N,E,D,P,Q,DP,DQ,C) {
  //alert("RSASetPrivateEx called");
  if (N == null) throw "RSASetPrivateEx N == null";
  if (E == null) throw "RSASetPrivateEx E == null";
  if (N.length == 0) throw "RSASetPrivateEx N.length == 0";
  if (E.length == 0) throw "RSASetPrivateEx E.length == 0";

  if (N != null && E != null && N.length > 0 && E.length > 0) {
    this.n = parseBigInt(N,16);
    this.e = parseInt(E,16);
    this.d = parseBigInt(D,16);
    this.p = parseBigInt(P,16);
    this.q = parseBigInt(Q,16);
    this.dmp1 = parseBigInt(DP,16);
    this.dmq1 = parseBigInt(DQ,16);
    this.coeff = parseBigInt(C,16);
  } else {
    alert("Invalid RSA private key in RSASetPrivateEx");
  }
}

// Generate a new random private key B bits long, using public expt E
function RSAGenerate(B,E) {
  var rng = new SecureRandom();
  var qs = B>>1;
  this.e = parseInt(E,16);
  var ee = new BigInteger(E,16);
  for(;;) {
    for(;;) {
      this.p = new BigInteger(B-qs,1,rng);
      if(this.p.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) == 0 && this.p.isProbablePrime(10)) break;
    }
    for(;;) {
      this.q = new BigInteger(qs,1,rng);
      if(this.q.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) == 0 && this.q.isProbablePrime(10)) break;
    }
    if(this.p.compareTo(this.q) <= 0) {
      var t = this.p;
      this.p = this.q;
      this.q = t;
    }
    var p1 = this.p.subtract(BigInteger.ONE);	// p1 = p - 1
    var q1 = this.q.subtract(BigInteger.ONE);	// q1 = q - 1
    var phi = p1.multiply(q1);
    if(phi.gcd(ee).compareTo(BigInteger.ONE) == 0) {
      this.n = this.p.multiply(this.q);	// this.n = p * q
      this.d = ee.modInverse(phi);	// this.d =
      this.dmp1 = this.d.mod(p1);	// this.dmp1 = d mod (p - 1)
      this.dmq1 = this.d.mod(q1);	// this.dmq1 = d mod (q - 1)
      this.coeff = this.q.modInverse(this.p);	// this.coeff = (q ^ -1) mod p
      break;
    }
  }
}

// Perform raw private operation on "x": return x^d (mod n)
function RSADoPrivate(x) {
  if(this.p == null || this.q == null)
    return x.modPow(this.d, this.n);

  // TODO: re-calculate any missing CRT params
  var xp = x.mod(this.p).modPow(this.dmp1, this.p); // xp=cp?
  var xq = x.mod(this.q).modPow(this.dmq1, this.q); // xq=cq?

  while(xp.compareTo(xq) < 0)
    xp = xp.add(this.p);
  // NOTE:
  // xp.subtract(xq) => cp -cq
  // xp.subtract(xq).multiply(this.coeff).mod(this.p) => (cp - cq) * u mod p = h
  // xp.subtract(xq).multiply(this.coeff).mod(this.p).multiply(this.q).add(xq) => cq + (h * q) = M
  return xp.subtract(xq).multiply(this.coeff).mod(this.p).multiply(this.q).add(xq);
}

// Return the PKCS#1 RSA decryption of "ctext".
// "ctext" is an even-length hex string and the output is a plain string.
function RSADecrypt(ctext) {
  var c = parseBigInt(ctext, 16);
  var m = this.doPrivate(c);
  if(m == null) return null;
  return pkcs1unpad2(m, (this.n.bitLength()+7)>>3);
}

// Return the PKCS#1 OAEP RSA decryption of "ctext".
// "ctext" is an even-length hex string and the output is a plain string.
function RSADecryptOAEP(ctext, hash) {
  var c = parseBigInt(ctext, 16);
  var m = this.doPrivate(c);
  if(m == null) return null;
  return oaep_unpad(m, (this.n.bitLength()+7)>>3, hash);
}

// Return the PKCS#1 RSA decryption of "ctext".
// "ctext" is a Base64-encoded string and the output is a plain string.
//function RSAB64Decrypt(ctext) {
//  var h = b64tohex(ctext);
//  if(h) return this.decrypt(h); else return null;
//}

// protected
RSAKey.prototype.doPrivate = RSADoPrivate;

// public
RSAKey.prototype.setPrivate = RSASetPrivate;
RSAKey.prototype.setPrivateEx = RSASetPrivateEx;
RSAKey.prototype.generate = RSAGenerate;
RSAKey.prototype.decrypt = RSADecrypt;
RSAKey.prototype.decryptOAEP = RSADecryptOAEP;
//RSAKey.prototype.b64_decrypt = RSAB64Decrypt;
/*! crypto-1.0.4.js (c) 2013 Kenji Urushima | kjur.github.com/jsrsasign/license
 */
/*
 * crypto.js - Cryptographic Algorithm Provider class
 *
 * Copyright (c) 2013 Kenji Urushima (kenji.urushima@gmail.com)
 *
 * This software is licensed under the terms of the MIT License.
 * http://kjur.github.com/jsrsasign/license
 *
 * The above copyright and license notice shall be
 * included in all copies or substantial portions of the Software.
 */

/**
 * @fileOverview
 * @name crypto-1.0.js
 * @author Kenji Urushima kenji.urushima@gmail.com
 * @version 1.0.4 (2013-Mar-28)
 * @since 2.2
 * @license <a href="http://kjur.github.io/jsrsasign/license/">MIT License</a>
 */

/**
 * kjur's class library name space
 * @name KJUR
 * @namespace kjur's class library name space
 */
if (typeof KJUR == "undefined" || !KJUR) KJUR = {};
/**
 * kjur's cryptographic algorithm provider library name space
 * <p>
 * This namespace privides following crytpgrahic classes.
 * <ul>
 * <li>{@link KJUR.crypto.MessageDigest} - Java JCE(cryptograhic extension) style MessageDigest class</li>
 * <li>{@link KJUR.crypto.Signature} - Java JCE(cryptograhic extension) style Signature class</li>
 * <li>{@link KJUR.crypto.Util} - cryptographic utility functions and properties</li>
 * </ul>
 * NOTE: Please ignore method summary and document of this namespace. This caused by a bug of jsdoc2.
 * </p>
 * @name KJUR.crypto
 * @namespace
 */
if (typeof KJUR.crypto == "undefined" || !KJUR.crypto) KJUR.crypto = {};

/**
 * static object for cryptographic function utilities
 * @name KJUR.crypto.Util
 * @class static object for cryptographic function utilities
 * @property {Array} DIGESTINFOHEAD PKCS#1 DigestInfo heading hexadecimal bytes for each hash algorithms
 * @description
 */
KJUR.crypto.Util = new function() {
    this.DIGESTINFOHEAD = {
	'sha1':      "3021300906052b0e03021a05000414",
        'sha224':    "302d300d06096086480165030402040500041c",
	'sha256':    "3031300d060960864801650304020105000420",
	'sha384':    "3041300d060960864801650304020205000430",
	'sha512':    "3051300d060960864801650304020305000440",
	'md2':       "3020300c06082a864886f70d020205000410",
	'md5':       "3020300c06082a864886f70d020505000410",
	'ripemd160': "3021300906052b2403020105000414"
    };

    /**
     * get hexadecimal DigestInfo
     * @name getDigestInfoHex
     * @memberOf KJUR.crypto.Util
     * @function
     * @param {String} hHash hexadecimal hash value
     * @param {String} alg hash algorithm name (ex. 'sha1')
     * @return {String} hexadecimal string DigestInfo ASN.1 structure
     */
    this.getDigestInfoHex = function(hHash, alg) {
	if (typeof this.DIGESTINFOHEAD[alg] == "undefined")
	    throw "alg not supported in Util.DIGESTINFOHEAD: " + alg;
	return this.DIGESTINFOHEAD[alg] + hHash;
    };

    /**
     * get PKCS#1 padded hexadecimal DigestInfo
     * @name getPaddedDigestInfoHex
     * @memberOf KJUR.crypto.Util
     * @function
     * @param {String} hHash hexadecimal hash value
     * @param {String} alg hash algorithm name (ex. 'sha1')
     * @param {Integer} keySize key bit length (ex. 1024)
     * @return {String} hexadecimal string of PKCS#1 padded DigestInfo
     */
    this.getPaddedDigestInfoHex = function(hHash, alg, keySize) {
	var hDigestInfo = this.getDigestInfoHex(hHash, alg);
	var pmStrLen = keySize / 4; // minimum PM length

	if (hDigestInfo.length + 22 > pmStrLen) // len(0001+ff(*8)+00+hDigestInfo)=22
	    throw "key is too short for SigAlg: keylen=" + keySize + "," + alg;

	var hHead = "0001";
	var hTail = "00" + hDigestInfo;
	var hMid = "";
	var fLen = pmStrLen - hHead.length - hTail.length;
	for (var i = 0; i < fLen; i += 2) {
	    hMid += "ff";
	}
	var hPaddedMessage = hHead + hMid + hTail;
	return hPaddedMessage;
    };

    /**
     * get hexadecimal SHA1 hash of string
     * @name sha1
     * @memberOf KJUR.crypto.Util
     * @function
     * @param {String} s input string to be hashed
     * @return {String} hexadecimal string of hash value
     * @since 1.0.3
     */
    this.sha1 = function(s) {
        var md = new KJUR.crypto.MessageDigest({'alg':'sha1', 'prov':'cryptojs'});
        return md.digestString(s);
    };

    /**
     * get hexadecimal SHA256 hash of string
     * @name sha256
     * @memberOf KJUR.crypto.Util
     * @function
     * @param {String} s input string to be hashed
     * @return {String} hexadecimal string of hash value
     * @since 1.0.3
     */
    this.sha256 = function(s) {
        var md = new KJUR.crypto.MessageDigest({'alg':'sha256', 'prov':'cryptojs'});
        return md.digestString(s);
    };

    /**
     * get hexadecimal SHA512 hash of string
     * @name sha512
     * @memberOf KJUR.crypto.Util
     * @function
     * @param {String} s input string to be hashed
     * @return {String} hexadecimal string of hash value
     * @since 1.0.3
     */
    this.sha512 = function(s) {
        var md = new KJUR.crypto.MessageDigest({'alg':'sha512', 'prov':'cryptojs'});
        return md.digestString(s);
    };

    /**
     * get hexadecimal MD5 hash of string
     * @name md5
     * @memberOf KJUR.crypto.Util
     * @function
     * @param {String} s input string to be hashed
     * @return {String} hexadecimal string of hash value
     * @since 1.0.3
     */
    this.md5 = function(s) {
        var md = new KJUR.crypto.MessageDigest({'alg':'md5', 'prov':'cryptojs'});
        return md.digestString(s);
    };

    /**
     * get hexadecimal RIPEMD160 hash of string
     * @name ripemd160
     * @memberOf KJUR.crypto.Util
     * @function
     * @param {String} s input string to be hashed
     * @return {String} hexadecimal string of hash value
     * @since 1.0.3
     */
    this.ripemd160 = function(s) {
        var md = new KJUR.crypto.MessageDigest({'alg':'ripemd160', 'prov':'cryptojs'});
        return md.digestString(s);
    };
};

/**
 * MessageDigest class which is very similar to java.security.MessageDigest class
 * @name KJUR.crypto.MessageDigest
 * @class MessageDigest class which is very similar to java.security.MessageDigest class
 * @param {Array} params parameters for constructor
 * @description
 * <br/>
 * Currently this supports following algorithm and providers combination:
 * <ul>
 * <li>md5 - cryptojs</li>
 * <li>sha1 - cryptojs</li>
 * <li>sha224 - cryptojs</li>
 * <li>sha256 - cryptojs</li>
 * <li>sha384 - cryptojs</li>
 * <li>sha512 - cryptojs</li>
 * <li>ripemd160 - cryptojs</li>
 * <li>sha256 - sjcl (NEW from crypto.js 1.0.4)</li>
 * </ul>
 * @example
 * // CryptoJS provider sample
 * &lt;script src="http://crypto-js.googlecode.com/svn/tags/3.1.2/build/components/core.js"&gt;&lt;/script&gt;
 * &lt;script src="http://crypto-js.googlecode.com/svn/tags/3.1.2/build/components/sha1.js"&gt;&lt;/script&gt;
 * &lt;script src="crypto-1.0.js"&gt;&lt;/script&gt;
 * var md = new KJUR.crypto.MessageDigest({alg: "sha1", prov: "cryptojs"});
 * md.updateString('aaa')
 * var mdHex = md.digest()
 *
 * // SJCL(Stanford JavaScript Crypto Library) provider sample
 * &lt;script src="http://bitwiseshiftleft.github.io/sjcl/sjcl.js"&gt;&lt;/script&gt;
 * &lt;script src="crypto-1.0.js"&gt;&lt;/script&gt;
 * var md = new KJUR.crypto.MessageDigest({alg: "sha256", prov: "sjcl"}); // sjcl supports sha256 only
 * md.updateString('aaa')
 * var mdHex = md.digest()
 */
KJUR.crypto.MessageDigest = function(params) {
    var md = null;
    var algName = null;
    var provName = null;
    var _CryptoJSMdName = {
	'md5': 'CryptoJS.algo.MD5',
	'sha1': 'CryptoJS.algo.SHA1',
	'sha224': 'CryptoJS.algo.SHA224',
	'sha256': 'CryptoJS.algo.SHA256',
	'sha384': 'CryptoJS.algo.SHA384',
	'sha512': 'CryptoJS.algo.SHA512',
	'ripemd160': 'CryptoJS.algo.RIPEMD160'
    };

    /**
     * set hash algorithm and provider
     * @name setAlgAndProvider
     * @memberOf KJUR.crypto.MessageDigest
     * @function
     * @param {String} alg hash algorithm name
     * @param {String} prov provider name
     * @description
     * @example
     * // for SHA1
     * md.setAlgAndProvider('sha1', 'cryptojs');
     * // for RIPEMD160
     * md.setAlgAndProvider('ripemd160', 'cryptojs');
     */
    this.setAlgAndProvider = function(alg, prov) {
	if (':md5:sha1:sha224:sha256:sha384:sha512:ripemd160:'.indexOf(alg) != -1 &&
	    prov == 'cryptojs') {
	    try {
		this.md = eval(_CryptoJSMdName[alg]).create();
	    } catch (ex) {
		throw "setAlgAndProvider hash alg set fail alg=" + alg + "/" + ex;
	    }
	    this.updateString = function(str) {
		this.md.update(str);
	    };
	    this.updateHex = function(hex) {
		var wHex = CryptoJS.enc.Hex.parse(hex);
		this.md.update(wHex);
	    };
	    this.digest = function() {
		var hash = this.md.finalize();
		return hash.toString(CryptoJS.enc.Hex);
	    };
	    this.digestString = function(str) {
		this.updateString(str);
		return this.digest();
	    };
	    this.digestHex = function(hex) {
		this.updateHex(hex);
		return this.digest();
	    };
	}
	if (':sha256:'.indexOf(alg) != -1 &&
	    prov == 'sjcl') {
	    try {
		this.md = new sjcl.hash.sha256();
	    } catch (ex) {
		throw "setAlgAndProvider hash alg set fail alg=" + alg + "/" + ex;
	    }
	    this.updateString = function(str) {
		this.md.update(str);
	    };
	    this.updateHex = function(hex) {
		var baHex = sjcl.codec.hex.toBits(hex);
		this.md.update(baHex);
	    };
	    this.digest = function() {
		var hash = this.md.finalize();
		return sjcl.codec.hex.fromBits(hash);
	    };
	    this.digestString = function(str) {
		this.updateString(str);
		return this.digest();
	    };
	    this.digestHex = function(hex) {
		this.updateHex(hex);
		return this.digest();
	    };
	}
    };

    /**
     * update digest by specified string
     * @name updateString
     * @memberOf KJUR.crypto.MessageDigest
     * @function
     * @param {String} str string to update
     * @description
     * @example
     * md.updateString('New York');
     */
    this.updateString = function(str) {
	throw "updateString(str) not supported for this alg/prov: " + this.algName + "/" + this.provName;
    };

    /**
     * update digest by specified hexadecimal string
     * @name updateHex
     * @memberOf KJUR.crypto.MessageDigest
     * @function
     * @param {String} hex hexadecimal string to update
     * @description
     * @example
     * md.updateHex('0afe36');
     */
    this.updateHex = function(hex) {
	throw "updateHex(hex) not supported for this alg/prov: " + this.algName + "/" + this.provName;
    };

    /**
     * completes hash calculation and returns hash result
     * @name digest
     * @memberOf KJUR.crypto.MessageDigest
     * @function
     * @description
     * @example
     * md.digest()
     */
    this.digest = function() {
	throw "digest() not supported for this alg/prov: " + this.algName + "/" + this.provName;
    };

    /**
     * performs final update on the digest using string, then completes the digest computation
     * @name digestString
     * @memberOf KJUR.crypto.MessageDigest
     * @function
     * @param {String} str string to final update
     * @description
     * @example
     * md.digestString('aaa')
     */
    this.digestString = function(str) {
	throw "digestString(str) not supported for this alg/prov: " + this.algName + "/" + this.provName;
    };

    /**
     * performs final update on the digest using hexadecimal string, then completes the digest computation
     * @name digestHex
     * @memberOf KJUR.crypto.MessageDigest
     * @function
     * @param {String} hex hexadecimal string to final update
     * @description
     * @example
     * md.digestHex('0f2abd')
     */
    this.digestHex = function(hex) {
	throw "digestHex(hex) not supported for this alg/prov: " + this.algName + "/" + this.provName;
    };

    if (typeof params != "undefined") {
	if (typeof params['alg'] != "undefined") {
	    this.algName = params['alg'];
	    this.provName = params['prov'];
	    this.setAlgAndProvider(params['alg'], params['prov']);
	}
    }
};


/**
 * Signature class which is very similar to java.security.Signature class
 * @name KJUR.crypto.Signature
 * @class Signature class which is very similar to java.security.Signature class
 * @param {Array} params parameters for constructor
 * @property {String} state Current state of this signature object whether 'SIGN', 'VERIFY' or null
 * @description
 * <br/>
 * As for params of constructor's argument, it can be specify following attributes:
 * <ul>
 * <li>alg - signature algorithm name (ex. {MD5,SHA1,SHA224,SHA256,SHA384,SHA512,RIPEMD160}withRSA)</li>
 * <li>provider - currently 'cryptojs/jsrsa' only</li>
 * <li>prvkeypem - PEM string of signer's private key. If this specified, no need to call initSign(prvKey).</li>
 * </ul>
 * <h4>SUPPORTED ALGORITHMS AND PROVIDERS</h4>
 * Signature class supports {MD5,SHA1,SHA224,SHA256,SHA384,SHA512,RIPEMD160}
 * withRSA algorithm in 'cryptojs/jsrsa' provider.
 * <h4>EXAMPLES</h4>
 * @example
 * // signature generation
 * var sig = new KJUR.crypto.Signature({"alg": "SHA1withRSA", "prov": "cryptojs/jsrsa"});
 * sig.initSign(prvKey);
 * sig.updateString('aaa');
 * var hSigVal = sig.sign();
 *
 * // signature validation
 * var sig2 = new KJUR.crypto.Signature({"alg": "SHA1withRSA", "prov": "cryptojs/jsrsa"});
 * sig2.initVerifyByCertificatePEM(cert)
 * sig.updateString('aaa');
 * var isValid = sig2.verify(hSigVal);
 */
KJUR.crypto.Signature = function(params) {
    var prvKey = null; // RSAKey for signing
    var pubKey = null; // RSAKey for verifying

    var md = null; // KJUR.crypto.MessageDigest object
    var sig = null;
    var algName = null;
    var provName = null;
    var algProvName = null;
    var mdAlgName = null;
    var pubkeyAlgName = null;
    var state = null;

    var sHashHex = null; // hex hash value for hex
    var hDigestInfo = null;
    var hPaddedDigestInfo = null;
    var hSign = null;

    this._setAlgNames = function() {
	if (this.algName.match(/^(.+)with(.+)$/)) {
	    this.mdAlgName = RegExp.$1.toLowerCase();
	    this.pubkeyAlgName = RegExp.$2.toLowerCase();
	}
    };

    this._zeroPaddingOfSignature = function(hex, bitLength) {
	var s = "";
	var nZero = bitLength / 4 - hex.length;
	for (var i = 0; i < nZero; i++) {
	    s = s + "0";
	}
	return s + hex;
    };

    /**
     * set signature algorithm and provider
     * @name setAlgAndProvider
     * @memberOf KJUR.crypto.Signature
     * @function
     * @param {String} alg signature algorithm name
     * @param {String} prov provider name
     * @description
     * @example
     * md.setAlgAndProvider('SHA1withRSA', 'cryptojs/jsrsa');
     */
    this.setAlgAndProvider = function(alg, prov) {
	this._setAlgNames();
	if (prov != 'cryptojs/jsrsa')
	    throw "provider not supported: " + prov;

	if (':md5:sha1:sha224:sha256:sha384:sha512:ripemd160:'.indexOf(this.mdAlgName) != -1) {
	    try {
		this.md = new KJUR.crypto.MessageDigest({'alg':this.mdAlgName,'prov':'cryptojs'});
	    } catch (ex) {
		throw "setAlgAndProvider hash alg set fail alg=" + this.mdAlgName + "/" + ex;
	    }

	    this.initSign = function(prvKey) {
		this.prvKey = prvKey;
		this.state = "SIGN";
	    };

	    this.initVerifyByPublicKey = function(rsaPubKey) {
		this.pubKey = rsaPubKey;
		this.state = "VERIFY";
	    };

	    this.initVerifyByCertificatePEM = function(certPEM) {
		var x509 = new X509();
		x509.readCertPEM(certPEM);
		this.pubKey = x509.subjectPublicKeyRSA;
		this.state = "VERIFY";
	    };

	    this.updateString = function(str) {
		this.md.updateString(str);
	    };
	    this.updateHex = function(hex) {
		this.md.updateHex(hex);
	    };
	    this.sign = function() {
                var util = KJUR.crypto.Util;
		var keyLen = this.prvKey.n.bitLength();
		this.sHashHex = this.md.digest();
		this.hDigestInfo = util.getDigestInfoHex(this.sHashHex, this.mdAlgName);
		this.hPaddedDigestInfo =
                    util.getPaddedDigestInfoHex(this.sHashHex, this.mdAlgName, keyLen);

		var biPaddedDigestInfo = parseBigInt(this.hPaddedDigestInfo, 16);
		this.hoge = biPaddedDigestInfo.toString(16);

		var biSign = this.prvKey.doPrivate(biPaddedDigestInfo);
		this.hSign = this._zeroPaddingOfSignature(biSign.toString(16), keyLen);
		return this.hSign;
	    };
	    this.signString = function(str) {
		this.updateString(str);
		this.sign();
	    };
	    this.signHex = function(hex) {
		this.updateHex(hex);
		this.sign();
	    };
	    this.verify = function(hSigVal) {
                var util = KJUR.crypto.Util;
		var keyLen = this.pubKey.n.bitLength();
		this.sHashHex = this.md.digest();

		var biSigVal = parseBigInt(hSigVal, 16);
		var biPaddedDigestInfo = this.pubKey.doPublic(biSigVal);
		this.hPaddedDigestInfo = biPaddedDigestInfo.toString(16);
                var s = this.hPaddedDigestInfo;
                s = s.replace(/^1ff+00/, '');

		var hDIHEAD = KJUR.crypto.Util.DIGESTINFOHEAD[this.mdAlgName];
                if (s.indexOf(hDIHEAD) != 0) {
		    return false;
		}
		var hHashFromDI = s.substr(hDIHEAD.length);
		//alert(hHashFromDI + "\n" + this.sHashHex);
		return (hHashFromDI == this.sHashHex);
	    };
	}
    };

    /**
     * Initialize this object for verifying with a public key
     * @name initVerifyByPublicKey
     * @memberOf KJUR.crypto.Signature
     * @function
     * @param {RSAKey} rsaPubKey RSAKey object of public key
     * @since 1.0.2
     * @description
     * @example
     * sig.initVerifyByPublicKey(prvKey)
     */
    this.initVerifyByPublicKey = function(rsaPubKey) {
	throw "initVerifyByPublicKey(rsaPubKeyy) not supported for this alg:prov=" + this.algProvName;
    };

    /**
     * Initialize this object for verifying with a certficate
     * @name initVerifyByCertificatePEM
     * @memberOf KJUR.crypto.Signature
     * @function
     * @param {String} certPEM PEM formatted string of certificate
     * @since 1.0.2
     * @description
     * @example
     * sig.initVerifyByCertificatePEM(certPEM)
     */
    this.initVerifyByCertificatePEM = function(certPEM) {
	throw "initVerifyByCertificatePEM(certPEM) not supported for this alg:prov=" + this.algProvName;
    };

    /**
     * Initialize this object for signing
     * @name initSign
     * @memberOf KJUR.crypto.Signature
     * @function
     * @param {RSAKey} prvKey RSAKey object of private key
     * @description
     * @example
     * sig.initSign(prvKey)
     */
    this.initSign = function(prvKey) {
	throw "initSign(prvKey) not supported for this alg:prov=" + this.algProvName;
    };

    /**
     * Updates the data to be signed or verified by a string
     * @name updateString
     * @memberOf KJUR.crypto.Signature
     * @function
     * @param {String} str string to use for the update
     * @description
     * @example
     * sig.updateString('aaa')
     */
    this.updateString = function(str) {
	throw "updateString(str) not supported for this alg:prov=" + this.algProvName;
    };

    /**
     * Updates the data to be signed or verified by a hexadecimal string
     * @name updateHex
     * @memberOf KJUR.crypto.Signature
     * @function
     * @param {String} hex hexadecimal string to use for the update
     * @description
     * @example
     * sig.updateHex('1f2f3f')
     */
    this.updateHex = function(hex) {
	throw "updateHex(hex) not supported for this alg:prov=" + this.algProvName;
    };

    /**
     * Returns the signature bytes of all data updates as a hexadecimal string
     * @name sign
     * @memberOf KJUR.crypto.Signature
     * @function
     * @return the signature bytes as a hexadecimal string
     * @description
     * @example
     * var hSigValue = sig.sign()
     */
    this.sign = function() {
	throw "sign() not supported for this alg:prov=" + this.algProvName;
    };

    /**
     * performs final update on the sign using string, then returns the signature bytes of all data updates as a hexadecimal string
     * @name signString
     * @memberOf KJUR.crypto.Signature
     * @function
     * @param {String} str string to final update
     * @return the signature bytes of a hexadecimal string
     * @description
     * @example
     * var hSigValue = sig.signString('aaa')
     */
    this.signString = function(str) {
	throw "digestString(str) not supported for this alg:prov=" + this.algProvName;
    };

    /**
     * performs final update on the sign using hexadecimal string, then returns the signature bytes of all data updates as a hexadecimal string
     * @name signHex
     * @memberOf KJUR.crypto.Signature
     * @function
     * @param {String} hex hexadecimal string to final update
     * @return the signature bytes of a hexadecimal string
     * @description
     * @example
     * var hSigValue = sig.signHex('1fdc33')
     */
    this.signHex = function(hex) {
	throw "digestHex(hex) not supported for this alg:prov=" + this.algProvName;
    };

    /**
     * verifies the passed-in signature.
     * @name verify
     * @memberOf KJUR.crypto.Signature
     * @function
     * @param {String} str string to final update
     * @return {Boolean} true if the signature was verified, otherwise false
     * @description
     * @example
     * var isValid = sig.verify('1fbcefdca4823a7(snip)')
     */
    this.verify = function(hSigVal) {
	throw "verify(hSigVal) not supported for this alg:prov=" + this.algProvName;
    };

    if (typeof params != "undefined") {
	if (typeof params['alg'] != "undefined") {
	    this.algName = params['alg'];
	    this.provName = params['prov'];
	    this.algProvName = params['alg'] + ":" + params['prov'];
	    this.setAlgAndProvider(params['alg'], params['prov']);
	    this._setAlgNames();
	}
	if (typeof params['prvkeypem'] != "undefined") {
	    if (typeof params['prvkeypas'] != "undefined") {
		throw "both prvkeypem and prvkeypas parameters not supported";
	    } else {
		try {
		    var prvKey = new RSAKey();
		    prvKey.readPrivateKeyFromPEMString(params['prvkeypem']);
		    this.initSign(prvKey);
		} catch (ex) {
		    throw "fatal error to load pem private key: " + ex;
		}
	    }
	}
    }
};

/*! rsapem-1.1.js (c) 2012 Kenji Urushima | kjur.github.com/jsrsasign/license
 */
//
// rsa-pem.js - adding function for reading/writing PKCS#1 PEM private key
//              to RSAKey class.
//
// version: 1.1.1 (2013-Apr-12)
//
// Copyright (c) 2010-2013 Kenji Urushima (kenji.urushima@gmail.com)
//
// This software is licensed under the terms of the MIT License.
// http://kjur.github.com/jsrsasign/license/
//
// The above copyright and license notice shall be
// included in all copies or substantial portions of the Software.
//
//
// Depends on:
//
//
//
// _RSApem_pemToBase64(sPEM)
//
//   removing PEM header, PEM footer and space characters including
//   new lines from PEM formatted RSA private key string.
//

/**
 * @fileOverview
 * @name rsapem-1.1.js
 * @author Kenji Urushima kenji.urushima@gmail.com
 * @version 1.1
 * @license <a href="http://kjur.github.io/jsrsasign/license/">MIT License</a>
 */
function _rsapem_pemToBase64(sPEMPrivateKey) {
  var s = sPEMPrivateKey;
  s = s.replace("-----BEGIN RSA PRIVATE KEY-----", "");
  s = s.replace("-----END RSA PRIVATE KEY-----", "");
  s = s.replace(/[ \n]+/g, "");
  return s;
}

function _rsapem_getPosArrayOfChildrenFromHex(hPrivateKey) {
  var a = new Array();
  var v1 = ASN1HEX.getStartPosOfV_AtObj(hPrivateKey, 0);
  var n1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, v1);
  var e1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, n1);
  var d1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, e1);
  var p1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, d1);
  var q1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, p1);
  var dp1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, q1);
  var dq1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, dp1);
  var co1 = ASN1HEX.getPosOfNextSibling_AtObj(hPrivateKey, dq1);
  a.push(v1, n1, e1, d1, p1, q1, dp1, dq1, co1);
  return a;
}

function _rsapem_getHexValueArrayOfChildrenFromHex(hPrivateKey) {
  var posArray = _rsapem_getPosArrayOfChildrenFromHex(hPrivateKey);
  var v =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[0]);
  var n =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[1]);
  var e =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[2]);
  var d =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[3]);
  var p =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[4]);
  var q =  ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[5]);
  var dp = ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[6]);
  var dq = ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[7]);
  var co = ASN1HEX.getHexOfV_AtObj(hPrivateKey, posArray[8]);
  var a = new Array();
  a.push(v, n, e, d, p, q, dp, dq, co);
  return a;
}

/**
 * read RSA private key from a ASN.1 hexadecimal string
 * @name readPrivateKeyFromASN1HexString
 * @memberOf RSAKey#
 * @function
 * @param {String} keyHex ASN.1 hexadecimal string of PKCS#1 private key.
 * @since 1.1.1
 */
function _rsapem_readPrivateKeyFromASN1HexString(keyHex) {
  var a = _rsapem_getHexValueArrayOfChildrenFromHex(keyHex);
  this.setPrivateEx(a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);
}

/**
 * read PKCS#1 private key from a string
 * @name readPrivateKeyFromPEMString
 * @memberOf RSAKey#
 * @function
 * @param {String} keyPEM string of PKCS#1 private key.
 */
function _rsapem_readPrivateKeyFromPEMString(keyPEM) {
  var keyB64 = _rsapem_pemToBase64(keyPEM);
  var keyHex = b64tohex(keyB64) // depends base64.js
  var a = _rsapem_getHexValueArrayOfChildrenFromHex(keyHex);
  this.setPrivateEx(a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);
}

RSAKey.prototype.readPrivateKeyFromPEMString = _rsapem_readPrivateKeyFromPEMString;
RSAKey.prototype.readPrivateKeyFromASN1HexString = _rsapem_readPrivateKeyFromASN1HexString;
/*! rsasign-1.2.2.js (c) 2012 Kenji Urushima | kjur.github.com/jsrsasign/license
 */
//
// rsa-sign.js - adding signing functions to RSAKey class.
//
//
// version: 1.2.2 (13 May 2013)
//
// Copyright (c) 2010-2013 Kenji Urushima (kenji.urushima@gmail.com)
//
// This software is licensed under the terms of the MIT License.
// http://kjur.github.com/jsrsasign/license/
//
// The above copyright and license notice shall be
// included in all copies or substantial portions of the Software.

//
// Depends on:
//   function sha1.hex(s) of sha1.js
//   jsbn.js
//   jsbn2.js
//   rsa.js
//   rsa2.js
//

// keysize / pmstrlen
//  512 /  128
// 1024 /  256
// 2048 /  512
// 4096 / 1024

/**
 * @fileOverview
 * @name rsasign-1.2.js
 * @author Kenji Urushima kenji.urushima@gmail.com
 * @version 1.2.2
 * @license <a href="http://kjur.github.io/jsrsasign/license/">MIT License</a>
 */

/**
 * @property {Dictionary} _RSASIGN_DIHEAD
 * @description Array of head part of hexadecimal DigestInfo value for hash algorithms.
 * You can add any DigestInfo hash algorith for signing.
 * See PKCS#1 v2.1 spec (p38).
 */
var _RSASIGN_DIHEAD = [];
_RSASIGN_DIHEAD['sha1'] =      "3021300906052b0e03021a05000414";
_RSASIGN_DIHEAD['sha256'] =    "3031300d060960864801650304020105000420";
_RSASIGN_DIHEAD['sha384'] =    "3041300d060960864801650304020205000430";
_RSASIGN_DIHEAD['sha512'] =    "3051300d060960864801650304020305000440";
_RSASIGN_DIHEAD['md2'] =       "3020300c06082a864886f70d020205000410";
_RSASIGN_DIHEAD['md5'] =       "3020300c06082a864886f70d020505000410";
_RSASIGN_DIHEAD['ripemd160'] = "3021300906052b2403020105000414";

/**
 * @property {Dictionary} _RSASIGN_HASHHEXFUNC
 * @description Array of functions which calculate hash and returns it as hexadecimal.
 * You can add any hash algorithm implementations.
 */
var _RSASIGN_HASHHEXFUNC = [];
_RSASIGN_HASHHEXFUNC['sha1'] =      function(s){return KJUR.crypto.Util.sha1(s);};
_RSASIGN_HASHHEXFUNC['sha256'] =    function(s){return KJUR.crypto.Util.sha256(s);}
_RSASIGN_HASHHEXFUNC['sha512'] =    function(s){return KJUR.crypto.Util.sha512(s);}
_RSASIGN_HASHHEXFUNC['md5'] =       function(s){return KJUR.crypto.Util.md5(s);};
_RSASIGN_HASHHEXFUNC['ripemd160'] = function(s){return KJUR.crypto.Util.ripemd160(s);};

//_RSASIGN_HASHHEXFUNC['sha1'] =   function(s){return sha1.hex(s);}   // http://user1.matsumoto.ne.jp/~goma/js/hash.html
//_RSASIGN_HASHHEXFUNC['sha256'] = function(s){return sha256.hex;}    // http://user1.matsumoto.ne.jp/~goma/js/hash.html

var _RE_HEXDECONLY = new RegExp("");
_RE_HEXDECONLY.compile("[^0-9a-f]", "gi");

// ========================================================================
// Signature Generation
// ========================================================================

function _rsasign_getHexPaddedDigestInfoForString(s, keySize, hashAlg) {
    var pmStrLen = keySize / 4;
    var hashFunc = _RSASIGN_HASHHEXFUNC[hashAlg];
    var sHashHex = hashFunc(s);

    var sHead = "0001";
    var sTail = "00" + _RSASIGN_DIHEAD[hashAlg] + sHashHex;
    var sMid = "";
    var fLen = pmStrLen - sHead.length - sTail.length;
    for (var i = 0; i < fLen; i += 2) {
	sMid += "ff";
    }
    sPaddedMessageHex = sHead + sMid + sTail;
    return sPaddedMessageHex;
}

function _zeroPaddingOfSignature(hex, bitLength) {
    var s = "";
    var nZero = bitLength / 4 - hex.length;
    for (var i = 0; i < nZero; i++) {
	s = s + "0";
    }
    return s + hex;
}

/**
 * sign for a message string with RSA private key.<br/>
 * @name signString
 * @memberOf RSAKey#
 * @function
 * @param {String} s message string to be signed.
 * @param {String} hashAlg hash algorithm name for signing.<br/>
 * @return returns hexadecimal string of signature value.
 */
function _rsasign_signString(s, hashAlg) {
    //alert("this.n.bitLength() = " + this.n.bitLength());
    var hPM = _rsasign_getHexPaddedDigestInfoForString(s, this.n.bitLength(), hashAlg);
    var biPaddedMessage = parseBigInt(hPM, 16);
    var biSign = this.doPrivate(biPaddedMessage);
    var hexSign = biSign.toString(16);
    return _zeroPaddingOfSignature(hexSign, this.n.bitLength());
}

function _rsasign_signStringWithSHA1(s) {
    return _rsasign_signString.call(this, s, 'sha1');
}

function _rsasign_signStringWithSHA256(s) {
    return _rsasign_signString.call(this, s, 'sha256');
}

// PKCS#1 (PSS) mask generation function
function pss_mgf1_str(seed, len, hash) {
    var mask = '', i = 0;

    while (mask.length < len) {
        mask += hash(seed + String.fromCharCode.apply(String, [
                (i & 0xff000000) >> 24,
                (i & 0x00ff0000) >> 16,
                (i & 0x0000ff00) >> 8,
                i & 0x000000ff]));
        i += 1;
    }

    return mask;
}

/**
 * sign for a message string with RSA private key by PKCS#1 PSS signing.<br/>
 * @name signStringPSS
 * @memberOf RSAKey#
 * @function
 * @param {String} s message string to be signed.
 * @param {String} hashAlg hash algorithm name for signing.<br/>
 * @return returns hexadecimal string of signature value.
 */
function _rsasign_signStringPSS(s, hashAlg, sLen) {
    var hashFunc = _RSASIGN_HASHRAWFUNC[hashAlg];
    var mHash = hashFunc(s);
    var hLen = mHash.length;
    var emBits = this.n.bitLength() - 1;
    var emLen = Math.ceil(emBits / 8);
    var i;

    if (sLen === -1) {
        sLen = hLen; // same has hash length
    } else if ((sLen === -2) || (sLen === undefined)) {
        sLen = emLen - hLen - 2; // maximum
    } else if (sLen < -2) {
        throw "invalid salt length";
    }

    if (emLen < (hLen + sLen + 2)) {
        throw "data too long";
    }

    var salt = '';

    if (sLen > 0) {
        salt = new Array(sLen);
        new SecureRandom().nextBytes(salt);
        salt = String.fromCharCode.apply(String, salt);
    }

    var H = hashFunc('\x00\x00\x00\x00\x00\x00\x00\x00' + mHash + salt);
    var PS = [];

    for (i = 0; i < emLen - sLen - hLen - 2; i += 1) {
        PS[i] = 0x00;
    }

    var DB = String.fromCharCode.apply(String, PS) + '\x01' + salt;
    var dbMask = pss_mgf1_str(H, DB.length, hashFunc);
    var maskedDB = [];

    for (i = 0; i < DB.length; i += 1) {
        maskedDB[i] = DB.charCodeAt(i) ^ dbMask.charCodeAt(i);
    }

    var mask = (0xff00 >> (8 * emLen - emBits)) & 0xff;
    maskedDB[0] &= ~mask;

    for (i = 0; i < hLen; i++) {
        maskedDB.push(H.charCodeAt(i));
    }

    maskedDB.push(0xbc);

    return _zeroPaddingOfSignature(
            this.doPrivate(new BigInteger(maskedDB)).toString(16),
            this.n.bitLength());
}

// ========================================================================
// Signature Verification
// ========================================================================

function _rsasign_getDecryptSignatureBI(biSig, hN, hE) {
    var rsa = new RSAKey();
    rsa.setPublic(hN, hE);
    var biDecryptedSig = rsa.doPublic(biSig);
    return biDecryptedSig;
}

function _rsasign_getHexDigestInfoFromSig(biSig, hN, hE) {
    var biDecryptedSig = _rsasign_getDecryptSignatureBI(biSig, hN, hE);
    var hDigestInfo = biDecryptedSig.toString(16).replace(/^1f+00/, '');
    return hDigestInfo;
}

function _rsasign_getAlgNameAndHashFromHexDisgestInfo(hDigestInfo) {
    for (var algName in _RSASIGN_DIHEAD) {
	var head = _RSASIGN_DIHEAD[algName];
	var len = head.length;
	if (hDigestInfo.substring(0, len) == head) {
	    var a = [algName, hDigestInfo.substring(len)];
	    return a;
	}
    }
    return [];
}

function _rsasign_verifySignatureWithArgs(sMsg, biSig, hN, hE) {
    var hDigestInfo = _rsasign_getHexDigestInfoFromSig(biSig, hN, hE);
    var digestInfoAry = _rsasign_getAlgNameAndHashFromHexDisgestInfo(hDigestInfo);
    if (digestInfoAry.length == 0) return false;
    var algName = digestInfoAry[0];
    var diHashValue = digestInfoAry[1];
    var ff = _RSASIGN_HASHHEXFUNC[algName];
    var msgHashValue = ff(sMsg);
    return (diHashValue == msgHashValue);
}

function _rsasign_verifyHexSignatureForMessage(hSig, sMsg) {
    var biSig = parseBigInt(hSig, 16);
    var result = _rsasign_verifySignatureWithArgs(sMsg, biSig,
						  this.n.toString(16),
						  this.e.toString(16));
    return result;
}

/**
 * verifies a sigature for a message string with RSA public key.<br/>
 * @name verifyString
 * @memberOf RSAKey#
 * @function
 * @param {String} sMsg message string to be verified.
 * @param {String} hSig hexadecimal string of siganture.<br/>
 *                 non-hexadecimal charactors including new lines will be ignored.
 * @return returns 1 if valid, otherwise 0
 */
function _rsasign_verifyString(sMsg, hSig) {
    hSig = hSig.replace(_RE_HEXDECONLY, '');
    if (hSig.length != this.n.bitLength() / 4) return 0;
    hSig = hSig.replace(/[ \n]+/g, "");
    var biSig = parseBigInt(hSig, 16);
    var biDecryptedSig = this.doPublic(biSig);
    var hDigestInfo = biDecryptedSig.toString(16).replace(/^1f+00/, '');
    var digestInfoAry = _rsasign_getAlgNameAndHashFromHexDisgestInfo(hDigestInfo);

    if (digestInfoAry.length == 0) return false;
    var algName = digestInfoAry[0];
    var diHashValue = digestInfoAry[1];
    var ff = _RSASIGN_HASHHEXFUNC[algName];
    var msgHashValue = ff(sMsg);
    return (diHashValue == msgHashValue);
}

/**
 * verifies a sigature for a message string with RSA public key by PKCS#1 PSS sign.<br/>
 * @name verifyStringPSS
 * @memberOf RSAKey#
 * @function
 * @param {String} sMsg message string to be verified.
 * @param {String} hSig hexadecimal string of siganture.<br/>
 *                 non-hexadecimal charactors including new lines will be ignored.
 * @return returns 1 if valid, otherwise 0
 */
function _rsasign_verifyStringPSS(sMsg, hSig, hashAlg, sLen) {
    if (hSig.length !== this.n.bitLength() / 4) {
        return false;
    }

    var hashFunc = _RSASIGN_HASHRAWFUNC[hashAlg];
    var mHash = hashFunc(sMsg);
    var hLen = mHash.length;
    var emBits = this.n.bitLength() - 1;
    var emLen = Math.ceil(emBits / 8);
    var i;

    if (sLen === -1) {
        sLen = hLen; // same has hash length
    } else if ((sLen === -2) || (sLen === undefined)) {
        sLen = emLen - hLen - 2; // maximum
    } else if (sLen < -2) {
        throw "invalid salt length";
    }

    if (emLen < (hLen + sLen + 2)) {
        throw "data too long";
    }

    var em = this.doPublic(parseBigInt(hSig, 16)).toByteArray();

    for (i = 0; i < em.length; i += 1) {
        em[i] &= 0xff;
    }

    while (em.length < emLen) {
        em.unshift(0);
    }

    if (em[emLen -1] !== 0xbc) {
        throw "encoded message does not end in 0xbc";
    }

    em = String.fromCharCode.apply(String, em);

    var maskedDB = em.substr(0, emLen - hLen - 1);
    var H = em.substr(maskedDB.length, hLen);

    var mask = (0xff00 >> (8 * emLen - emBits)) & 0xff;

    if ((maskedDB.charCodeAt(0) & mask) !== 0) {
        throw "bits beyond keysize not zero";
    }

    var dbMask = pss_mgf1_str(H, maskedDB.length, hashFunc);
    var DB = [];

    for (i = 0; i < maskedDB.length; i += 1) {
        DB[i] = maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i);
    }

    DB[0] &= ~mask;

    var checkLen = emLen - hLen - sLen - 2;

    for (i = 0; i < checkLen; i += 1) {
        if (DB[i] !== 0x00) {
            throw "leftmost octets not zero";
        }
    }

    if (DB[checkLen] !== 0x01) {
        throw "0x01 marker not found";
    }

    return H === hashFunc('\x00\x00\x00\x00\x00\x00\x00\x00' + mHash +
                          String.fromCharCode.apply(String, DB.slice(-sLen)));
}

RSAKey.prototype.signString = _rsasign_signString;
RSAKey.prototype.signStringWithSHA1 = _rsasign_signStringWithSHA1;
RSAKey.prototype.signStringWithSHA256 = _rsasign_signStringWithSHA256;
RSAKey.prototype.sign = _rsasign_signString;
RSAKey.prototype.signWithSHA1 = _rsasign_signStringWithSHA1;
RSAKey.prototype.signWithSHA256 = _rsasign_signStringWithSHA256;
RSAKey.prototype.signStringPSS = _rsasign_signStringPSS;
RSAKey.prototype.signPSS = _rsasign_signStringPSS;
RSAKey.SALT_LEN_HLEN = -1;
RSAKey.SALT_LEN_MAX = -2;

RSAKey.prototype.verifyString = _rsasign_verifyString;
RSAKey.prototype.verifyHexSignatureForMessage = _rsasign_verifyHexSignatureForMessage;
RSAKey.prototype.verify = _rsasign_verifyString;
RSAKey.prototype.verifyHexSignatureForByteArrayMessage = _rsasign_verifyHexSignatureForMessage;
RSAKey.prototype.verifyStringPSS = _rsasign_verifyStringPSS;
RSAKey.prototype.verifyPSS = _rsasign_verifyStringPSS;
RSAKey.SALT_LEN_RECOVER = -2;

/**
 * @name RSAKey
 * @class key of RSA public key algorithm
 * @description Tom Wu's RSA Key class and extension
 */
/*! asn1hex-1.1.js (c) 2012 Kenji Urushima | kjur.github.com/jsrsasign/license
 */
//
// asn1hex.js - Hexadecimal represented ASN.1 string library
//
// version: 1.1 (09-May-2012)
//
// Copyright (c) 2010-2012 Kenji Urushima (kenji.urushima@gmail.com)
//
// This software is licensed under the terms of the MIT License.
// http://kjur.github.com/jsrsasign/license/
//
// The above copyright and license notice shall be
// included in all copies or substantial portions of the Software.
//
// Depends on:
//

// MEMO:
//   f('3082025b02...', 2) ... 82025b ... 3bytes
//   f('020100', 2) ... 01 ... 1byte
//   f('0203001...', 2) ... 03 ... 1byte
//   f('02818003...', 2) ... 8180 ... 2bytes
//   f('3080....0000', 2) ... 80 ... -1
//
//   Requirements:
//   - ASN.1 type octet length MUST be 1.
//     (i.e. ASN.1 primitives like SET, SEQUENCE, INTEGER, OCTETSTRING ...)
//   -

/**
 * @fileOverview
 * @name asn1hex-1.1.js
 * @author Kenji Urushima kenji.urushima@gmail.com
 * @version 1.1
 * @license <a href="http://kjur.github.io/jsrsasign/license/">MIT License</a>
 */

/**
 * get byte length for ASN.1 L(length) bytes
 * @name getByteLengthOfL_AtObj
 * @memberOf ASN1HEX
 * @function
 * @param {String} s hexadecimal string of ASN.1 DER encoded data
 * @param {Number} pos string index
 * @return byte length for ASN.1 L(length) bytes
 */
function _asnhex_getByteLengthOfL_AtObj(s, pos) {
  if (s.substring(pos + 2, pos + 3) != '8') return 1;
  var i = parseInt(s.substring(pos + 3, pos + 4));
  if (i == 0) return -1; 		// length octet '80' indefinite length
  if (0 < i && i < 10) return i + 1;	// including '8?' octet;
  return -2;				// malformed format
}


/**
 * get hexadecimal string for ASN.1 L(length) bytes
 * @name getHexOfL_AtObj
 * @memberOf ASN1HEX
 * @function
 * @param {String} s hexadecimal string of ASN.1 DER encoded data
 * @param {Number} pos string index
 * @return {String} hexadecimal string for ASN.1 L(length) bytes
 */
function _asnhex_getHexOfL_AtObj(s, pos) {
  var len = _asnhex_getByteLengthOfL_AtObj(s, pos);
  if (len < 1) return '';
  return s.substring(pos + 2, pos + 2 + len * 2);
}

//
//   getting ASN.1 length value at the position 'idx' of
//   hexa decimal string 's'.
//
//   f('3082025b02...', 0) ... 82025b ... ???
//   f('020100', 0) ... 01 ... 1
//   f('0203001...', 0) ... 03 ... 3
//   f('02818003...', 0) ... 8180 ... 128
/**
 * get integer value of ASN.1 length for ASN.1 data
 * @name getIntOfL_AtObj
 * @memberOf ASN1HEX
 * @function
 * @param {String} s hexadecimal string of ASN.1 DER encoded data
 * @param {Number} pos string index
 * @return ASN.1 L(length) integer value
 */
function _asnhex_getIntOfL_AtObj(s, pos) {
  var hLength = _asnhex_getHexOfL_AtObj(s, pos);
  if (hLength == '') return -1;
  var bi;
  if (parseInt(hLength.substring(0, 1)) < 8) {
     bi = parseBigInt(hLength, 16);
  } else {
     bi = parseBigInt(hLength.substring(2), 16);
  }
  return bi.intValue();
}

/**
 * get ASN.1 value starting string position for ASN.1 object refered by index 'idx'.
 * @name getStartPosOfV_AtObj
 * @memberOf ASN1HEX
 * @function
 * @param {String} s hexadecimal string of ASN.1 DER encoded data
 * @param {Number} pos string index
 */
function _asnhex_getStartPosOfV_AtObj(s, pos) {
  var l_len = _asnhex_getByteLengthOfL_AtObj(s, pos);
  if (l_len < 0) return l_len;
  return pos + (l_len + 1) * 2;
}

/**
 * get hexadecimal string of ASN.1 V(value)
 * @name getHexOfV_AtObj
 * @memberOf ASN1HEX
 * @function
 * @param {String} s hexadecimal string of ASN.1 DER encoded data
 * @param {Number} pos string index
 * @return {String} hexadecimal string of ASN.1 value.
 */
function _asnhex_getHexOfV_AtObj(s, pos) {
  var pos1 = _asnhex_getStartPosOfV_AtObj(s, pos);
  var len = _asnhex_getIntOfL_AtObj(s, pos);
  return s.substring(pos1, pos1 + len * 2);
}

/**
 * get hexadecimal string of ASN.1 TLV at
 * @name getHexOfTLV_AtObj
 * @memberOf ASN1HEX
 * @function
 * @param {String} s hexadecimal string of ASN.1 DER encoded data
 * @param {Number} pos string index
 * @return {String} hexadecimal string of ASN.1 TLV.
 * @since 1.1
 */
function _asnhex_getHexOfTLV_AtObj(s, pos) {
  var hT = s.substr(pos, 2);
  var hL = _asnhex_getHexOfL_AtObj(s, pos);
  var hV = _asnhex_getHexOfV_AtObj(s, pos);
  return hT + hL + hV;
}

/**
 * get next sibling starting index for ASN.1 object string
 * @name getPosOfNextSibling_AtObj
 * @memberOf ASN1HEX
 * @function
 * @param {String} s hexadecimal string of ASN.1 DER encoded data
 * @param {Number} pos string index
 * @return next sibling starting index for ASN.1 object string
 */
function _asnhex_getPosOfNextSibling_AtObj(s, pos) {
  var pos1 = _asnhex_getStartPosOfV_AtObj(s, pos);
  var len = _asnhex_getIntOfL_AtObj(s, pos);
  return pos1 + len * 2;
}

/**
 * get array of indexes of child ASN.1 objects
 * @name getPosArrayOfChildren_AtObj
 * @memberOf ASN1HEX
 * @function
 * @param {String} s hexadecimal string of ASN.1 DER encoded data
 * @param {Number} start string index of ASN.1 object
 * @return {Array of Number} array of indexes for childen of ASN.1 objects
 */
function _asnhex_getPosArrayOfChildren_AtObj(h, pos) {
  var a = new Array();
  var p0 = _asnhex_getStartPosOfV_AtObj(h, pos);
  a.push(p0);

  var len = _asnhex_getIntOfL_AtObj(h, pos);
  var p = p0;
  var k = 0;
  while (1) {
    var pNext = _asnhex_getPosOfNextSibling_AtObj(h, p);
    if (pNext == null || (pNext - p0  >= (len * 2))) break;
    if (k >= 200) break;

    a.push(pNext);
    p = pNext;

    k++;
  }

  return a;
}

/**
 * get string index of nth child object of ASN.1 object refered by h, idx
 * @name getNthChildIndex_AtObj
 * @memberOf ASN1HEX
 * @function
 * @param {String} h hexadecimal string of ASN.1 DER encoded data
 * @param {Number} idx start string index of ASN.1 object
 * @param {Number} nth for child
 * @return {Number} string index of nth child.
 * @since 1.1
 */
function _asnhex_getNthChildIndex_AtObj(h, idx, nth) {
  var a = _asnhex_getPosArrayOfChildren_AtObj(h, idx);
  return a[nth];
}

// ========== decendant methods ==============================

/**
 * get string index of nth child object of ASN.1 object refered by h, idx
 * @name getDecendantIndexByNthList
 * @memberOf ASN1HEX
 * @function
 * @param {String} h hexadecimal string of ASN.1 DER encoded data
 * @param {Number} currentIndex start string index of ASN.1 object
 * @param {Array of Number} nthList array list of nth
 * @return {Number} string index refered by nthList
 * @since 1.1
 */
function _asnhex_getDecendantIndexByNthList(h, currentIndex, nthList) {
  if (nthList.length == 0) {
    return currentIndex;
  }
  var firstNth = nthList.shift();
  var a = _asnhex_getPosArrayOfChildren_AtObj(h, currentIndex);
  return _asnhex_getDecendantIndexByNthList(h, a[firstNth], nthList);
}

/**
 * get hexadecimal string of ASN.1 TLV refered by current index and nth index list.
 * @name getDecendantHexTLVByNthList
 * @memberOf ASN1HEX
 * @function
 * @param {String} h hexadecimal string of ASN.1 DER encoded data
 * @param {Number} currentIndex start string index of ASN.1 object
 * @param {Array of Number} nthList array list of nth
 * @return {Number} hexadecimal string of ASN.1 TLV refered by nthList
 * @since 1.1
 */
function _asnhex_getDecendantHexTLVByNthList(h, currentIndex, nthList) {
  var idx = _asnhex_getDecendantIndexByNthList(h, currentIndex, nthList);
  return _asnhex_getHexOfTLV_AtObj(h, idx);
}

/**
 * get hexadecimal string of ASN.1 V refered by current index and nth index list.
 * @name getDecendantHexVByNthList
 * @memberOf ASN1HEX
 * @function
 * @param {String} h hexadecimal string of ASN.1 DER encoded data
 * @param {Number} currentIndex start string index of ASN.1 object
 * @param {Array of Number} nthList array list of nth
 * @return {Number} hexadecimal string of ASN.1 V refered by nthList
 * @since 1.1
 */
function _asnhex_getDecendantHexVByNthList(h, currentIndex, nthList) {
  var idx = _asnhex_getDecendantIndexByNthList(h, currentIndex, nthList);
  return _asnhex_getHexOfV_AtObj(h, idx);
}

// ========== class definition ==============================

/**
 * ASN.1 DER encoded hexadecimal string utility class
 * @class ASN.1 DER encoded hexadecimal string utility class
 * @author Kenji Urushima
 * @version 1.1 (09 May 2012)
 * @see <a href="http://kjur.github.com/jsrsasigns/">'jwrsasign'(RSA Sign JavaScript Library) home page http://kjur.github.com/jsrsasign/</a>
 * @since 1.1
 */
function ASN1HEX() {
  return ASN1HEX;
}

ASN1HEX.getByteLengthOfL_AtObj = _asnhex_getByteLengthOfL_AtObj;
ASN1HEX.getHexOfL_AtObj = _asnhex_getHexOfL_AtObj;
ASN1HEX.getIntOfL_AtObj = _asnhex_getIntOfL_AtObj;
ASN1HEX.getStartPosOfV_AtObj = _asnhex_getStartPosOfV_AtObj;
ASN1HEX.getHexOfV_AtObj = _asnhex_getHexOfV_AtObj;
ASN1HEX.getHexOfTLV_AtObj = _asnhex_getHexOfTLV_AtObj;
ASN1HEX.getPosOfNextSibling_AtObj = _asnhex_getPosOfNextSibling_AtObj;
ASN1HEX.getPosArrayOfChildren_AtObj = _asnhex_getPosArrayOfChildren_AtObj;
ASN1HEX.getNthChildIndex_AtObj = _asnhex_getNthChildIndex_AtObj;
ASN1HEX.getDecendantIndexByNthList = _asnhex_getDecendantIndexByNthList;
ASN1HEX.getDecendantHexVByNthList = _asnhex_getDecendantHexVByNthList;
ASN1HEX.getDecendantHexTLVByNthList = _asnhex_getDecendantHexTLVByNthList;
/*! x509-1.1.js (c) 2012 Kenji Urushima | kjur.github.com/jsrsasign/license
 */
//
// x509.js - X509 class to read subject public key from certificate.
//
// version: 1.1 (10-May-2012)
//
// Copyright (c) 2010-2012 Kenji Urushima (kenji.urushima@gmail.com)
//
// This software is licensed under the terms of the MIT License.
// http://kjur.github.com/jsrsasign/license
//
// The above copyright and license notice shall be
// included in all copies or substantial portions of the Software.
//

// Depends:
//   base64.js
//   rsa.js
//   asn1hex.js

/**
 * @fileOverview
 * @name x509-1.1.js
 * @author Kenji Urushima kenji.urushima@gmail.com
 * @version 1.1
 * @license <a href="http://kjur.github.io/jsrsasign/license/">MIT License</a>
 */

function _x509_pemToBase64(sCertPEM) {
  var s = sCertPEM;
  s = s.replace("-----BEGIN CERTIFICATE-----", "");
  s = s.replace("-----END CERTIFICATE-----", "");
  s = s.replace(/[ \n]+/g, "");
  return s;
}

function _x509_pemToHex(sCertPEM) {
  var b64Cert = _x509_pemToBase64(sCertPEM);
  var hCert = b64tohex(b64Cert);
  return hCert;
}

function _x509_getHexTbsCertificateFromCert(hCert) {
  var pTbsCert = ASN1HEX.getStartPosOfV_AtObj(hCert, 0);
  return pTbsCert;
}

// NOTE: privateKeyUsagePeriod field of X509v2 not supported.
// NOTE: v1 and v3 supported
function _x509_getSubjectPublicKeyInfoPosFromCertHex(hCert) {
  var pTbsCert = ASN1HEX.getStartPosOfV_AtObj(hCert, 0);
  var a = ASN1HEX.getPosArrayOfChildren_AtObj(hCert, pTbsCert);
  if (a.length < 1) return -1;
  if (hCert.substring(a[0], a[0] + 10) == "a003020102") { // v3
    if (a.length < 6) return -1;
    return a[6];
  } else {
    if (a.length < 5) return -1;
    return a[5];
  }
}

// NOTE: Without BITSTRING encapsulation.
function _x509_getSubjectPublicKeyPosFromCertHex(hCert) {
  var pInfo = _x509_getSubjectPublicKeyInfoPosFromCertHex(hCert);
  if (pInfo == -1) return -1;
  var a = ASN1HEX.getPosArrayOfChildren_AtObj(hCert, pInfo);
  if (a.length != 2) return -1;
  var pBitString = a[1];
  if (hCert.substring(pBitString, pBitString + 2) != '03') return -1;
  var pBitStringV = ASN1HEX.getStartPosOfV_AtObj(hCert, pBitString);

  if (hCert.substring(pBitStringV, pBitStringV + 2) != '00') return -1;
  return pBitStringV + 2;
}

function _x509_getPublicKeyHexArrayFromCertHex(hCert) {
  var p = _x509_getSubjectPublicKeyPosFromCertHex(hCert);
  var a = ASN1HEX.getPosArrayOfChildren_AtObj(hCert, p);
  if (a.length != 2) return [];
  var hN = ASN1HEX.getHexOfV_AtObj(hCert, a[0]);
  var hE = ASN1HEX.getHexOfV_AtObj(hCert, a[1]);
  if (hN != null && hE != null) {
    return [hN, hE];
  } else {
    return [];
  }
}

function _x509_getPublicKeyHexArrayFromCertPEM(sCertPEM) {
  var hCert = _x509_pemToHex(sCertPEM);
  var a = _x509_getPublicKeyHexArrayFromCertHex(hCert);
  return a;
}

// ===== get basic fields from hex =====================================
/**
 * get hexadecimal string of serialNumber field of certificate.<br/>
 * @name getSerialNumberHex
 * @memberOf X509#
 * @function
 */
function _x509_getSerialNumberHex() {
  return ASN1HEX.getDecendantHexVByNthList(this.hex, 0, [0, 1]);
}

/**
 * get hexadecimal string of issuer field of certificate.<br/>
 * @name getIssuerHex
 * @memberOf X509#
 * @function
 */
function _x509_getIssuerHex() {
  return ASN1HEX.getDecendantHexTLVByNthList(this.hex, 0, [0, 3]);
}

/**
 * get string of issuer field of certificate.<br/>
 * @name getIssuerString
 * @memberOf X509#
 * @function
 */
function _x509_getIssuerString() {
  return _x509_hex2dn(ASN1HEX.getDecendantHexTLVByNthList(this.hex, 0, [0, 3]));
}

/**
 * get hexadecimal string of subject field of certificate.<br/>
 * @name getSubjectHex
 * @memberOf X509#
 * @function
 */
function _x509_getSubjectHex() {
  return ASN1HEX.getDecendantHexTLVByNthList(this.hex, 0, [0, 5]);
}

/**
 * get string of subject field of certificate.<br/>
 * @name getSubjectString
 * @memberOf X509#
 * @function
 */
function _x509_getSubjectString() {
  return _x509_hex2dn(ASN1HEX.getDecendantHexTLVByNthList(this.hex, 0, [0, 5]));
}

/**
 * get notBefore field string of certificate.<br/>
 * @name getNotBefore
 * @memberOf X509#
 * @function
 */
function _x509_getNotBefore() {
  var s = ASN1HEX.getDecendantHexVByNthList(this.hex, 0, [0, 4, 0]);
  s = s.replace(/(..)/g, "%$1");
  s = decodeURIComponent(s);
  return s;
}

/**
 * get notAfter field string of certificate.<br/>
 * @name getNotAfter
 * @memberOf X509#
 * @function
 */
function _x509_getNotAfter() {
  var s = ASN1HEX.getDecendantHexVByNthList(this.hex, 0, [0, 4, 1]);
  s = s.replace(/(..)/g, "%$1");
  s = decodeURIComponent(s);
  return s;
}

// ===== read certificate =====================================

_x509_DN_ATTRHEX = {
    "0603550406": "C",
    "060355040a": "O",
    "060355040b": "OU",
    "0603550403": "CN",
    "0603550405": "SN",
    "0603550408": "ST",
    "0603550407": "L" };

function _x509_hex2dn(hDN) {
  var s = "";
  var a = ASN1HEX.getPosArrayOfChildren_AtObj(hDN, 0);
  for (var i = 0; i < a.length; i++) {
    var hRDN = ASN1HEX.getHexOfTLV_AtObj(hDN, a[i]);
    s = s + "/" + _x509_hex2rdn(hRDN);
  }
  return s;
}

function _x509_hex2rdn(hRDN) {
    var hType = ASN1HEX.getDecendantHexTLVByNthList(hRDN, 0, [0, 0]);
    var hValue = ASN1HEX.getDecendantHexVByNthList(hRDN, 0, [0, 1]);
    var type = "";
    try { type = _x509_DN_ATTRHEX[hType]; } catch (ex) { type = hType; }
    hValue = hValue.replace(/(..)/g, "%$1");
    var value = decodeURIComponent(hValue);
    return type + "=" + value;
}

// ===== read certificate =====================================


/**
 * read PEM formatted X.509 certificate from string.<br/>
 * @name readCertPEM
 * @memberOf X509#
 * @function
 * @param {String} sCertPEM string for PEM formatted X.509 certificate
 */
function _x509_readCertPEM(sCertPEM) {
  var hCert = _x509_pemToHex(sCertPEM);
  var a = _x509_getPublicKeyHexArrayFromCertHex(hCert);
  var rsa = new RSAKey();
  rsa.setPublic(a[0], a[1]);
  this.subjectPublicKeyRSA = rsa;
  this.subjectPublicKeyRSA_hN = a[0];
  this.subjectPublicKeyRSA_hE = a[1];
  this.hex = hCert;
}

function _x509_readCertPEMWithoutRSAInit(sCertPEM) {
  var hCert = _x509_pemToHex(sCertPEM);
  var a = _x509_getPublicKeyHexArrayFromCertHex(hCert);
  this.subjectPublicKeyRSA.setPublic(a[0], a[1]);
  this.subjectPublicKeyRSA_hN = a[0];
  this.subjectPublicKeyRSA_hE = a[1];
  this.hex = hCert;
}

/**
 * X.509 certificate class.<br/>
 * @class X.509 certificate class
 * @property {RSAKey} subjectPublicKeyRSA Tom Wu's RSAKey object
 * @property {String} subjectPublicKeyRSA_hN hexadecimal string for modulus of RSA public key
 * @property {String} subjectPublicKeyRSA_hE hexadecimal string for public exponent of RSA public key
 * @property {String} hex hexacedimal string for X.509 certificate.
 * @author Kenji Urushima
 * @version 1.0.1 (08 May 2012)
 * @see <a href="http://kjur.github.com/jsrsasigns/">'jwrsasign'(RSA Sign JavaScript Library) home page http://kjur.github.com/jsrsasign/</a>
 */
function X509() {
  this.subjectPublicKeyRSA = null;
  this.subjectPublicKeyRSA_hN = null;
  this.subjectPublicKeyRSA_hE = null;
  this.hex = null;
}

X509.prototype.readCertPEM = _x509_readCertPEM;
X509.prototype.readCertPEMWithoutRSAInit = _x509_readCertPEMWithoutRSAInit;
X509.prototype.getSerialNumberHex = _x509_getSerialNumberHex;
X509.prototype.getIssuerHex = _x509_getIssuerHex;
X509.prototype.getSubjectHex = _x509_getSubjectHex;
X509.prototype.getIssuerString = _x509_getIssuerString;
X509.prototype.getSubjectString = _x509_getSubjectString;
X509.prototype.getNotBefore = _x509_getNotBefore;
X509.prototype.getNotAfter = _x509_getNotAfter;

// Copyright (c) 2005  Tom Wu
// All Rights Reserved.
// See "LICENSE" for details.

// Basic JavaScript BN library - subset useful for RSA encryption.

// Bits per digit
var dbits;

// JavaScript engine analysis
var canary = 0xdeadbeefcafe;
var j_lm = ((canary&0xffffff)==0xefcafe);

// (public) Constructor
function BigInteger(a,b,c) {
  if(a != null)
    if("number" == typeof a) this.fromNumber(a,b,c);
    else if(b == null && "string" != typeof a) this.fromString(a,256);
    else this.fromString(a,b);
}

// return new, unset BigInteger
function nbi() { return new BigInteger(null); }

// am: Compute w_j += (x*this_i), propagate carries,
// c is initial carry, returns final carry.
// c < 3*dvalue, x < 2*dvalue, this_i < dvalue
// We need to select the fastest one that works in this environment.

// am1: use a single mult and divide to get the high bits,
// max digit bits should be 26 because
// max internal value = 2*dvalue^2-2*dvalue (< 2^53)
function am1(i,x,w,j,c,n) {
  while(--n >= 0) {
    var v = x*this[i++]+w[j]+c;
    c = Math.floor(v/0x4000000);
    w[j++] = v&0x3ffffff;
  }
  return c;
}
// am2 avoids a big mult-and-extract completely.
// Max digit bits should be <= 30 because we do bitwise ops
// on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)
function am2(i,x,w,j,c,n) {
  var xl = x&0x7fff, xh = x>>15;
  while(--n >= 0) {
    var l = this[i]&0x7fff;
    var h = this[i++]>>15;
    var m = xh*l+h*xl;
    l = xl*l+((m&0x7fff)<<15)+w[j]+(c&0x3fffffff);
    c = (l>>>30)+(m>>>15)+xh*h+(c>>>30);
    w[j++] = l&0x3fffffff;
  }
  return c;
}
// Alternately, set max digit bits to 28 since some
// browsers slow down when dealing with 32-bit numbers.
function am3(i,x,w,j,c,n) {
  var xl = x&0x3fff, xh = x>>14;
  while(--n >= 0) {
    var l = this[i]&0x3fff;
    var h = this[i++]>>14;
    var m = xh*l+h*xl;
    l = xl*l+((m&0x3fff)<<14)+w[j]+c;
    c = (l>>28)+(m>>14)+xh*h;
    w[j++] = l&0xfffffff;
  }
  return c;
}
if(j_lm && (navigator.appName == "Microsoft Internet Explorer")) {
  BigInteger.prototype.am = am2;
  dbits = 30;
}
else if(j_lm && (navigator.appName != "Netscape")) {
  BigInteger.prototype.am = am1;
  dbits = 26;
}
else { // Mozilla/Netscape seems to prefer am3
  BigInteger.prototype.am = am3;
  dbits = 28;
}

BigInteger.prototype.DB = dbits;
BigInteger.prototype.DM = ((1<<dbits)-1);
BigInteger.prototype.DV = (1<<dbits);

var BI_FP = 52;
BigInteger.prototype.FV = Math.pow(2,BI_FP);
BigInteger.prototype.F1 = BI_FP-dbits;
BigInteger.prototype.F2 = 2*dbits-BI_FP;

// Digit conversions
var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
var BI_RC = new Array();
var rr,vv;
rr = "0".charCodeAt(0);
for(vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
rr = "a".charCodeAt(0);
for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
rr = "A".charCodeAt(0);
for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;

function int2char(n) { return BI_RM.charAt(n); }
function intAt(s,i) {
  var c = BI_RC[s.charCodeAt(i)];
  return (c==null)?-1:c;
}

// (protected) copy this to r
function bnpCopyTo(r) {
  for(var i = this.t-1; i >= 0; --i) r[i] = this[i];
  r.t = this.t;
  r.s = this.s;
}

// (protected) set from integer value x, -DV <= x < DV
function bnpFromInt(x) {
  this.t = 1;
  this.s = (x<0)?-1:0;
  if(x > 0) this[0] = x;
  else if(x < -1) this[0] = x+DV;
  else this.t = 0;
}

// return bigint initialized to value
function nbv(i) { var r = nbi(); r.fromInt(i); return r; }

// (protected) set from string and radix
function bnpFromString(s,b) {
  var k;
  if(b == 16) k = 4;
  else if(b == 8) k = 3;
  else if(b == 256) k = 8; // byte array
  else if(b == 2) k = 1;
  else if(b == 32) k = 5;
  else if(b == 4) k = 2;
  else { this.fromRadix(s,b); return; }
  this.t = 0;
  this.s = 0;
  var i = s.length, mi = false, sh = 0;
  while(--i >= 0) {
    var x = (k==8)?s[i]&0xff:intAt(s,i);
    if(x < 0) {
      if(s.charAt(i) == "-") mi = true;
      continue;
    }
    mi = false;
    if(sh == 0)
      this[this.t++] = x;
    else if(sh+k > this.DB) {
      this[this.t-1] |= (x&((1<<(this.DB-sh))-1))<<sh;
      this[this.t++] = (x>>(this.DB-sh));
    }
    else
      this[this.t-1] |= x<<sh;
    sh += k;
    if(sh >= this.DB) sh -= this.DB;
  }
  if(k == 8 && (s[0]&0x80) != 0) {
    this.s = -1;
    if(sh > 0) this[this.t-1] |= ((1<<(this.DB-sh))-1)<<sh;
  }
  this.clamp();
  if(mi) BigInteger.ZERO.subTo(this,this);
}

// (protected) clamp off excess high words
function bnpClamp() {
  var c = this.s&this.DM;
  while(this.t > 0 && this[this.t-1] == c) --this.t;
}

// (public) return string representation in given radix
function bnToString(b) {
  if(this.s < 0) return "-"+this.negate().toString(b);
  var k;
  if(b == 16) k = 4;
  else if(b == 8) k = 3;
  else if(b == 2) k = 1;
  else if(b == 32) k = 5;
  else if(b == 4) k = 2;
  else return this.toRadix(b);
  var km = (1<<k)-1, d, m = false, r = "", i = this.t;
  var p = this.DB-(i*this.DB)%k;
  if(i-- > 0) {
    if(p < this.DB && (d = this[i]>>p) > 0) { m = true; r = int2char(d); }
    while(i >= 0) {
      if(p < k) {
        d = (this[i]&((1<<p)-1))<<(k-p);
        d |= this[--i]>>(p+=this.DB-k);
      }
      else {
        d = (this[i]>>(p-=k))&km;
        if(p <= 0) { p += this.DB; --i; }
      }
      if(d > 0) m = true;
      if(m) r += int2char(d);
    }
  }
  return m?r:"0";
}

// (public) -this
function bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; }

// (public) |this|
function bnAbs() { return (this.s<0)?this.negate():this; }

// (public) return + if this > a, - if this < a, 0 if equal
function bnCompareTo(a) {
  var r = this.s-a.s;
  if(r != 0) return r;
  var i = this.t;
  r = i-a.t;
  if(r != 0) return (this.s<0)?-r:r;
  while(--i >= 0) if((r=this[i]-a[i]) != 0) return r;
  return 0;
}

// returns bit length of the integer x
function nbits(x) {
  var r = 1, t;
  if((t=x>>>16) != 0) { x = t; r += 16; }
  if((t=x>>8) != 0) { x = t; r += 8; }
  if((t=x>>4) != 0) { x = t; r += 4; }
  if((t=x>>2) != 0) { x = t; r += 2; }
  if((t=x>>1) != 0) { x = t; r += 1; }
  return r;
}

// (public) return the number of bits in "this"
function bnBitLength() {
  if(this.t <= 0) return 0;
  return this.DB*(this.t-1)+nbits(this[this.t-1]^(this.s&this.DM));
}

// (protected) r = this << n*DB
function bnpDLShiftTo(n,r) {
  var i;
  for(i = this.t-1; i >= 0; --i) r[i+n] = this[i];
  for(i = n-1; i >= 0; --i) r[i] = 0;
  r.t = this.t+n;
  r.s = this.s;
}

// (protected) r = this >> n*DB
function bnpDRShiftTo(n,r) {
  for(var i = n; i < this.t; ++i) r[i-n] = this[i];
  r.t = Math.max(this.t-n,0);
  r.s = this.s;
}

// (protected) r = this << n
function bnpLShiftTo(n,r) {
  var bs = n%this.DB;
  var cbs = this.DB-bs;
  var bm = (1<<cbs)-1;
  var ds = Math.floor(n/this.DB), c = (this.s<<bs)&this.DM, i;
  for(i = this.t-1; i >= 0; --i) {
    r[i+ds+1] = (this[i]>>cbs)|c;
    c = (this[i]&bm)<<bs;
  }
  for(i = ds-1; i >= 0; --i) r[i] = 0;
  r[ds] = c;
  r.t = this.t+ds+1;
  r.s = this.s;
  r.clamp();
}

// (protected) r = this >> n
function bnpRShiftTo(n,r) {
  r.s = this.s;
  var ds = Math.floor(n/this.DB);
  if(ds >= this.t) { r.t = 0; return; }
  var bs = n%this.DB;
  var cbs = this.DB-bs;
  var bm = (1<<bs)-1;
  r[0] = this[ds]>>bs;
  for(var i = ds+1; i < this.t; ++i) {
    r[i-ds-1] |= (this[i]&bm)<<cbs;
    r[i-ds] = this[i]>>bs;
  }
  if(bs > 0) r[this.t-ds-1] |= (this.s&bm)<<cbs;
  r.t = this.t-ds;
  r.clamp();
}

// (protected) r = this - a
function bnpSubTo(a,r) {
  var i = 0, c = 0, m = Math.min(a.t,this.t);
  while(i < m) {
    c += this[i]-a[i];
    r[i++] = c&this.DM;
    c >>= this.DB;
  }
  if(a.t < this.t) {
    c -= a.s;
    while(i < this.t) {
      c += this[i];
      r[i++] = c&this.DM;
      c >>= this.DB;
    }
    c += this.s;
  }
  else {
    c += this.s;
    while(i < a.t) {
      c -= a[i];
      r[i++] = c&this.DM;
      c >>= this.DB;
    }
    c -= a.s;
  }
  r.s = (c<0)?-1:0;
  if(c < -1) r[i++] = this.DV+c;
  else if(c > 0) r[i++] = c;
  r.t = i;
  r.clamp();
}

// (protected) r = this * a, r != this,a (HAC 14.12)
// "this" should be the larger one if appropriate.
function bnpMultiplyTo(a,r) {
  var x = this.abs(), y = a.abs();
  var i = x.t;
  r.t = i+y.t;
  while(--i >= 0) r[i] = 0;
  for(i = 0; i < y.t; ++i) r[i+x.t] = x.am(0,y[i],r,i,0,x.t);
  r.s = 0;
  r.clamp();
  if(this.s != a.s) BigInteger.ZERO.subTo(r,r);
}

// (protected) r = this^2, r != this (HAC 14.16)
function bnpSquareTo(r) {
  var x = this.abs();
  var i = r.t = 2*x.t;
  while(--i >= 0) r[i] = 0;
  for(i = 0; i < x.t-1; ++i) {
    var c = x.am(i,x[i],r,2*i,0,1);
    if((r[i+x.t]+=x.am(i+1,2*x[i],r,2*i+1,c,x.t-i-1)) >= x.DV) {
      r[i+x.t] -= x.DV;
      r[i+x.t+1] = 1;
    }
  }
  if(r.t > 0) r[r.t-1] += x.am(i,x[i],r,2*i,0,1);
  r.s = 0;
  r.clamp();
}

// (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
// r != q, this != m.  q or r may be null.
function bnpDivRemTo(m,q,r) {
  var pm = m.abs();
  if(pm.t <= 0) return;
  var pt = this.abs();
  if(pt.t < pm.t) {
    if(q != null) q.fromInt(0);
    if(r != null) this.copyTo(r);
    return;
  }
  if(r == null) r = nbi();
  var y = nbi(), ts = this.s, ms = m.s;
  var nsh = this.DB-nbits(pm[pm.t-1]);	// normalize modulus
  if(nsh > 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); }
  else { pm.copyTo(y); pt.copyTo(r); }
  var ys = y.t;
  var y0 = y[ys-1];
  if(y0 == 0) return;
  var yt = y0*(1<<this.F1)+((ys>1)?y[ys-2]>>this.F2:0);
  var d1 = this.FV/yt, d2 = (1<<this.F1)/yt, e = 1<<this.F2;
  var i = r.t, j = i-ys, t = (q==null)?nbi():q;
  y.dlShiftTo(j,t);
  if(r.compareTo(t) >= 0) {
    r[r.t++] = 1;
    r.subTo(t,r);
  }
  BigInteger.ONE.dlShiftTo(ys,t);
  t.subTo(y,y);	// "negative" y so we can replace sub with am later
  while(y.t < ys) y[y.t++] = 0;
  while(--j >= 0) {
    // Estimate quotient digit
    var qd = (r[--i]==y0)?this.DM:Math.floor(r[i]*d1+(r[i-1]+e)*d2);
    if((r[i]+=y.am(0,qd,r,j,0,ys)) < qd) {	// Try it out
      y.dlShiftTo(j,t);
      r.subTo(t,r);
      while(r[i] < --qd) r.subTo(t,r);
    }
  }
  if(q != null) {
    r.drShiftTo(ys,q);
    if(ts != ms) BigInteger.ZERO.subTo(q,q);
  }
  r.t = ys;
  r.clamp();
  if(nsh > 0) r.rShiftTo(nsh,r);	// Denormalize remainder
  if(ts < 0) BigInteger.ZERO.subTo(r,r);
}

// (public) this mod a
function bnMod(a) {
  var r = nbi();
  this.abs().divRemTo(a,null,r);
  if(this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r,r);
  return r;
}

// Modular reduction using "classic" algorithm
function Classic(m) { this.m = m; }
function cConvert(x) {
  if(x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
  else return x;
}
function cRevert(x) { return x; }
function cReduce(x) { x.divRemTo(this.m,null,x); }
function cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }
function cSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

Classic.prototype.convert = cConvert;
Classic.prototype.revert = cRevert;
Classic.prototype.reduce = cReduce;
Classic.prototype.mulTo = cMulTo;
Classic.prototype.sqrTo = cSqrTo;

// (protected) return "-1/this % 2^DB"; useful for Mont. reduction
// justification:
//         xy == 1 (mod m)
//         xy =  1+km
//   xy(2-xy) = (1+km)(1-km)
// x[y(2-xy)] = 1-k^2m^2
// x[y(2-xy)] == 1 (mod m^2)
// if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
// should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
// JS multiply "overflows" differently from C/C++, so care is needed here.
function bnpInvDigit() {
  if(this.t < 1) return 0;
  var x = this[0];
  if((x&1) == 0) return 0;
  var y = x&3;		// y == 1/x mod 2^2
  y = (y*(2-(x&0xf)*y))&0xf;	// y == 1/x mod 2^4
  y = (y*(2-(x&0xff)*y))&0xff;	// y == 1/x mod 2^8
  y = (y*(2-(((x&0xffff)*y)&0xffff)))&0xffff;	// y == 1/x mod 2^16
  // last step - calculate inverse mod DV directly;
  // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints
  y = (y*(2-x*y%this.DV))%this.DV;		// y == 1/x mod 2^dbits
  // we really want the negative inverse, and -DV < y < DV
  return (y>0)?this.DV-y:-y;
}

// Montgomery reduction
function Montgomery(m) {
  this.m = m;
  this.mp = m.invDigit();
  this.mpl = this.mp&0x7fff;
  this.mph = this.mp>>15;
  this.um = (1<<(m.DB-15))-1;
  this.mt2 = 2*m.t;
}

// xR mod m
function montConvert(x) {
  var r = nbi();
  x.abs().dlShiftTo(this.m.t,r);
  r.divRemTo(this.m,null,r);
  if(x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r,r);
  return r;
}

// x/R mod m
function montRevert(x) {
  var r = nbi();
  x.copyTo(r);
  this.reduce(r);
  return r;
}

// x = x/R mod m (HAC 14.32)
function montReduce(x) {
  while(x.t <= this.mt2)	// pad x so am has enough room later
    x[x.t++] = 0;
  for(var i = 0; i < this.m.t; ++i) {
    // faster way of calculating u0 = x[i]*mp mod DV
    var j = x[i]&0x7fff;
    var u0 = (j*this.mpl+(((j*this.mph+(x[i]>>15)*this.mpl)&this.um)<<15))&x.DM;
    // use am to combine the multiply-shift-add into one call
    j = i+this.m.t;
    x[j] += this.m.am(0,u0,x,i,0,this.m.t);
    // propagate carry
    while(x[j] >= x.DV) { x[j] -= x.DV; x[++j]++; }
  }
  x.clamp();
  x.drShiftTo(this.m.t,x);
  if(x.compareTo(this.m) >= 0) x.subTo(this.m,x);
}

// r = "x^2/R mod m"; x != r
function montSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

// r = "xy/R mod m"; x,y != r
function montMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }

Montgomery.prototype.convert = montConvert;
Montgomery.prototype.revert = montRevert;
Montgomery.prototype.reduce = montReduce;
Montgomery.prototype.mulTo = montMulTo;
Montgomery.prototype.sqrTo = montSqrTo;

// (protected) true iff this is even
function bnpIsEven() { return ((this.t>0)?(this[0]&1):this.s) == 0; }

// (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)
function bnpExp(e,z) {
  if(e > 0xffffffff || e < 1) return BigInteger.ONE;
  var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e)-1;
  g.copyTo(r);
  while(--i >= 0) {
    z.sqrTo(r,r2);
    if((e&(1<<i)) > 0) z.mulTo(r2,g,r);
    else { var t = r; r = r2; r2 = t; }
  }
  return z.revert(r);
}

// (public) this^e % m, 0 <= e < 2^32
function bnModPowInt(e,m) {
  var z;
  if(e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);
  return this.exp(e,z);
}

// protected
BigInteger.prototype.copyTo = bnpCopyTo;
BigInteger.prototype.fromInt = bnpFromInt;
BigInteger.prototype.fromString = bnpFromString;
BigInteger.prototype.clamp = bnpClamp;
BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
BigInteger.prototype.drShiftTo = bnpDRShiftTo;
BigInteger.prototype.lShiftTo = bnpLShiftTo;
BigInteger.prototype.rShiftTo = bnpRShiftTo;
BigInteger.prototype.subTo = bnpSubTo;
BigInteger.prototype.multiplyTo = bnpMultiplyTo;
BigInteger.prototype.squareTo = bnpSquareTo;
BigInteger.prototype.divRemTo = bnpDivRemTo;
BigInteger.prototype.invDigit = bnpInvDigit;
BigInteger.prototype.isEven = bnpIsEven;
BigInteger.prototype.exp = bnpExp;

// public
BigInteger.prototype.toString = bnToString;
BigInteger.prototype.negate = bnNegate;
BigInteger.prototype.abs = bnAbs;
BigInteger.prototype.compareTo = bnCompareTo;
BigInteger.prototype.bitLength = bnBitLength;
BigInteger.prototype.mod = bnMod;
BigInteger.prototype.modPowInt = bnModPowInt;

// "constants"
BigInteger.ZERO = nbv(0);
BigInteger.ONE = nbv(1);
// Copyright (c) 2005-2009  Tom Wu
// All Rights Reserved.
// See "LICENSE" for details.

// Extended JavaScript BN functions, required for RSA private ops.

// Version 1.1: new BigInteger("0", 10) returns "proper" zero
// Version 1.2: square() API, isProbablePrime fix

// (public)
function bnClone() { var r = nbi(); this.copyTo(r); return r; }

// (public) return value as integer
function bnIntValue() {
  if(this.s < 0) {
    if(this.t == 1) return this[0]-this.DV;
    else if(this.t == 0) return -1;
  }
  else if(this.t == 1) return this[0];
  else if(this.t == 0) return 0;
  // assumes 16 < DB < 32
  return ((this[1]&((1<<(32-this.DB))-1))<<this.DB)|this[0];
}

// (public) return value as byte
function bnByteValue() { return (this.t==0)?this.s:(this[0]<<24)>>24; }

// (public) return value as short (assumes DB>=16)
function bnShortValue() { return (this.t==0)?this.s:(this[0]<<16)>>16; }

// (protected) return x s.t. r^x < DV
function bnpChunkSize(r) { return Math.floor(Math.LN2*this.DB/Math.log(r)); }

// (public) 0 if this == 0, 1 if this > 0
function bnSigNum() {
  if(this.s < 0) return -1;
  else if(this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;
  else return 1;
}

// (protected) convert to radix string
function bnpToRadix(b) {
  if(b == null) b = 10;
  if(this.signum() == 0 || b < 2 || b > 36) return "0";
  var cs = this.chunkSize(b);
  var a = Math.pow(b,cs);
  var d = nbv(a), y = nbi(), z = nbi(), r = "";
  this.divRemTo(d,y,z);
  while(y.signum() > 0) {
    r = (a+z.intValue()).toString(b).substr(1) + r;
    y.divRemTo(d,y,z);
  }
  return z.intValue().toString(b) + r;
}

// (protected) convert from radix string
function bnpFromRadix(s,b) {
  this.fromInt(0);
  if(b == null) b = 10;
  var cs = this.chunkSize(b);
  var d = Math.pow(b,cs), mi = false, j = 0, w = 0;
  for(var i = 0; i < s.length; ++i) {
    var x = intAt(s,i);
    if(x < 0) {
      if(s.charAt(i) == "-" && this.signum() == 0) mi = true;
      continue;
    }
    w = b*w+x;
    if(++j >= cs) {
      this.dMultiply(d);
      this.dAddOffset(w,0);
      j = 0;
      w = 0;
    }
  }
  if(j > 0) {
    this.dMultiply(Math.pow(b,j));
    this.dAddOffset(w,0);
  }
  if(mi) BigInteger.ZERO.subTo(this,this);
}

// (protected) alternate constructor
function bnpFromNumber(a,b,c) {
  if("number" == typeof b) {
    // new BigInteger(int,int,RNG)
    if(a < 2) this.fromInt(1);
    else {
      this.fromNumber(a,c);
      if(!this.testBit(a-1))	// force MSB set
        this.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,this);
      if(this.isEven()) this.dAddOffset(1,0); // force odd
      while(!this.isProbablePrime(b)) {
        this.dAddOffset(2,0);
        if(this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a-1),this);
      }
    }
  }
  else {
    // new BigInteger(int,RNG)
    var x = new Array(), t = a&7;
    x.length = (a>>3)+1;
    b.nextBytes(x);
    if(t > 0) x[0] &= ((1<<t)-1); else x[0] = 0;
    this.fromString(x,256);
  }
}

// (public) convert to bigendian byte array
function bnToByteArray() {
  var i = this.t, r = new Array();
  r[0] = this.s;
  var p = this.DB-(i*this.DB)%8, d, k = 0;
  if(i-- > 0) {
    if(p < this.DB && (d = this[i]>>p) != (this.s&this.DM)>>p)
      r[k++] = d|(this.s<<(this.DB-p));
    while(i >= 0) {
      if(p < 8) {
        d = (this[i]&((1<<p)-1))<<(8-p);
        d |= this[--i]>>(p+=this.DB-8);
      }
      else {
        d = (this[i]>>(p-=8))&0xff;
        if(p <= 0) { p += this.DB; --i; }
      }
      if((d&0x80) != 0) d |= -256;
      if(k == 0 && (this.s&0x80) != (d&0x80)) ++k;
      if(k > 0 || d != this.s) r[k++] = d;
    }
  }
  return r;
}

function bnEquals(a) { return(this.compareTo(a)==0); }
function bnMin(a) { return(this.compareTo(a)<0)?this:a; }
function bnMax(a) { return(this.compareTo(a)>0)?this:a; }

// (protected) r = this op a (bitwise)
function bnpBitwiseTo(a,op,r) {
  var i, f, m = Math.min(a.t,this.t);
  for(i = 0; i < m; ++i) r[i] = op(this[i],a[i]);
  if(a.t < this.t) {
    f = a.s&this.DM;
    for(i = m; i < this.t; ++i) r[i] = op(this[i],f);
    r.t = this.t;
  }
  else {
    f = this.s&this.DM;
    for(i = m; i < a.t; ++i) r[i] = op(f,a[i]);
    r.t = a.t;
  }
  r.s = op(this.s,a.s);
  r.clamp();
}

// (public) this & a
function op_and(x,y) { return x&y; }
function bnAnd(a) { var r = nbi(); this.bitwiseTo(a,op_and,r); return r; }

// (public) this | a
function op_or(x,y) { return x|y; }
function bnOr(a) { var r = nbi(); this.bitwiseTo(a,op_or,r); return r; }

// (public) this ^ a
function op_xor(x,y) { return x^y; }
function bnXor(a) { var r = nbi(); this.bitwiseTo(a,op_xor,r); return r; }

// (public) this & ~a
function op_andnot(x,y) { return x&~y; }
function bnAndNot(a) { var r = nbi(); this.bitwiseTo(a,op_andnot,r); return r; }

// (public) ~this
function bnNot() {
  var r = nbi();
  for(var i = 0; i < this.t; ++i) r[i] = this.DM&~this[i];
  r.t = this.t;
  r.s = ~this.s;
  return r;
}

// (public) this << n
function bnShiftLeft(n) {
  var r = nbi();
  if(n < 0) this.rShiftTo(-n,r); else this.lShiftTo(n,r);
  return r;
}

// (public) this >> n
function bnShiftRight(n) {
  var r = nbi();
  if(n < 0) this.lShiftTo(-n,r); else this.rShiftTo(n,r);
  return r;
}

// return index of lowest 1-bit in x, x < 2^31
function lbit(x) {
  if(x == 0) return -1;
  var r = 0;
  if((x&0xffff) == 0) { x >>= 16; r += 16; }
  if((x&0xff) == 0) { x >>= 8; r += 8; }
  if((x&0xf) == 0) { x >>= 4; r += 4; }
  if((x&3) == 0) { x >>= 2; r += 2; }
  if((x&1) == 0) ++r;
  return r;
}

// (public) returns index of lowest 1-bit (or -1 if none)
function bnGetLowestSetBit() {
  for(var i = 0; i < this.t; ++i)
    if(this[i] != 0) return i*this.DB+lbit(this[i]);
  if(this.s < 0) return this.t*this.DB;
  return -1;
}

// return number of 1 bits in x
function cbit(x) {
  var r = 0;
  while(x != 0) { x &= x-1; ++r; }
  return r;
}

// (public) return number of set bits
function bnBitCount() {
  var r = 0, x = this.s&this.DM;
  for(var i = 0; i < this.t; ++i) r += cbit(this[i]^x);
  return r;
}

// (public) true iff nth bit is set
function bnTestBit(n) {
  var j = Math.floor(n/this.DB);
  if(j >= this.t) return(this.s!=0);
  return((this[j]&(1<<(n%this.DB)))!=0);
}

// (protected) this op (1<<n)
function bnpChangeBit(n,op) {
  var r = BigInteger.ONE.shiftLeft(n);
  this.bitwiseTo(r,op,r);
  return r;
}

// (public) this | (1<<n)
function bnSetBit(n) { return this.changeBit(n,op_or); }

// (public) this & ~(1<<n)
function bnClearBit(n) { return this.changeBit(n,op_andnot); }

// (public) this ^ (1<<n)
function bnFlipBit(n) { return this.changeBit(n,op_xor); }

// (protected) r = this + a
function bnpAddTo(a,r) {
  var i = 0, c = 0, m = Math.min(a.t,this.t);
  while(i < m) {
    c += this[i]+a[i];
    r[i++] = c&this.DM;
    c >>= this.DB;
  }
  if(a.t < this.t) {
    c += a.s;
    while(i < this.t) {
      c += this[i];
      r[i++] = c&this.DM;
      c >>= this.DB;
    }
    c += this.s;
  }
  else {
    c += this.s;
    while(i < a.t) {
      c += a[i];
      r[i++] = c&this.DM;
      c >>= this.DB;
    }
    c += a.s;
  }
  r.s = (c<0)?-1:0;
  if(c > 0) r[i++] = c;
  else if(c < -1) r[i++] = this.DV+c;
  r.t = i;
  r.clamp();
}

// (public) this + a
function bnAdd(a) { var r = nbi(); this.addTo(a,r); return r; }

// (public) this - a
function bnSubtract(a) { var r = nbi(); this.subTo(a,r); return r; }

// (public) this * a
function bnMultiply(a) { var r = nbi(); this.multiplyTo(a,r); return r; }

// (public) this^2
function bnSquare() { var r = nbi(); this.squareTo(r); return r; }

// (public) this / a
function bnDivide(a) { var r = nbi(); this.divRemTo(a,r,null); return r; }

// (public) this % a
function bnRemainder(a) { var r = nbi(); this.divRemTo(a,null,r); return r; }

// (public) [this/a,this%a]
function bnDivideAndRemainder(a) {
  var q = nbi(), r = nbi();
  this.divRemTo(a,q,r);
  return new Array(q,r);
}

// (protected) this *= n, this >= 0, 1 < n < DV
function bnpDMultiply(n) {
  this[this.t] = this.am(0,n-1,this,0,0,this.t);
  ++this.t;
  this.clamp();
}

// (protected) this += n << w words, this >= 0
function bnpDAddOffset(n,w) {
  if(n == 0) return;
  while(this.t <= w) this[this.t++] = 0;
  this[w] += n;
  while(this[w] >= this.DV) {
    this[w] -= this.DV;
    if(++w >= this.t) this[this.t++] = 0;
    ++this[w];
  }
}

// A "null" reducer
function NullExp() {}
function nNop(x) { return x; }
function nMulTo(x,y,r) { x.multiplyTo(y,r); }
function nSqrTo(x,r) { x.squareTo(r); }

NullExp.prototype.convert = nNop;
NullExp.prototype.revert = nNop;
NullExp.prototype.mulTo = nMulTo;
NullExp.prototype.sqrTo = nSqrTo;

// (public) this^e
function bnPow(e) { return this.exp(e,new NullExp()); }

// (protected) r = lower n words of "this * a", a.t <= n
// "this" should be the larger one if appropriate.
function bnpMultiplyLowerTo(a,n,r) {
  var i = Math.min(this.t+a.t,n);
  r.s = 0; // assumes a,this >= 0
  r.t = i;
  while(i > 0) r[--i] = 0;
  var j;
  for(j = r.t-this.t; i < j; ++i) r[i+this.t] = this.am(0,a[i],r,i,0,this.t);
  for(j = Math.min(a.t,n); i < j; ++i) this.am(0,a[i],r,i,0,n-i);
  r.clamp();
}

// (protected) r = "this * a" without lower n words, n > 0
// "this" should be the larger one if appropriate.
function bnpMultiplyUpperTo(a,n,r) {
  --n;
  var i = r.t = this.t+a.t-n;
  r.s = 0; // assumes a,this >= 0
  while(--i >= 0) r[i] = 0;
  for(i = Math.max(n-this.t,0); i < a.t; ++i)
    r[this.t+i-n] = this.am(n-i,a[i],r,0,0,this.t+i-n);
  r.clamp();
  r.drShiftTo(1,r);
}

// Barrett modular reduction
function Barrett(m) {
  // setup Barrett
  this.r2 = nbi();
  this.q3 = nbi();
  BigInteger.ONE.dlShiftTo(2*m.t,this.r2);
  this.mu = this.r2.divide(m);
  this.m = m;
}

function barrettConvert(x) {
  if(x.s < 0 || x.t > 2*this.m.t) return x.mod(this.m);
  else if(x.compareTo(this.m) < 0) return x;
  else { var r = nbi(); x.copyTo(r); this.reduce(r); return r; }
}

function barrettRevert(x) { return x; }

// x = x mod m (HAC 14.42)
function barrettReduce(x) {
  x.drShiftTo(this.m.t-1,this.r2);
  if(x.t > this.m.t+1) { x.t = this.m.t+1; x.clamp(); }
  this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);
  this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);
  while(x.compareTo(this.r2) < 0) x.dAddOffset(1,this.m.t+1);
  x.subTo(this.r2,x);
  while(x.compareTo(this.m) >= 0) x.subTo(this.m,x);
}

// r = x^2 mod m; x != r
function barrettSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

// r = x*y mod m; x,y != r
function barrettMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }

Barrett.prototype.convert = barrettConvert;
Barrett.prototype.revert = barrettRevert;
Barrett.prototype.reduce = barrettReduce;
Barrett.prototype.mulTo = barrettMulTo;
Barrett.prototype.sqrTo = barrettSqrTo;

// (public) this^e % m (HAC 14.85)
function bnModPow(e,m) {
  var i = e.bitLength(), k, r = nbv(1), z;
  if(i <= 0) return r;
  else if(i < 18) k = 1;
  else if(i < 48) k = 3;
  else if(i < 144) k = 4;
  else if(i < 768) k = 5;
  else k = 6;
  if(i < 8)
    z = new Classic(m);
  else if(m.isEven())
    z = new Barrett(m);
  else
    z = new Montgomery(m);

  // precomputation
  var g = new Array(), n = 3, k1 = k-1, km = (1<<k)-1;
  g[1] = z.convert(this);
  if(k > 1) {
    var g2 = nbi();
    z.sqrTo(g[1],g2);
    while(n <= km) {
      g[n] = nbi();
      z.mulTo(g2,g[n-2],g[n]);
      n += 2;
    }
  }

  var j = e.t-1, w, is1 = true, r2 = nbi(), t;
  i = nbits(e[j])-1;
  while(j >= 0) {
    if(i >= k1) w = (e[j]>>(i-k1))&km;
    else {
      w = (e[j]&((1<<(i+1))-1))<<(k1-i);
      if(j > 0) w |= e[j-1]>>(this.DB+i-k1);
    }

    n = k;
    while((w&1) == 0) { w >>= 1; --n; }
    if((i -= n) < 0) { i += this.DB; --j; }
    if(is1) {	// ret == 1, don't bother squaring or multiplying it
      g[w].copyTo(r);
      is1 = false;
    }
    else {
      while(n > 1) { z.sqrTo(r,r2); z.sqrTo(r2,r); n -= 2; }
      if(n > 0) z.sqrTo(r,r2); else { t = r; r = r2; r2 = t; }
      z.mulTo(r2,g[w],r);
    }

    while(j >= 0 && (e[j]&(1<<i)) == 0) {
      z.sqrTo(r,r2); t = r; r = r2; r2 = t;
      if(--i < 0) { i = this.DB-1; --j; }
    }
  }
  return z.revert(r);
}

// (public) gcd(this,a) (HAC 14.54)
function bnGCD(a) {
  var x = (this.s<0)?this.negate():this.clone();
  var y = (a.s<0)?a.negate():a.clone();
  if(x.compareTo(y) < 0) { var t = x; x = y; y = t; }
  var i = x.getLowestSetBit(), g = y.getLowestSetBit();
  if(g < 0) return x;
  if(i < g) g = i;
  if(g > 0) {
    x.rShiftTo(g,x);
    y.rShiftTo(g,y);
  }
  while(x.signum() > 0) {
    if((i = x.getLowestSetBit()) > 0) x.rShiftTo(i,x);
    if((i = y.getLowestSetBit()) > 0) y.rShiftTo(i,y);
    if(x.compareTo(y) >= 0) {
      x.subTo(y,x);
      x.rShiftTo(1,x);
    }
    else {
      y.subTo(x,y);
      y.rShiftTo(1,y);
    }
  }
  if(g > 0) y.lShiftTo(g,y);
  return y;
}

// (protected) this % n, n < 2^26
function bnpModInt(n) {
  if(n <= 0) return 0;
  var d = this.DV%n, r = (this.s<0)?n-1:0;
  if(this.t > 0)
    if(d == 0) r = this[0]%n;
    else for(var i = this.t-1; i >= 0; --i) r = (d*r+this[i])%n;
  return r;
}

// (public) 1/this % m (HAC 14.61)
function bnModInverse(m) {
  var ac = m.isEven();
  if((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;
  var u = m.clone(), v = this.clone();
  var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
  while(u.signum() != 0) {
    while(u.isEven()) {
      u.rShiftTo(1,u);
      if(ac) {
        if(!a.isEven() || !b.isEven()) { a.addTo(this,a); b.subTo(m,b); }
        a.rShiftTo(1,a);
      }
      else if(!b.isEven()) b.subTo(m,b);
      b.rShiftTo(1,b);
    }
    while(v.isEven()) {
      v.rShiftTo(1,v);
      if(ac) {
        if(!c.isEven() || !d.isEven()) { c.addTo(this,c); d.subTo(m,d); }
        c.rShiftTo(1,c);
      }
      else if(!d.isEven()) d.subTo(m,d);
      d.rShiftTo(1,d);
    }
    if(u.compareTo(v) >= 0) {
      u.subTo(v,u);
      if(ac) a.subTo(c,a);
      b.subTo(d,b);
    }
    else {
      v.subTo(u,v);
      if(ac) c.subTo(a,c);
      d.subTo(b,d);
    }
  }
  if(v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
  if(d.compareTo(m) >= 0) return d.subtract(m);
  if(d.signum() < 0) d.addTo(m,d); else return d;
  if(d.signum() < 0) return d.add(m); else return d;
}

var lowprimes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997];
var lplim = (1<<26)/lowprimes[lowprimes.length-1];

// (public) test primality with certainty >= 1-.5^t
function bnIsProbablePrime(t) {
  var i, x = this.abs();
  if(x.t == 1 && x[0] <= lowprimes[lowprimes.length-1]) {
    for(i = 0; i < lowprimes.length; ++i)
      if(x[0] == lowprimes[i]) return true;
    return false;
  }
  if(x.isEven()) return false;
  i = 1;
  while(i < lowprimes.length) {
    var m = lowprimes[i], j = i+1;
    while(j < lowprimes.length && m < lplim) m *= lowprimes[j++];
    m = x.modInt(m);
    while(i < j) if(m%lowprimes[i++] == 0) return false;
  }
  return x.millerRabin(t);
}

// (protected) true if probably prime (HAC 4.24, Miller-Rabin)
function bnpMillerRabin(t) {
  var n1 = this.subtract(BigInteger.ONE);
  var k = n1.getLowestSetBit();
  if(k <= 0) return false;
  var r = n1.shiftRight(k);
  t = (t+1)>>1;
  if(t > lowprimes.length) t = lowprimes.length;
  var a = nbi();
  for(var i = 0; i < t; ++i) {
    //Pick bases at random, instead of starting at 2
    a.fromInt(lowprimes[Math.floor(Math.random()*lowprimes.length)]);
    var y = a.modPow(r,this);
    if(y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
      var j = 1;
      while(j++ < k && y.compareTo(n1) != 0) {
        y = y.modPowInt(2,this);
        if(y.compareTo(BigInteger.ONE) == 0) return false;
      }
      if(y.compareTo(n1) != 0) return false;
    }
  }
  return true;
}

// protected
BigInteger.prototype.chunkSize = bnpChunkSize;
BigInteger.prototype.toRadix = bnpToRadix;
BigInteger.prototype.fromRadix = bnpFromRadix;
BigInteger.prototype.fromNumber = bnpFromNumber;
BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
BigInteger.prototype.changeBit = bnpChangeBit;
BigInteger.prototype.addTo = bnpAddTo;
BigInteger.prototype.dMultiply = bnpDMultiply;
BigInteger.prototype.dAddOffset = bnpDAddOffset;
BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
BigInteger.prototype.modInt = bnpModInt;
BigInteger.prototype.millerRabin = bnpMillerRabin;

// public
BigInteger.prototype.clone = bnClone;
BigInteger.prototype.intValue = bnIntValue;
BigInteger.prototype.byteValue = bnByteValue;
BigInteger.prototype.shortValue = bnShortValue;
BigInteger.prototype.signum = bnSigNum;
BigInteger.prototype.toByteArray = bnToByteArray;
BigInteger.prototype.equals = bnEquals;
BigInteger.prototype.min = bnMin;
BigInteger.prototype.max = bnMax;
BigInteger.prototype.and = bnAnd;
BigInteger.prototype.or = bnOr;
BigInteger.prototype.xor = bnXor;
BigInteger.prototype.andNot = bnAndNot;
BigInteger.prototype.not = bnNot;
BigInteger.prototype.shiftLeft = bnShiftLeft;
BigInteger.prototype.shiftRight = bnShiftRight;
BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
BigInteger.prototype.bitCount = bnBitCount;
BigInteger.prototype.testBit = bnTestBit;
BigInteger.prototype.setBit = bnSetBit;
BigInteger.prototype.clearBit = bnClearBit;
BigInteger.prototype.flipBit = bnFlipBit;
BigInteger.prototype.add = bnAdd;
BigInteger.prototype.subtract = bnSubtract;
BigInteger.prototype.multiply = bnMultiply;
BigInteger.prototype.divide = bnDivide;
BigInteger.prototype.remainder = bnRemainder;
BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
BigInteger.prototype.modPow = bnModPow;
BigInteger.prototype.modInverse = bnModInverse;
BigInteger.prototype.pow = bnPow;
BigInteger.prototype.gcd = bnGCD;
BigInteger.prototype.isProbablePrime = bnIsProbablePrime;

// JSBN-specific extension
BigInteger.prototype.square = bnSquare;

// BigInteger interfaces not implemented in jsbn:

// BigInteger(int signum, byte[] magnitude)
// double doubleValue()
// float floatValue()
// int hashCode()
// long longValue()
// static BigInteger valueOf(long val)

},{"__browserify_Buffer":159}],129:[function(require,module,exports){
var global=typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};;(function(undefined) {
	"use strict";

	var $scope
	, conflict, conflictResolution = [];
	if (typeof global == 'object' && global) {
		$scope = global;
	} else if (typeof window !== 'undefined'){
		$scope = window;
	} else {
		$scope = {};
	}
	conflict = $scope.DeepDiff;
	if (conflict) {
		conflictResolution.push(
			function() {
				if ('undefined' !== typeof conflict && $scope.DeepDiff === accumulateDiff) {
					$scope.DeepDiff = conflict;
					conflict = undefined;
				}
			});
	}

	// nodejs compatible on server side and in the browser.
  function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  }

  function Diff(kind, path) {
  	Object.defineProperty(this, 'kind', { value: kind, enumerable: true });
  	if (path && path.length) {
  		Object.defineProperty(this, 'path', { value: path, enumerable: true });
  	}
  }

  function DiffEdit(path, origin, value) {
  	DiffEdit.super_.call(this, 'E', path);
  	Object.defineProperty(this, 'lhs', { value: origin, enumerable: true });
  	Object.defineProperty(this, 'rhs', { value: value, enumerable: true });
  }
  inherits(DiffEdit, Diff);

  function DiffNew(path, value) {
  	DiffNew.super_.call(this, 'N', path);
  	Object.defineProperty(this, 'rhs', { value: value, enumerable: true });
  }
  inherits(DiffNew, Diff);

  function DiffDeleted(path, value) {
  	DiffDeleted.super_.call(this, 'D', path);
  	Object.defineProperty(this, 'lhs', { value: value, enumerable: true });
  }
  inherits(DiffDeleted, Diff);

  function DiffArray(path, index, item) {
  	DiffArray.super_.call(this, 'A', path);
  	Object.defineProperty(this, 'index', { value: index, enumerable: true });
  	Object.defineProperty(this, 'item', { value: item, enumerable: true });
  }
  inherits(DiffArray, Diff);

  function arrayRemove(arr, from, to) {
  	var rest = arr.slice((to || from) + 1 || arr.length);
  	arr.length = from < 0 ? arr.length + from : from;
  	arr.push.apply(arr, rest);
  	return arr;
  }

  function deepDiff(lhs, rhs, changes, path, key, stack) {
  	path = path || [];
  	var currentPath = path.slice(0);
  	if (key) { currentPath.push(key); }
  	var ltype = typeof lhs;
  	var rtype = typeof rhs;
  	if (ltype === 'undefined') {
  		if (rtype !== 'undefined') {
  			changes(new DiffNew(currentPath, rhs ));
  		}
  	} else if (rtype === 'undefined') {
  		changes(new DiffDeleted(currentPath, lhs));
  	} else if (ltype !== rtype) {
  		changes(new DiffEdit(currentPath, lhs, rhs));
  	} else if (lhs instanceof Date && rhs instanceof Date && ((lhs-rhs) != 0) ) {
  		changes(new DiffEdit(currentPath, lhs, rhs));
  	} else if (ltype === 'object' && lhs != null && rhs != null) {
  		stack = stack || [];
  		if (stack.indexOf(lhs) < 0) {
  			stack.push(lhs);
  			if (Array.isArray(lhs)) {
  				var i
  				, len = lhs.length
  				, ea = function(d) {
  					changes(new DiffArray(currentPath, i, d));
  				};
  				for(i = 0; i < lhs.length; i++) {
  					if (i >= rhs.length) {
  						changes(new DiffArray(currentPath, i, new DiffDeleted(undefined, lhs[i])));
  					} else {
  						deepDiff(lhs[i], rhs[i], ea, [], null, stack);
  					}
  				}
  				while(i < rhs.length) {
  					changes(new DiffArray(currentPath, i, new DiffNew(undefined, rhs[i++])));
  				}
  			} else {
  				var akeys = Object.keys(lhs);
  				var pkeys = Object.keys(rhs);
  				akeys.forEach(function(k) {
  					var i = pkeys.indexOf(k);
  					if (i >= 0) {
  						deepDiff(lhs[k], rhs[k], changes, currentPath, k, stack);
  						pkeys = arrayRemove(pkeys, i);
  					} else {
  						deepDiff(lhs[k], undefined, changes, currentPath, k, stack);
  					}
  				});
  				pkeys.forEach(function(k) {
  					deepDiff(undefined, rhs[k], changes, currentPath, k, stack);
  				});
  			}
  			stack.length = stack.length - 1;
  		}
  	} else if (lhs !== rhs) {
  		changes(new DiffEdit(currentPath, lhs, rhs));
  	}
  }

  function accumulateDiff(lhs, rhs, accum) {
  	accum = accum || [];
  	deepDiff(lhs, rhs, function(diff) {
  		if (diff) {
  			accum.push(diff);
  		}
  	});
  	return (accum.length) ? accum : undefined;
  }

	function applyArrayChange(arr, index, change) {
		if (change.path && change.path.length) {
			// the structure of the object at the index has changed...
			var it = arr[index], i, u = change.path.length - 1;
			for(i = 0; i < u; i++){
				it = it[change.path[i]];
			}
			switch(change.kind) {
				case 'A':
					// Array was modified...
					// it will be an array...
					applyArrayChange(it, change.index, change.item);
					break;
				case 'D':
					// Item was deleted...
					delete it[change.path[i]];
					break;
				case 'E':
				case 'N':
					// Item was edited or is new...
					it[change.path[i]] = change.rhs;
					break;
			}
		} else {
			// the array item is different...
			switch(change.kind) {
				case 'A':
					// Array was modified...
					// it will be an array...
					applyArrayChange(arr[index], change.index, change.item);
					break;
				case 'D':
					// Item was deleted...
					arr = arrayRemove(arr, index);
					break;
				case 'E':
				case 'N':
					// Item was edited or is new...
					arr[index] = change.rhs;
					break;
			}
		}
		return arr;
	}

	function applyChange(target, source, change) {
		if (!(change instanceof Diff)) {
			throw new TypeError('[Object] change must be instanceof Diff');
		}
		if (target && source && change) {
			var it = target, i, u;
			u = change.path.length - 1;
			for(i = 0; i < u; i++){
				if (typeof it[change.path[i]] === 'undefined') {
					it[change.path[i]] = {};
				}
				it = it[change.path[i]];
			}
			switch(change.kind) {
				case 'A':
					// Array was modified...
					// it will be an array...
					applyArrayChange(it[change.path[i]], change.index, change.item);
					break;
				case 'D':
					// Item was deleted...
					delete it[change.path[i]];
					break;
				case 'E':
				case 'N':
					// Item was edited or is new...
					it[change.path[i]] = change.rhs;
					break;
				}
			}
		}

	function applyDiff(target, source, filter) {
		if (target && source) {
			var onChange = function(change) {
				if (!filter || filter(target, source, change)) {
					applyChange(target, source, change);
				}
			};
			deepDiff(target, source, onChange);
		}
	}

	Object.defineProperties(accumulateDiff, {

		diff: { value: accumulateDiff, enumerable:true },
		observableDiff: { value: deepDiff, enumerable:true },
		applyDiff: { value: applyDiff, enumerable:true },
		applyChange: { value: applyChange, enumerable:true },
		isConflict: { get: function() { return 'undefined' !== typeof conflict; }, enumerable: true },
		noConflict: {
			value: function () {
				if (conflictResolution) {
					conflictResolution.forEach(function (it) { it(); });
					conflictResolution = null;
				}
				return accumulateDiff;
			},
			enumerable: true
		}
	});

	if (typeof module != 'undefined' && module && typeof exports == 'object' && exports && module.exports === exports) {
		module.exports = accumulateDiff; // nodejs
	} else {
		$scope.DeepDiff = accumulateDiff; // other... browser?
	}
}());


},{}],130:[function(require,module,exports){
/* See LICENSE file for terms of use */

/*
 * Text diff implementation.
 *
 * This library supports the following APIS:
 * JsDiff.diffChars: Character by character diff
 * JsDiff.diffWords: Word (as defined by \b regex) diff which ignores whitespace
 * JsDiff.diffLines: Line based diff
 *
 * JsDiff.diffCss: Diff targeted at CSS content
 *
 * These methods are based on the implementation proposed in
 * "An O(ND) Difference Algorithm and its Variations" (Myers, 1986).
 * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.4.6927
 */
var JsDiff = (function() {
  /*jshint maxparams: 5*/
  function clonePath(path) {
    return { newPos: path.newPos, components: path.components.slice(0) };
  }
  function removeEmpty(array) {
    var ret = [];
    for (var i = 0; i < array.length; i++) {
      if (array[i]) {
        ret.push(array[i]);
      }
    }
    return ret;
  }
  function escapeHTML(s) {
    var n = s;
    n = n.replace(/&/g, '&amp;');
    n = n.replace(/</g, '&lt;');
    n = n.replace(/>/g, '&gt;');
    n = n.replace(/"/g, '&quot;');

    return n;
  }

  var Diff = function(ignoreWhitespace) {
    this.ignoreWhitespace = ignoreWhitespace;
  };
  Diff.prototype = {
      diff: function(oldString, newString) {
        // Handle the identity case (this is due to unrolling editLength == 0
        if (newString === oldString) {
          return [{ value: newString }];
        }
        if (!newString) {
          return [{ value: oldString, removed: true }];
        }
        if (!oldString) {
          return [{ value: newString, added: true }];
        }

        newString = this.tokenize(newString);
        oldString = this.tokenize(oldString);

        var newLen = newString.length, oldLen = oldString.length;
        var maxEditLength = newLen + oldLen;
        var bestPath = [{ newPos: -1, components: [] }];

        // Seed editLength = 0
        var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);
        if (bestPath[0].newPos+1 >= newLen && oldPos+1 >= oldLen) {
          return bestPath[0].components;
        }

        for (var editLength = 1; editLength <= maxEditLength; editLength++) {
          for (var diagonalPath = -1*editLength; diagonalPath <= editLength; diagonalPath+=2) {
            var basePath;
            var addPath = bestPath[diagonalPath-1],
                removePath = bestPath[diagonalPath+1];
            oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;
            if (addPath) {
              // No one else is going to attempt to use this value, clear it
              bestPath[diagonalPath-1] = undefined;
            }

            var canAdd = addPath && addPath.newPos+1 < newLen;
            var canRemove = removePath && 0 <= oldPos && oldPos < oldLen;
            if (!canAdd && !canRemove) {
              bestPath[diagonalPath] = undefined;
              continue;
            }

            // Select the diagonal that we want to branch from. We select the prior
            // path whose position in the new string is the farthest from the origin
            // and does not pass the bounds of the diff graph
            if (!canAdd || (canRemove && addPath.newPos < removePath.newPos)) {
              basePath = clonePath(removePath);
              this.pushComponent(basePath.components, oldString[oldPos], undefined, true);
            } else {
              basePath = clonePath(addPath);
              basePath.newPos++;
              this.pushComponent(basePath.components, newString[basePath.newPos], true, undefined);
            }

            var oldPos = this.extractCommon(basePath, newString, oldString, diagonalPath);

            if (basePath.newPos+1 >= newLen && oldPos+1 >= oldLen) {
              return basePath.components;
            } else {
              bestPath[diagonalPath] = basePath;
            }
          }
        }
      },

      pushComponent: function(components, value, added, removed) {
        var last = components[components.length-1];
        if (last && last.added === added && last.removed === removed) {
          // We need to clone here as the component clone operation is just
          // as shallow array clone
          components[components.length-1] =
            {value: this.join(last.value, value), added: added, removed: removed };
        } else {
          components.push({value: value, added: added, removed: removed });
        }
      },
      extractCommon: function(basePath, newString, oldString, diagonalPath) {
        var newLen = newString.length,
            oldLen = oldString.length,
            newPos = basePath.newPos,
            oldPos = newPos - diagonalPath;
        while (newPos+1 < newLen && oldPos+1 < oldLen && this.equals(newString[newPos+1], oldString[oldPos+1])) {
          newPos++;
          oldPos++;

          this.pushComponent(basePath.components, newString[newPos], undefined, undefined);
        }
        basePath.newPos = newPos;
        return oldPos;
      },

      equals: function(left, right) {
        var reWhitespace = /\S/;
        if (this.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right)) {
          return true;
        } else {
          return left === right;
        }
      },
      join: function(left, right) {
        return left + right;
      },
      tokenize: function(value) {
        return value;
      }
  };

  var CharDiff = new Diff();

  var WordDiff = new Diff(true);
  var WordWithSpaceDiff = new Diff();
  WordDiff.tokenize = WordWithSpaceDiff.tokenize = function(value) {
    return removeEmpty(value.split(/(\s+|\b)/));
  };

  var CssDiff = new Diff(true);
  CssDiff.tokenize = function(value) {
    return removeEmpty(value.split(/([{}:;,]|\s+)/));
  };

  var LineDiff = new Diff();
  LineDiff.tokenize = function(value) {
    var retLines = [],
        lines = value.split(/^/m);

    for(var i = 0; i < lines.length; i++) {
      var line = lines[i],
          lastLine = lines[i - 1];

      // Merge lines that may contain windows new lines
      if (line == '\n' && lastLine && lastLine[lastLine.length - 1] === '\r') {
        retLines[retLines.length - 1] += '\n';
      } else if (line) {
        retLines.push(line);
      }
    }

    return retLines;
  };

  return {
    Diff: Diff,

    diffChars: function(oldStr, newStr) { return CharDiff.diff(oldStr, newStr); },
    diffWords: function(oldStr, newStr) { return WordDiff.diff(oldStr, newStr); },
    diffWordsWithSpace: function(oldStr, newStr) { return WordWithSpaceDiff.diff(oldStr, newStr); },
    diffLines: function(oldStr, newStr) { return LineDiff.diff(oldStr, newStr); },

    diffCss: function(oldStr, newStr) { return CssDiff.diff(oldStr, newStr); },

    createPatch: function(fileName, oldStr, newStr, oldHeader, newHeader) {
      var ret = [];

      ret.push('Index: ' + fileName);
      ret.push('===================================================================');
      ret.push('--- ' + fileName + (typeof oldHeader === 'undefined' ? '' : '\t' + oldHeader));
      ret.push('+++ ' + fileName + (typeof newHeader === 'undefined' ? '' : '\t' + newHeader));

      var diff = LineDiff.diff(oldStr, newStr);
      if (!diff[diff.length-1].value) {
        diff.pop();   // Remove trailing newline add
      }
      diff.push({value: '', lines: []});   // Append an empty value to make cleanup easier

      function contextLines(lines) {
        return lines.map(function(entry) { return ' ' + entry; });
      }
      function eofNL(curRange, i, current) {
        var last = diff[diff.length-2],
            isLast = i === diff.length-2,
            isLastOfType = i === diff.length-3 && (current.added !== last.added || current.removed !== last.removed);

        // Figure out if this is the last line for the given file and missing NL
        if (!/\n$/.test(current.value) && (isLast || isLastOfType)) {
          curRange.push('\\ No newline at end of file');
        }
      }

      var oldRangeStart = 0, newRangeStart = 0, curRange = [],
          oldLine = 1, newLine = 1;
      for (var i = 0; i < diff.length; i++) {
        var current = diff[i],
            lines = current.lines || current.value.replace(/\n$/, '').split('\n');
        current.lines = lines;

        if (current.added || current.removed) {
          if (!oldRangeStart) {
            var prev = diff[i-1];
            oldRangeStart = oldLine;
            newRangeStart = newLine;

            if (prev) {
              curRange = contextLines(prev.lines.slice(-4));
              oldRangeStart -= curRange.length;
              newRangeStart -= curRange.length;
            }
          }
          curRange.push.apply(curRange, lines.map(function(entry) { return (current.added?'+':'-') + entry; }));
          eofNL(curRange, i, current);

          if (current.added) {
            newLine += lines.length;
          } else {
            oldLine += lines.length;
          }
        } else {
          if (oldRangeStart) {
            // Close out any changes that have been output (or join overlapping)
            if (lines.length <= 8 && i < diff.length-2) {
              // Overlapping
              curRange.push.apply(curRange, contextLines(lines));
            } else {
              // end the range and output
              var contextSize = Math.min(lines.length, 4);
              ret.push(
                  '@@ -' + oldRangeStart + ',' + (oldLine-oldRangeStart+contextSize)
                  + ' +' + newRangeStart + ',' + (newLine-newRangeStart+contextSize)
                  + ' @@');
              ret.push.apply(ret, curRange);
              ret.push.apply(ret, contextLines(lines.slice(0, contextSize)));
              if (lines.length <= 4) {
                eofNL(ret, i, current);
              }

              oldRangeStart = 0;  newRangeStart = 0; curRange = [];
            }
          }
          oldLine += lines.length;
          newLine += lines.length;
        }
      }

      return ret.join('\n') + '\n';
    },

    applyPatch: function(oldStr, uniDiff) {
      var diffstr = uniDiff.split('\n');
      var diff = [];
      var remEOFNL = false,
          addEOFNL = false;

      for (var i = (diffstr[0][0]==='I'?4:0); i < diffstr.length; i++) {
        if(diffstr[i][0] === '@') {
          var meh = diffstr[i].split(/@@ -(\d+),(\d+) \+(\d+),(\d+) @@/);
          diff.unshift({
            start:meh[3],
            oldlength:meh[2],
            oldlines:[],
            newlength:meh[4],
            newlines:[]
          });
        } else if(diffstr[i][0] === '+') {
          diff[0].newlines.push(diffstr[i].substr(1));
        } else if(diffstr[i][0] === '-') {
          diff[0].oldlines.push(diffstr[i].substr(1));
        } else if(diffstr[i][0] === ' ') {
          diff[0].newlines.push(diffstr[i].substr(1));
          diff[0].oldlines.push(diffstr[i].substr(1));
        } else if(diffstr[i][0] === '\\') {
          if (diffstr[i-1][0] === '+') {
            remEOFNL = true;
          } else if(diffstr[i-1][0] === '-') {
            addEOFNL = true;
          }
        }
      }

      var str = oldStr.split('\n');
      for (var i = diff.length - 1; i >= 0; i--) {
        var d = diff[i];
        for (var j = 0; j < d.oldlength; j++) {
          if(str[d.start-1+j] !== d.oldlines[j]) {
            return false;
          }
        }
        Array.prototype.splice.apply(str,[d.start-1,+d.oldlength].concat(d.newlines));
      }

      if (remEOFNL) {
        while (!str[str.length-1]) {
          str.pop();
        }
      } else if (addEOFNL) {
        str.push('');
      }
      return str.join('\n');
    },

    convertChangesToXML: function(changes){
      var ret = [];
      for ( var i = 0; i < changes.length; i++) {
        var change = changes[i];
        if (change.added) {
          ret.push('<ins>');
        } else if (change.removed) {
          ret.push('<del>');
        }

        ret.push(escapeHTML(change.value));

        if (change.added) {
          ret.push('</ins>');
        } else if (change.removed) {
          ret.push('</del>');
        }
      }
      return ret.join('');
    },

    // See: http://code.google.com/p/google-diff-match-patch/wiki/API
    convertChangesToDMP: function(changes){
      var ret = [], change;
      for ( var i = 0; i < changes.length; i++) {
        change = changes[i];
        ret.push([(change.added ? 1 : change.removed ? -1 : 0), change.value]);
      }
      return ret;
    }
  };
})();

if (typeof module !== 'undefined') {
    module.exports = JsDiff;
}

},{}],131:[function(require,module,exports){
var Buffer=require("__browserify_Buffer");//     uuid.js
//
//     Copyright (c) 2010-2012 Robert Kieffer
//     MIT License - http://opensource.org/licenses/mit-license.php

(function() {
  var _global = this;

  // Unique ID creation requires a high quality random # generator.  We feature
  // detect to determine the best RNG source, normalizing to a function that
  // returns 128-bits of randomness, since that's what's usually required
  var _rng;

  // Node.js crypto-based RNG - http://nodejs.org/docs/v0.6.2/api/crypto.html
  //
  // Moderately fast, high quality
  if (typeof(require) == 'function') {
    try {
      var _rb = require('crypto').randomBytes;
      _rng = _rb && function() {return _rb(16);};
    } catch(e) {}
  }

  if (!_rng && _global.crypto && crypto.getRandomValues) {
    // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
    //
    // Moderately fast, high quality
    var _rnds8 = new Uint8Array(16);
    _rng = function whatwgRNG() {
      crypto.getRandomValues(_rnds8);
      return _rnds8;
    };
  }

  if (!_rng) {
    // Math.random()-based (RNG)
    //
    // If all else fails, use Math.random().  It's fast, but is of unspecified
    // quality.
    var  _rnds = new Array(16);
    _rng = function() {
      for (var i = 0, r; i < 16; i++) {
        if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
        _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
      }

      return _rnds;
    };
  }

  // Buffer class to use
  var BufferClass = typeof(Buffer) == 'function' ? Buffer : Array;

  // Maps for number <-> hex string conversion
  var _byteToHex = [];
  var _hexToByte = {};
  for (var i = 0; i < 256; i++) {
    _byteToHex[i] = (i + 0x100).toString(16).substr(1);
    _hexToByte[_byteToHex[i]] = i;
  }

  // **`parse()` - Parse a UUID into it's component bytes**
  function parse(s, buf, offset) {
    var i = (buf && offset) || 0, ii = 0;

    buf = buf || [];
    s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
      if (ii < 16) { // Don't overflow!
        buf[i + ii++] = _hexToByte[oct];
      }
    });

    // Zero out remaining bytes if string was short
    while (ii < 16) {
      buf[i + ii++] = 0;
    }

    return buf;
  }

  // **`unparse()` - Convert UUID byte array (ala parse()) into a string**
  function unparse(buf, offset) {
    var i = offset || 0, bth = _byteToHex;
    return  bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]];
  }

  // **`v1()` - Generate time-based UUID**
  //
  // Inspired by https://github.com/LiosK/UUID.js
  // and http://docs.python.org/library/uuid.html

  // random #'s we need to init node and clockseq
  var _seedBytes = _rng();

  // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
  var _nodeId = [
    _seedBytes[0] | 0x01,
    _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]
  ];

  // Per 4.2.2, randomize (14 bit) clockseq
  var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;

  // Previous uuid creation time
  var _lastMSecs = 0, _lastNSecs = 0;

  // See https://github.com/broofa/node-uuid for API details
  function v1(options, buf, offset) {
    var i = buf && offset || 0;
    var b = buf || [];

    options = options || {};

    var clockseq = options.clockseq != null ? options.clockseq : _clockseq;

    // UUID timestamps are 100 nano-second units since the Gregorian epoch,
    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
    var msecs = options.msecs != null ? options.msecs : new Date().getTime();

    // Per 4.2.1.2, use count of uuid's generated during the current clock
    // cycle to simulate higher resolution clock
    var nsecs = options.nsecs != null ? options.nsecs : _lastNSecs + 1;

    // Time since last uuid creation (in msecs)
    var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

    // Per 4.2.1.2, Bump clockseq on clock regression
    if (dt < 0 && options.clockseq == null) {
      clockseq = clockseq + 1 & 0x3fff;
    }

    // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
    // time interval
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs == null) {
      nsecs = 0;
    }

    // Per 4.2.1.2 Throw error if too many uuids are requested
    if (nsecs >= 10000) {
      throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
    }

    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;

    // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
    msecs += 12219292800000;

    // `time_low`
    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
    b[i++] = tl >>> 24 & 0xff;
    b[i++] = tl >>> 16 & 0xff;
    b[i++] = tl >>> 8 & 0xff;
    b[i++] = tl & 0xff;

    // `time_mid`
    var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
    b[i++] = tmh >>> 8 & 0xff;
    b[i++] = tmh & 0xff;

    // `time_high_and_version`
    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
    b[i++] = tmh >>> 16 & 0xff;

    // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
    b[i++] = clockseq >>> 8 | 0x80;

    // `clock_seq_low`
    b[i++] = clockseq & 0xff;

    // `node`
    var node = options.node || _nodeId;
    for (var n = 0; n < 6; n++) {
      b[i + n] = node[n];
    }

    return buf ? buf : unparse(b);
  }

  // **`v4()` - Generate random UUID**

  // See https://github.com/broofa/node-uuid for API details
  function v4(options, buf, offset) {
    // Deprecated - 'format' argument, as supported in v1.2
    var i = buf && offset || 0;

    if (typeof(options) == 'string') {
      buf = options == 'binary' ? new BufferClass(16) : null;
      options = null;
    }
    options = options || {};

    var rnds = options.random || (options.rng || _rng)();

    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
    rnds[6] = (rnds[6] & 0x0f) | 0x40;
    rnds[8] = (rnds[8] & 0x3f) | 0x80;

    // Copy bytes to buffer, if provided
    if (buf) {
      for (var ii = 0; ii < 16; ii++) {
        buf[i + ii] = rnds[ii];
      }
    }

    return buf || unparse(rnds);
  }

  // Export public API
  var uuid = v4;
  uuid.v1 = v1;
  uuid.v4 = v4;
  uuid.parse = parse;
  uuid.unparse = unparse;
  uuid.BufferClass = BufferClass;

  if (typeof define === 'function' && define.amd) {
    // Publish as AMD module
    define(function() {return uuid;});
  } else if (typeof(module) != 'undefined' && module.exports) {
    // Publish as node.js module
    module.exports = uuid;
  } else {
    // Publish as global (in browsers)
    var _previousRoot = _global.uuid;

    // **`noConflict()` - (browser only) to reset global 'uuid' var**
    uuid.noConflict = function() {
      _global.uuid = _previousRoot;
      return uuid;
    };

    _global.uuid = uuid;
  }
}).call(this);

},{"__browserify_Buffer":159,"crypto":152}],132:[function(require,module,exports){
"use strict";

module.exports = {
  Operation: require('./src/operation'),
  Compound: require('./src/compound'),
  ArrayOperation: require('./src/array_operation'),
  TextOperation: require('./src/text_operation'),
  ObjectOperation: require('./src/object_operation'),
  Helpers: require('./src/operation_helpers')
};

},{"./src/array_operation":141,"./src/compound":142,"./src/object_operation":143,"./src/operation":144,"./src/operation_helpers":145,"./src/text_operation":146}],133:[function(require,module,exports){
"use strict";

var util = require("./src/util");

util.async = require("./src/async");
util.errors = require("./src/errors");
util.html = require("./src/html");
util.dom = require("./src/dom");
util.Fragmenter = require("./src/fragmenter");

module.exports = util;

},{"./src/async":134,"./src/dom":135,"./src/errors":136,"./src/fragmenter":137,"./src/html":138,"./src/util":139}],134:[function(require,module,exports){
"use strict";

var _ = require("underscore");
var util = require("./util.js");

// Helpers for Asynchronous Control Flow
// --------

var async = {};

function callAsynchronousChain(options, cb) {
  var _finally = options["finally"] || function(err, data) { cb(err, data); };
  _finally = _.once(_finally);
  var data = options.data || {};
  var functions = options.functions;

  if (!_.isFunction(cb)) {
    return cb("Illegal arguments: a callback function must be provided");
  }

  var index = 0;
  var stopOnError = (options.stopOnError===undefined) ? true : options.stopOnError;
  var errors = [];

  function process(data) {
    var func = functions[index];

    // stop if no function is left
    if (!func) {
      if (errors.length > 0) {
        return _finally(new Error("Multiple errors occurred.", data));
      } else {
        return _finally(null, data);
      }
    }

    // A function that is used as call back for each function
    // which does the progression in the chain via recursion.
    // On errors the given callback will be called and recursion is stopped.
    var recursiveCallback = _.once(function(err, data) {
      // stop on error
      if (err) {
        if (stopOnError) {
          return _finally(err, null);
        } else {
          errors.push(err);
        }
      }

      index += 1;
      process(data);
    });

    // catch exceptions and propagat
    try {
      if (func.length === 0) {
        func();
        recursiveCallback(null, data);
      }
      else if (func.length === 1) {
        func(recursiveCallback);
      }
      else {
        func(data, recursiveCallback);
      }
    } catch (err) {
      console.log("util.async caught error:", err);
      util.printStackTrace(err);
      _finally(err);
    }
  }

  // start processing
  process(data);
}

// Calls a given list of asynchronous functions sequentially
// -------------------
// options:
//    functions:  an array of functions of the form f(data,cb)
//    data:       data provided to the first function; optional
//    finally:    a function that will always be called at the end, also on errors; optional

async.sequential = function(options, cb) {
  // allow to call this with an array of functions instead of options
  if(_.isArray(options)) {
    options = { functions: options };
  }
  callAsynchronousChain(options, cb);
};

function asynchronousIterator(options) {
  return function(data, cb) {
    // retrieve items via selector if a selector function is given
    var items = options.selector ? options.selector(data) : options.items;
    var _finally = options["finally"] || function(err, data) { cb(err, data); };
    _finally = _.once(_finally);

    // don't do nothing if no items are given
    if (!items) {
      return _finally(null, data);
    }

    var isArray = _.isArray(items);

    if (options.before) {
      options.before(data);
    }

    var funcs = [];
    var iterator = options.iterator;

    // TODO: discuss convention for iterator function signatures.
    // trying to achieve a combination of underscore and node.js callback style
    function arrayFunction(item, index) {
      return function(data, cb) {
        if (iterator.length === 2) {
          iterator(item, cb);
        } else if (iterator.length === 3) {
          iterator(item, index, cb);
        } else {
          iterator(item, index, data, cb);
        }
      };
    }

    function objectFunction(value, key) {
      return function(data, cb) {
        if (iterator.length === 2) {
          iterator(value, cb);
        } else if (iterator.length === 3) {
          iterator(value, key, cb);
        } else {
          iterator(value, key, data, cb);
        }
      };
    }

    if (isArray) {
      for (var idx = 0; idx < items.length; idx++) {
        funcs.push(arrayFunction(items[idx], idx));
      }
    } else {
      for (var key in items) {
        funcs.push(objectFunction(items[key], key));
      }
    }

    //console.log("Iterator:", iterator, "Funcs:", funcs);
    var chainOptions = {
      functions: funcs,
      data: data,
      finally: _finally,
      stopOnError: options.stopOnError
    };
    callAsynchronousChain(chainOptions, cb);
  };
}

// Creates an each-iterator for util.async chains
// -----------
//
//     var func = util.async.each(items, function(item, [idx, [data,]] cb) { ... });
//     var func = util.async.each(options)
//
// options:
//    items:    the items to be iterated
//    selector: used to select items dynamically from the data provided by the previous function in the chain
//    before:   an extra function called before iteration
//    iterator: the iterator function (item, [idx, [data,]] cb)
//       with item: the iterated item,
//            data: the propagated data (optional)
//            cb:   the callback

// TODO: support only one version and add another function
async.iterator = function(options_or_items, iterator) {
  var options;
  if (arguments.length == 1) {
    options = options_or_items;
  } else {
    options = {
      items: options_or_items,
      iterator: iterator
    };
  }
  return asynchronousIterator(options);
};

async.each = function(options, cb) {
  // create the iterator and call instantly
  var f = asynchronousIterator(options);
  f(null, cb);
};

module.exports = async;

},{"./util.js":139,"underscore":140}],135:[function(require,module,exports){
"use strict";

var _ = require("underscore");

// Helpers for working with the DOM

var dom = {};

dom.ChildNodeIterator = function(arg) {
  if(_.isArray(arg)) {
    this.nodes = arg;
  } else {
    this.nodes = arg.childNodes;
  }
  this.length = this.nodes.length;
  this.pos = -1;
};

dom.ChildNodeIterator.prototype = {
  hasNext: function() {
    return this.pos < this.length - 1;
  },

  next: function() {
    this.pos += 1;
    return this.nodes[this.pos];
  },

  back: function() {
    if (this.pos >= 0) {
      this.pos -= 1;
    }
    return this;
  }
};

// Note: it is not safe regarding browser in-compatibilities
// to access el.children directly.
dom.getChildren = function(el) {
  if (el.children !== undefined) return el.children;
  var children = [];
  var child = el.firstElementChild;
  while (child) {
    children.push(child);
    child = child.nextElementSibling;
  }
  return children;
};

dom.getNodeType = function(el) {
  if (el.nodeType === Node.TEXT_NODE) {
    return "text";
  } else if (el.nodeType === Node.COMMENT_NODE) {
    return "comment";
  } else if (el.tagName) {
    return el.tagName.toLowerCase();
  } else {
    throw new Error("Unknown node type");
  }
};

module.exports = dom;

},{"underscore":140}],136:[function(require,module,exports){
"use strict";

var util = require('./util');

var errors = {};

// The base class for Substance Errors
// -------
// We have been not so happy with the native error as it is really poor with respect to
// stack information and presentation.
// This implementation has a more usable stack trace which is rendered using `err.printStacktrace()`.
// Moreover, it provides error codes and error chaining.
var SubstanceError = function(message, rootError) {

  // If a root error is given try to take over as much information as possible
  if (rootError) {
    Error.call(this, message, rootError.fileName, rootError.lineNumber);

    if (rootError instanceof SubstanceError) {
      this.__stack = rootError.__stack;
    } else if (rootError.stack) {
      this.__stack = util.parseStackTrace(rootError);
    } else {
      this.__stack = util.callstack(1);
    }

  }

  // otherwise create a new stacktrace
  else {
    Error.call(this, message);
    this.__stack = util.callstack(1);
  }

  this.message = message;
};

SubstanceError.Prototype = function() {

  this.name = "SubstanceError";
  this.code = -1;

  this.toString = function() {
    return this.name+":"+this.message;
  };

  this.toJSON = function() {
    return {
      name: this.name,
      message: this.message,
      code: this.code,
      stack: this.stack
    };
  };

  this.printStackTrace = function() {
    util.printStackTrace(this);
  };
};

SubstanceError.Prototype.prototype = Error.prototype;
SubstanceError.prototype = new SubstanceError.Prototype();

Object.defineProperty(SubstanceError.prototype, "stack", {
  get: function() {
    var str = [];
    for (var idx = 0; idx < this.__stack.length; idx++) {
      var s = this.__stack[idx];
      str.push(s.file+":"+s.line+":"+s.col+" ("+s.func+")");
    }
    return str.join("\n");
  },
  set: function() { throw new Error("SubstanceError.stack is read-only."); }
});

errors.SubstanceError = SubstanceError;


var createSubstanceErrorSubclass = function(parent, name, code) {
  return function(message) {
    parent.call(this, message);
    this.name = name;
    this.code = code;
  };
};

errors.define = function(className, code, parent) {
  if (!className) throw new SubstanceError("Name is required.");
  if (code === undefined) code = -1;

  parent = parent || SubstanceError;
  var ErrorClass = createSubstanceErrorSubclass(parent, className, code);
  var ErrorClassPrototype = function() {};
  ErrorClassPrototype.prototype = parent.prototype;
  ErrorClass.prototype = new ErrorClassPrototype();
  ErrorClass.prototype.constructor = ErrorClass;

  errors[className] = ErrorClass;
  return ErrorClass;
};

module.exports = errors;

},{"./util":139}],137:[function(require,module,exports){
"use strict";

var _ = require("underscore");

var ENTER = 1;
var EXIT = -1;

// Fragmenter
// --------
//
// An algorithm that is used to fragment overlapping structure elements
// following a priority rule set.
// E.g., we use this for creating DOM elements for annotations. The annotations
// can partially be overlapping. However this is not allowed in general for DOM elements
// or other hierarchical structures.
//
// Example: For the Annotation use casec consider a 'comment' spanning partially
// over an 'emphasis' annotation.
// 'The <comment>quick brown <bold>fox</comment> jumps over</bold> the lazy dog.'
// We want to be able to create a valid XML structure:
// 'The <comment>quick brown <bold>fox</bold></comment><bold> jumps over</bold> the lazy dog.'
//
// For that one would choose
//
//     {
//        'comment': 0,
//        'bold': 1
//     }
//
// as priority levels.
// In case of structural violations as in the example, elements with a higher level
// would be fragmented and those with lower levels would be preserved as one piece.
//
// TODO: If a violation for nodes of the same level occurs an Error should be thrown.
// Currently, in such cases the first element that is opened earlier is preserved.

var Fragmenter = function(levels) {
  if (!levels) {
    throw new Error("Requires a specification of element levels.");
  }
  this.levels = levels;
};

Fragmenter.Prototype = function() {

  // This is a sweep algorithm wich uses a set of ENTER/EXIT entries
  // to manage a stack of active elements.
  // Whenever a new element is entered it will be appended to its parent element.
  // The stack is ordered by the annotation types.
  //
  // Examples:
  //
  // - simple case:
  //
  //       [top] -> ENTER(idea1) -> [top, idea1]
  //
  //   Creates a new 'idea' element and appends it to 'top'
  //
  // - stacked ENTER:
  //
  //       [top, idea1] -> ENTER(bold1) -> [top, idea1, bold1]
  //
  //   Creates a new 'bold' element and appends it to 'idea1'
  //
  // - simple EXIT:
  //
  //       [top, idea1] -> EXIT(idea1) -> [top]
  //
  //   Removes 'idea1' from stack.
  //
  // - reordering ENTER:
  //
  //       [top, bold1] -> ENTER(idea1) -> [top, idea1, bold1]
  //
  //   Inserts 'idea1' at 2nd position, creates a new 'bold1', and appends itself to 'top'
  //
  // - reordering EXIT
  //
  //       [top, idea1, bold1] -> EXIT(idea1)) -> [top, bold1]
  //
  //   Removes 'idea1' from stack and creates a new 'bold1'
  //

  // Orders sweep events according to following precedences:
  //
  // 1. pos
  // 2. EXIT < ENTER
  // 3. if both ENTER: ascending level
  // 4. if both EXIT: descending level

  var _compare = function(a, b) {
    if (a.pos < b.pos) return -1;
    if (a.pos > b.pos) return 1;

    if (a.mode < b.mode) return -1;
    if (a.mode > b.mode) return 1;

    if (a.mode === ENTER) {
      if (a.level < b.level) return -1;
      if (a.level > b.level) return 1;
    }

    if (a.mode === EXIT) {
      if (a.level > b.level) return -1;
      if (a.level < b.level) return 1;
    }

    return 0;
  };

  var extractEntries = function(annotations) {
    var entries = [];
    _.each(annotations, function(a) {
      var l = this.levels[a.type];

      // ignore annotations that are not registered
      if (l === undefined) {
        return;
      }

      entries.push({ pos : a.range[0], mode: ENTER, level: l, id: a.id, type: a.type });
      entries.push({ pos : a.range[1], mode: EXIT, level: l, id: a.id, type: a.type });
    }, this);
    return entries;
  };

  this.onText = function(/*context, text*/) {};

  // should return the created user context
  this.onEnter = function(/*entry, parentContext*/) {
    return null;
  };
  this.onExit = function(/*entry, parentContext*/) {};

  this.enter = function(entry, parentContext) {
    return this.onEnter(entry, parentContext);
  };

  this.exit = function(entry, parentContext) {
    this.onExit(entry, parentContext);
  };

  this.createText = function(context, text) {
    this.onText(context, text);
  };

  this.start = function(rootContext, text, annotations) {
    var entries = extractEntries.call(this, annotations);
    entries.sort(_compare.bind(this));

    var stack = [{context: rootContext, entry: null}];

    var pos = 0;

    for (var i = 0; i < entries.length; i++) {
      var entry = entries[i];

      // in any case we add the last text to the current element
      this.createText(stack[stack.length-1].context, text.substring(pos, entry.pos));

      pos = entry.pos;
      var level = 1;

      var idx;

      if (entry.mode === ENTER) {
        // find the correct position and insert an entry
        for (; level < stack.length; level++) {
          if (entry.level < stack[level].entry.level) {
            break;
          }
        }
        stack.splice(level, 0, {entry: entry});
      }
      else if (entry.mode === EXIT) {
        // find the according entry and remove it from the stack
        for (; level < stack.length; level++) {
          if (stack[level].entry.id === entry.id) {
            break;
          }
        }
        for (idx = level; idx < stack.length; idx++) {
          this.exit(stack[idx].entry, stack[idx-1].context);
        }
        stack.splice(level, 1);
      }

      // create new elements for all lower entries
      for (idx = level; idx < stack.length; idx++) {
        stack[idx].context = this.enter(stack[idx].entry, stack[idx-1].context);
      }
    }

    // Finally append a trailing text node
    this.createText(rootContext, text.substring(pos));
  };

};
Fragmenter.prototype = new Fragmenter.Prototype();

module.exports = Fragmenter;

},{"underscore":140}],138:[function(require,module,exports){
"use strict";

var html = {};
var _ = require("underscore");

html.templates = {};

// html.compileTemplate = function(tplName) {
//   var rawTemplate = $('script[name='+tplName+']').html();
//   html.templates[tplName] = Handlebars.compile(rawTemplate);
// };

html.renderTemplate = function(tplName, data) {
  return html.templates[tplName](data);
};

// Handlebars.registerHelper('ifelse', function(cond, textIf, textElse) {
//   textIf = Handlebars.Utils.escapeExpression(textIf);
//   textElse  = Handlebars.Utils.escapeExpression(textElse);
//   return new Handlebars.SafeString(cond ? textIf : textElse);
// });

if (typeof window !== "undefined") {
  // A fake console to calm down some browsers.
  if (!window.console) {
    window.console = {
      log: function(msg) {
        // No-op
      }
    };
  }
}

// Render Underscore templates
html.tpl = function (tpl, ctx) {
  ctx = ctx || {};
  var source = $('script[name='+tpl+']').html();
  return _.template(source, ctx);
};

// Exports
// ====

module.exports = html;

},{"underscore":140}],139:[function(require,module,exports){
"use strict";

// Imports
// ====

var _ = require('underscore');

// Module
// ====

var util = {};

// UUID Generator
// -----------------

/*!
Math.uuid.js (v1.4)
http://www.broofa.com
mailto:robert@broofa.com

Copyright (c) 2010 Robert Kieffer
Dual licensed under the MIT and GPL licenses.
*/

util.uuid = function (prefix, len) {
  var chars = '0123456789abcdefghijklmnopqrstuvwxyz'.split(''),
      uuid = [],
      radix = 16,
      idx;
  len = len || 32;

  if (len) {
    // Compact form
    for (idx = 0; idx < len; idx++) uuid[idx] = chars[0 | Math.random()*radix];
  } else {
    // rfc4122, version 4 form
    var r;

    // rfc4122 requires these characters
    uuid[8] = uuid[13] = uuid[18] = uuid[23] = '-';
    uuid[14] = '4';

    // Fill in random data.  At i==19 set the high bits of clock sequence as
    // per rfc4122, sec. 4.1.5
    for (idx = 0; idx < 36; idx++) {
      if (!uuid[idx]) {
        r = 0 | Math.random()*16;
        uuid[idx] = chars[(idx == 19) ? (r & 0x3) | 0x8 : r];
      }
    }
  }
  return (prefix ? prefix : "") + uuid.join('');
};

// creates a uuid function that generates counting uuids
util.uuidGen = function(defaultPrefix) {
  var id = 1;
  defaultPrefix = (defaultPrefix !== undefined) ? defaultPrefix : "uuid_";
  return function(prefix) {
    prefix = prefix || defaultPrefix;
    return prefix+(id++);
  };
};


// Events
// ---------------

// Taken from Backbone.js
//
// A module that can be mixed in to *any object* in order to provide it with
// custom events. You may bind with `on` or remove with `off` callback
// functions to an event; `trigger`-ing an event fires all callbacks in
// succession.
//
//     var object = {};
//     _.extend(object, util.Events);
//     object.on('expand', function(){ alert('expanded'); });
//     object.trigger('expand');
//

// A difficult-to-believe, but optimized internal dispatch function for
// triggering events. Tries to keep the usual cases speedy (most internal
// Backbone events have 3 arguments).
var triggerEvents = function(events, args) {
  var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
  switch (args.length) {
    case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;
    case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;
    case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
    case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
    default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args);
  }
};

// Regular expression used to split event strings.
var eventSplitter = /\s+/;

// Implement fancy features of the Events API such as multiple event
// names `"change blur"` and jQuery-style event maps `{change: action}`
// in terms of the existing API.
var eventsApi = function(obj, action, name, rest) {
  if (!name) return true;

  // Handle event maps.
  if (typeof name === 'object') {
    for (var key in name) {
      obj[action].apply(obj, [key, name[key]].concat(rest));
    }
    return false;
  }

  // Handle space separated event names.
  if (eventSplitter.test(name)) {
    var names = name.split(eventSplitter);
    for (var i = 0, l = names.length; i < l; i++) {
      obj[action].apply(obj, [names[i]].concat(rest));
    }
    return false;
  }

  return true;
};

util.Events = {

  // Bind an event to a `callback` function. Passing `"all"` will bind
  // the callback to all events fired.
  on: function(name, callback, context) {
    if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;
    this._events =  this._events || {};
    var events = this._events[name] || (this._events[name] = []);
    events.push({callback: callback, context: context, ctx: context || this});
    return this;
  },

  // Bind an event to only be triggered a single time. After the first time
  // the callback is invoked, it will be removed.
  once: function(name, callback, context) {
    if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;
    var self = this;
    var once = _.once(function() {
      self.off(name, once);
      callback.apply(this, arguments);
    });
    once._callback = callback;
    return this.on(name, once, context);
  },

  // Remove one or many callbacks. If `context` is null, removes all
  // callbacks with that function. If `callback` is null, removes all
  // callbacks for the event. If `name` is null, removes all bound
  // callbacks for all events.
  off: function(name, callback, context) {
    var retain, ev, events, names, i, l, j, k;
    if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;
    if (!name && !callback && !context) {
      this._events = {};
      return this;
    }

    names = name ? [name] : _.keys(this._events);
    for (i = 0, l = names.length; i < l; i++) {
      name = names[i];
      events = this._events[name];
      if (events) {
        this._events[name] = retain = [];
        if (callback || context) {
          for (j = 0, k = events.length; j < k; j++) {
            ev = events[j];
            if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||
                (context && context !== ev.context)) {
              retain.push(ev);
            }
          }
        }
        if (!retain.length) delete this._events[name];
      }
    }

    return this;
  },

  // Trigger one or many events, firing all bound callbacks. Callbacks are
  // passed the same arguments as `trigger` is, apart from the event name
  // (unless you're listening on `"all"`, which will cause your callback to
  // receive the true name of the event as the first argument).
  trigger: function(name) {
    if (!this._events) return this;
    var args = Array.prototype.slice.call(arguments, 1);
    if (!eventsApi(this, 'trigger', name, args)) return this;
    var events = this._events[name];
    var allEvents = this._events.all;
    if (events) triggerEvents(events, args);
    if (allEvents) triggerEvents(allEvents, arguments);
    return this;
  },

  triggerLater: function() {
    var self = this;
    var _arguments = arguments;
    setTimeout(function() {
      self.trigger.apply(self, _arguments);
    }, 0);
  },

  // Tell this object to stop listening to either specific events ... or
  // to every object it's currently listening to.
  stopListening: function(obj, name, callback) {
    var listeners = this._listeners;
    if (!listeners) return this;
    var deleteListener = !name && !callback;
    if (typeof name === 'object') callback = this;
    if (obj) (listeners = {})[obj._listenerId] = obj;
    for (var id in listeners) {
      listeners[id].off(name, callback, this);
      if (deleteListener) delete this._listeners[id];
    }
    return this;
  }

};

var listenMethods = {listenTo: 'on', listenToOnce: 'once'};

// Inversion-of-control versions of `on` and `once`. Tell *this* object to
// listen to an event in another object ... keeping track of what it's
// listening to.
_.each(listenMethods, function(implementation, method) {
  util.Events[method] = function(obj, name, callback) {
    var listeners = this._listeners || (this._listeners = {});
    var id = obj._listenerId || (obj._listenerId = _.uniqueId('l'));
    listeners[id] = obj;
    if (typeof name === 'object') callback = this;
    obj[implementation](name, callback, this);
    return this;
  };
});

// Aliases for backwards compatibility.
util.Events.bind   = util.Events.on;
util.Events.unbind = util.Events.off;

util.Events.Listener = {

  listenTo: function(obj, name, callback) {
    if (!_.isFunction(callback)) {
      throw new Error("Illegal argument: expecting function as callback, was: " + callback);
    }

    // initialize container for keeping handlers to unbind later
    this._handlers = this._handlers || [];

    obj.on(name, callback, this);

    this._handlers.push({
      unbind: function() {
        obj.off(name, callback);
      }
    });

    return this;
  },

  stopListening: function() {
    if (this._handlers) {
      for (var i = 0; i < this._handlers.length; i++) {
        this._handlers[i].unbind();
      }
    }
  }

};

util.propagate = function(data, cb) {
  if(!_.isFunction(cb)) {
    throw "Illegal argument: provided callback is not a function";
  }
  return function(err) {
    if (err) return cb(err);
    cb(null, data);
  };
};

// shamelessly stolen from backbone.js:
// Helper function to correctly set up the prototype chain, for subclasses.
// Similar to `goog.inherits`, but uses a hash of prototype properties and
// class properties to be extended.
var ctor = function(){};
util.inherits = function(parent, protoProps, staticProps) {
  var child;

  // The constructor function for the new subclass is either defined by you
  // (the "constructor" property in your `extend` definition), or defaulted
  // by us to simply call the parent's constructor.
  if (protoProps && protoProps.hasOwnProperty('constructor')) {
    child = protoProps.constructor;
  } else {
    child = function(){ parent.apply(this, arguments); };
  }

  // Inherit class (static) properties from parent.
  _.extend(child, parent);

  // Set the prototype chain to inherit from `parent`, without calling
  // `parent`'s constructor function.
  ctor.prototype = parent.prototype;
  child.prototype = new ctor();

  // Add prototype properties (instance properties) to the subclass,
  // if supplied.
  if (protoProps) _.extend(child.prototype, protoProps);

  // Add static properties to the constructor function, if supplied.
  if (staticProps) _.extend(child, staticProps);

  // Correctly set child's `prototype.constructor`.
  child.prototype.constructor = child;

  // Set a convenience property in case the parent's prototype is needed later.
  child.__super__ = parent.prototype;

  return child;
};

// Util to read seed data from file system
// ----------

util.getJSON = function(resource, cb) {
  if (typeof exports !== 'undefined') {
    var fs = require('fs');
    var obj = JSON.parse(fs.readFileSync(resource, 'utf8'));
    cb(null, obj);
  } else {
    //console.log("util.getJSON", resource);
    $.getJSON(resource)
      .done(function(obj) { cb(null, obj); })
      .error(function(err) { cb(err, null); });
  }
};

util.prototype = function(that) {
  /*jshint proto: true*/ // supressing a warning about using deprecated __proto__.
  return Object.getPrototypeOf ? Object.getPrototypeOf(that) : that.__proto__;
};

util.inherit = function(Super, Self) {
  var super_proto = _.isFunction(Super) ? new Super() : Super;
  var proto;
  if (_.isFunction(Self)) {
    Self.prototype = super_proto;
    proto = new Self();
  } else {
    var TmpClass = function(){};
    TmpClass.prototype = super_proto;
    proto = _.extend(new TmpClass(), Self);
  }
  return proto;
};

util.pimpl = function(pimpl) {
  var Pimpl = function(self) {
    this.self = self;
  };
  Pimpl.prototype = pimpl;
  return function(self) { self = self || this; return new Pimpl(self); };
};

util.parseStackTrace = function(err) {
  var SAFARI_STACK_ELEM = /([^@]*)@(.*):(\d+)/;
  var CHROME_STACK_ELEM = /\s*at ([^(]*)[(](.*):(\d+):(\d+)[)]/;

  var idx;
  var stackTrace = err.stack.split('\n');

  // parse the stack trace: each line is a tuple (function, file, lineNumber)
  // Note: unfortunately this is interpreter specific
  // safari: "<function>@<file>:<lineNumber>"
  // chrome: "at <function>(<file>:<line>:<col>"

  var stack = [];
  for (idx = 0; idx < stackTrace.length; idx++) {
    var match = SAFARI_STACK_ELEM.exec(stackTrace[idx]);
    if (!match) match = CHROME_STACK_ELEM.exec(stackTrace[idx]);
    if (match) {
      var entry = {
        func: match[1],
        file: match[2],
        line: match[3],
        col: match[4] || 0
      };
      if (entry.func === "") entry.func = "<anonymous>";
      stack.push(entry);
    }
  }

  return stack;
};

util.callstack = function(k) {
  var err;
  try { throw new Error(); } catch (_err) { err = _err; }
  var stack = util.parseStackTrace(err);
  k = k || 0;
  return stack.splice(k+1);
};

util.stacktrace = function (err) {
  var stack = (arguments.length === 0) ? util.callstack().splice(1) : util.parseStackTrace(err);
  var str = [];
  _.each(stack, function(s) {
    str.push(s.file+":"+s.line+":"+s.col+" ("+s.func+")");
  });
  return str.join("\n");
};

util.printStackTrace = function(err, N) {
  if (!err.stack) return;

  var stack;

  // Substance errors have a nice stack already
  if (err.__stack !== undefined) {
    stack = err.__stack;
  }
  // built-in errors have the stack trace as one string
  else if (_.isString(err.stack)) {
    stack = util.parseStackTrace(err);
  }
  else return;

  N = N || stack.length;
  N = Math.min(N, stack.length);

  for (var idx = 0; idx < N; idx++) {
    var s = stack[idx];
    console.log(s.file+":"+s.line+":"+s.col, "("+s.func+")");
  }
};

// computes the difference of obj1 to obj2
util.diff = function(obj1, obj2) {
  var diff;
  if (_.isArray(obj1) && _.isArray(obj2)) {
    diff = _.difference(obj2, obj1);
    // return null in case of equality
    if (diff.length === 0) return null;
    else return diff;
  }
  if (_.isObject(obj1) && _.isObject(obj2)) {
    diff = {};
    _.each(Object.keys(obj2), function(key) {
      var d = util.diff(obj1[key], obj2[key]);
      if (d) diff[key] = d;
    });
    // return null in case of equality
    if (_.isEmpty(diff)) return null;
    else return diff;
  }
  if(obj1 !== obj2) return obj2;
};

// Deep-Clone a given object
// --------
// Note: this is currently done via JSON.parse(JSON.stringify(obj))
//       which is in fact not optimal, as it depends on `toJSON` implementation.
util.deepclone = function(obj) {
  if (obj === undefined) return undefined;
  if (obj === null) return null;
  return JSON.parse(JSON.stringify(obj));
};

// Clones a given object
// --------
// Calls obj's `clone` function if available,
// otherwise clones the obj using `util.deepclone()`.
util.clone = function(obj) {
  if (obj === null || obj === undefined) {
    return obj;
  }
  if (_.isFunction(obj.clone)) {
    return obj.clone();
  }
  return util.deepclone(obj);
};

util.freeze = function(obj) {
  var idx;
  if (_.isObject(obj)) {
    if (Object.isFrozen(obj)) return obj;

    var keys = Object.keys(obj);
    for (idx = 0; idx < keys.length; idx++) {
      var key = keys[idx];
      obj[key] = util.freeze(obj[key]);
    }
    return Object.freeze(obj);
  } else if (_.isArray(obj)) {
    var arr = obj;
    for (idx = 0; idx < arr.length; idx++) {
      arr[idx] = util.freeze(arr[idx]);
    }
    return Object.freeze(arr);
  } else {
    return obj; // Object.freeze(obj);
  }
};

util.later = function(f, context) {
  return function() {
    var _args = arguments;
    setTimeout(function() {
      f.apply(context, _args);
    }, 0);
  };
};


// Returns true if a string doesn't contain any real content

util.isEmpty = function(str) {
  return !str.match(/\w/);
};

// Create a human readable, but URL-compatible slug from a string

util.slug = function(str) {
  str = str.replace(/^\s+|\s+$/g, ''); // trim
  str = str.toLowerCase();
  
  // remove accents, swap ñ for n, etc
  var from = "àáäâèéëêìíïîòóöôùúüûñç·/_,:;";
  var to   = "aaaaeeeeiiiioooouuuunc------";
  for (var i=0, l=from.length ; i<l ; i++) {
    str = str.replace(new RegExp(from.charAt(i), 'g'), to.charAt(i));
  }

  str = str.replace(/[^a-z0-9 -]/g, '') // remove invalid chars
    .replace(/\s+/g, '-') // collapse whitespace and replace by -
    .replace(/-+/g, '-'); // collapse dashes

  return str;
};

// Export
// ====

module.exports = util;

},{"fs":148,"underscore":140}],140:[function(require,module,exports){
//     Underscore.js 1.5.2
//     http://underscorejs.org
//     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Establish the object that gets returned to break out of a loop iteration.
  var breaker = {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    concat           = ArrayProto.concat,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeForEach      = ArrayProto.forEach,
    nativeMap          = ArrayProto.map,
    nativeReduce       = ArrayProto.reduce,
    nativeReduceRight  = ArrayProto.reduceRight,
    nativeFilter       = ArrayProto.filter,
    nativeEvery        = ArrayProto.every,
    nativeSome         = ArrayProto.some,
    nativeIndexOf      = ArrayProto.indexOf,
    nativeLastIndexOf  = ArrayProto.lastIndexOf,
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object via a string identifier,
  // for Closure Compiler "advanced" mode.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.5.2';

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles objects with the built-in `forEach`, arrays, and raw objects.
  // Delegates to **ECMAScript 5**'s native `forEach` if available.
  var each = _.each = _.forEach = function(obj, iterator, context) {
    if (obj == null) return;
    if (nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, length = obj.length; i < length; i++) {
        if (iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      var keys = _.keys(obj);
      for (var i = 0, length = keys.length; i < length; i++) {
        if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;
      }
    }
  };

  // Return the results of applying the iterator to each element.
  // Delegates to **ECMAScript 5**'s native `map` if available.
  _.map = _.collect = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
    each(obj, function(value, index, list) {
      results.push(iterator.call(context, value, index, list));
    });
    return results;
  };

  var reduceError = 'Reduce of empty array with no initial value';

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function(value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var length = obj.length;
    if (length !== +length) {
      var keys = _.keys(obj);
      length = keys.length;
    }
    each(obj, function(value, index, list) {
      index = keys ? keys[--length] : --length;
      if (!initial) {
        memo = obj[index];
        initial = true;
      } else {
        memo = iterator.call(context, memo, obj[index], index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, iterator, context) {
    var result;
    any(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Delegates to **ECMAScript 5**'s native `filter` if available.
  // Aliased as `select`.
  _.filter = _.select = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
    each(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, iterator, context) {
    return _.filter(obj, function(value, index, list) {
      return !iterator.call(context, value, index, list);
    }, context);
  };

  // Determine whether all of the elements match a truth test.
  // Delegates to **ECMAScript 5**'s native `every` if available.
  // Aliased as `all`.
  _.every = _.all = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = true;
    if (obj == null) return result;
    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
    each(obj, function(value, index, list) {
      if (!(result = result && iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if at least one element in the object matches a truth test.
  // Delegates to **ECMAScript 5**'s native `some` if available.
  // Aliased as `any`.
  var any = _.some = _.any = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = false;
    if (obj == null) return result;
    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
    each(obj, function(value, index, list) {
      if (result || (result = iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if the array or object contains a given value (using `===`).
  // Aliased as `include`.
  _.contains = _.include = function(obj, target) {
    if (obj == null) return false;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
    return any(obj, function(value) {
      return value === target;
    });
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      return (isFunc ? method : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, function(value){ return value[key]; });
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs, first) {
    if (_.isEmpty(attrs)) return first ? void 0 : [];
    return _[first ? 'find' : 'filter'](obj, function(value) {
      for (var key in attrs) {
        if (attrs[key] !== value[key]) return false;
      }
      return true;
    });
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.where(obj, attrs, true);
  };

  // Return the maximum element or (element-based computation).
  // Can't optimize arrays of integers longer than 65,535 elements.
  // See [WebKit Bug 80797](https://bugs.webkit.org/show_bug.cgi?id=80797)
  _.max = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.max.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj)) return -Infinity;
    var result = {computed : -Infinity, value: -Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed > result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.min.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj)) return Infinity;
    var result = {computed : Infinity, value: Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed < result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Shuffle an array, using the modern version of the 
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  _.shuffle = function(obj) {
    var rand;
    var index = 0;
    var shuffled = [];
    each(obj, function(value) {
      rand = _.random(index++);
      shuffled[index - 1] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };

  // Sample **n** random values from an array.
  // If **n** is not specified, returns a single random element from the array.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (arguments.length < 2 || guard) {
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // An internal function to generate lookup iterators.
  var lookupIterator = function(value) {
    return _.isFunction(value) ? value : function(obj){ return obj[value]; };
  };

  // Sort the object's values by a criterion produced by an iterator.
  _.sortBy = function(obj, value, context) {
    var iterator = lookupIterator(value);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iterator.call(context, value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, value, context) {
      var result = {};
      var iterator = value == null ? _.identity : lookupIterator(value);
      each(obj, function(value, index) {
        var key = iterator.call(context, value, index, obj);
        behavior(result, key, value);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, key, value) {
    (_.has(result, key) ? result[key] : (result[key] = [])).push(value);
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, key, value) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, key) {
    _.has(result, key) ? result[key]++ : result[key] = 1;
  });

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iterator, context) {
    iterator = iterator == null ? _.identity : lookupIterator(iterator);
    var value = iterator.call(context, obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = (low + high) >>> 1;
      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
    }
    return low;
  };

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (obj.length === +obj.length) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    return (n == null) || guard ? array[0] : slice.call(array, 0, n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if ((n == null) || guard) {
      return array[array.length - 1];
    } else {
      return slice.call(array, Math.max(array.length - n, 0));
    }
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, (n == null) || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, output) {
    if (shallow && _.every(input, _.isArray)) {
      return concat.apply(output, input);
    }
    each(input, function(value) {
      if (_.isArray(value) || _.isArguments(value)) {
        shallow ? push.apply(output, value) : flatten(value, shallow, output);
      } else {
        output.push(value);
      }
    });
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iterator, context) {
    if (_.isFunction(isSorted)) {
      context = iterator;
      iterator = isSorted;
      isSorted = false;
    }
    var initial = iterator ? _.map(array, iterator, context) : array;
    var results = [];
    var seen = [];
    each(initial, function(value, index) {
      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {
        seen.push(value);
        results.push(array[index]);
      }
    });
    return results;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(_.flatten(arguments, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function(item) {
      return _.every(rest, function(other) {
        return _.indexOf(other, item) >= 0;
      });
    });
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
    return _.filter(array, function(value){ return !_.contains(rest, value); });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    var length = _.max(_.pluck(arguments, "length").concat(0));
    var results = new Array(length);
    for (var i = 0; i < length; i++) {
      results[i] = _.pluck(arguments, '' + i);
    }
    return results;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    if (list == null) return {};
    var result = {};
    for (var i = 0, length = list.length; i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
  // we need this function. Return the position of the first occurrence of an
  // item in an array, or -1 if the item is not included in the array.
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if (array == null) return -1;
    var i = 0, length = array.length;
    if (isSorted) {
      if (typeof isSorted == 'number') {
        i = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted);
      } else {
        i = _.sortedIndex(array, item);
        return array[i] === item ? i : -1;
      }
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
    for (; i < length; i++) if (array[i] === item) return i;
    return -1;
  };

  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
  _.lastIndexOf = function(array, item, from) {
    if (array == null) return -1;
    var hasIndex = from != null;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
    }
    var i = (hasIndex ? from : array.length);
    while (i--) if (array[i] === item) return i;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(length);

    while(idx < length) {
      range[idx++] = start;
      start += step;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Reusable constructor function for prototype setting.
  var ctor = function(){};

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    var args, bound;
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError;
    args = slice.call(arguments, 2);
    return bound = function() {
      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
      ctor.prototype = func.prototype;
      var self = new ctor;
      ctor.prototype = null;
      var result = func.apply(self, args.concat(slice.call(arguments)));
      if (Object(result) === result) return result;
      return self;
    };
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context.
  _.partial = function(func) {
    var args = slice.call(arguments, 1);
    return function() {
      return func.apply(this, args.concat(slice.call(arguments)));
    };
  };

  // Bind all of an object's methods to that object. Useful for ensuring that
  // all callbacks defined on an object belong to it.
  _.bindAll = function(obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length === 0) throw new Error("bindAll must be passed function names");
    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function() {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
    };
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){ return func.apply(null, args); }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    options || (options = {});
    var later = function() {
      previous = options.leading === false ? 0 : new Date;
      timeout = null;
      result = func.apply(context, args);
    };
    return function() {
      var now = new Date;
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0) {
        clearTimeout(timeout);
        timeout = null;
        previous = now;
        result = func.apply(context, args);
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;
    return function() {
      context = this;
      args = arguments;
      timestamp = new Date();
      var later = function() {
        var last = (new Date()) - timestamp;
        if (last < wait) {
          timeout = setTimeout(later, wait - last);
        } else {
          timeout = null;
          if (!immediate) result = func.apply(context, args);
        }
      };
      var callNow = immediate && !timeout;
      if (!timeout) {
        timeout = setTimeout(later, wait);
      }
      if (callNow) result = func.apply(context, args);
      return result;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = function(func) {
    var ran = false, memo;
    return function() {
      if (ran) return memo;
      ran = true;
      memo = func.apply(this, arguments);
      func = null;
      return memo;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return function() {
      var args = [func];
      push.apply(args, arguments);
      return wrapper.apply(this, args);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var funcs = arguments;
    return function() {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = nativeKeys || function(obj) {
    if (obj !== Object(obj)) throw new TypeError('Invalid object');
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = new Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = new Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    each(keys, function(key) {
      if (key in obj) copy[key] = obj[key];
    });
    return copy;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    for (var key in obj) {
      if (!_.contains(keys, key)) copy[key] = obj[key];
    }
    return copy;
  };

  // Fill in a given object with default properties.
  _.defaults = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          if (obj[prop] === void 0) obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a == 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className != toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return a == String(b);
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] == a) return bStack[length] == b;
    }
    // Objects with different constructors are not equivalent, but `Object`s
    // from different frames are.
    var aCtor = a.constructor, bCtor = b.constructor;
    if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&
                             _.isFunction(bCtor) && (bCtor instanceof bCtor))) {
      return false;
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    var size = 0, result = true;
    // Recursively compare objects and arrays.
    if (className == '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size == b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          if (!(result = eq(a[size], b[size], aStack, bStack))) break;
        }
      }
    } else {
      // Deep compare objects.
      for (var key in a) {
        if (_.has(a, key)) {
          // Count the expected number of properties.
          size++;
          // Deep compare each member.
          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
        }
      }
      // Ensure that both objects contain the same number of properties.
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !(size--)) break;
        }
        result = !size;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return result;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b, [], []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) == '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    return obj === Object(obj);
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) == '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }

  // Optimize `isFunction` if appropriate.
  if (typeof (/./) !== 'function') {
    _.isFunction = function(obj) {
      return typeof obj === 'function';
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj != +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iterators.
  _.identity = function(value) {
    return value;
  };

  // Run a function **n** times.
  _.times = function(n, iterator, context) {
    var accum = Array(Math.max(0, n));
    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // List of HTML entities for escaping.
  var entityMap = {
    escape: {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;'
    }
  };
  entityMap.unescape = _.invert(entityMap.escape);

  // Regexes containing the keys and values listed immediately above.
  var entityRegexes = {
    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
  };

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  _.each(['escape', 'unescape'], function(method) {
    _[method] = function(string) {
      if (string == null) return '';
      return ('' + string).replace(entityRegexes[method], function(match) {
        return entityMap[method][match];
      });
    };
  });

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property) {
    if (object == null) return void 0;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result.call(this, func.apply(_, args));
      };
    });
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\t':     't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  _.template = function(text, data, settings) {
    var render;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = new RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset)
        .replace(escaper, function(match) { return '\\' + escapes[match]; });

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      }
      if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      }
      if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }
      index = offset + match.length;
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + "return __p;\n";

    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    if (data) return render(data, _);
    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled function source as a convenience for precompilation.
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function, which will delegate to the wrapper.
  _.chain = function(obj) {
    return _(obj).chain();
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(obj) {
    return this._chain ? _(obj).chain() : obj;
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
      return result.call(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result.call(this, method.apply(this._wrapped, arguments));
    };
  });

  _.extend(_.prototype, {

    // Start chaining a wrapped Underscore object.
    chain: function() {
      this._chain = true;
      return this;
    },

    // Extracts the result from a wrapped and chained object.
    value: function() {
      return this._wrapped;
    }

  });

}).call(this);

},{}],141:[function(require,module,exports){
"use strict";

// Import
// ========

var _ = require('underscore');
var util   = require('substance-util');
var errors = util.errors;
var Operation = require('./operation');
var Compound = require('./compound');

var NOP = "NOP";
var DEL = "delete";
var INS = "insert";
var MOV = 'move';

// ArrayOperations can be used to describe changes to arrays by operations.
// ========
//
// Insertions
// --------
//
// An insertion is specified by
//    {
//      type: '+',
//      val:  <value>,
//      pos:  <position>
//    }
// or shorter:
//    ['+', <value>, <position>]
//
//
// Deletions
// --------
//
// A deletion is in the same way as Insertions but with '-' as type.
//
//    ['-', <value>, <position>]
//
// The value must be specified too as otherwise the operation would not be invertible.
//
var Move;

var ArrayOperation = function(options) {

  if (options.type === undefined) {
    throw new errors.OperationError("Illegal argument: insufficient data.");
  }

  // Insert: '+', Delete: '-', Move: '>>'
  this.type = options.type;

  if (this.type === NOP) return;

  // the position where to apply the operation
  this.pos = options.pos;

  // the string to delete or insert
  this.val = options.val;

  // Move operations have a target position
  this.target = options.target;

  // sanity checks
  if(this.type !== NOP && this.type !== INS && this.type !== DEL && this.type !== MOV) {
    throw new errors.OperationError("Illegal type.");
  }

  if (this.type === INS || this.type === DEL) {
    if (this.pos === undefined || this.val === undefined) {
      throw new errors.OperationError("Illegal argument: insufficient data.");
    }
    if (!_.isNumber(this.pos) && this.pos < 0) {
      throw new errors.OperationError("Illegal argument: expecting positive number as pos.");
    }
  } else if (this.type === MOV) {
    if (this.pos === undefined || this.target === undefined) {
      throw new errors.OperationError("Illegal argument: insufficient data.");
    }
    if (!_.isNumber(this.pos) && this.pos < 0) {
      throw new errors.OperationError("Illegal argument: expecting positive number as pos.");
    }
    if (!_.isNumber(this.target) && this.target < 0) {
      throw new errors.OperationError("Illegal argument: expecting positive number as target.");
    }
  }
};

ArrayOperation.fromJSON = function(data) {
  if (_.isArray(data)) {
    if (data[0] === MOV) {
      return new Move(data[1], data[2]);
    } else {
      return new ArrayOperation(data);
    }
  }
  if (data.type === MOV) {
    return Move.fromJSON(data);
  } else if (data.type === Compound.TYPE) {
    var ops = [];
    for (var idx = 0; idx < data.ops.length; idx ++) {
      ops.push(ArrayOperation.fromJSON(data.ops[idx]));
    }
    return ArrayOperation.Compound(ops, data.data);
  }
  else  {
    return new ArrayOperation(data);
  }
};

ArrayOperation.Prototype = function() {

  this.clone = function() {
    return new ArrayOperation(this);
  };

  this.apply = function(array) {

    if (this.type === NOP) {
      return array;
    }

    var adapter = (array instanceof ArrayOperation.ArrayAdapter) ? array : new ArrayOperation.ArrayAdapter(array);

    // Insert
    if (this.type === INS) {
      adapter.insert(this.pos, this.val);
    }
    // Delete
    else if (this.type === DEL) {
      adapter.delete(this.pos, this.val);
    }
    else {
      throw new errors.OperationError("Illegal state.");
    }
    return array;
  };

  this.invert = function() {
    var data = this.toJSON();

    if (this.type === INS) data.type = DEL;
    else if (this.type === DEL) data.type = INS;
    else if (this.type === NOP) data.type = NOP;
    else {
      throw new errors.OperationError("Illegal state.");
    }

    return new ArrayOperation(data);
  };

  this.hasConflict = function(other) {
    return ArrayOperation.hasConflict(this, other);
  };

  this.toJSON = function() {
    var result = {
      type: this.type,
    };

    if (this.type === NOP) return result;

    result.pos = this.pos;
    result.val = this.val;

    return result;
  };

  this.isInsert = function() {
    return this.type === INS;
  };

  this.isDelete = function() {
    return this.type === DEL;
  };

  this.isNOP = function() {
    return this.type === NOP;
  };

  this.isMove = function() {
    return this.type === MOV;
  };

};
ArrayOperation.Prototype.prototype = Operation.prototype;
ArrayOperation.prototype = new ArrayOperation.Prototype();

var _NOP = 0;
var _DEL = 1;
var _INS = 2;
var _MOV = 4;

var CODE = {};
CODE[NOP] = _NOP;
CODE[DEL] = _DEL;
CODE[INS] = _INS;
CODE[MOV] = _MOV;

var _hasConflict = [];

_hasConflict[_DEL | _DEL] = function(a,b) {
  return a.pos === b.pos;
};

_hasConflict[_DEL | _INS] = function() {
  return false;
};

_hasConflict[_INS | _INS] = function(a,b) {
  return a.pos === b.pos;
};

/*
  As we provide Move as quasi atomic operation we have to look at it conflict potential.

  A move is realized as composite of Delete and Insert.

  M / I: ( -> I / I conflict)

    m.s < i && m.t == i-1
    else i && m.t == i

  M / D: ( -> D / D conflict)

    m.s === d

  M / M:

    1. M/D conflict
    2. M/I conflict
*/

var hasConflict = function(a, b) {
  if (a.type === NOP || b.type === NOP) return false;
  var caseId = CODE[a.type] | CODE[b.type];

  if (_hasConflict[caseId]) {
    return _hasConflict[caseId](a,b);
  } else {
    return false;
  }
};

var transform0;

function transform_insert_insert(a, b, first) {

  if (a.pos === b.pos) {
    if (first) {
      b.pos += 1;
    } else {
      a.pos += 1;
    }
  }
  // a before b
  else if (a.pos < b.pos) {
    b.pos += 1;
  }

  // a after b
  else  {
    a.pos += 1;
  }

}

function transform_delete_delete(a, b) {

  // turn the second of two concurrent deletes into a NOP
  if (a.pos === b.pos) {
    b.type = NOP;
    a.type = NOP;
    return;
  }

  if (a.pos < b.pos) {
    b.pos -= 1;
  } else {
    a.pos -= 1;
  }

}

function transform_insert_delete(a, b) {

  // reduce to a normalized case
  if (a.type === DEL) {
    var tmp = a;
    a = b;
    b = tmp;
  }

  if (a.pos <= b.pos) {
    b.pos += 1;
  } else {
    a.pos -= 1;
  }

}

function transform_move(a, b, check, first) {
  if (a.type !== MOV) return transform_move(b, a, check, !first);

  var del = {type: DEL, pos: a.pos};
  var ins = {type: INS, pos: a.target};

  var options = {inplace: true, check:check};

  if (b.type === DEL && a.pos === b.pos) {
    a.type = NOP;
    b.pos = a.target;

  } else if (b.type === MOV && a.pos === b.pos) {
    if (first) {
      b.pos = a.target;
      a.type = NOP;
    } else {
      a.pos = b.target;
      b.type = NOP;
    }
  } else {

    if (first) {
      transform0(del, b, options);
      transform0(ins, b, options);
    } else {
      transform0(b, del, options);
      transform0(b, ins, options);
    }

    a.pos = del.pos;
    a.target = ins.pos;

  }
}

transform0 = function(a, b, options) {

  options = options || {};

  if (options.check && hasConflict(a, b)) {
    throw Operation.conflict(a, b);
  }

  if (!options.inplace) {
    a = util.clone(a);
    b = util.clone(b);
  }

  if (a.type === NOP || b.type === NOP)  {
    // nothing to transform
  }
  else if (a.type === INS && b.type === INS)  {
    transform_insert_insert(a, b, true);
  }
  else if (a.type === DEL && b.type === DEL) {
    transform_delete_delete(a, b, true);
  }
  else if (a.type === MOV || b.type === MOV) {
    transform_move(a, b, options.check, true);
  }
  else {
    transform_insert_delete(a, b, true);
  }

  return [a, b];
};

var __apply__ = function(op, array) {
  if (_.isArray(op)) {
    if (op[0] === MOV) {
      op = new Move(op[1], op[2]);
    } else {
      op = new ArrayOperation(op);
    }
  } else if (!(op instanceof ArrayOperation)) {
    op = ArrayOperation.fromJSON(op);
  }
  return op.apply(array);
};

ArrayOperation.transform = Compound.createTransform(transform0);
ArrayOperation.hasConflict = hasConflict;

ArrayOperation.perform = __apply__;
// DEPRECATED: use ArrayOperation.perform
ArrayOperation.apply = __apply__;

// Note: this is implemented manually, to avoid the value parameter
// necessary for Insert and Delete
var Move = function(source, target) {

  this.type = MOV;
  this.pos = source;
  this.target = target;

  if (!_.isNumber(this.pos) || !_.isNumber(this.target) || this.pos < 0 || this.target < 0) {
    throw new errors.OperationError("Illegal argument");
  }
};

Move.Prototype = function() {

  this.clone = function() {
    return new Move(this.pos, this.target);
  };

  this.apply = function(array) {
    if (this.type === NOP) return array;

    var adapter = (array instanceof ArrayOperation.ArrayAdapter) ? array : new ArrayOperation.ArrayAdapter(array);

    var val = array[this.pos];
    adapter.move(val, this.pos, this.target);

    return array;
  };

  this.invert = function() {
    return new Move(this.target, this.pos);
  };

  this.toJSON = function() {
    return {
      type: MOV,
      pos: this.pos,
      target: this.target
    };
  };

};
Move.Prototype.prototype = ArrayOperation.prototype;
Move.prototype = new Move.Prototype();

Move.fromJSON = function(data) {
  return new Move(data.pos, data.target);
};


// classical LCSS, implemented inplace and using traceback trick
var lcss = function(arr1, arr2) {
  var i,j;
  var L = [0];

  for (i = 0; i < arr1.length; i++) {
    for (j = 0; j < arr2.length; j++) {
      L[j+1] = L[j+1] || 0;
      if (_.isEqual(arr1[i], arr2[j])) {
        L[j+1] = Math.max(L[j+1], L[j]+1);
      } else {
        L[j+1] = Math.max(L[j+1], L[j]);
      }
    }
  }

  var seq = [];
  for (j = arr2.length; j >= 0; j--) {
    if (L[j] > L[j-1]) {
      seq.unshift(arr2[j-1]);
    }
  }

  return seq;
};


// Factory methods
// -------
//
// Note: you should use these methods instead of manually define
// an operation. This is allows us to change the underlying implementation
// without breaking your code.


ArrayOperation.Insert = function(pos, val) {
  return new ArrayOperation({type:INS, pos: pos, val: val});
};


// Factory methods
// -------
//
// Deletes an element from an array
// When array is provided value is looked up
// When pos is given, element at that position gets removed

ArrayOperation.Delete = function(posOrArray, val) {
  var pos = posOrArray;
  if (_.isArray(pos)) {
    pos = pos.indexOf(val);
  }
  if (pos < 0) return new ArrayOperation({type: NOP});
  return new ArrayOperation({type:DEL, pos: pos, val: val});
};

ArrayOperation.Move = function(pos1, pos2) {
  return new Move(pos1, pos2);
};

ArrayOperation.Push = function(arr, val) {
  var index = arr.length;
  return ArrayOperation.Insert(index, val);
};

ArrayOperation.Pop = function(arr) {
  // First we need to find a way to return values
  var index = arr.length-1;
  return ArrayOperation.Delete(index, arr[index]);
};


// Creates a compound operation that transforms the given oldArray
// into the new Array
ArrayOperation.Update = function(oldArray, newArray) {

  // 1. Compute longest common subsequence
  var seq = lcss(oldArray, newArray);

  // 2. Iterate through the three sequences and generate a sequence of
  //    retains, deletes, and inserts

  var a = seq;
  var b = oldArray;
  var c = newArray;
  var pos1, pos2, pos3;
  pos1 = 0;
  pos2 = 0;
  pos3 = 0;

  seq = [];

  while(pos2 < b.length || pos3 < c.length) {
    if (a[pos1] === b[pos2] && b[pos2] === c[pos3]) {
      pos1++; pos2++; pos3++;
      seq.push(1);
    } else if (a[pos1] === b[pos2]) {
      seq.push(['+', c[pos3++]]);
    } else {
      seq.push(['-', b[pos2++]]);
    }
  }

  // 3. Create a compound for the computed sequence

  return ArrayOperation.Sequence(seq);
};

ArrayOperation.Compound = function(ops, data) {
  // do not create a Compound if not necessary
  if (ops.length === 1 && !data) return ops[0];
  else return new Compound(ops, data);
};

// Convenience factory method to create an operation that clears the given array.
// --------
//

ArrayOperation.Clear = function(arr) {
  var ops = [];
  for (var idx = 0; idx < arr.length; idx++) {
    ops.push(ArrayOperation.Delete(0, arr[idx]));
  }
  return ArrayOperation.Compound(ops);
};



// Convenience factory method to create an incremental complex array update.
// --------
//
// Example:
//  Input:
//    [1,2,3,4,5,6,7]
//  Sequence:
//    [2, ['-', 3], 2, ['+', 8]]
//  Output:
//    [1,2,4,5,8,6,7]
//
// Syntax:
//
//  - positive Number: skip / retain
//  - tuple ['-', <val>]: delete element at current position
//  - tuple ['+', <val>]: insert element at current position

ArrayOperation.Sequence = function(seq) {
  var pos = 0;
  var ops = [];

  for (var idx = 0; idx < seq.length; idx++) {
    var s = seq[idx];

    if (_.isNumber(s) && s > 0) {
      pos += s;
    } else {
      if (s[0] === "+") {
        ops.push(ArrayOperation.Insert(pos, s[1]));
        pos+=1;
      } else if (s[0] === "-") {
        ops.push(ArrayOperation.Delete(pos, s[1]));
      } else {
        throw new errors.OperationError("Illegal operation.");
      }
    }
  }

  return new Compound(ops);
};

ArrayOperation.create = function(array, spec) {
  var type = spec[0];
  var val, pos;
  if (type === INS || type === "+") {
    pos = spec[1];
    val = spec[2];
    return ArrayOperation.Insert(pos, val);
  } else if (type === DEL || type === "-") {
    pos = spec[1];
    val = array[pos];
    return ArrayOperation.Delete(pos, val);
  } else if (type === MOV || type === ">>") {
    pos = spec[1];
    var target = spec[2];
    return ArrayOperation.Move(pos, target);
  } else {
    throw new errors.OperationError("Illegal specification.");
  }
};

var ArrayAdapter = function(arr) {
  this.array = arr;
};

ArrayAdapter.prototype = {
  insert: function(pos, val) {
    if (this.array.length < pos) {
      throw new errors.OperationError("Provided array is too small.");
    }
    this.array.splice(pos, 0, val);
  },

  delete: function(pos, val) {
    if (this.array.length < pos) {
      throw new errors.OperationError("Provided array is too small.");
    }
    if (this.array[pos] !== val) {
      throw new errors.OperationError("Unexpected value at position " + pos + ". Expected " + val + ", found " + this.array[pos]);
    }
    this.array.splice(pos, 1);
  },

  move: function(val, pos, to) {
    if (this.array.length < pos) {
      throw new errors.OperationError("Provided array is too small.");
    }
    this.array.splice(pos, 1);

    if (this.array.length < to) {
      throw new errors.OperationError("Provided array is too small.");
    }
    this.array.splice(to, 0, val);
  }
};
ArrayOperation.ArrayAdapter = ArrayAdapter;

ArrayOperation.NOP = NOP;
ArrayOperation.DELETE = DEL;
ArrayOperation.INSERT = INS;
ArrayOperation.MOVE = MOV;

// Export
// ========

module.exports = ArrayOperation;

},{"./compound":142,"./operation":144,"substance-util":133,"underscore":140}],142:[function(require,module,exports){
"use strict";

// Import
// ========

var _    = require('underscore');
var util   = require('substance-util');
var Operation = require('./operation');

// Module
// ========

var COMPOUND = "compound";

var Compound = function(ops, data) {
  this.type = COMPOUND;
  this.ops = ops;
  this.alias = undefined;
  this.data = data;

  if (!ops || ops.length === 0) {
    throw new Operation.OperationError("No operations given.");
  }
};

Compound.Prototype = function() {

  this.clone = function() {
    var ops = [];
    for (var idx = 0; idx < this.ops.length; idx++) {
      ops.push(util.clone(this.ops[idx]));
    }
    return new Compound(ops, util.clone(this.data));
  };

  this.apply = function(obj) {
    for (var idx = 0; idx < this.ops.length; idx++) {
      obj = this.ops[idx].apply(obj);
    }
    return obj;
  };

  this.invert = function() {
    var ops = [];
    for (var idx = 0; idx < this.ops.length; idx++) {
      // reverse the order of the inverted atomic commands
      ops.unshift(this.ops[idx].invert());
    }
    return new Compound(ops, this.data);
  };

  this.toJSON = function() {
    var result = {
      type: COMPOUND,
      ops: this.ops,
    };
    if (this.alias) result.alias = this.alias;
    if (this.data) result.data = this.data;
    return result;
  };

};
Compound.Prototype.prototype = Operation.prototype;
Compound.prototype = new Compound.Prototype();

Compound.TYPE = COMPOUND;

// Transforms a compound and another given change inplace.
// --------
//

var compound_transform = function(a, b, first, check, transform0) {
  var idx;

  if (b.type === COMPOUND) {
    for (idx = 0; idx < b.ops.length; idx++) {
      compound_transform(a, b.ops[idx], first, check, transform0);
    }
  }

  else {
    for (idx = 0; idx < a.ops.length; idx++) {
      var _a, _b;
      if (first) {
        _a = a.ops[idx];
        _b = b;
      } else {
        _a = b;
        _b = a.ops[idx];
      }
      transform0(_a, _b, {inplace: true, check: check});
    }
  }
};

// A helper to create a transform method that supports Compounds.
// --------
//

Compound.createTransform = function(primitive_transform) {
  return function(a, b, options) {
    options = options || {};
    if(a.type === COMPOUND || b.type === COMPOUND) {
      if (!options.inplace) {
        a = util.clone(a);
        b = util.clone(b);
      }
      if (a.type === COMPOUND) {
        compound_transform(a, b, true, options.check, primitive_transform);
      } else if (b.type === COMPOUND) {
        compound_transform(b, a, false, options.check, primitive_transform);
      }
      return [a, b];
    } else {
      return primitive_transform(a, b, options);
    }

  };
};

// Export
// ========

module.exports = Compound;

},{"./operation":144,"substance-util":133,"underscore":140}],143:[function(require,module,exports){
"use strict";

// Import
// ========

var _ = require('underscore');
var util = require('substance-util');
var errors = util.errors;
var Operation = require('./operation');
var Compound = require('./compound');
var TextOperation = require('./text_operation');
var ArrayOperation = require('./array_operation');

var NOP = "NOP";
var CREATE = "create";
var DELETE = 'delete';
var UPDATE = 'update';
var SET = 'set';

var ObjectOperation = function(data) {

  this.type = data.type;
  this.path = data.path;

  if (this.type === CREATE || this.type === DELETE) {
    this.val = data.val;
  }

  // Updates can be given as value or as Operation (Text, Array)
  else if (this.type === UPDATE) {
    if (data.diff !== undefined) {
      this.diff = data.diff;
      this.propertyType = data.propertyType;
    } else {
      throw new errors.OperationError("Illegal argument: update by value or by diff must be provided");
    }
  }

  else if (this.type === SET) {
    this.val = data.val;
    this.original = data.original;
  }
};

ObjectOperation.fromJSON = function(data) {
  if (data.type === Compound.TYPE) {
    var ops = [];
    for (var idx = 0; idx < data.ops.length; idx++) {
      ops.push(ObjectOperation.fromJSON(data.ops[idx]));
    }
    return ObjectOperation.Compound(ops, data.data);

  } else {
    var op = new ObjectOperation(data);
    if (data.type === "update") {
      switch (data.propertyType) {
      case "string":
        op.diff = TextOperation.fromJSON(op.diff);
        break;
      case "array":
        op.diff = ArrayOperation.fromJSON(op.diff);
        break;
      default:
        throw new Error("Don't know how to deserialize this operation:" + JSON.stringify(data));
      }
    }
    return op;
  }
};

ObjectOperation.Prototype = function() {

  this.clone = function() {
    return new ObjectOperation(this);
  };

  this.isNOP = function() {
    if (this.type === NOP) return true;
    else if (this.type === UPDATE) return this.diff.isNOP();
  };

  this.apply = function(obj) {
    if (this.type === NOP) return obj;

    // Note: this allows to use a custom adapter implementation
    // to support other object like backends
    var adapter = (obj instanceof ObjectOperation.Object) ? obj : new ObjectOperation.Object(obj);

    if (this.type === CREATE) {
      // clone here as the operations value must not be changed
      adapter.create(this.path, util.clone(this.val));
      return obj;
    }

    var val = adapter.get(this.path);

    if (this.type === DELETE) {
      // TODO: maybe we could tolerate such deletes
      if (val === undefined) {
        throw new errors.OperationError("Property " + JSON.stringify(this.path) + " not found.");
      }
      adapter.delete(this.path, val);
    }

    else if (this.type === UPDATE) {
      if (this.propertyType === 'object') {
        val = ObjectOperation.apply(this.diff, val);
        if(!adapter.inplace()) adapter.update(this.path, val, this.diff);
      }
      else if (this.propertyType === 'array') {
        val = ArrayOperation.apply(this.diff, val);
        if(!adapter.inplace()) adapter.update(this.path, val, this.diff);
      }
      else if (this.propertyType === 'string') {
        val = TextOperation.apply(this.diff, val);
        adapter.update(this.path, val, this.diff);
      }
      else {
        throw new errors.OperationError("Unsupported type for operational update.");
      }
    }

    else if (this.type === SET) {
      // clone here as the operations value must not be changed
      adapter.set(this.path, util.clone(this.val));
    }

    else {
      throw new errors.OperationError("Illegal state.");
    }

    return obj;
  };

  this.invert = function() {

    if (this.type === NOP) {
      return { type: NOP };
    }

    var result = new ObjectOperation(this);

    if (this.type === CREATE) {
      result.type = DELETE;
    }

    else if (this.type === DELETE) {
      result.type = CREATE;
    }

    else if (this.type === UPDATE) {
      var invertedDiff;
      if (this.propertyType === 'string') {
        invertedDiff = TextOperation.fromJSON(this.diff).invert();
      }
      else if (this.propertyType === 'array') {
        invertedDiff = ArrayOperation.fromJSON(this.diff).invert();
      }
      result.diff = invertedDiff;
      result.propertyType = this.propertyType;
    }

    else if (this.type === SET) {
      result.val = this.original;
      result.original = this.val;
    }

    else {
      throw new errors.OperationError("Illegal state.");
    }

    return result;
  };

  this.hasConflict = function(other) {
    return ObjectOperation.hasConflict(this, other);
  };

  this.toJSON = function() {

    if (this.type === NOP) {
      return {
        type: NOP
      };
    }

    var data = {
      type: this.type,
      path: this.path,
    };

    if (this.type === CREATE || this.type === DELETE) {
      data.val = this.val;
    }

    else if (this.type === UPDATE) {
      data.diff = this.diff;
      data.propertyType = this.propertyType;
    }

    else if (this.type === SET) {
      data.val = this.val;
      data.original = this.original;
    }

    return data;
  };

};
ObjectOperation.Prototype.prototype = Operation.prototype;
ObjectOperation.prototype = new ObjectOperation.Prototype();

ObjectOperation.Object = function(obj) {
  this.obj = obj;
};

ObjectOperation.Object.Prototype = function() {

  function resolve(self, obj, path, create) {
    var item = obj;
    var idx = 0;
    for (; idx < path.length-1; idx++) {
      if (item === undefined) {
        throw new Error("Key error: could not find element for path " + JSON.stringify(self.path));
      }

      if (item[path[idx]] === undefined && create) {
        item[path[idx]] = {};
      }

      item = item[path[idx]];
    }
    return {parent: item, key: path[idx]};
  }

  this.get = function(path) {
    var item = resolve(this, this.obj, path);
    return item.parent[item.key];
  };

  this.create = function(path, value) {
    var item = resolve(this, this.obj, path, true);
    if (item.parent[item.key] !== undefined) {
      throw new errors.OperationError("Value already exists. path =" + JSON.stringify(path));
    }
    item.parent[item.key] = value;
  };

  // Note: in the default implementation we do not need the diff
  this.update = function(path, value, diff) {
    this.set(path, value);
  };

  this.set = function(path, value) {
    var item = resolve(this, this.obj, path);
    item.parent[item.key] = value;
  };

  this.delete = function(path) {
    var item = resolve(this, this.obj, path);
    delete item.parent[item.key];
  };

  this.inplace = function() {
    return true;
  };

};
ObjectOperation.Object.prototype = new ObjectOperation.Object.Prototype();


var hasConflict = function(a, b) {
  if (a.type === NOP || b.type === NOP) return false;

  return _.isEqual(a.path, b.path);
};

var transform_delete_delete = function(a, b) {
  // both operations have the same effect.
  // the transformed operations are turned into NOPs
  a.type = NOP;
  b.type = NOP;
};

var transform_create_create = function() {
  // TODO: maybe it would be possible to create an differntial update that transforms the one into the other
  // However, we fail for now.
  throw new errors.OperationError("Can not transform two concurring creates of the same property");
};

var transform_delete_create = function(a, b, flipped) {
  if (a.type !== DELETE) {
    return transform_delete_create(b, a, true);
  }

  if (!flipped) {
    a.type = NOP;
  } else {
    a.val = b.val;
    b.type = NOP;
  }
};

var transform_delete_update = function(a, b, flipped) {
  if (a.type !== DELETE) {
    return transform_delete_update(b, a, true);
  }

  var op;
  if (b.propertyType === 'string') {
    op = TextOperation.fromJSON(b.diff);
  } else if (b.propertyType === 'array') {
    op = ArrayOperation.fromJSON(b.diff);
  }

  // (DELETE, UPDATE) is transformed into (DELETE, CREATE)
  if (!flipped) {
    a.type = NOP;
    b.type = CREATE;
    b.val = op.apply(a.val);
  }
  // (UPDATE, DELETE): the delete is updated to delete the updated value
  else {
    a.val = op.apply(a.val);
    b.type = NOP;
  }

};

var transform_create_update = function() {
  // it is not possible to reasonably transform this.
  throw new errors.OperationError("Can not transform a concurring create and update of the same property");
};

var transform_update_update = function(a, b) {

  // Note: this is a conflict the user should know about

  var op_a, op_b, t;
  if (b.propertyType === 'string') {
    op_a = TextOperation.fromJSON(a.diff);
    op_b = TextOperation.fromJSON(b.diff);
    t = TextOperation.transform(op_a, op_b, {inplace: true});
  } else if (b.propertyType === 'array') {
    op_a = ArrayOperation.fromJSON(a.diff);
    op_b = ArrayOperation.fromJSON(b.diff);
    t = ArrayOperation.transform(op_a, op_b, {inplace: true});
  } else if (b.propertyType === 'object') {
    op_a = ObjectOperation.fromJSON(a.diff);
    op_b = ObjectOperation.fromJSON(b.diff);
    t = ObjectOperation.transform(op_a, op_b, {inplace: true});
  }

  a.diff = t[0];
  b.diff = t[1];
};

var transform_create_set = function(a, b, flipped) {
  if (a.type !== CREATE) return transform_create_set(b, a, true);

  if (!flipped) {
    a.type = NOP;
    b.original = a.val;
  } else {
    a.type = SET;
    a.original = b.val;
    b.type = NOP;
  }

};

var transform_delete_set = function(a, b, flipped) {
  if (a.type !== DELETE) return transform_delete_set(b, a, true);

  if (!flipped) {
    a.type = NOP;
    b.type = CREATE;
    b.original = undefined;
  } else {
    a.val = b.val;
    b.type = NOP;
  }

};

var transform_update_set = function() {
  throw new errors.OperationError("Can not transform update/set of the same property.");
};

var transform_set_set = function(a, b) {
  a.type = NOP;
  b.original = a.val;
};

var _NOP = 0;
var _CREATE = 1;
var _DELETE = 2;
var _UPDATE = 4;
var _SET = 8;

var CODE = {};
CODE[NOP] =_NOP;
CODE[CREATE] = _CREATE;
CODE[DELETE] = _DELETE;
CODE[UPDATE] = _UPDATE;
CODE[SET] = _SET;

var __transform__ = [];
__transform__[_DELETE | _DELETE] = transform_delete_delete;
__transform__[_DELETE | _CREATE] = transform_delete_create;
__transform__[_DELETE | _UPDATE] = transform_delete_update;
__transform__[_CREATE | _CREATE] = transform_create_create;
__transform__[_CREATE | _UPDATE] = transform_create_update;
__transform__[_UPDATE | _UPDATE] = transform_update_update;
__transform__[_CREATE | _SET   ] = transform_create_set;
__transform__[_DELETE | _SET   ] = transform_delete_set;
__transform__[_UPDATE | _SET   ] = transform_update_set;
__transform__[_SET    | _SET   ] = transform_set_set;

var transform = function(a, b, options) {

  options = options || {};

  var conflict = hasConflict(a, b);

  if (options.check && conflict) {
    throw Operation.conflict(a, b);
  }

  if (!options.inplace) {
    a = util.clone(a);
    b = util.clone(b);
  }

  // without conflict: a' = a, b' = b
  if (!conflict) {
    return [a, b];
  }

  __transform__[CODE[a.type] | CODE[b.type]](a,b);

  return [a, b];
};

ObjectOperation.transform = Compound.createTransform(transform);
ObjectOperation.hasConflict = hasConflict;

var __apply__ = function(op, obj) {
  if (!(op instanceof ObjectOperation)) {
    op = ObjectOperation.fromJSON(op);
  }
  return op.apply(obj);
};

// TODO: rename to "exec" or perform
ObjectOperation.apply = __apply__;

ObjectOperation.Create = function(path, val) {
  return new ObjectOperation({type: CREATE, path: path, val: val});
};

ObjectOperation.Delete = function(path, val) {
  return new ObjectOperation({type: DELETE, path: path, val: val});
};

function guessPropertyType(op) {

  if (op instanceof Compound) {
    return guessPropertyType(op.ops[0]);
  }
  if (op instanceof TextOperation) {
    return "string";
  }
  else if (op instanceof ArrayOperation) {
    return  "array";
  }
  else {
    return "other";
  }
}

ObjectOperation.Update = function(path, diff, propertyType) {
  propertyType = propertyType || guessPropertyType(diff);

  return new ObjectOperation({
    type: UPDATE,
    path: path,
    diff: diff,
    propertyType: propertyType
  });
};

ObjectOperation.Set = function(path, oldVal, newVal) {
  return new ObjectOperation({
    type: SET,
    path: path,
    val: util.clone(newVal),
    original: util.clone(oldVal)
  });
};

ObjectOperation.Compound = function(ops, data) {
  if (ops.length === 0) return null;
  else return new Compound(ops, data);
};

// TODO: this can not deal with cyclic references
var __extend__ = function(obj, newVals, path, deletes, creates, updates) {
  var keys = Object.getOwnPropertyNames(newVals);

  for (var idx = 0; idx < keys.length; idx++) {
    var key = keys[idx];
    var p = path.concat(key);

    if (newVals[key] === undefined && obj[key] !== undefined) {
      deletes.push(ObjectOperation.Delete(p, obj[key]));

    } else if (_.isObject(newVals[key])) {

      // TODO: for now, the structure must be the same
      if (!_.isObject(obj[key])) {
        throw new errors.OperationError("Incompatible arguments: newVals must have same structure as obj.");
      }
      __extend__(obj[key], newVals[key], p, deletes, creates, updates);

    } else {
      if (obj[key] === undefined) {
        creates.push(ObjectOperation.Create(p, newVals[key]));
      } else {
        var oldVal = obj[key];
        var newVal = newVals[key];
        if (!_.isEqual(oldVal, newVal)) {
          updates.push(ObjectOperation.Set(p, oldVal, newVal));
        }
      }
    }
  }
};

ObjectOperation.Extend = function(obj, newVals) {
  var deletes = [];
  var creates = [];
  var updates = [];
  __extend__(obj, newVals, [], deletes, creates, updates);
  return ObjectOperation.Compound(deletes.concat(creates).concat(updates));
};

ObjectOperation.NOP = NOP;
ObjectOperation.CREATE = CREATE;
ObjectOperation.DELETE = DELETE;
ObjectOperation.UPDATE = UPDATE;
ObjectOperation.SET = SET;

// Export
// ========

module.exports = ObjectOperation;

},{"./array_operation":141,"./compound":142,"./operation":144,"./text_operation":146,"substance-util":133,"underscore":140}],144:[function(require,module,exports){
"use strict";

// Import
// ========

var util   = require('substance-util');
var errors   = util.errors;

var OperationError = errors.define("OperationError", -1);
var Conflict = errors.define("Conflict", -1);

var Operation = function() {};

Operation.Prototype = function() {

  this.clone = function() {
    throw new Error("Not implemented.");
  };

  this.apply = function() {
    throw new Error("Not implemented.");
  };

  this.invert = function() {
    throw new Error("Not implemented.");
  };

  this.hasConflict = function() {
    throw new Error("Not implemented.");
  };

};

Operation.prototype = new Operation.Prototype();

Operation.conflict = function(a, b) {
  var conflict = new errors.Conflict("Conflict: " + JSON.stringify(a) +" vs " + JSON.stringify(b));
  conflict.a = a;
  conflict.b = b;
  return conflict;
};

Operation.OperationError = OperationError;
Operation.Conflict = Conflict;

// Export
// ========

module.exports = Operation;

},{"substance-util":133}],145:[function(require,module,exports){
"use strict";

var TextOperation = require("./text_operation");
var ArrayOperation = require("./array_operation");

var Helpers = {};

Helpers.last = function(op) {
  if (op.type === "compound") {
    return op.ops[op.ops.length-1];
  }
  return op;
};

// Iterates all atomic operations contained in a given operation
// --------
//
// - op: an Operation instance
// - iterator: a `function(op)`
// - context: the `this` context for the iterator function
// - reverse: if present, the operations are iterated reversely

Helpers.each = function(op, iterator, context, reverse) {
  if (op.type === "compound") {
    var l = op.ops.length;
    for (var i = 0; i < l; i++) {
      var child = op.ops[i];
      if (reverse) {
        child = op.ops[l-i-1];
      }
      if (child.type === "compound") {
        if (Helpers.each(child, iterator, context, reverse) === false) {
          return false;
        }
      }
      else {
        if (iterator.call(context, child) === false) {
          return false;
        }
      }
    }
    return true;
  } else {
    return iterator.call(context, op);
  }
};

Helpers.invert = function(op, type) {
  switch (type) {
  case "string":
    return TextOperation.fromJSON(op).invert();
  case "array":
    return ArrayOperation.fromJSON(op).invert();
  default:
    throw new Error("Don't know how to invert this operation.");
  }
};

module.exports = Helpers;

},{"./array_operation":141,"./text_operation":146}],146:[function(require,module,exports){
"use strict";

// Import
// ========

var _ = require('underscore');
var util = require('substance-util');
var errors = util.errors;
var Operation = require('./operation');
var Compound = require('./compound');


var INS = "+";
var DEL = "-";

var TextOperation = function(options) {

  // if this operation should be created using an array
  if (_.isArray(options)) {
    options = {
      type: options[0],
      pos: options[1],
      str: options[2]
    };
  }

  if (options.type === undefined || options.pos === undefined || options.str === undefined) {
    throw new errors.OperationError("Illegal argument: insufficient data.");
  }

  // '+' or '-'
  this.type = options.type;

  // the position where to apply the operation
  this.pos = options.pos;

  // the string to delete or insert
  this.str = options.str;

  // sanity checks
  if(!this.isInsert() && !this.isDelete()) {
    throw new errors.OperationError("Illegal type.");
  }
  if (!_.isString(this.str)) {
    throw new errors.OperationError("Illegal argument: expecting string.");
  }
  if (!_.isNumber(this.pos) && this.pos < 0) {
    throw new errors.OperationError("Illegal argument: expecting positive number as pos.");
  }
};

TextOperation.fromJSON = function(data) {

  if (data.type === Compound.TYPE) {
    var ops = [];
    for (var idx = 0; idx < data.ops.length; idx++) {
      ops.push(TextOperation.fromJSON(data.ops[idx]));
    }
    return TextOperation.Compound(ops,data.data);

  } else {
    return new TextOperation(data);
  }
};

TextOperation.Prototype = function() {

  this.clone = function() {
    return new TextOperation(this);
  };

  this.isNOP = function() {
    return this.type === "NOP" || this.str.length === 0;
  };

  this.isInsert = function() {
    return this.type === INS;
  };

  this.isDelete = function() {
    return this.type === DEL;
  };

  this.length = function() {
    return this.str.length;
  };

  this.apply = function(str) {
    if (this.isEmpty()) return str;

    var adapter = (str instanceof TextOperation.StringAdapter) ? str : new TextOperation.StringAdapter(str);

    if (this.type === INS) {
      adapter.insert(this.pos, this.str);
    }
    else if (this.type === DEL) {
      adapter.delete(this.pos, this.str.length);
    }
    else {
      throw new errors.OperationError("Illegal operation type: " + this.type);
    }

    return adapter.get();
  };

  this.invert = function() {
    var data = {
      type: this.isInsert() ? '-' : '+',
      pos: this.pos,
      str: this.str
    };
    return new TextOperation(data);
  };

  this.hasConflict = function(other) {
    return TextOperation.hasConflict(this, other);
  };

  this.isEmpty = function() {
    return this.str.length === 0;
  };

  this.toJSON = function() {
    return {
      type: this.type,
      pos: this.pos,
      str: this.str
    };
  };

};
TextOperation.Prototype.prototype = Operation.prototype;
TextOperation.prototype = new TextOperation.Prototype();

var hasConflict = function(a, b) {

  // Insert vs Insert:
  //
  // Insertions are conflicting iff their insert position is the same.

  if (a.type === INS && b.type === INS)  return (a.pos === b.pos);

  // Delete vs Delete:
  //
  // Deletions are conflicting if their ranges overlap.

  if (a.type === DEL && b.type === DEL) {
    // to have no conflict, either `a` should be after `b` or `b` after `a`, otherwise.
    return !(a.pos >= b.pos + b.str.length || b.pos >= a.pos + a.str.length);
  }

  // Delete vs Insert:
  //
  // A deletion and an insertion are conflicting if the insert position is within the deleted range.

  var del, ins;
  if (a.type === DEL) {
    del = a; ins = b;
  } else {
    del = b; ins = a;
  }

  return (ins.pos >= del.pos && ins.pos < del.pos + del.str.length);
};

// Transforms two Insertions
// --------

function transform_insert_insert(a, b, first) {

  if (a.pos === b.pos) {
    if (first) {
      b.pos += a.str.length;
    } else {
      a.pos += b.str.length;
    }
  }

  else if (a.pos < b.pos) {
    b.pos += a.str.length;
  }

  else {
    a.pos += b.str.length;
  }

}

// Transform two Deletions
// --------
//

function transform_delete_delete(a, b, first) {

  // reduce to a normalized case
  if (a.pos > b.pos) {
    return transform_delete_delete(b, a, !first);
  }

  if (a.pos === b.pos && a.str.length > b.str.length) {
    return transform_delete_delete(b, a, !first);
  }


  // take out overlapping parts
  if (b.pos < a.pos + a.str.length) {
    var s = b.pos - a.pos;
    var s1 = a.str.length - s;
    var s2 = s + b.str.length;

    a.str = a.str.slice(0, s) + a.str.slice(s2);
    b.str = b.str.slice(s1);
    b.pos -= s;
  } else {
    b.pos -= a.str.length;
  }

}

// Transform Insert and Deletion
// --------
//

function transform_insert_delete(a, b) {

  if (a.type === DEL) {
    return transform_insert_delete(b, a);
  }

  // we can assume, that a is an insertion and b is a deletion

  // a is before b
  if (a.pos <= b.pos) {
    b.pos += a.str.length;
  }

  // a is after b
  else if (a.pos >= b.pos + b.str.length) {
    a.pos -= b.str.length;
  }

  // Note: this is a conflict case the user should be noticed about
  // If applied still, the deletion takes precedence
  // a.pos > b.pos && <= b.pos + b.length()
  else {
    var s = a.pos - b.pos;
    b.str = b.str.slice(0, s) + a.str + b.str.slice(s);
    a.str = "";
  }

}

var transform0 = function(a, b, options) {

  options = options || {};

  if (options.check && hasConflict(a, b)) {
    throw Operation.conflict(a, b);
  }

  if (!options.inplace) {
    a = util.clone(a);
    b = util.clone(b);
  }

  if (a.type === INS && b.type === INS)  {
    transform_insert_insert(a, b, true);
  }
  else if (a.type === DEL && b.type === DEL) {
    transform_delete_delete(a, b, true);
  }
  else {
    transform_insert_delete(a,b);
  }

  return [a, b];
};

var __apply__ = function(op, array) {
  if (_.isArray(op)) {
    op = new TextOperation(op);
  }
  else if (!(op instanceof TextOperation)) {
    op = TextOperation.fromJSON(op);
  }
  return op.apply(array);
};

TextOperation.transform = Compound.createTransform(transform0);
TextOperation.apply = __apply__;

var StringAdapter = function(str) {
  this.str = str;
};
StringAdapter.prototype = {
  insert: function(pos, str) {
    if (this.str.length < pos) {
      throw new errors.OperationError("Provided string is too short.");
    }
    this.str = this.str.slice(0, pos) + str + this.str.slice(pos);
  },

  delete: function(pos, length) {
    if (this.str.length < pos + length) {
      throw new errors.OperationError("Provided string is too short.");
    }
    this.str = this.str.slice(0, pos) + this.str.slice(pos + length);
  },

  get: function() {
    return this.str;
  }
};

TextOperation.Insert = function(pos, str) {
  return new TextOperation(["+", pos, str]);
};

TextOperation.Delete = function(pos, str) {
  return new TextOperation(["-", pos, str]);
};

TextOperation.Compound = function(ops, data) {
  // do not create a Compound if not necessary
  if (ops.length === 1 && !data) return ops[0];
  else return new Compound(ops, data);
};

// Converts from a given a sequence in the format of Tim's lib
// which is an array of numbers and strings.
// 1. positive number: retain a number of characters
// 2. negative number: delete a string with the given length at the current position
// 3. string: insert the given string at the current position

TextOperation.fromOT = function(str, ops) {

  var atomicOps = []; // atomic ops

  // iterating through the sequence and bookkeeping the position
  // in the source and destination str
  var srcPos = 0,
      dstPos = 0;

  if (!_.isArray(ops)) {
    ops = _.toArray(arguments).slice(1);
  }

  _.each(ops, function(op) {
    if (_.isString(op)) { // insert chars
      atomicOps.push(TextOperation.Insert(dstPos, op));
      dstPos += op.length;
    } else if (op<0) { // delete n chars
      var n = -op;
      atomicOps.push(TextOperation.Delete(dstPos, str.slice(srcPos, srcPos+n)));
      srcPos += n;
    } else { // skip n chars
      srcPos += op;
      dstPos += op;
    }
  });

  if (atomicOps.length === 0) {
    return null;
  }

  return TextOperation.Compound(atomicOps);
};

TextOperation.fromSequence = TextOperation.fromOT;

// A helper class to model Text selections and to provide an easy way
// to bookkeep changes by other applied TextOperations
var Range = function(range) {
  if (_.isArray(range)) {
    this.start = range[0];
    this.length = range[1];
  } else {
    this.start = range.start;
    this.length = range.length;
  }
};

// Transforms a given range tuple (offset, length) in-place.
// --------
//

var range_transform = function(range, textOp, expandLeft, expandRight) {

  var changed = false;

  // handle compound operations
  if (textOp.type === Compound.TYPE) {
    for (var idx = 0; idx < textOp.ops.length; idx++) {
      var op = textOp.ops[idx];
      range_transform(range, op);
    }
    return;
  }


  var start, end;

  if (_.isArray(range)) {
    start = range[0];
    end = range[1];
  } else {
    start = range.start;
    end = start + range.length;
  }

  // Delete
  if (textOp.type === DEL) {
    var pos1 = textOp.pos;
    var pos2 = textOp.pos+textOp.str.length;

    if (pos1 <= start) {
      start -= Math.min(pos2-pos1, start-pos1);
      changed = true;
    }
    if (pos1 <= end) {
      end -= Math.min(pos2-pos1, end-pos1);
      changed = true;
    }

  } else if (textOp.type === INS) {
    var pos = textOp.pos;
    var l = textOp.str.length;

    if ( (pos < start) ||
         (pos === start && !expandLeft) ) {
      start += l;
      changed = true;
    }

    if ( (pos < end) ||
         (pos === end && expandRight) ) {
      end += l;
      changed = true;
    }
  }

  if (changed) {
    if (_.isArray(range)) {
      range[0] = start;
      range[1] = end;
    } else {
      range.start = start;
      range.length = end - start;
    }
  }

  return changed;
};

Range.Prototype = function() {

  this.clone = function() {
    return new Range(this);
  };

  this.toJSON = function() {
    var result = {
      start: this.start,
      length: this.length
    };
    // if (this.expand) result.expand = true;
    return result;
  };

  this.transform = function(textOp, expand) {
    return range_transform(this.range, textOp, expand);
  };

};
Range.prototype = new Range.Prototype();

Range.transform = function(range, op, expandLeft, expandRight) {
  return range_transform(range, op, expandLeft, expandRight);
};

Range.fromJSON = function(data) {
  return new Range(data);
};

TextOperation.StringAdapter = StringAdapter;
TextOperation.Range = Range;
TextOperation.INSERT = INS;
TextOperation.DELETE = DEL;

// Export
// ========

module.exports = TextOperation;

},{"./compound":142,"./operation":144,"substance-util":133,"underscore":140}],147:[function(require,module,exports){
window.wik = require('./index.js')

},{"./index.js":1}],148:[function(require,module,exports){

},{}],149:[function(require,module,exports){
// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

// when used in node, this will actually load the util module we depend on
// versus loading the builtin util module as happens otherwise
// this is a bug in node module loading as far as I am concerned
var util = require('util/');

var pSlice = Array.prototype.slice;
var hasOwn = Object.prototype.hasOwnProperty;

// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  }
  else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = stackStartFunction.name;
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function replacer(key, value) {
  if (util.isUndefined(value)) {
    return '' + value;
  }
  if (util.isNumber(value) && (isNaN(value) || !isFinite(value))) {
    return value.toString();
  }
  if (util.isFunction(value) || util.isRegExp(value)) {
    return value.toString();
  }
  return value;
}

function truncate(s, n) {
  if (util.isString(s)) {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

function getMessage(self) {
  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +
         self.operator + ' ' +
         truncate(JSON.stringify(self.expected, replacer), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

function _deepEqual(actual, expected) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
    if (actual.length != expected.length) return false;

    for (var i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) return false;
    }

    return true;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!util.isObject(actual) && !util.isObject(expected)) {
    return actual == expected;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  try {
    var ka = objectKeys(a),
        kb = objectKeys(b),
        key, i;
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (util.isString(expected)) {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/message) {
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

assert.ifError = function(err) { if (err) {throw err;}};

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

},{"util/":173}],150:[function(require,module,exports){
module.exports=require(148)
},{}],151:[function(require,module,exports){
var Buffer = require('buffer').Buffer;
var intSize = 4;
var zeroBuffer = new Buffer(intSize); zeroBuffer.fill(0);
var chrsz = 8;

function toArray(buf, bigEndian) {
  if ((buf.length % intSize) !== 0) {
    var len = buf.length + (intSize - (buf.length % intSize));
    buf = Buffer.concat([buf, zeroBuffer], len);
  }

  var arr = [];
  var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;
  for (var i = 0; i < buf.length; i += intSize) {
    arr.push(fn.call(buf, i));
  }
  return arr;
}

function toBuffer(arr, size, bigEndian) {
  var buf = new Buffer(size);
  var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;
  for (var i = 0; i < arr.length; i++) {
    fn.call(buf, arr[i], i * 4, true);
  }
  return buf;
}

function hash(buf, fn, hashSize, bigEndian) {
  if (!Buffer.isBuffer(buf)) buf = new Buffer(buf);
  var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);
  return toBuffer(arr, hashSize, bigEndian);
}

module.exports = { hash: hash };

},{"buffer":161}],152:[function(require,module,exports){
var Buffer = require('buffer').Buffer
var sha = require('./sha')
var sha256 = require('./sha256')
var rng = require('./rng')
var md5 = require('./md5')

var algorithms = {
  sha1: sha,
  sha256: sha256,
  md5: md5
}

var blocksize = 64
var zeroBuffer = new Buffer(blocksize); zeroBuffer.fill(0)
function hmac(fn, key, data) {
  if(!Buffer.isBuffer(key)) key = new Buffer(key)
  if(!Buffer.isBuffer(data)) data = new Buffer(data)

  if(key.length > blocksize) {
    key = fn(key)
  } else if(key.length < blocksize) {
    key = Buffer.concat([key, zeroBuffer], blocksize)
  }

  var ipad = new Buffer(blocksize), opad = new Buffer(blocksize)
  for(var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }

  var hash = fn(Buffer.concat([ipad, data]))
  return fn(Buffer.concat([opad, hash]))
}

function hash(alg, key) {
  alg = alg || 'sha1'
  var fn = algorithms[alg]
  var bufs = []
  var length = 0
  if(!fn) error('algorithm:', alg, 'is not yet supported')
  return {
    update: function (data) {
      if(!Buffer.isBuffer(data)) data = new Buffer(data)
        
      bufs.push(data)
      length += data.length
      return this
    },
    digest: function (enc) {
      var buf = Buffer.concat(bufs)
      var r = key ? hmac(fn, key, buf) : fn(buf)
      bufs = null
      return enc ? r.toString(enc) : r
    }
  }
}

function error () {
  var m = [].slice.call(arguments).join(' ')
  throw new Error([
    m,
    'we accept pull requests',
    'http://github.com/dominictarr/crypto-browserify'
    ].join('\n'))
}

exports.createHash = function (alg) { return hash(alg) }
exports.createHmac = function (alg, key) { return hash(alg, key) }
exports.randomBytes = function(size, callback) {
  if (callback && callback.call) {
    try {
      callback.call(this, undefined, new Buffer(rng(size)))
    } catch (err) { callback(err) }
  } else {
    return new Buffer(rng(size))
  }
}

function each(a, f) {
  for(var i in a)
    f(a[i], i)
}

// the least I can do is make error messages for the rest of the node.js/crypto api.
each(['createCredentials'
, 'createCipher'
, 'createCipheriv'
, 'createDecipher'
, 'createDecipheriv'
, 'createSign'
, 'createVerify'
, 'createDiffieHellman'
, 'pbkdf2'], function (name) {
  exports[name] = function () {
    error('sorry,', name, 'is not implemented yet')
  }
})

},{"./md5":153,"./rng":154,"./sha":155,"./sha256":156,"buffer":161}],153:[function(require,module,exports){
/*
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

var helpers = require('./helpers');

/*
 * Perform a simple self-test to see if the VM is working
 */
function md5_vm_test()
{
  return hex_md5("abc") == "900150983cd24fb0d6963f7d28e17f72";
}

/*
 * Calculate the MD5 of an array of little-endian words, and a bit length
 */
function core_md5(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << ((len) % 32);
  x[(((len + 64) >>> 9) << 4) + 14] = len;

  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;

    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
  }
  return Array(a, b, c, d);

}

/*
 * These functions implement the four basic operations the algorithm uses.
 */
function md5_cmn(q, a, b, x, s, t)
{
  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
}
function md5_ff(a, b, c, d, x, s, t)
{
  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
}
function md5_gg(a, b, c, d, x, s, t)
{
  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
}
function md5_hh(a, b, c, d, x, s, t)
{
  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5_ii(a, b, c, d, x, s, t)
{
  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function bit_rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

module.exports = function md5(buf) {
  return helpers.hash(buf, core_md5, 16);
};

},{"./helpers":151}],154:[function(require,module,exports){
// Original code adapted from Robert Kieffer.
// details at https://github.com/broofa/node-uuid
(function() {
  var _global = this;

  var mathRNG, whatwgRNG;

  // NOTE: Math.random() does not guarantee "cryptographic quality"
  mathRNG = function(size) {
    var bytes = new Array(size);
    var r;

    for (var i = 0, r; i < size; i++) {
      if ((i & 0x03) == 0) r = Math.random() * 0x100000000;
      bytes[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return bytes;
  }

  if (_global.crypto && crypto.getRandomValues) {
    whatwgRNG = function(size) {
      var bytes = new Uint8Array(size);
      crypto.getRandomValues(bytes);
      return bytes;
    }
  }

  module.exports = whatwgRNG || mathRNG;

}())

},{}],155:[function(require,module,exports){
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var helpers = require('./helpers');

/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */
function core_sha1(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << (24 - len % 32);
  x[((len + 64 >> 9) << 4) + 15] = len;

  var w = Array(80);
  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;
  var e = -1009589776;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    var olde = e;

    for(var j = 0; j < 80; j++)
    {
      if(j < 16) w[j] = x[i + j];
      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                       safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = rol(b, 30);
      b = a;
      a = t;
    }

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }
  return Array(a, b, c, d, e);

}

/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */
function sha1_ft(t, b, c, d)
{
  if(t < 20) return (b & c) | ((~b) & d);
  if(t < 40) return b ^ c ^ d;
  if(t < 60) return (b & c) | (b & d) | (c & d);
  return b ^ c ^ d;
}

/*
 * Determine the appropriate additive constant for the current iteration
 */
function sha1_kt(t)
{
  return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
         (t < 60) ? -1894007588 : -899497514;
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

module.exports = function sha1(buf) {
  return helpers.hash(buf, core_sha1, 20, true);
};

},{"./helpers":151}],156:[function(require,module,exports){

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var helpers = require('./helpers');

var safe_add = function(x, y) {
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
};

var S = function(X, n) {
  return (X >>> n) | (X << (32 - n));
};

var R = function(X, n) {
  return (X >>> n);
};

var Ch = function(x, y, z) {
  return ((x & y) ^ ((~x) & z));
};

var Maj = function(x, y, z) {
  return ((x & y) ^ (x & z) ^ (y & z));
};

var Sigma0256 = function(x) {
  return (S(x, 2) ^ S(x, 13) ^ S(x, 22));
};

var Sigma1256 = function(x) {
  return (S(x, 6) ^ S(x, 11) ^ S(x, 25));
};

var Gamma0256 = function(x) {
  return (S(x, 7) ^ S(x, 18) ^ R(x, 3));
};

var Gamma1256 = function(x) {
  return (S(x, 17) ^ S(x, 19) ^ R(x, 10));
};

var core_sha256 = function(m, l) {
  var K = new Array(0x428A2F98,0x71374491,0xB5C0FBCF,0xE9B5DBA5,0x3956C25B,0x59F111F1,0x923F82A4,0xAB1C5ED5,0xD807AA98,0x12835B01,0x243185BE,0x550C7DC3,0x72BE5D74,0x80DEB1FE,0x9BDC06A7,0xC19BF174,0xE49B69C1,0xEFBE4786,0xFC19DC6,0x240CA1CC,0x2DE92C6F,0x4A7484AA,0x5CB0A9DC,0x76F988DA,0x983E5152,0xA831C66D,0xB00327C8,0xBF597FC7,0xC6E00BF3,0xD5A79147,0x6CA6351,0x14292967,0x27B70A85,0x2E1B2138,0x4D2C6DFC,0x53380D13,0x650A7354,0x766A0ABB,0x81C2C92E,0x92722C85,0xA2BFE8A1,0xA81A664B,0xC24B8B70,0xC76C51A3,0xD192E819,0xD6990624,0xF40E3585,0x106AA070,0x19A4C116,0x1E376C08,0x2748774C,0x34B0BCB5,0x391C0CB3,0x4ED8AA4A,0x5B9CCA4F,0x682E6FF3,0x748F82EE,0x78A5636F,0x84C87814,0x8CC70208,0x90BEFFFA,0xA4506CEB,0xBEF9A3F7,0xC67178F2);
  var HASH = new Array(0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A, 0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19);
    var W = new Array(64);
    var a, b, c, d, e, f, g, h, i, j;
    var T1, T2;
  /* append padding */
  m[l >> 5] |= 0x80 << (24 - l % 32);
  m[((l + 64 >> 9) << 4) + 15] = l;
  for (var i = 0; i < m.length; i += 16) {
    a = HASH[0]; b = HASH[1]; c = HASH[2]; d = HASH[3]; e = HASH[4]; f = HASH[5]; g = HASH[6]; h = HASH[7];
    for (var j = 0; j < 64; j++) {
      if (j < 16) {
        W[j] = m[j + i];
      } else {
        W[j] = safe_add(safe_add(safe_add(Gamma1256(W[j - 2]), W[j - 7]), Gamma0256(W[j - 15])), W[j - 16]);
      }
      T1 = safe_add(safe_add(safe_add(safe_add(h, Sigma1256(e)), Ch(e, f, g)), K[j]), W[j]);
      T2 = safe_add(Sigma0256(a), Maj(a, b, c));
      h = g; g = f; f = e; e = safe_add(d, T1); d = c; c = b; b = a; a = safe_add(T1, T2);
    }
    HASH[0] = safe_add(a, HASH[0]); HASH[1] = safe_add(b, HASH[1]); HASH[2] = safe_add(c, HASH[2]); HASH[3] = safe_add(d, HASH[3]);
    HASH[4] = safe_add(e, HASH[4]); HASH[5] = safe_add(f, HASH[5]); HASH[6] = safe_add(g, HASH[6]); HASH[7] = safe_add(h, HASH[7]);
  }
  return HASH;
};

module.exports = function sha256(buf) {
  return helpers.hash(buf, core_sha256, 32, true);
};

},{"./helpers":151}],157:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        throw TypeError('Uncaught, unspecified "error" event.');
      }
      return false;
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      console.trace();
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],158:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],159:[function(require,module,exports){
require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"PcZj9L":[function(require,module,exports){
var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192

/**
 * If `browserSupport`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (compatible down to IE6)
 */
var browserSupport = (function () {
   // Detect if browser supports Typed Arrays. Supported browsers are IE 10+,
   // Firefox 4+, Chrome 7+, Safari 5.1+, Opera 11.6+, iOS 4.2+.
   if (typeof Uint8Array === 'undefined' || typeof ArrayBuffer === 'undefined' ||
        typeof DataView === 'undefined')
      return false

  // Does the browser support adding properties to `Uint8Array` instances? If
  // not, then that's the same as no `Uint8Array` support. We need to be able to
  // add all the node Buffer API methods.
  // Relevant Firefox bug: https://bugzilla.mozilla.org/show_bug.cgi?id=695438
  try {
    var arr = new Uint8Array(0)
    arr.foo = function () { return 42 }
    return 42 === arr.foo()
  } catch (e) {
    return false
  }
})()


/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Workaround: node's base64 implementation allows for non-padded strings
  // while base64-js does not.
  if (encoding === 'base64' && type === 'string') {
    subject = stringtrim(subject)
    while (subject.length % 4 !== 0) {
      subject = subject + '='
    }
  }

  // Find the length
  var length
  if (type === 'number')
    length = coerce(subject)
  else if (type === 'string')
    length = Buffer.byteLength(subject, encoding)
  else if (type === 'object')
    length = coerce(subject.length) // Assume object is an array
  else
    throw new Error('First argument needs to be a number, array or string.')

  var buf
  if (browserSupport) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    buf = augment(new Uint8Array(length))
  } else {
    // Fallback: Return this instance of Buffer
    buf = this
    buf.length = length
  }

  var i
  if (Buffer.isBuffer(subject)) {
    // Speed optimization -- use set if we're copying from a Uint8Array
    buf.set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    for (i = 0; i < length; i++) {
      if (Buffer.isBuffer(subject))
        buf[i] = subject.readUInt8(i)
      else
        buf[i] = subject[i]
    }
  } else if (type === 'string') {
    buf.write(subject, 0, encoding)
  } else if (type === 'number' && !browserSupport && !noZero) {
    for (i = 0; i < length; i++) {
      buf[i] = 0
    }
  }

  return buf
}

// STATIC METHODS
// ==============

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
      return true

    default:
      return false
  }
}

Buffer.isBuffer = function (b) {
  return b && b._isBuffer
}

Buffer.byteLength = function (str, encoding) {
  switch (encoding || 'utf8') {
    case 'hex':
      return str.length / 2

    case 'utf8':
    case 'utf-8':
      return utf8ToBytes(str).length

    case 'ascii':
    case 'binary':
      return str.length

    case 'base64':
      return base64ToBytes(str).length

    default:
      throw new Error('Unknown encoding')
  }
}

Buffer.concat = function (list, totalLength) {
  if (!isArray(list)) {
    throw new Error('Usage: Buffer.concat(list, [totalLength])\n' +
        'list should be an Array.')
  }

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (typeof totalLength !== 'number') {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

// BUFFER INSTANCE METHODS
// =======================

function _hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) {
    throw new Error('Invalid hex string')
  }
  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(byte)) throw new Error('Invalid hex string')
    buf[offset + i] = byte
  }
  Buffer._charsWritten = i * 2
  return i
}

function _utf8Write (buf, string, offset, length) {
  var bytes, pos
  return Buffer._charsWritten = blitBuffer(utf8ToBytes(string), buf, offset, length)
}

function _asciiWrite (buf, string, offset, length) {
  var bytes, pos
  return Buffer._charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length)
}

function _binaryWrite (buf, string, offset, length) {
  return _asciiWrite(buf, string, offset, length)
}

function _base64Write (buf, string, offset, length) {
  var bytes, pos
  return Buffer._charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length)
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0
  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  switch (encoding) {
    case 'hex':
      return _hexWrite(this, string, offset, length)

    case 'utf8':
    case 'utf-8':
      return _utf8Write(this, string, offset, length)

    case 'ascii':
      return _asciiWrite(this, string, offset, length)

    case 'binary':
      return _binaryWrite(this, string, offset, length)

    case 'base64':
      return _base64Write(this, string, offset, length)

    default:
      throw new Error('Unknown encoding')
  }
}

Buffer.prototype.toString = function (encoding, start, end) {
  var self = this

  encoding = String(encoding || 'utf8').toLowerCase()
  start = Number(start) || 0
  end = (end !== undefined)
    ? Number(end)
    : end = self.length

  // Fastpath empty strings
  if (end === start)
    return ''

  switch (encoding) {
    case 'hex':
      return _hexSlice(self, start, end)

    case 'utf8':
    case 'utf-8':
      return _utf8Slice(self, start, end)

    case 'ascii':
      return _asciiSlice(self, start, end)

    case 'binary':
      return _binarySlice(self, start, end)

    case 'base64':
      return _base64Slice(self, start, end)

    default:
      throw new Error('Unknown encoding')
  }
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var source = this

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (!target_start) target_start = 0

  // Copy 0 bytes; we're done
  if (end === start) return
  if (target.length === 0 || source.length === 0) return

  // Fatal error conditions
  if (end < start)
    throw new Error('sourceEnd < sourceStart')
  if (target_start < 0 || target_start >= target.length)
    throw new Error('targetStart out of bounds')
  if (start < 0 || start >= source.length)
    throw new Error('sourceStart out of bounds')
  if (end < 0 || end > source.length)
    throw new Error('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  // copy!
  for (var i = 0; i < end - start; i++)
    target[i + target_start] = this[i + start]
}

function _base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function _utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function _asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++)
    ret += String.fromCharCode(buf[i])
  return ret
}

function _binarySlice (buf, start, end) {
  return _asciiSlice(buf, start, end)
}

function _hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

// TODO: add test that modifying the new buffer slice will modify memory in the
// original buffer! Use code from:
// http://nodejs.org/api/buffer.html#buffer_buf_slice_start_end
Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = clamp(start, len, 0)
  end = clamp(end, len, len)

  if (browserSupport) {
    return augment(this.subarray(start, end))
  } else {
    // TODO: slicing works, with limitations (no parent tracking/update)
    // https://github.com/feross/native-buffer-browserify/issues/9
    var sliceLen = end - start
    var newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
    return newBuf
  }
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  var buf = this
  if (!noAssert) {
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < buf.length, 'Trying to read beyond buffer length')
  }

  if (offset >= buf.length)
    return

  return buf[offset]
}

function _readUInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  if (browserSupport) {
    if (offset + 1 < len) {
      return buf._dataview.getUint16(offset, littleEndian)
    } else {
      var dv = new DataView(new ArrayBuffer(2))
      dv.setUint8(0, buf[len - 1])
      return dv.getUint16(0, littleEndian)
    }
  } else {
    var val
    if (littleEndian) {
      val = buf[offset]
      if (offset + 1 < len)
        val |= buf[offset + 1] << 8
    } else {
      val = buf[offset] << 8
      if (offset + 1 < len)
        val |= buf[offset + 1]
    }
    return val
  }
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  return _readUInt16(this, offset, true, noAssert)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  return _readUInt16(this, offset, false, noAssert)
}

function _readUInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  if (browserSupport) {
    if (offset + 3 < len) {
      return buf._dataview.getUint32(offset, littleEndian)
    } else {
      var dv = new DataView(new ArrayBuffer(4))
      for (var i = 0; i + offset < len; i++) {
        dv.setUint8(i, buf[i + offset])
      }
      return dv.getUint32(0, littleEndian)
    }
  } else {
    var val
    if (littleEndian) {
      if (offset + 2 < len)
        val = buf[offset + 2] << 16
      if (offset + 1 < len)
        val |= buf[offset + 1] << 8
      val |= buf[offset]
      if (offset + 3 < len)
        val = val + (buf[offset + 3] << 24 >>> 0)
    } else {
      if (offset + 1 < len)
        val = buf[offset + 1] << 16
      if (offset + 2 < len)
        val |= buf[offset + 2] << 8
      if (offset + 3 < len)
        val |= buf[offset + 3]
      val = val + (buf[offset] << 24 >>> 0)
    }
    return val
  }
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  return _readUInt32(this, offset, true, noAssert)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  return _readUInt32(this, offset, false, noAssert)
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  var buf = this
  if (!noAssert) {
    assert(offset !== undefined && offset !== null,
        'missing offset')
    assert(offset < buf.length, 'Trying to read beyond buffer length')
  }

  if (offset >= buf.length)
    return

  if (browserSupport) {
    return buf._dataview.getInt8(offset)
  } else {
    var neg = buf[offset] & 0x80
    if (neg)
      return (0xff - buf[offset] + 1) * -1
    else
      return buf[offset]
  }
}

function _readInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  if (browserSupport) {
    if (offset + 1 === len) {
      var dv = new DataView(new ArrayBuffer(2))
      dv.setUint8(0, buf[len - 1])
      return dv.getInt16(0, littleEndian)
    } else {
      return buf._dataview.getInt16(offset, littleEndian)
    }
  } else {
    var val = _readUInt16(buf, offset, littleEndian, true)
    var neg = val & 0x8000
    if (neg)
      return (0xffff - val + 1) * -1
    else
      return val
  }
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  return _readInt16(this, offset, true, noAssert)
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  return _readInt16(this, offset, false, noAssert)
}

function _readInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  if (browserSupport) {
    if (offset + 3 >= len) {
      var dv = new DataView(new ArrayBuffer(4))
      for (var i = 0; i + offset < len; i++) {
        dv.setUint8(i, buf[i + offset])
      }
      return dv.getInt32(0, littleEndian)
    } else {
      return buf._dataview.getInt32(offset, littleEndian)
    }
  } else {
    var val = _readUInt32(buf, offset, littleEndian, true)
    var neg = val & 0x80000000
    if (neg)
      return (0xffffffff - val + 1) * -1
    else
      return val
  }
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  return _readInt32(this, offset, true, noAssert)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  return _readInt32(this, offset, false, noAssert)
}

function _readFloat (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  if (browserSupport) {
    return buf._dataview.getFloat32(offset, littleEndian)
  } else {
    return ieee754.read(buf, offset, littleEndian, 23, 4)
  }
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  return _readFloat(this, offset, true, noAssert)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  return _readFloat(this, offset, false, noAssert)
}

function _readDouble (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 7 < buf.length, 'Trying to read beyond buffer length')
  }

  if (browserSupport) {
    return buf._dataview.getFloat64(offset, littleEndian)
  } else {
    return ieee754.read(buf, offset, littleEndian, 52, 8)
  }
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  return _readDouble(this, offset, true, noAssert)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  return _readDouble(this, offset, false, noAssert)
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  var buf = this
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xff)
  }

  if (offset >= buf.length) return

  buf[offset] = value
}

function _writeUInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (browserSupport) {
    if (offset + 1 === len) {
      var dv = new DataView(new ArrayBuffer(2))
      dv.setUint16(0, value, littleEndian)
      buf[offset] = dv.getUint8(0)
    } else {
      buf._dataview.setUint16(offset, value, littleEndian)
    }
  } else {
    for (var i = 0, j = Math.min(len - offset, 2); i < j; i++) {
      buf[offset + i] =
          (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
              (littleEndian ? i : 1 - i) * 8
    }
  }
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  _writeUInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  _writeUInt16(this, value, offset, false, noAssert)
}

function _writeUInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffffffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  var i
  if (browserSupport) {
    if (offset + 3 >= len) {
      var dv = new DataView(new ArrayBuffer(4))
      dv.setUint32(0, value, littleEndian)
      for (i = 0; i + offset < len; i++) {
        buf[i + offset] = dv.getUint8(i)
      }
    } else {
      buf._dataview.setUint32(offset, value, littleEndian)
    }
  } else {
    for (i = 0, j = Math.min(len - offset, 4); i < j; i++) {
      buf[offset + i] =
          (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
    }
  }
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  _writeUInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  _writeUInt32(this, value, offset, false, noAssert)
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  var buf = this
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7f, -0x80)
  }

  if (offset >= buf.length)
    return

  if (browserSupport) {
    buf._dataview.setInt8(offset, value)
  } else {
    if (value >= 0)
      buf.writeUInt8(value, offset, noAssert)
    else
      buf.writeUInt8(0xff + value + 1, offset, noAssert)
  }
}

function _writeInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fff, -0x8000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (browserSupport) {
    if (offset + 1 === len) {
      var dv = new DataView(new ArrayBuffer(2))
      dv.setInt16(0, value, littleEndian)
      buf[offset] = dv.getUint8(0)
    } else {
      buf._dataview.setInt16(offset, value, littleEndian)
    }
  } else {
    if (value >= 0)
      _writeUInt16(buf, value, offset, littleEndian, noAssert)
    else
      _writeUInt16(buf, 0xffff + value + 1, offset, littleEndian, noAssert)
  }
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  _writeInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  _writeInt16(this, value, offset, false, noAssert)
}

function _writeInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fffffff, -0x80000000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (browserSupport) {
    if (offset + 3 >= len) {
      var dv = new DataView(new ArrayBuffer(4))
      dv.setInt32(0, value, littleEndian)
      for (var i = 0; i + offset < len; i++) {
        buf[i + offset] = dv.getUint8(i)
      }
    } else {
      buf._dataview.setInt32(offset, value, littleEndian)
    }
  } else {
    if (value >= 0)
      _writeUInt32(buf, value, offset, littleEndian, noAssert)
    else
      _writeUInt32(buf, 0xffffffff + value + 1, offset, littleEndian, noAssert)
  }
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  _writeInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  _writeInt32(this, value, offset, false, noAssert)
}

function _writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (browserSupport) {
    if (offset + 3 >= len) {
      var dv = new DataView(new ArrayBuffer(4))
      dv.setFloat32(0, value, littleEndian)
      for (var i = 0; i + offset < len; i++) {
        buf[i + offset] = dv.getUint8(i)
      }
    } else {
      buf._dataview.setFloat32(offset, value, littleEndian)
    }
  } else {
    ieee754.write(buf, value, offset, littleEndian, 23, 4)
  }
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  _writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  _writeFloat(this, value, offset, false, noAssert)
}

function _writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 7 < buf.length,
        'Trying to write beyond buffer length')
    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (browserSupport) {
    if (offset + 7 >= len) {
      var dv = new DataView(new ArrayBuffer(8))
      dv.setFloat64(0, value, littleEndian)
      for (var i = 0; i + offset < len; i++) {
        buf[i + offset] = dv.getUint8(i)
      }
    } else {
      buf._dataview.setFloat64(offset, value, littleEndian)
    }
  } else {
    ieee754.write(buf, value, offset, littleEndian, 52, 8)
  }
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  _writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  _writeDouble(this, value, offset, false, noAssert)
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (typeof value === 'string') {
    value = value.charCodeAt(0)
  }

  if (typeof value !== 'number' || isNaN(value)) {
    throw new Error('value is not a number')
  }

  if (end < start) throw new Error('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) {
    throw new Error('start out of bounds')
  }

  if (end < 0 || end > this.length) {
    throw new Error('end out of bounds')
  }

  for (var i = start; i < end; i++) {
    this[i] = value
  }
}

Buffer.prototype.inspect = function () {
  var out = []
  var len = this.length
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i])
    if (i === exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...'
      break
    }
  }
  return '<Buffer ' + out.join(' ') + '>'
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Not added to Buffer.prototype since it should only
 * be available in browsers that support ArrayBuffer.
 */
function BufferToArrayBuffer () {
  return (new Buffer(this)).buffer
}

// HELPER FUNCTIONS
// ================

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

var BP = Buffer.prototype

function augment (arr) {
  arr._isBuffer = true

  // Augment the Uint8Array *instance* (not the class!) with Buffer methods
  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BufferToArrayBuffer

  if (arr.byteLength !== 0)
    arr._dataview = new DataView(arr.buffer, arr.byteOffset, arr.byteLength)

  return arr
}

// slice(start, end)
function clamp (index, len, defaultValue) {
  if (typeof index !== 'number') return defaultValue
  index = ~~index;  // Coerce to integer.
  if (index >= len) return len
  if (index >= 0) return index
  index += len
  if (index >= 0) return index
  return 0
}

function coerce (length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length)
  return length < 0 ? 0 : length
}

function isArray (subject) {
  return (Array.isArray || function (subject) {
    return Object.prototype.toString.call(subject) === '[object Array]'
  })(subject)
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++)
    if (str.charCodeAt(i) <= 0x7F)
      byteArray.push(str.charCodeAt(i))
    else {
      var h = encodeURIComponent(str.charAt(i)).substr(1).split('%')
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16))
    }
  return byteArray
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(str)
}

function blitBuffer (src, dst, offset, length) {
  var pos
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

/*
 * We have to make sure that the value is a valid integer. This means that it
 * is non-negative. It has no fractional component and that it does not
 * exceed the maximum allowed value.
 */
function verifuint (value, max) {
  assert(typeof value == 'number', 'cannot write a non-number as a number')
  assert(value >= 0,
      'specified a negative value for writing an unsigned value')
  assert(value <= max, 'value is larger than maximum value for type')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifsint(value, max, min) {
  assert(typeof value == 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifIEEE754(value, max, min) {
  assert(typeof value == 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
}

function assert (test, message) {
  if (!test) throw new Error(message || 'Failed assertion')
}

},{"base64-js":3,"ieee754":4}],"native-buffer-browserify":[function(require,module,exports){
module.exports=require('PcZj9L');
},{}],3:[function(require,module,exports){
(function (exports) {
	'use strict';

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	function b64ToByteArray(b64) {
		var i, j, l, tmp, placeHolders, arr;
	
		if (b64.length % 4 > 0) {
			throw 'Invalid string. Length must be a multiple of 4';
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		placeHolders = indexOf(b64, '=');
		placeHolders = placeHolders > 0 ? b64.length - placeHolders : 0;

		// base64 is 4/3 + up to two characters of the original data
		arr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length;

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (indexOf(lookup, b64.charAt(i)) << 18) | (indexOf(lookup, b64.charAt(i + 1)) << 12) | (indexOf(lookup, b64.charAt(i + 2)) << 6) | indexOf(lookup, b64.charAt(i + 3));
			arr.push((tmp & 0xFF0000) >> 16);
			arr.push((tmp & 0xFF00) >> 8);
			arr.push(tmp & 0xFF);
		}

		if (placeHolders === 2) {
			tmp = (indexOf(lookup, b64.charAt(i)) << 2) | (indexOf(lookup, b64.charAt(i + 1)) >> 4);
			arr.push(tmp & 0xFF);
		} else if (placeHolders === 1) {
			tmp = (indexOf(lookup, b64.charAt(i)) << 10) | (indexOf(lookup, b64.charAt(i + 1)) << 4) | (indexOf(lookup, b64.charAt(i + 2)) >> 2);
			arr.push((tmp >> 8) & 0xFF);
			arr.push(tmp & 0xFF);
		}

		return arr;
	}

	function uint8ToBase64(uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length;

		function tripletToBase64 (num) {
			return lookup.charAt(num >> 18 & 0x3F) + lookup.charAt(num >> 12 & 0x3F) + lookup.charAt(num >> 6 & 0x3F) + lookup.charAt(num & 0x3F);
		};

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
			output += tripletToBase64(temp);
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1];
				output += lookup.charAt(temp >> 2);
				output += lookup.charAt((temp << 4) & 0x3F);
				output += '==';
				break;
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);
				output += lookup.charAt(temp >> 10);
				output += lookup.charAt((temp >> 4) & 0x3F);
				output += lookup.charAt((temp << 2) & 0x3F);
				output += '=';
				break;
		}

		return output;
	}

	module.exports.toByteArray = b64ToByteArray;
	module.exports.fromByteArray = uint8ToBase64;
}());

function indexOf (arr, elt /*, from*/) {
	var len = arr.length;

	var from = Number(arguments[1]) || 0;
	from = (from < 0)
		? Math.ceil(from)
		: Math.floor(from);
	if (from < 0)
		from += len;

	for (; from < len; from++) {
		if ((typeof arr === 'string' && arr.charAt(from) === elt) ||
				(typeof arr !== 'string' && arr[from] === elt)) {
			return from;
		}
	}
	return -1;
}

},{}],4:[function(require,module,exports){
exports.read = function(buffer, offset, isLE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isLE ? (nBytes - 1) : 0,
      d = isLE ? -1 : 1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isLE ? 0 : (nBytes - 1),
      d = isLE ? 1 : -1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}]},{},[])
;;module.exports=require("native-buffer-browserify").Buffer

},{}],160:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],161:[function(require,module,exports){
var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192

/**
 * If `Buffer._useTypedArrays`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (compatible down to IE6)
 */
Buffer._useTypedArrays = (function () {
   // Detect if browser supports Typed Arrays. Supported browsers are IE 10+,
   // Firefox 4+, Chrome 7+, Safari 5.1+, Opera 11.6+, iOS 4.2+.
   if (typeof Uint8Array === 'undefined' || typeof ArrayBuffer === 'undefined')
      return false

  // Does the browser support adding properties to `Uint8Array` instances? If
  // not, then that's the same as no `Uint8Array` support. We need to be able to
  // add all the node Buffer API methods.
  // Relevant Firefox bug: https://bugzilla.mozilla.org/show_bug.cgi?id=695438
  try {
    var arr = new Uint8Array(0)
    arr.foo = function () { return 42 }
    return 42 === arr.foo() &&
        typeof arr.subarray === 'function' // Chrome 9-10 lack `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Workaround: node's base64 implementation allows for non-padded strings
  // while base64-js does not.
  if (encoding === 'base64' && type === 'string') {
    subject = stringtrim(subject)
    while (subject.length % 4 !== 0) {
      subject = subject + '='
    }
  }

  // Find the length
  var length
  if (type === 'number')
    length = coerce(subject)
  else if (type === 'string')
    length = Buffer.byteLength(subject, encoding)
  else if (type === 'object')
    length = coerce(subject.length) // Assume object is an array
  else
    throw new Error('First argument needs to be a number, array or string.')

  var buf
  if (Buffer._useTypedArrays) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    buf = augment(new Uint8Array(length))
  } else {
    // Fallback: Return this instance of Buffer
    buf = this
    buf.length = length
    buf._isBuffer = true
  }

  var i
  if (typeof Uint8Array === 'function' && subject instanceof Uint8Array) {
    // Speed optimization -- use set if we're copying from a Uint8Array
    buf.set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    for (i = 0; i < length; i++) {
      if (Buffer.isBuffer(subject))
        buf[i] = subject.readUInt8(i)
      else
        buf[i] = subject[i]
    }
  } else if (type === 'string') {
    buf.write(subject, 0, encoding)
  } else if (type === 'number' && !Buffer._useTypedArrays && !noZero) {
    for (i = 0; i < length; i++) {
      buf[i] = 0
    }
  }

  return buf
}

// STATIC METHODS
// ==============

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
      return true
    default:
      return false
  }
}

Buffer.isBuffer = function (b) {
  return (b != null && b._isBuffer) || false
}

Buffer.byteLength = function (str, encoding) {
  switch (encoding || 'utf8') {
    case 'hex':
      return str.length / 2
    case 'utf8':
    case 'utf-8':
      return utf8ToBytes(str).length
    case 'ascii':
    case 'binary':
      return str.length
    case 'base64':
      return base64ToBytes(str).length
    default:
      throw new Error('Unknown encoding')
  }
}

Buffer.concat = function (list, totalLength) {
  assert(isArray(list), 'Usage: Buffer.concat(list, [totalLength])\n' +
      'list should be an Array.')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (typeof totalLength !== 'number') {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

// BUFFER INSTANCE METHODS
// =======================

function _hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  assert(strLen % 2 === 0, 'Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    assert(!isNaN(byte), 'Invalid hex string')
    buf[offset + i] = byte
  }
  Buffer._charsWritten = i * 2
  return i
}

function _utf8Write (buf, string, offset, length) {
  var bytes, pos
  return Buffer._charsWritten = blitBuffer(utf8ToBytes(string), buf, offset, length)
}

function _asciiWrite (buf, string, offset, length) {
  var bytes, pos
  return Buffer._charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length)
}

function _binaryWrite (buf, string, offset, length) {
  return _asciiWrite(buf, string, offset, length)
}

function _base64Write (buf, string, offset, length) {
  var bytes, pos
  return Buffer._charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length)
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0
  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  switch (encoding) {
    case 'hex':
      return _hexWrite(this, string, offset, length)
    case 'utf8':
    case 'utf-8':
      return _utf8Write(this, string, offset, length)
    case 'ascii':
      return _asciiWrite(this, string, offset, length)
    case 'binary':
      return _binaryWrite(this, string, offset, length)
    case 'base64':
      return _base64Write(this, string, offset, length)
    default:
      throw new Error('Unknown encoding')
  }
}

Buffer.prototype.toString = function (encoding, start, end) {
  var self = this

  encoding = String(encoding || 'utf8').toLowerCase()
  start = Number(start) || 0
  end = (end !== undefined)
    ? Number(end)
    : end = self.length

  // Fastpath empty strings
  if (end === start)
    return ''

  switch (encoding) {
    case 'hex':
      return _hexSlice(self, start, end)
    case 'utf8':
    case 'utf-8':
      return _utf8Slice(self, start, end)
    case 'ascii':
      return _asciiSlice(self, start, end)
    case 'binary':
      return _binarySlice(self, start, end)
    case 'base64':
      return _base64Slice(self, start, end)
    default:
      throw new Error('Unknown encoding')
  }
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var source = this

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (!target_start) target_start = 0

  // Copy 0 bytes; we're done
  if (end === start) return
  if (target.length === 0 || source.length === 0) return

  // Fatal error conditions
  assert(end >= start, 'sourceEnd < sourceStart')
  assert(target_start >= 0 && target_start < target.length,
      'targetStart out of bounds')
  assert(start >= 0 && start < source.length, 'sourceStart out of bounds')
  assert(end >= 0 && end <= source.length, 'sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  // copy!
  for (var i = 0; i < end - start; i++)
    target[i + target_start] = this[i + start]
}

function _base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function _utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function _asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++)
    ret += String.fromCharCode(buf[i])
  return ret
}

function _binarySlice (buf, start, end) {
  return _asciiSlice(buf, start, end)
}

function _hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

// http://nodejs.org/api/buffer.html#buffer_buf_slice_start_end
Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = clamp(start, len, 0)
  end = clamp(end, len, len)

  if (Buffer._useTypedArrays) {
    return augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    var newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
    return newBuf
  }
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  var buf = this
  if (!noAssert) {
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < buf.length, 'Trying to read beyond buffer length')
  }

  if (offset >= buf.length)
    return

  return buf[offset]
}

function _readUInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    val = buf[offset]
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
  } else {
    val = buf[offset] << 8
    if (offset + 1 < len)
      val |= buf[offset + 1]
  }
  return val
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  return _readUInt16(this, offset, true, noAssert)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  return _readUInt16(this, offset, false, noAssert)
}

function _readUInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    if (offset + 2 < len)
      val = buf[offset + 2] << 16
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
    val |= buf[offset]
    if (offset + 3 < len)
      val = val + (buf[offset + 3] << 24 >>> 0)
  } else {
    if (offset + 1 < len)
      val = buf[offset + 1] << 16
    if (offset + 2 < len)
      val |= buf[offset + 2] << 8
    if (offset + 3 < len)
      val |= buf[offset + 3]
    val = val + (buf[offset] << 24 >>> 0)
  }
  return val
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  return _readUInt32(this, offset, true, noAssert)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  return _readUInt32(this, offset, false, noAssert)
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  var buf = this
  if (!noAssert) {
    assert(offset !== undefined && offset !== null,
        'missing offset')
    assert(offset < buf.length, 'Trying to read beyond buffer length')
  }

  if (offset >= buf.length)
    return

  var neg = buf[offset] & 0x80
  if (neg)
    return (0xff - buf[offset] + 1) * -1
  else
    return buf[offset]
}

function _readInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = _readUInt16(buf, offset, littleEndian, true)
  var neg = val & 0x8000
  if (neg)
    return (0xffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  return _readInt16(this, offset, true, noAssert)
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  return _readInt16(this, offset, false, noAssert)
}

function _readInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = _readUInt32(buf, offset, littleEndian, true)
  var neg = val & 0x80000000
  if (neg)
    return (0xffffffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  return _readInt32(this, offset, true, noAssert)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  return _readInt32(this, offset, false, noAssert)
}

function _readFloat (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 23, 4)
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  return _readFloat(this, offset, true, noAssert)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  return _readFloat(this, offset, false, noAssert)
}

function _readDouble (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 7 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 52, 8)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  return _readDouble(this, offset, true, noAssert)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  return _readDouble(this, offset, false, noAssert)
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  var buf = this
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xff)
  }

  if (offset >= buf.length) return

  buf[offset] = value
}

function _writeUInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 2); i < j; i++) {
    buf[offset + i] =
        (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
            (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  _writeUInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  _writeUInt16(this, value, offset, false, noAssert)
}

function _writeUInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffffffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 4); i < j; i++) {
    buf[offset + i] =
        (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  _writeUInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  _writeUInt32(this, value, offset, false, noAssert)
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  var buf = this
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7f, -0x80)
  }

  if (offset >= buf.length)
    return

  if (value >= 0)
    buf.writeUInt8(value, offset, noAssert)
  else
    buf.writeUInt8(0xff + value + 1, offset, noAssert)
}

function _writeInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fff, -0x8000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    _writeUInt16(buf, value, offset, littleEndian, noAssert)
  else
    _writeUInt16(buf, 0xffff + value + 1, offset, littleEndian, noAssert)
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  _writeInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  _writeInt16(this, value, offset, false, noAssert)
}

function _writeInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fffffff, -0x80000000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    _writeUInt32(buf, value, offset, littleEndian, noAssert)
  else
    _writeUInt32(buf, 0xffffffff + value + 1, offset, littleEndian, noAssert)
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  _writeInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  _writeInt32(this, value, offset, false, noAssert)
}

function _writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 23, 4)
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  _writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  _writeFloat(this, value, offset, false, noAssert)
}

function _writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 7 < buf.length,
        'Trying to write beyond buffer length')
    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 52, 8)
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  _writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  _writeDouble(this, value, offset, false, noAssert)
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (typeof value === 'string') {
    value = value.charCodeAt(0)
  }

  assert(typeof value === 'number' && !isNaN(value), 'value is not a number')
  assert(end >= start, 'end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  assert(start >= 0 && start < this.length, 'start out of bounds')
  assert(end >= 0 && end <= this.length, 'end out of bounds')

  for (var i = start; i < end; i++) {
    this[i] = value
  }
}

Buffer.prototype.inspect = function () {
  var out = []
  var len = this.length
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i])
    if (i === exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...'
      break
    }
  }
  return '<Buffer ' + out.join(' ') + '>'
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Not added to Buffer.prototype since it should only
 * be available in browsers that support ArrayBuffer.
 */
function BufferToArrayBuffer () {
  return (new Buffer(this)).buffer
}

// HELPER FUNCTIONS
// ================

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

var BP = Buffer.prototype

function augment (arr) {
  arr._isBuffer = true

  // Augment the Uint8Array *instance* (not the class!) with Buffer methods
  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BufferToArrayBuffer

  return arr
}

// slice(start, end)
function clamp (index, len, defaultValue) {
  if (typeof index !== 'number') return defaultValue
  index = ~~index;  // Coerce to integer.
  if (index >= len) return len
  if (index >= 0) return index
  index += len
  if (index >= 0) return index
  return 0
}

function coerce (length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length)
  return length < 0 ? 0 : length
}

function isArray (subject) {
  return (Array.isArray || function (subject) {
    return Object.prototype.toString.call(subject) === '[object Array]'
  })(subject)
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    var b = str.charCodeAt(i)
    if (b <= 0x7F)
      byteArray.push(str.charCodeAt(i))
    else {
      var start = i
      if (b >= 0xD800 && b <= 0xDFFF) i++
      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16))
    }
  }
  return byteArray
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(str)
}

function blitBuffer (src, dst, offset, length) {
  var pos
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

/*
 * We have to make sure that the value is a valid integer. This means that it
 * is non-negative. It has no fractional component and that it does not
 * exceed the maximum allowed value.
 */
function verifuint (value, max) {
  assert(typeof value == 'number', 'cannot write a non-number as a number')
  assert(value >= 0,
      'specified a negative value for writing an unsigned value')
  assert(value <= max, 'value is larger than maximum value for type')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifsint(value, max, min) {
  assert(typeof value == 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifIEEE754(value, max, min) {
  assert(typeof value == 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
}

function assert (test, message) {
  if (!test) throw new Error(message || 'Failed assertion')
}

},{"base64-js":162,"ieee754":163}],162:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var ZERO   = '0'.charCodeAt(0)
	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS)
			return 62 // '+'
		if (code === SLASH)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	module.exports.toByteArray = b64ToByteArray
	module.exports.fromByteArray = uint8ToBase64
}())

},{}],163:[function(require,module,exports){
exports.read = function(buffer, offset, isLE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isLE ? (nBytes - 1) : 0,
      d = isLE ? -1 : 1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isLE ? 0 : (nBytes - 1),
      d = isLE ? 1 : -1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],164:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

module.exports = Duplex;
var inherits = require('inherits');
var setImmediate = require('process/browser.js').nextTick;
var Readable = require('./readable.js');
var Writable = require('./writable.js');

inherits(Duplex, Readable);

Duplex.prototype.write = Writable.prototype.write;
Duplex.prototype.end = Writable.prototype.end;
Duplex.prototype._write = Writable.prototype._write;

function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false)
    this.readable = false;

  if (options && options.writable === false)
    this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false)
    this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended)
    return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  var self = this;
  setImmediate(function () {
    self.end();
  });
}

},{"./readable.js":168,"./writable.js":170,"inherits":158,"process/browser.js":166}],165:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('./readable.js');
Stream.Writable = require('./writable.js');
Stream.Duplex = require('./duplex.js');
Stream.Transform = require('./transform.js');
Stream.PassThrough = require('./passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"./duplex.js":164,"./passthrough.js":167,"./readable.js":168,"./transform.js":169,"./writable.js":170,"events":157,"inherits":158}],166:[function(require,module,exports){
module.exports=require(160)
},{}],167:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

module.exports = PassThrough;

var Transform = require('./transform.js');
var inherits = require('inherits');
inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};

},{"./transform.js":169,"inherits":158}],168:[function(require,module,exports){
var process=require("__browserify_process");// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Readable;
Readable.ReadableState = ReadableState;

var EE = require('events').EventEmitter;
var Stream = require('./index.js');
var Buffer = require('buffer').Buffer;
var setImmediate = require('process/browser.js').nextTick;
var StringDecoder;

var inherits = require('inherits');
inherits(Readable, Stream);

function ReadableState(options, stream) {
  options = options || {};

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.buffer = [];
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = false;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // In streams that never have any data, and do push(null) right away,
  // the consumer can miss the 'end' event if they do some I/O before
  // consuming the stream.  So, we don't emit('end') until some reading
  // happens.
  this.calledRead = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, becuase any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;


  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder)
      StringDecoder = require('string_decoder').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  if (!(this instanceof Readable))
    return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
  var state = this._readableState;

  if (typeof chunk === 'string' && !state.objectMode) {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = new Buffer(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (chunk === null || chunk === undefined) {
    state.reading = false;
    if (!state.ended)
      onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var e = new Error('stream.unshift() after end event');
      stream.emit('error', e);
    } else {
      if (state.decoder && !addToFront && !encoding)
        chunk = state.decoder.write(chunk);

      // update the buffer info.
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront) {
        state.buffer.unshift(chunk);
      } else {
        state.reading = false;
        state.buffer.push(chunk);
      }

      if (state.needReadable)
        emitReadable(stream);

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}



// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended &&
         (state.needReadable ||
          state.length < state.highWaterMark ||
          state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
  if (!StringDecoder)
    StringDecoder = require('string_decoder').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
};

// Don't raise the hwm > 128MB
var MAX_HWM = 0x800000;
function roundUpToNextPowerOf2(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2
    n--;
    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
    n++;
  }
  return n;
}

function howMuchToRead(n, state) {
  if (state.length === 0 && state.ended)
    return 0;

  if (state.objectMode)
    return n === 0 ? 0 : 1;

  if (isNaN(n) || n === null) {
    // only flow one buffer at a time
    if (state.flowing && state.buffer.length)
      return state.buffer[0].length;
    else
      return state.length;
  }

  if (n <= 0)
    return 0;

  // If we're asking for more than the target buffer level,
  // then raise the water mark.  Bump up to the next highest
  // power of 2, to prevent increasing it excessively in tiny
  // amounts.
  if (n > state.highWaterMark)
    state.highWaterMark = roundUpToNextPowerOf2(n);

  // don't have that much.  return null, unless we've ended.
  if (n > state.length) {
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    } else
      return state.length;
  }

  return n;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
  var state = this._readableState;
  state.calledRead = true;
  var nOrig = n;

  if (typeof n !== 'number' || n > 0)
    state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 &&
      state.needReadable &&
      (state.length >= state.highWaterMark || state.ended)) {
    emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0)
      endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;

  // if we currently have less than the highWaterMark, then also read some
  if (state.length - n <= state.highWaterMark)
    doRead = true;

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading)
    doRead = false;

  if (doRead) {
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0)
      state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read called its callback synchronously, then `reading`
  // will be false, and we need to re-evaluate how much data we
  // can return to the user.
  if (doRead && !state.reading)
    n = howMuchToRead(nOrig, state);

  var ret;
  if (n > 0)
    ret = fromList(n, state);
  else
    ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended)
    state.needReadable = true;

  // If we happened to read() exactly the remaining amount in the
  // buffer, and the EOF has been seen at this point, then make sure
  // that we emit 'end' on the very next tick.
  if (state.ended && !state.endEmitted && state.length === 0)
    endReadable(this);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!Buffer.isBuffer(chunk) &&
      'string' !== typeof chunk &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode &&
      !er) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}


function onEofChunk(stream, state) {
  if (state.decoder && !state.ended) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // if we've ended and we have some data left, then emit
  // 'readable' now to make sure it gets picked up.
  if (state.length > 0)
    emitReadable(stream);
  else
    endReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (state.emittedReadable)
    return;

  state.emittedReadable = true;
  if (state.sync)
    setImmediate(function() {
      emitReadable_(stream);
    });
  else
    emitReadable_(stream);
}

function emitReadable_(stream) {
  stream.emit('readable');
}


// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    setImmediate(function() {
      maybeReadMore_(stream, state);
    });
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended &&
         state.length < state.highWaterMark) {
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
  this.emit('error', new Error('not implemented'));
};

Readable.prototype.pipe = function(dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;

  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
              dest !== process.stdout &&
              dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted)
    setImmediate(endFn);
  else
    src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    if (readable !== src) return;
    cleanup();
  }

  function onend() {
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  function cleanup() {
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (!dest._writableState || dest._writableState.needDrain)
      ondrain();
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  // check for listeners before emit removes one-time listeners.
  var errListeners = EE.listenerCount(dest, 'error');
  function onerror(er) {
    unpipe();
    if (errListeners === 0 && EE.listenerCount(dest, 'error') === 0)
      dest.emit('error', er);
  }
  dest.once('error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    // the handler that waits for readable events after all
    // the data gets sucked out in flow.
    // This would be easier to follow with a .once() handler
    // in flow(), but that is too slow.
    this.on('readable', pipeOnReadable);

    state.flowing = true;
    setImmediate(function() {
      flow(src);
    });
  }

  return dest;
};

function pipeOnDrain(src) {
  return function() {
    var dest = this;
    var state = src._readableState;
    state.awaitDrain--;
    if (state.awaitDrain === 0)
      flow(src);
  };
}

function flow(src) {
  var state = src._readableState;
  var chunk;
  state.awaitDrain = 0;

  function write(dest, i, list) {
    var written = dest.write(chunk);
    if (false === written) {
      state.awaitDrain++;
    }
  }

  while (state.pipesCount && null !== (chunk = src.read())) {

    if (state.pipesCount === 1)
      write(state.pipes, 0, null);
    else
      forEach(state.pipes, write);

    src.emit('data', chunk);

    // if anyone needs a drain, then we have to wait for that.
    if (state.awaitDrain > 0)
      return;
  }

  // if every destination was unpiped, either before entering this
  // function, or in the while loop, then stop flowing.
  //
  // NB: This is a pretty rare edge case.
  if (state.pipesCount === 0) {
    state.flowing = false;

    // if there were data event listeners added, then switch to old mode.
    if (EE.listenerCount(src, 'data') > 0)
      emitDataEvents(src);
    return;
  }

  // at this point, no one needed a drain, so we just ran out of data
  // on the next readable event, start it over again.
  state.ranOut = true;
}

function pipeOnReadable() {
  if (this._readableState.ranOut) {
    this._readableState.ranOut = false;
    flow(this);
  }
}


Readable.prototype.unpipe = function(dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0)
    return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes)
      return this;

    if (!dest)
      dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    this.removeListener('readable', pipeOnReadable);
    state.flowing = false;
    if (dest)
      dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    this.removeListener('readable', pipeOnReadable);
    state.flowing = false;

    for (var i = 0; i < len; i++)
      dests[i].emit('unpipe', this);
    return this;
  }

  // try to find the right one.
  var i = indexOf(state.pipes, dest);
  if (i === -1)
    return this;

  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1)
    state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data' && !this._readableState.flowing)
    emitDataEvents(this);

  if (ev === 'readable' && this.readable) {
    var state = this._readableState;
    if (!state.readableListening) {
      state.readableListening = true;
      state.emittedReadable = false;
      state.needReadable = true;
      if (!state.reading) {
        this.read(0);
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
  emitDataEvents(this);
  this.read(0);
  this.emit('resume');
};

Readable.prototype.pause = function() {
  emitDataEvents(this, true);
  this.emit('pause');
};

function emitDataEvents(stream, startPaused) {
  var state = stream._readableState;

  if (state.flowing) {
    // https://github.com/isaacs/readable-stream/issues/16
    throw new Error('Cannot switch to old mode now.');
  }

  var paused = startPaused || false;
  var readable = false;

  // convert to an old-style stream.
  stream.readable = true;
  stream.pipe = Stream.prototype.pipe;
  stream.on = stream.addListener = Stream.prototype.on;

  stream.on('readable', function() {
    readable = true;

    var c;
    while (!paused && (null !== (c = stream.read())))
      stream.emit('data', c);

    if (c === null) {
      readable = false;
      stream._readableState.needReadable = true;
    }
  });

  stream.pause = function() {
    paused = true;
    this.emit('pause');
  };

  stream.resume = function() {
    paused = false;
    if (readable)
      setImmediate(function() {
        stream.emit('readable');
      });
    else
      this.read(0);
    this.emit('resume');
  };

  // now make it start, just in case it hadn't already.
  stream.emit('readable');
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function() {
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length)
        self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function(chunk) {
    if (state.decoder)
      chunk = state.decoder.write(chunk);
    if (!chunk || !state.objectMode && !chunk.length)
      return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (typeof stream[i] === 'function' &&
        typeof this[i] === 'undefined') {
      this[i] = function(method) { return function() {
        return stream[method].apply(stream, arguments);
      }}(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function(ev) {
    stream.on(ev, function (x) {
      return self.emit.apply(self, ev, x);
    });
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function(n) {
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};



// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
function fromList(n, state) {
  var list = state.buffer;
  var length = state.length;
  var stringMode = !!state.decoder;
  var objectMode = !!state.objectMode;
  var ret;

  // nothing in the list, definitely empty.
  if (list.length === 0)
    return null;

  if (length === 0)
    ret = null;
  else if (objectMode)
    ret = list.shift();
  else if (!n || n >= length) {
    // read it all, truncate the array.
    if (stringMode)
      ret = list.join('');
    else
      ret = Buffer.concat(list, length);
    list.length = 0;
  } else {
    // read just some of it.
    if (n < list[0].length) {
      // just take a part of the first list item.
      // slice is the same for buffers and strings.
      var buf = list[0];
      ret = buf.slice(0, n);
      list[0] = buf.slice(n);
    } else if (n === list[0].length) {
      // first list is a perfect match
      ret = list.shift();
    } else {
      // complex case.
      // we have enough to cover it, but it spans past the first buffer.
      if (stringMode)
        ret = '';
      else
        ret = new Buffer(n);

      var c = 0;
      for (var i = 0, l = list.length; i < l && c < n; i++) {
        var buf = list[0];
        var cpy = Math.min(n - c, buf.length);

        if (stringMode)
          ret += buf.slice(0, cpy);
        else
          buf.copy(ret, c, 0, cpy);

        if (cpy < buf.length)
          list[0] = buf.slice(cpy);
        else
          list.shift();

        c += cpy;
      }
    }
  }

  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0)
    throw new Error('endReadable called on non-empty stream');

  if (!state.endEmitted && state.calledRead) {
    state.ended = true;
    setImmediate(function() {
      // Check that we didn't get one last unshift.
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');
      }
    });
  }
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf (xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

},{"./index.js":165,"__browserify_process":160,"buffer":161,"events":157,"inherits":158,"process/browser.js":166,"string_decoder":171}],169:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

module.exports = Transform;

var Duplex = require('./duplex.js');
var inherits = require('inherits');
inherits(Transform, Duplex);


function TransformState(options, stream) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb)
    return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined)
    stream.push(data);

  if (cb)
    cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}


function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);

  Duplex.call(this, options);

  var ts = this._transformState = new TransformState(options, this);

  // when the writable side finishes, then flush out anything remaining.
  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  this.once('finish', function() {
    if ('function' === typeof this._flush)
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}

Transform.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function(chunk, encoding, cb) {
  throw new Error('not implemented');
};

Transform.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform ||
        rs.needReadable ||
        rs.length < rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function(n) {
  var ts = this._transformState;

  if (ts.writechunk && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};


function done(stream, er) {
  if (er)
    return stream.emit('error', er);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var rs = stream._readableState;
  var ts = stream._transformState;

  if (ws.length)
    throw new Error('calling transform done when ws.length != 0');

  if (ts.transforming)
    throw new Error('calling transform done when still transforming');

  return stream.push(null);
}

},{"./duplex.js":164,"inherits":158}],170:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, cb), and it'll handle all
// the drain event emission and buffering.

module.exports = Writable;
Writable.WritableState = WritableState;

var isUint8Array = typeof Uint8Array !== 'undefined'
  ? function (x) { return x instanceof Uint8Array }
  : function (x) {
    return x && x.constructor && x.constructor.name === 'Uint8Array'
  }
;
var isArrayBuffer = typeof ArrayBuffer !== 'undefined'
  ? function (x) { return x instanceof ArrayBuffer }
  : function (x) {
    return x && x.constructor && x.constructor.name === 'ArrayBuffer'
  }
;

var inherits = require('inherits');
var Stream = require('./index.js');
var setImmediate = require('process/browser.js').nextTick;
var Buffer = require('buffer').Buffer;

inherits(Writable, Stream);

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
}

function WritableState(options, stream) {
  options = options || {};

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, becuase any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function(er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.buffer = [];
}

function Writable(options) {
  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) && !(this instanceof Stream.Duplex))
    return new Writable(options);

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
  this.emit('error', new Error('Cannot pipe. Not readable.'));
};


function writeAfterEnd(stream, state, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  setImmediate(function() {
    cb(er);
  });
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  if (!Buffer.isBuffer(chunk) &&
      'string' !== typeof chunk &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode) {
    var er = new TypeError('Invalid non-string/buffer chunk');
    stream.emit('error', er);
    setImmediate(function() {
      cb(er);
    });
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function(chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isUint8Array(chunk))
    chunk = new Buffer(chunk);
  if (isArrayBuffer(chunk) && typeof Uint8Array !== 'undefined')
    chunk = new Buffer(new Uint8Array(chunk));
  
  if (Buffer.isBuffer(chunk))
    encoding = 'buffer';
  else if (!encoding)
    encoding = state.defaultEncoding;

  if (typeof cb !== 'function')
    cb = function() {};

  if (state.ended)
    writeAfterEnd(this, state, cb);
  else if (validChunk(this, state, chunk, cb))
    ret = writeOrBuffer(this, state, chunk, encoding, cb);

  return ret;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode &&
      state.decodeStrings !== false &&
      typeof chunk === 'string') {
    chunk = new Buffer(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  state.needDrain = !ret;

  if (state.writing)
    state.buffer.push(new WriteReq(chunk, encoding, cb));
  else
    doWrite(stream, state, len, chunk, encoding, cb);

  return ret;
}

function doWrite(stream, state, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  if (sync)
    setImmediate(function() {
      cb(er);
    });
  else
    cb(er);

  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er)
    onwriteError(stream, state, sync, er, cb);
  else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(stream, state);

    if (!finished && !state.bufferProcessing && state.buffer.length)
      clearBuffer(stream, state);

    if (sync) {
      setImmediate(function() {
        afterWrite(stream, state, finished, cb);
      });
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream, state);
  cb();
  if (finished)
    finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}


// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;

  for (var c = 0; c < state.buffer.length; c++) {
    var entry = state.buffer[c];
    var chunk = entry.chunk;
    var encoding = entry.encoding;
    var cb = entry.callback;
    var len = state.objectMode ? 1 : chunk.length;

    doWrite(stream, state, len, chunk, encoding, cb);

    // if we didn't call the onwrite immediately, then
    // it means that we need to wait until it does.
    // also, that means that the chunk and cb are currently
    // being processed, so move the buffer counter past them.
    if (state.writing) {
      c++;
      break;
    }
  }

  state.bufferProcessing = false;
  if (c < state.buffer.length)
    state.buffer = state.buffer.slice(c);
  else
    state.buffer.length = 0;
}

Writable.prototype._write = function(chunk, encoding, cb) {
  cb(new Error('not implemented'));
};

Writable.prototype.end = function(chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (typeof chunk !== 'undefined' && chunk !== null)
    this.write(chunk, encoding);

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished)
    endWritable(this, state, cb);
};


function needFinish(stream, state) {
  return (state.ending &&
          state.length === 0 &&
          !state.finished &&
          !state.writing);
}

function finishMaybe(stream, state) {
  var need = needFinish(stream, state);
  if (need) {
    state.finished = true;
    stream.emit('finish');
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished)
      setImmediate(cb);
    else
      stream.once('finish', cb);
  }
  state.ended = true;
}

},{"./index.js":165,"buffer":161,"inherits":158,"process/browser.js":166}],171:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = require('buffer').Buffer;

function assertEncoding(encoding) {
  if (encoding && !Buffer.isEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  this.charBuffer = new Buffer(6);
  this.charReceived = 0;
  this.charLength = 0;
};


StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  var offset = 0;

  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var i = (buffer.length >= this.charLength - this.charReceived) ?
                this.charLength - this.charReceived :
                buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, offset, i);
    this.charReceived += (i - offset);
    offset = i;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (i == buffer.length) return charStr;

    // otherwise cut off the characters end from the beginning of this buffer
    buffer = buffer.slice(i, buffer.length);
    break;
  }

  var lenIncomplete = this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - lenIncomplete, end);
    this.charReceived = lenIncomplete;
    end -= lenIncomplete;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    this.charBuffer.write(charStr.charAt(charStr.length - 1), this.encoding);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }

  return i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  var incomplete = this.charReceived = buffer.length % 2;
  this.charLength = incomplete ? 2 : 0;
  return incomplete;
}

function base64DetectIncompleteChar(buffer) {
  var incomplete = this.charReceived = buffer.length % 3;
  this.charLength = incomplete ? 3 : 0;
  return incomplete;
}

},{"buffer":161}],172:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],173:[function(require,module,exports){
var process=require("__browserify_process"),global=typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

},{"./support/isBuffer":172,"__browserify_process":160,"inherits":158}]},{},[147])